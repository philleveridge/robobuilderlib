
Robobuilderlib.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000482  00800100  0000ded4  0000df68  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000ded4  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000093b  00800582  0000e356  0000e3ea  2**0
                  ALLOC
  3 .eeprom       000004e8  00810000  00810000  0000e3ea  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .debug_aranges 00000200  00000000  00000000  0000e8d2  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_pubnames 000027c4  00000000  00000000  0000ead2  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000a12b  00000000  00000000  00011296  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002158  00000000  00000000  0001b3c1  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00007e38  00000000  00000000  0001d519  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000e10  00000000  00000000  00025354  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000027b8  00000000  00000000  00026164  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000049b0  00000000  00000000  0002891c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000568  00000000  00000000  0002d2cc  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 07 1f 	jmp	0x3e0e	; 0x3e0e <__ctors_end>
       4:	0c 94 26 1f 	jmp	0x3e4c	; 0x3e4c <__bad_interrupt>
       8:	0c 94 26 1f 	jmp	0x3e4c	; 0x3e4c <__bad_interrupt>
       c:	0c 94 26 1f 	jmp	0x3e4c	; 0x3e4c <__bad_interrupt>
      10:	0c 94 26 1f 	jmp	0x3e4c	; 0x3e4c <__bad_interrupt>
      14:	0c 94 26 1f 	jmp	0x3e4c	; 0x3e4c <__bad_interrupt>
      18:	0c 94 26 1f 	jmp	0x3e4c	; 0x3e4c <__bad_interrupt>
      1c:	0c 94 ba 2d 	jmp	0x5b74	; 0x5b74 <__vector_7>
      20:	0c 94 26 1f 	jmp	0x3e4c	; 0x3e4c <__bad_interrupt>
      24:	0c 94 26 1f 	jmp	0x3e4c	; 0x3e4c <__bad_interrupt>
      28:	0c 94 a9 2d 	jmp	0x5b52	; 0x5b52 <__vector_10>
      2c:	0c 94 26 1f 	jmp	0x3e4c	; 0x3e4c <__bad_interrupt>
      30:	0c 94 26 1f 	jmp	0x3e4c	; 0x3e4c <__bad_interrupt>
      34:	0c 94 26 1f 	jmp	0x3e4c	; 0x3e4c <__bad_interrupt>
      38:	0c 94 11 20 	jmp	0x4022	; 0x4022 <__vector_14>
      3c:	0c 94 26 1f 	jmp	0x3e4c	; 0x3e4c <__bad_interrupt>
      40:	0c 94 8e 1f 	jmp	0x3f1c	; 0x3f1c <__vector_16>
      44:	0c 94 26 1f 	jmp	0x3e4c	; 0x3e4c <__bad_interrupt>
      48:	0c 94 5d 1f 	jmp	0x3eba	; 0x3eba <__vector_18>
      4c:	0c 94 26 1f 	jmp	0x3e4c	; 0x3e4c <__bad_interrupt>
      50:	0c 94 28 1f 	jmp	0x3e50	; 0x3e50 <__vector_20>
      54:	0c 94 e8 2b 	jmp	0x57d0	; 0x57d0 <__vector_21>
      58:	0c 94 26 1f 	jmp	0x3e4c	; 0x3e4c <__bad_interrupt>
      5c:	0c 94 26 1f 	jmp	0x3e4c	; 0x3e4c <__bad_interrupt>
      60:	0c 94 26 1f 	jmp	0x3e4c	; 0x3e4c <__bad_interrupt>
      64:	0c 94 26 1f 	jmp	0x3e4c	; 0x3e4c <__bad_interrupt>
      68:	0c 94 26 1f 	jmp	0x3e4c	; 0x3e4c <__bad_interrupt>
      6c:	0c 94 26 1f 	jmp	0x3e4c	; 0x3e4c <__bad_interrupt>
      70:	0c 94 26 1f 	jmp	0x3e4c	; 0x3e4c <__bad_interrupt>
      74:	0c 94 26 1f 	jmp	0x3e4c	; 0x3e4c <__bad_interrupt>
      78:	0c 94 eb 21 	jmp	0x43d6	; 0x43d6 <__vector_30>
      7c:	0c 94 26 1f 	jmp	0x3e4c	; 0x3e4c <__bad_interrupt>
      80:	0c 94 35 22 	jmp	0x446a	; 0x446a <__vector_32>
      84:	0c 94 26 1f 	jmp	0x3e4c	; 0x3e4c <__bad_interrupt>
      88:	0c 94 26 1f 	jmp	0x3e4c	; 0x3e4c <__bad_interrupt>
      8c:	b4 4b       	sbci	r27, 0xB4	; 180
      8e:	b4 4b       	sbci	r27, 0xB4	; 180
      90:	0e 4d       	sbci	r16, 0xDE	; 222
      92:	8a 4d       	sbci	r24, 0xDA	; 218
      94:	8a 4d       	sbci	r24, 0xDA	; 218
      96:	45 4d       	sbci	r20, 0xD5	; 213
      98:	01 4d       	sbci	r16, 0xD1	; 209
      9a:	b4 4b       	sbci	r27, 0xB4	; 180
      9c:	3b 4c       	sbci	r19, 0xCB	; 203
      9e:	90 4d       	sbci	r25, 0xD0	; 208
      a0:	0a 4d       	sbci	r16, 0xDA	; 218
      a2:	45 4d       	sbci	r20, 0xD5	; 213
      a4:	45 4d       	sbci	r20, 0xD5	; 213
      a6:	4d 4d       	sbci	r20, 0xDD	; 221
      a8:	e0 4c       	sbci	r30, 0xC0	; 192
      aa:	0a 4d       	sbci	r16, 0xDA	; 218
      ac:	45 4d       	sbci	r20, 0xD5	; 213
      ae:	90 4d       	sbci	r25, 0xD0	; 208
      b0:	1d 4c       	sbci	r17, 0xCD	; 205
      b2:	3b 50       	subi	r19, 0x0B	; 11
      b4:	96 4f       	sbci	r25, 0xF6	; 246
      b6:	e3 50       	subi	r30, 0x03	; 3
      b8:	81 52       	subi	r24, 0x21	; 33
      ba:	81 52       	subi	r24, 0x21	; 33
      bc:	75 50       	subi	r23, 0x05	; 5
      be:	7e 50       	subi	r23, 0x0E	; 14
      c0:	f5 4f       	sbci	r31, 0xF5	; 245
      c2:	24 50       	subi	r18, 0x04	; 4
      c4:	4e 52       	subi	r20, 0x2E	; 46
      c6:	df 51       	subi	r29, 0x1F	; 31
      c8:	07 52       	subi	r16, 0x27	; 39
      ca:	0b 52       	subi	r16, 0x2B	; 43
      cc:	be 4f       	sbci	r27, 0xFE	; 254
      ce:	56 50       	subi	r21, 0x06	; 6
      d0:	02 51       	subi	r16, 0x12	; 18
      d2:	53 52       	subi	r21, 0x23	; 35
      d4:	68 52       	subi	r22, 0x28	; 40
      d6:	06 50       	subi	r16, 0x06	; 6
      d8:	44 65       	ori	r20, 0x54	; 84
      da:	47 65       	ori	r20, 0x57	; 87
      dc:	4c 65       	ori	r20, 0x5C	; 92
      de:	4f 65       	ori	r20, 0x5F	; 95
      e0:	52 65       	ori	r21, 0x52	; 82
      e2:	55 65       	ori	r21, 0x55	; 85
      e4:	64 65       	ori	r22, 0x54	; 84
      e6:	58 65       	ori	r21, 0x58	; 88
      e8:	5b 65       	ori	r21, 0x5B	; 91
      ea:	5e 65       	ori	r21, 0x5E	; 94
      ec:	61 65       	ori	r22, 0x51	; 81
      ee:	92 65       	ori	r25, 0x52	; 82
      f0:	92 65       	ori	r25, 0x52	; 82
      f2:	92 65       	ori	r25, 0x52	; 82
      f4:	92 65       	ori	r25, 0x52	; 82
      f6:	92 65       	ori	r25, 0x52	; 82
      f8:	92 65       	ori	r25, 0x52	; 82
      fa:	92 65       	ori	r25, 0x52	; 82
      fc:	92 65       	ori	r25, 0x52	; 82
      fe:	92 65       	ori	r25, 0x52	; 82
     100:	69 65       	ori	r22, 0x59	; 89
     102:	6c 65       	ori	r22, 0x5C	; 92
     104:	6f 65       	ori	r22, 0x5F	; 95
     106:	92 65       	ori	r25, 0x52	; 82
     108:	92 65       	ori	r25, 0x52	; 82
     10a:	92 65       	ori	r25, 0x52	; 82
     10c:	92 65       	ori	r25, 0x52	; 82
     10e:	72 65       	ori	r23, 0x52	; 82
     110:	92 65       	ori	r25, 0x52	; 82
     112:	92 65       	ori	r25, 0x52	; 82
     114:	92 65       	ori	r25, 0x52	; 82
     116:	92 65       	ori	r25, 0x52	; 82
     118:	92 65       	ori	r25, 0x52	; 82
     11a:	92 65       	ori	r25, 0x52	; 82
     11c:	92 65       	ori	r25, 0x52	; 82
     11e:	92 65       	ori	r25, 0x52	; 82
     120:	92 65       	ori	r25, 0x52	; 82
     122:	92 65       	ori	r25, 0x52	; 82
     124:	92 65       	ori	r25, 0x52	; 82
     126:	92 65       	ori	r25, 0x52	; 82
     128:	92 65       	ori	r25, 0x52	; 82
     12a:	92 65       	ori	r25, 0x52	; 82
     12c:	75 65       	ori	r23, 0x55	; 85
     12e:	92 65       	ori	r25, 0x52	; 82
     130:	92 65       	ori	r25, 0x52	; 82
     132:	92 65       	ori	r25, 0x52	; 82
     134:	92 65       	ori	r25, 0x52	; 82
     136:	92 65       	ori	r25, 0x52	; 82
     138:	7e 65       	ori	r23, 0x5E	; 94

0000013a <version>:
     13a:	4d 6b 32 20 28 24 52 65 76 3a 20 31 30 35 20 24     Mk2 ($Rev: 105 $
     14a:	29 0d 0a 00                                         )...

0000014e <__c.1992>:
     14e:	52 6f 62 6f 73 20 00                                Robos .

00000155 <MotionZeroPos>:
     155:	7d c9 a3 43 6c 7d 30 59 b8 8e 59 27 7c a2 d3 7f     }..Cl}0Y..Y'|...

00000165 <HunoBasicPose>:
     165:	7d b3 c7 58 6c 7e 48 31 a3 8d 33 2f 31 c7 cd cd     }..Xl~H1..3/1...

00000175 <HunoBasic_PunchLeft_Torque>:
     175:	04 04 04 04 04 04 04 04 04 04 04 04 04 04 04 04     ................
     185:	02 02 02 02 02 02 02 02 02 02 00 00 00 00 00 00     ................
     195:	01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01     ................
     1a5:	02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02     ................
     1b5:	04 04 04 04 04 04 04 04 04 04 04 04 04 04 04 04     ................

000001c5 <HunoBasic_PunchLeft_Port>:
     1c5:	01 01 01 01 01 00 00 00 00 00 01 01 01 00 00 00     ................
     1d5:	01 01 01 01 01 00 00 00 00 00 01 01 01 00 00 00     ................
     1e5:	03 03 03 03 03 00 00 00 00 00 03 03 03 00 00 00     ................
     1f5:	03 03 03 03 03 00 00 00 00 00 03 03 03 00 00 00     ................
	...

00000215 <HunoBasic_PunchLeft_PGain>:
     215:	28 28 28 28 28 28 28 28 28 28 14 14 14 14 14 14     ((((((((((......

00000225 <HunoBasic_PunchLeft_DGain>:
     225:	3c 3c 3c 3c 3c 3c 3c 3c 3c 3c 1e 1e 1e 1e 1e 1e     <<<<<<<<<<......

00000235 <HunoBasic_PunchLeft_IGain>:
	...

00000245 <HunoBasic_PunchLeft_Frames>:
     245:	01 00 08 00 01 00 05 00 0f 00                       ..........

0000024f <HunoBasic_PunchLeft_TrTime>:
     24f:	46 00 36 01 a4 01 c8 00 2c 01                       F.6.....,.

00000259 <HunoBasic_PunchLeft_Position>:
     259:	7d b3 c7 58 6c 7e 48 31 a3 8d 33 2f 31 c7 cd cd     }..Xl~H1..3/1...
     269:	7d b3 c7 58 6c 7e 48 31 a3 8d 33 2f 31 c7 cd cd     }..Xl~H1..3/1...
     279:	6b a4 e9 6a 5f 6c 50 1d 9b 81 38 3e 28 a6 ce d0     k..j_lP...8>(...
     289:	6b a4 e9 6a 5f 91 4a 28 a3 9a 75 7c 72 a6 ce d0     k..j_.J(..u|r...
     299:	7e a4 de 64 6b 7d 50 1d 9b 8e 4f 2c 28 a6 ce d0     ~..dk}P...O,(...
     2a9:	7d b3 c7 58 6c 7e 48 31 a3 8d 33 2f 31 c7 cd cd     }..Xl~H1..3/1...

000002b9 <HunoBasic_PunchRight_Torque>:
     2b9:	04 04 04 04 04 04 04 04 04 04 04 04 04 04 04 04     ................
     2c9:	02 02 02 02 02 02 02 02 02 02 00 00 00 00 00 00     ................
     2d9:	01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01     ................
     2e9:	02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02     ................
     2f9:	04 04 04 04 04 04 04 04 04 04 04 04 04 04 04 04     ................

00000309 <HunoBasic_PunchRight_Port>:
     309:	00 00 00 00 00 01 01 01 01 01 00 00 00 01 01 01     ................
     319:	00 00 00 00 00 02 02 02 02 02 00 00 00 02 02 02     ................
     329:	00 00 00 00 00 03 03 03 03 02 00 00 00 03 03 03     ................
     339:	00 00 00 00 00 03 03 03 03 03 00 00 00 03 03 03     ................
	...

00000359 <HunoBasic_PunchRight_PGain>:
     359:	28 28 28 28 28 28 28 28 28 28 14 14 14 14 14 14     ((((((((((......

00000369 <HunoBasic_PunchRight_DGain>:
     369:	3c 3c 3c 3c 3c 3c 3c 3c 3c 3c 1e 1e 1e 1e 1e 1e     <<<<<<<<<<......

00000379 <HunoBasic_PunchRight_IGain>:
	...

00000389 <HunoBasic_PunchRight_Frames>:
     389:	01 00 08 00 01 00 05 00 0f 00                       ..........

00000393 <HunoBasic_PunchRight_TrTime>:
     393:	46 00 36 01 a4 01 c8 00 2c 01                       F.6.....,.

0000039d <HunoBasic_PunchRight_Position>:
     39d:	7d b3 c7 58 6c 7e 48 31 a3 8d 33 2f 31 c7 cd cd     }..Xl~H1..3/1...
     3ad:	7d b3 c7 58 6c 7e 48 31 a3 8d 33 2f 31 c7 cd cd     }..Xl~H1..3/1...
     3bd:	8b a3 e6 64 78 8e 57 0e 96 9f 4f 2c 28 b7 bc d0     ...dx.W...O,(...
     3cd:	6c a4 e0 61 6a 97 50 1c 99 a7 4f 2c 28 91 70 83     l..aj.P...O,(.p.
     3dd:	7e a4 de 64 6b 7d 50 1d 9b 8e 4f 2c 28 a6 ce d0     ~..dk}P...O,(...
     3ed:	7d b3 c7 58 6c 7e 48 31 a3 8d 33 2f 31 c7 cd cd     }..Xl~H1..3/1...

000003fd <HunoBasic_SidewalkLeft_Torque>:
     3fd:	04 04 04 04 04 04 04 04 04 04 04 04 04 04 04 04     ................
     40d:	04 04 04 04 04 04 04 04 04 04 04 04 04 04 04 04     ................
     41d:	02 02 02 02 02 02 02 02 02 02 00 00 00 00 00 00     ................
     42d:	02 02 02 02 02 00 00 00 00 00 03 03 03 03 03 03     ................
	...
     445:	00 00 04 04 04 04 04 03 04 04 04 04 04 04 04 04     ................
     455:	04 04 04 04 04 04 04 04                             ........

0000045d <HunoBasic_SidewalkLeft_Port>:
	...
     46d:	01 01 01 01 01 00 00 00 00 00 01 01 01 00 00 00     ................
	...
     48d:	01 01 01 01 01 00 00 00 00 00 01 01 01 00 00 00     ................
	...

000004bd <HunoBasic_SidewalkLeft_PGain>:
     4bd:	28 28 28 28 28 28 28 28 28 28 14 14 14 14 14 14     ((((((((((......

000004cd <HunoBasic_SidewalkLeft_DGain>:
     4cd:	3c 3c 3c 3c 3c 3c 3c 3c 3c 3c 1e 1e 1e 1e 1e 1e     <<<<<<<<<<......

000004dd <HunoBasic_SidewalkLeft_IGain>:
	...

000004ed <HunoBasic_SidewalkLeft_Frames>:
     4ed:	01 00 05 00 08 00 03 00 01 00 0f 00                 ............

000004f9 <HunoBasic_SidewalkLeft_TrTime>:
     4f9:	46 00 96 00 36 01 fa 00 78 00 2c 01                 F...6...x.,.

00000505 <HunoBasic_SidewalkLeft_Position>:
     505:	7d b3 c7 58 6c 7e 48 31 a3 8d 33 2f 31 c7 cd cd     }..Xl~H1..3/1...
     515:	7d b3 c7 58 6c 7e 48 31 a3 8d 33 2f 31 c7 cd cd     }..Xl~H1..3/1...
     525:	7e a7 de 62 6e 7d 54 1d 9b 8e 4f 2c 28 a6 ce d0     ~..bn}T...O,(...
     535:	6b a4 e9 66 5f 6c 50 1d 9b 81 38 3e 28 a6 ce d0     k..f_lP...8>(...
     545:	6b a4 e9 69 5f 91 4a 28 9d 9a 38 3e 28 a6 ce d0     k..i_.J(..8>(...
     555:	7e a4 de 5f 6b 7d 54 1d 9b 8e 4f 2c 28 a6 ce d0     ~.._k}T...O,(...
     565:	7d b3 c7 58 6c 7e 48 31 a3 8d 33 2f 31 c7 cd cd     }..Xl~H1..3/1...

00000575 <HunoBasic_SidewalkRight_Torque>:
     575:	04 04 04 04 04 04 04 04 04 04 04 04 04 04 04 04     ................
     585:	04 04 04 04 04 04 04 04 04 04 04 04 04 04 04 04     ................
     595:	02 02 02 02 02 02 02 02 02 02 04 04 04 04 04 04     ................
     5a5:	00 00 00 00 00 02 02 02 02 02 04 04 04 04 04 04     ................
     5b5:	00 00 00 00 00 02 02 02 02 02 04 04 04 04 04 04     ................
     5c5:	04 04 04 04 04 04 04 04 04 04 04 04 04 04 04 04     ................

000005d5 <HunoBasic_SidewalkRight_Port>:
	...
     5e9:	00 01 01 01 01 01 00 00 00 01 01 01 00 00 00 00     ................
	...
     609:	00 01 01 01 01 01 00 00 00 01 01 01 00 00 00 00     ................
	...

00000635 <HunoBasic_SidewalkRight_PGain>:
     635:	28 28 28 28 28 28 28 28 28 28 14 14 14 14 14 14     ((((((((((......

00000645 <HunoBasic_SidewalkRight_DGain>:
     645:	3c 3c 3c 3c 3c 3c 3c 3c 3c 3c 1e 1e 1e 1e 1e 1e     <<<<<<<<<<......

00000655 <HunoBasic_SidewalkRight_IGain>:
	...

00000665 <HunoBasic_SidewalkRight_Frames>:
     665:	01 00 05 00 08 00 03 00 01 00 0f 00                 ............

00000671 <HunoBasic_SidewalkRight_TrTime>:
     671:	46 00 96 00 36 01 c8 00 78 00 2c 01                 F...6...x.,.

0000067d <HunoBasic_SidewalkRight_Position>:
     67d:	7d b3 c7 58 6c 7e 48 31 a3 8d 33 2f 31 c7 cd cd     }..Xl~H1..3/1...
     68d:	7d b3 c7 58 6c 7e 48 31 a3 8d 33 2f 31 c7 cd cd     }..Xl~H1..3/1...
     69d:	7e a7 de 62 6e 7d 54 1d 9b 8e 4f 2c 28 a6 ce d0     ~..bn}T...O,(...
     6ad:	8b a3 e6 64 78 8e 57 0e 96 9f 4f 2c 28 b7 bc d0     ...dx.W...O,(...
     6bd:	6c a4 e0 61 6a 97 50 1c 99 a7 4f 2c 28 b7 bc d0     l..aj.P...O,(...
     6cd:	7e a6 de 62 71 7d 54 1d 9b 8e 4f 2c 28 a6 ce d0     ~..bq}T...O,(...
     6dd:	7d b3 c7 58 6c 7e 48 31 a3 8d 33 2f 31 c7 cd cd     }..Xl~H1..3/1...

000006ed <HunoBasic_TurnLeft_Torque>:
     6ed:	04 04 04 04 04 04 04 04 04 04 04 04 04 04 04 04     ................
     6fd:	01 01 01 01 01 01 01 01 01 01 04 04 04 04 04 04     ................
     70d:	01 01 01 01 01 01 01 01 01 01 04 04 04 04 04 04     ................
     71d:	02 02 02 02 02 02 02 02 02 02 04 04 04 04 04 04     ................
     72d:	01 01 01 01 01 01 01 01 01 01 04 04 04 04 04 04     ................
     73d:	03 03 03 03 03 03 03 03 03 03 04 04 04 04 04 04     ................

0000074d <HunoBasic_TurnLeft_Port>:
     74d:	01 01 01 01 01 00 00 00 00 00 01 01 01 00 00 00     ................
     75d:	01 01 01 01 01 00 00 00 00 00 01 01 01 00 00 00     ................
	...

000007ad <HunoBasic_TurnLeft_PGain>:
     7ad:	14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14     ................

000007bd <HunoBasic_TurnLeft_DGain>:
     7bd:	1e 1e 1e 1e 1e 1e 1e 1e 1e 1e 1e 1e 1e 1e 1e 1e     ................

000007cd <HunoBasic_TurnLeft_IGain>:
	...

000007dd <HunoBasic_TurnLeft_Frames>:
     7dd:	0a 00 05 00 0a 00 01 00 05 00 0a 00                 ............

000007e9 <HunoBasic_TurnLeft_TrTime>:
     7e9:	c8 00 c8 00 90 01 78 00 c8 00 90 01                 ......x.....

000007f5 <HunoBasic_TurnLeft_Position>:
     7f5:	7d b3 c7 58 6c 7e 48 31 a3 8d 33 2f 31 c7 cd cd     }..Xl~H1..3/1...
     805:	7d b3 c7 58 6c 7e 48 31 a3 8d 33 2f 31 c7 cd cd     }..Xl~H1..3/1...
     815:	7d a2 c7 48 6c 7e 3b 31 97 8d 33 2f 31 c7 cd cd     }..Hl~;1..3/1...
     825:	88 a9 d2 5d 79 8b 24 3d 90 9d 33 2f 31 c7 cd cd     ...]y.$=..3/1...
     835:	7d ad d2 5d 7b 8b 50 0e 89 9d 33 2f 31 c7 cd cd     }..]{.P...3/1...
     845:	86 ad d2 5d 7b 8b 50 1f 9d 9d 33 2f 31 c7 cd cd     ...]{.P...3/1...
     855:	7d b3 c7 58 6c 7e 48 31 a3 8d 33 2f 31 c7 cd cd     }..Xl~H1..3/1...

00000865 <HunoBasic_TurnRight_Torque>:
     865:	04 04 04 04 04 04 04 04 04 04 04 04 04 04 04 04     ................
     875:	01 01 01 01 01 01 01 01 01 01 04 04 04 04 04 04     ................
     885:	01 01 01 01 01 01 01 01 01 01 04 04 04 04 04 04     ................
     895:	02 02 02 02 02 02 02 02 02 02 04 04 04 04 04 04     ................
     8a5:	02 02 02 02 02 02 02 02 02 02 04 04 04 04 04 04     ................
     8b5:	03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03     ................

000008c5 <HunoBasic_TurnRight_Port>:
     8c5:	00 00 00 00 00 01 01 01 01 01 00 00 00 01 01 01     ................
     8d5:	00 00 00 00 00 01 01 01 01 01 00 00 00 01 01 00     ................
	...

00000925 <HunoBasic_TurnRight_PGain>:
     925:	14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14     ................

00000935 <HunoBasic_TurnRight_DGain>:
     935:	1e 1e 1e 1e 1e 1e 1e 1e 1e 1e 1e 1e 1e 1e 1e 1e     ................

00000945 <HunoBasic_TurnRight_IGain>:
	...

00000955 <HunoBasic_TurnRight_Frames>:
     955:	0a 00 05 00 0a 00 01 00 05 00 0a 00                 ............

00000961 <HunoBasic_TurnRight_TrTime>:
     961:	c8 00 c8 00 90 01 78 00 c8 00 90 01                 ......x.....

0000096d <HunoBasic_TurnRight_Position>:
     96d:	7d b3 c7 58 6c 7e 48 31 a3 8d 33 2f 31 c7 cd cd     }..Xl~H1..3/1...
     97d:	7d b3 c7 58 6c 7e 48 31 a3 8d 33 2f 31 c7 cd cd     }..Xl~H1..3/1...
     98d:	7d c1 cd 6b 6c 7e 59 31 b4 8d 33 2f 31 c7 cd cd     }..kl~Y1..3/1...
     99d:	77 d1 c3 6a 60 77 51 1f 9d 84 33 2f 31 c7 cd cd     w..j`wQ...3/1...
     9ad:	75 a2 e3 62 67 7d 4e 31 a3 7f 33 2f 31 c7 cd cd     u..bg}N1..3/1...
     9bd:	6e a8 cc 55 5c 75 51 31 a3 80 33 2f 31 c7 cd cd     n..U\uQ1..3/1...
     9cd:	7d b3 c7 58 6c 7e 48 31 a3 8d 33 2f 31 c7 cd cd     }..Xl~H1..3/1...

000009dd <HunoBasic_GetupBack_Torque>:
     9dd:	04 04 04 04 04 04 04 04 04 04 04 04 04 04 04 04     ................
     9ed:	04 04 04 04 04 04 04 04 04 04 04 04 04 04 04 04     ................
     9fd:	03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03     ................
	...
     a15:	00 00 04 04 04 04 04 04 03 03 03 03 03 03 03 03     ................
     a25:	03 03 03 03 03 03 03 03 02 02 02 02 02 02 02 02     ................
     a35:	02 02 04 04 04 04 04 04 02 02 02 02 02 02 02 02     ................
     a45:	02 02 04 04 04 04 04 04 02 02 02 02 02 02 02 02     ................
     a55:	02 02 04 04 04 04 04 04 02 02 02 02 02 02 02 02     ................
     a65:	02 02 04 04 04 04 04 04 03 03 03 03 03 03 03 03     ................
     a75:	03 03 03 03 03 03 03 03                             ........

00000a7d <HunoBasic_GetupBack_Port>:
	...
     a8d:	03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03     ................
	...
     aad:	02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02     ................
	...
     acd:	01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01     ................
	...
     aed:	03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03     ................
	...

00000b1d <HunoBasic_GetupBack_PGain>:
     b1d:	28 28 28 28 28 28 28 28 28 28 1e 1e 1e 1e 1e 1e     ((((((((((......

00000b2d <HunoBasic_GetupBack_DGain>:
     b2d:	3c 3c 3c 3c 3c 3c 3c 3c 3c 3c 32 32 32 32 32 32     <<<<<<<<<<222222

00000b3d <HunoBasic_GetupBack_IGain>:
	...

00000b4d <HunoBasic_GetupBack_Frames>:
     b4d:	0f 00 1e 00 2d 00 2d 00 2d 00 1e 00 1e 00 1e 00     ....-.-.-.......
     b5d:	1e 00 1e 00                                         ....

00000b61 <HunoBasic_GetupBack_TrTime>:
     b61:	2c 01 58 02 84 03 84 03 84 03 58 02 58 02 58 02     ,.X.......X.X.X.
     b71:	58 02 58 02                                         X.X.

00000b75 <HunoBasic_GetupBack_Position>:
     b75:	7d b3 c7 58 6c 7e 48 31 a3 8d 33 2f 31 c7 cd cd     }..Xl~H1..3/1...
     b85:	7d b3 c7 58 6c 7e 48 31 a3 8d 33 2f 31 c7 cd cd     }..Xl~H1..3/1...
     b95:	7c dc f7 7d 6c 7e 1d 04 7f 8c 33 2f 31 c7 cd cd     |..}l~....3/1...
     ba5:	7b dc f6 56 70 7e 1d 07 a9 8b 01 3b 4a fd bf b5     {..Vp~.....;J...
     bb5:	82 53 90 3f 6c 7d aa 67 bf 8b 01 3b a3 fd bf 58     .S.?l}.g...;...X
     bc5:	82 53 90 3f 6c 7d aa 67 bf 8b ea 7d 5a 05 81 a6     .S.?l}.g...}Z...
     bd5:	81 5e b7 64 6e 80 a2 6e ba 88 a0 2d 51 5a cd a7     .^.dn..n...-QZ..
     be5:	81 57 bf 3c 6e 80 a2 3b c1 88 8a 2e 59 74 cb a7     .W.<n..;....Yt..
     bf5:	81 81 be 41 6e 80 78 3b bb 8c 85 2d 51 74 cb a7     ...An.x;...-Qt..
     c05:	81 a1 c5 47 6e 80 59 35 b5 8f 8f 24 59 74 cb a7     ...Gn.Y5...$Yt..
     c15:	7d b3 c7 58 6c 7e 48 31 a3 8d 33 2f 31 c7 cd cd     }..Xl~H1..3/1...

00000c25 <HunoBasic_GetupFront_Torque>:
     c25:	04 04 04 04 04 04 04 04 04 04 04 04 04 04 04 04     ................
     c35:	01 01 01 01 01 01 01 01 01 01 04 04 04 04 04 04     ................
     c45:	04 04 04 04 04 04 04 04 04 04 04 04 04 04 04 04     ................
     c55:	01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01     ................
     c65:	01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01     ................
     c75:	02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02     ................
     c85:	02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02     ................
     c95:	02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02     ................
     ca5:	04 04 04 04 04 04 04 04 04 04 04 04 04 04 04 04     ................

00000cb5 <HunoBasic_GetupFront_Port>:
	...
     cc5:	03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03     ................
	...
     ce5:	02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02     ................
	...
     d05:	01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01     ................
	...
     d25:	03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03     ................
	...

00000d45 <HunoBasic_GetupFront_PGain>:
     d45:	28 28 28 28 28 28 28 28 28 28 14 14 14 14 14 14     ((((((((((......

00000d55 <HunoBasic_GetupFront_DGain>:
     d55:	3c 3c 3c 3c 3c 3c 3c 3c 3c 3c 1e 1e 1e 1e 1e 1e     <<<<<<<<<<......

00000d65 <HunoBasic_GetupFront_IGain>:
	...

00000d75 <HunoBasic_GetupFront_Frames>:
     d75:	0a 00 0a 00 0a 00 0a 00 01 00 23 00 1e 00 28 00     ..........#...(.
     d85:	1e 00                                               ..

00000d87 <HunoBasic_GetupFront_TrTime>:
     d87:	2c 01 f4 01 f4 01 bc 02 34 03 bc 02 58 02 20 03     ,.......4...X. .
     d97:	58 02                                               X.

00000d99 <HunoBasic_GetupFront_Position>:
     d99:	7d b3 c7 58 6c 7e 48 31 a3 8d 33 2f 31 c7 cd cd     }..Xl~H1..3/1...
     da9:	7d b3 c7 58 6c 7e 48 31 a3 8d 33 2f 31 c7 cd cd     }..Xl~H1..3/1...
     db9:	7d 52 d6 59 6c 7e 48 31 a3 8d 8f 2f 31 72 cd cd     }R.Yl~H1.../1r..
     dc9:	7d 52 da 65 72 7d a6 22 97 8f 8d 2f 31 72 cd cd     }R.er}.".../1r..
     dd9:	7d d2 e4 50 71 7c 23 19 ac 8e a7 2f 2f 52 cd cc     }..Pq|#....//R..
     de9:	7d da f7 56 71 7b 1f 05 a8 8d 09 57 92 fe a2 6c     }..Vq{.....W...l
     df9:	7d dc f4 7a 6d 7b 1d 05 80 8d 21 2a 92 de d2 6c     }..zm{....!*...l
     e09:	7d dc de 7a 71 7b 1d 1c 87 8d 62 32 4e 92 c5 a9     }..zq{....b2N...
     e19:	7d a0 f2 72 71 7b 57 08 87 8d 52 2f 45 ad cd bf     }..rq{W...R/E...
     e29:	7d b3 c7 58 6c 7e 48 31 a3 8d 33 2f 31 c7 cd cd     }..Xl~H1..3/1...

00000e39 <HunoBasic_WalkForward_Torque>:
     e39:	03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03     ................
     e49:	03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03     ................
     e59:	03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03     ................
     e69:	02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02     ................
     e79:	01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01     ................
	...
     ea9:	01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01     ................
     eb9:	02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02     ................
     ec9:	03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03     ................
     ed9:	03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03     ................
     ee9:	03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03     ................
     ef9:	02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02     ................
     f09:	01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01     ................
	...
     f39:	01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01     ................
     f49:	02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02     ................
     f59:	03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03     ................
     f69:	03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03     ................
     f79:	02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02     ................
     f89:	01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01     ................
	...
     fb9:	01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01     ................
     fc9:	02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02     ................
     fd9:	03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03     ................
     fe9:	03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03     ................
     ff9:	03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03     ................
    1009:	02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02     ................
    1019:	01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01     ................
	...
    1049:	01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01     ................
    1059:	02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02     ................
    1069:	03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03     ................
    1079:	03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03     ................
    1089:	02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02     ................
    1099:	01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01     ................
    10a9:	04 04 04 04 04 04 04 04 04 04 04 04 04 04 04 04     ................

000010b9 <HunoBasic_WalkForward_Port>:
	...
    10c9:	03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03     ................
    10d9:	03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03     ................
    10e9:	02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02     ................
    10f9:	01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01     ................
	...
    1129:	01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01     ................
    1139:	02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02     ................
    1149:	03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03     ................
    1159:	03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03     ................
    1169:	03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03     ................
    1179:	02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02     ................
    1189:	01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01     ................
	...
    11b9:	01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01     ................
    11c9:	02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02     ................
    11d9:	03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03     ................
    11e9:	03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03     ................
    11f9:	02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02     ................
    1209:	01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01     ................
	...
    1239:	01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01     ................
    1249:	02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02     ................
    1259:	03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03     ................
    1269:	03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03     ................
    1279:	03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03     ................
    1289:	02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02     ................
    1299:	01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01     ................
	...
    12c9:	01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01     ................
    12d9:	02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02     ................
    12e9:	03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03     ................
    12f9:	03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03     ................
    1309:	02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02     ................
    1319:	01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01     ................
	...

00001339 <HunoBasic_WalkForward_PGain>:
    1339:	29 29 29 29 29 29 29 29 29 29 14 14 14 14 14 14     ))))))))))......

00001349 <HunoBasic_WalkForward_DGain>:
    1349:	3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 1e 1e 1e 1e 1e 1e     ==========......

00001359 <HunoBasic_WalkForward_IGain>:
	...

00001369 <HunoBasic_WalkForward_Frames>:
    1369:	05 00 01 00 01 00 01 00 01 00 01 00 01 00 01 00     ................
    1379:	01 00 01 00 01 00 01 00 01 00 01 00 01 00 01 00     ................
    1389:	01 00 01 00 01 00 01 00 01 00 01 00 01 00 01 00     ................
    1399:	01 00 01 00 01 00 01 00 01 00 01 00 01 00 01 00     ................
    13a9:	01 00 01 00 01 00 01 00 01 00 01 00 0a 00 0f 00     ................

000013b9 <HunoBasic_WalkForward_TrTime>:
    13b9:	c8 00 19 00 19 00 19 00 19 00 19 00 19 00 19 00     ................
    13c9:	19 00 19 00 19 00 19 00 19 00 19 00 19 00 19 00     ................
    13d9:	19 00 19 00 19 00 19 00 19 00 19 00 19 00 19 00     ................
    13e9:	19 00 19 00 19 00 19 00 19 00 19 00 19 00 19 00     ................
    13f9:	19 00 19 00 19 00 19 00 19 00 19 00 c8 00 2c 01     ..............,.

00001409 <HunoBasic_WalkForward_Position>:
    1409:	7d b3 c7 58 6c 7e 48 31 a3 8d 33 2f 31 c7 cd cd     }..Xl~H1..3/1...
    1419:	7d b3 c7 58 6c 7e 48 31 a3 8d 33 2f 31 c7 cd cd     }..Xl~H1..3/1...
    1429:	7d b3 c7 58 6c 7e 48 31 a3 8d 33 2f 31 c7 cd cd     }..Xl~H1..3/1...
    1439:	82 a5 c9 51 73 86 51 1f 93 95 48 2c 28 91 d1 c9     ...Qs.Q...H,(...
    1449:	84 ab c5 53 75 89 56 1c 94 98 4e 2b 29 9a d1 ce     ...Su.V...N+)...
    1459:	84 af c3 57 75 8b 5b 1b 98 9a 57 2b 2b a4 d1 d3     ...Wu.[...W++...
    1469:	84 b2 c5 5b 75 89 5f 1c 9d 98 61 2b 30 ac d1 d5     ...[u._...a+0...
    1479:	82 b3 c9 5f 73 86 60 1f a1 95 69 2b 35 b3 d2 d6     ..._s.`...i+5...
    1489:	7f b2 ce 62 70 82 5f 23 a6 91 6f 2a 39 b6 d2 d6     ...bp._#..o*9...
    1499:	7c af d4 64 6d 7f 5c 28 aa 8e 71 2a 3b b7 d2 d6     |..dm.\(..q*;...
    14a9:	7c af d4 64 6d 7f 5c 28 aa 8e 71 2a 3b b7 d2 d6     |..dm.\(..q*;...
    14b9:	78 ac d9 66 69 7b 58 2e aa 8a 6f 2a 39 b6 d2 d6     x..fi{X...o*9...
    14c9:	74 a7 dd 67 65 78 53 33 a9 87 6a 2b 35 b3 d2 d6     t..gexS3..j+5...
    14d9:	71 a2 e0 66 62 76 4d 37 a7 85 61 2b 30 ad d1 d5     q..fbvM7..a+0...
    14e9:	6f 9d e1 62 60 76 49 39 a3 85 57 2b 2b a4 d1 d3     o..b`vI9..W++...
    14f9:	71 99 e0 5d 62 76 46 37 9f 85 4f 2b 29 9a d1 ce     q..]bvF7..O+)...
    1509:	74 98 dd 59 65 78 45 33 9b 87 48 2c 28 92 d1 c9     t..YexE3..H,(...
    1519:	78 99 d9 54 69 7b 46 2e 98 8a 45 2c 28 8c d0 c5     x..Ti{F...E,(...
    1529:	7b 9c d4 50 6c 7e 49 28 96 8d 44 2c 28 8a d0 c3     {..Pl~I(..D,(...
    1539:	7b 9c d4 50 6c 7e 49 28 96 8d 44 2c 28 8a d0 c3     {..Pl~I(..D,(...
    1549:	82 a5 c9 51 73 86 51 1f 93 95 48 2c 28 91 d1 c9     ...Qs.Q...H,(...
    1559:	84 ab c5 53 75 89 56 1c 94 98 4e 2b 29 9a d1 ce     ...Su.V...N+)...
    1569:	84 af c3 57 75 8b 5b 1b 98 9a 57 2b 2b a4 d1 d3     ...Wu.[...W++...
    1579:	84 b2 c5 5b 75 89 5f 1c 9d 98 61 2b 30 ac d1 d5     ...[u._...a+0...
    1589:	82 b3 c9 5f 73 86 60 1f a1 95 69 2b 35 b3 d2 d6     ..._s.`...i+5...
    1599:	7f b2 ce 62 70 82 5f 23 a6 91 6f 2a 39 b6 d2 d6     ...bp._#..o*9...
    15a9:	7c af d4 64 6d 7f 5c 28 aa 8e 71 2a 3b b7 d2 d6     |..dm.\(..q*;...
    15b9:	7c af d4 64 6d 7f 5c 28 aa 8e 71 2a 3b b7 d2 d6     |..dm.\(..q*;...
    15c9:	78 ac d9 66 69 7b 58 2e aa 8a 6f 2a 39 b6 d2 d6     x..fi{X...o*9...
    15d9:	74 a7 dd 67 65 78 53 33 a9 87 6a 2b 35 b3 d2 d6     t..gexS3..j+5...
    15e9:	71 a2 e0 66 62 76 4d 37 a7 85 61 2b 30 ad d1 d5     q..fbvM7..a+0...
    15f9:	6f 9d e1 62 60 76 49 39 a3 85 57 2b 2b a4 d1 d3     o..b`vI9..W++...
    1609:	71 99 e0 5d 62 76 46 37 9f 85 4f 2b 29 9a d1 ce     q..]bvF7..O+)...
    1619:	74 98 dd 59 65 78 45 33 9b 87 48 2c 28 92 d1 c9     t..YexE3..H,(...
    1629:	78 99 d9 54 69 7b 46 2e 98 8a 45 2c 28 8c d0 c5     x..Ti{F...E,(...
    1639:	7b 9c d4 50 6c 7e 49 28 96 8d 44 2c 28 8a d0 c3     {..Pl~I(..D,(...
    1649:	7b 9c d4 50 6c 7e 49 28 96 8d 44 2c 28 8a d0 c3     {..Pl~I(..D,(...
    1659:	82 a5 c9 51 73 86 51 1f 93 95 48 2c 28 91 d1 c9     ...Qs.Q...H,(...
    1669:	84 ab c5 53 75 89 56 1c 94 98 4e 2b 29 9a d1 ce     ...Su.V...N+)...
    1679:	7d a6 e5 6a 6c 7e 56 17 96 8d 33 2f 31 c7 cd cd     }..jl~V...3/1...
    1689:	7d b3 c7 58 6c 7e 48 31 a3 8d 33 2f 31 c7 cd cd     }..Xl~H1..3/1...

00001699 <HunoBasic_WalkBackward_Torque>:
    1699:	04 04 04 04 04 04 04 04 04 04 04 04 04 04 04 04     ................
    16a9:	03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03     ................
    16b9:	02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02     ................
    16c9:	03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03     ................
    16d9:	02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02     ................
    16e9:	01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01     ................
	...
    1719:	01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01     ................
    1729:	02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02     ................
    1739:	03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03     ................
    1749:	03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03     ................
    1759:	03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03     ................
    1769:	02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02     ................
    1779:	01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01     ................
	...
    17a9:	01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01     ................
    17b9:	02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02     ................
    17c9:	03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03     ................
    17d9:	03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03     ................
    17e9:	02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02     ................
    17f9:	01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01     ................
	...
    1829:	01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01     ................
    1839:	02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02     ................
    1849:	03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03     ................
    1859:	03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03     ................
    1869:	03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03     ................
    1879:	02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02     ................
    1889:	01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01     ................
	...
    18b9:	01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01     ................
    18c9:	02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02     ................
    18d9:	03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03     ................
    18e9:	03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03     ................
    18f9:	02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02     ................
    1909:	01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01     ................
    1919:	02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02     ................
    1929:	04 04 04 04 04 04 04 04 04 04 04 04 04 04 04 04     ................

00001939 <HunoBasic_WalkBackward_Port>:
	...
    1969:	03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03     ................
    1979:	02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02     ................
    1989:	01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01     ................
	...
    19b9:	01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01     ................
    19c9:	02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02     ................
    19d9:	03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03     ................
    19e9:	03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03     ................
    19f9:	03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03     ................
    1a09:	02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02     ................
    1a19:	01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01     ................
	...
    1a49:	01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01     ................
    1a59:	02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02     ................
    1a69:	03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03     ................
    1a79:	03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03     ................
    1a89:	02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02     ................
    1a99:	01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01     ................
	...
    1ac9:	01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01     ................
    1ad9:	02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02     ................
    1ae9:	03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03     ................
    1af9:	03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03     ................
    1b09:	03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03     ................
    1b19:	02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02     ................
    1b29:	01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01     ................
	...
    1b59:	01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01     ................
    1b69:	02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02     ................
    1b79:	03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03     ................
    1b89:	03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03     ................
    1b99:	02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02     ................
    1ba9:	01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01     ................
	...

00001bd9 <HunoBasic_WalkBackward_PGain>:
    1bd9:	29 29 29 29 29 29 29 29 29 29 14 14 14 14 14 14     ))))))))))......

00001be9 <HunoBasic_WalkBackward_DGain>:
    1be9:	3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 1e 1e 1e 1e 1e 1e     ==========......

00001bf9 <HunoBasic_WalkBackward_IGain>:
	...

00001c09 <HunoBasic_WalkBackward_Frames>:
    1c09:	05 00 14 00 01 00 01 00 01 00 01 00 01 00 01 00     ................
    1c19:	01 00 01 00 01 00 01 00 01 00 01 00 01 00 01 00     ................
    1c29:	01 00 01 00 01 00 01 00 01 00 01 00 01 00 01 00     ................
    1c39:	01 00 01 00 01 00 01 00 01 00 01 00 01 00 01 00     ................
    1c49:	01 00 01 00 01 00 01 00 01 00 01 00 01 00 01 00     ................
    1c59:	0a 00 14 00                                         ....

00001c5d <HunoBasic_WalkBackward_TrTime>:
    1c5d:	2c 01 90 01 19 00 19 00 19 00 19 00 19 00 19 00     ,...............
    1c6d:	19 00 19 00 19 00 19 00 19 00 19 00 19 00 19 00     ................
    1c7d:	19 00 19 00 19 00 19 00 19 00 19 00 19 00 19 00     ................
    1c8d:	19 00 19 00 19 00 19 00 19 00 19 00 19 00 19 00     ................
    1c9d:	19 00 19 00 19 00 19 00 19 00 19 00 19 00 19 00     ................
    1cad:	90 01 90 01                                         ....

00001cb1 <HunoBasic_WalkBackward_Position>:
    1cb1:	7d b3 c7 58 6c 7e 48 31 a3 8d 33 2f 31 c7 cd cd     }..Xl~H1..3/1...
    1cc1:	7d b3 c7 58 6c 7e 48 31 a3 8d 33 2f 31 c7 cd cd     }..Xl~H1..3/1...
    1cd1:	7d a0 dc 6b 6c 7e 58 1f 92 8d 33 2f 31 c7 cd cd     }..kl~X...3/1...
    1ce1:	78 99 da 58 69 7b 48 2e 97 8a 39 2b 33 ae d2 d6     x..Xi{H...9+3...
    1cf1:	74 97 df 5b 65 78 46 34 9b 87 3a 2b 30 b1 d2 d6     t..[exF4..:+0...
    1d01:	70 98 e2 5e 61 77 46 39 a0 86 3b 2b 2d b6 d2 d6     p..^awF9..;+-...
    1d11:	6f 9b e3 63 60 76 48 3c a5 85 3f 2b 29 bc d1 d5     o..c`vH<..?+)...
    1d21:	70 a0 e2 66 61 76 4c 3a a7 85 44 2c 28 bf d1 d1     p..favL:..D,(...
    1d31:	73 a5 df 68 64 78 52 34 a8 87 49 2c 28 c1 d1 ce     s..hdxR4..I,(...
    1d41:	78 a9 da 68 69 7b 58 2e a7 8a 4d 2c 28 c2 d1 cb     x..hi{X...M,(...
    1d51:	7b ad d4 67 6c 7e 5c 28 a5 8d 4e 2b 28 c2 d1 ca     {..gl~\(..N+(...
    1d61:	7b ad d4 67 6c 7e 5c 28 a5 8d 4e 2b 28 c2 d1 ca     {..gl~\(..N+(...
    1d71:	7f b0 ce 63 70 82 5f 22 a2 91 4d 2c 28 c2 d1 cb     ...cp._"..M,(...
    1d81:	82 b2 c8 5f 73 86 61 1d 9f 95 4a 2c 28 c1 d1 ce     ..._s.a...J,(...
    1d91:	83 b2 c3 5a 74 8a 60 1a 9c 99 45 2c 28 c0 d1 d1     ...Zt.`...E,(...
    1da1:	84 b0 c0 55 75 8b 5d 19 97 9a 3f 2b 29 bc d1 d5     ...Uu.]...?+)...
    1db1:	84 ac c2 53 75 8a 58 1a 94 99 3c 2b 2d b7 d2 d6     ...Su.X...<+-...
    1dc1:	82 a6 c8 52 73 87 53 1d 92 96 3a 2b 30 b2 d2 d6     ...Rs.S...:+0...
    1dd1:	7f a0 ce 53 70 82 4f 22 92 91 39 2b 33 ae d2 d6     ...Sp.O"..9+3...
    1de1:	7c 9c d4 55 6d 7f 4b 28 93 8e 39 2b 34 ad d1 d6     |..Um.K(..9+4...
    1df1:	7c 9c d4 55 6d 7f 4b 28 93 8e 39 2b 34 ad d1 d6     |..Um.K(..9+4...
    1e01:	74 97 df 5b 65 78 46 34 9b 87 3a 2b 30 b1 d2 d6     t..[exF4..:+0...
    1e11:	70 98 e2 5e 61 77 46 39 a0 86 3b 2b 2d b6 d2 d6     p..^awF9..;+-...
    1e21:	6f 9b e3 63 60 76 48 3c a5 85 3f 2b 29 bc d1 d5     o..c`vH<..?+)...
    1e31:	70 a0 e2 66 61 76 4c 3a a7 85 44 2c 28 bf d1 d1     p..favL:..D,(...
    1e41:	73 a5 df 68 64 78 52 34 a8 87 49 2c 28 c1 d1 ce     s..hdxR4..I,(...
    1e51:	78 a9 da 68 69 7b 58 2e a7 8a 4d 2c 28 c2 d1 cb     x..hi{X...M,(...
    1e61:	7b ad d4 67 6c 7e 5c 28 a5 8d 4e 2b 28 c2 d1 ca     {..gl~\(..N+(...
    1e71:	7b ad d4 67 6c 7e 5c 28 a5 8d 4e 2b 28 c2 d1 ca     {..gl~\(..N+(...
    1e81:	7f b0 ce 63 70 82 5f 22 a2 91 4d 2c 28 c2 d1 cb     ...cp._"..M,(...
    1e91:	82 b2 c8 5f 73 86 61 1d 9f 95 4a 2c 28 c1 d1 ce     ..._s.a...J,(...
    1ea1:	83 b2 c3 5a 74 8a 60 1a 9c 99 45 2c 28 c0 d1 d1     ...Zt.`...E,(...
    1eb1:	84 b0 c0 55 75 8b 5d 19 97 9a 3f 2b 29 bc d1 d5     ...Uu.]...?+)...
    1ec1:	84 ac c2 53 75 8a 58 1a 94 99 3c 2b 2d b7 d2 d6     ...Su.X...<+-...
    1ed1:	82 a6 c8 52 73 87 53 1d 92 96 3a 2b 30 b2 d2 d6     ...Rs.S...:+0...
    1ee1:	7f a0 ce 53 70 82 4f 22 92 91 39 2b 33 ae d2 d6     ...Sp.O"..9+3...
    1ef1:	7c 9c d4 55 6d 7f 4b 28 93 8e 39 2b 34 ad d1 d6     |..Um.K(..9+4...
    1f01:	7c 9c d4 55 6d 7f 4b 28 93 8e 39 2b 34 ad d1 d6     |..Um.K(..9+4...
    1f11:	74 97 df 5b 65 78 46 34 9b 87 3a 2b 30 b1 d2 d6     t..[exF4..:+0...
    1f21:	70 98 e2 5e 61 77 46 39 a0 86 3b 2b 2d b6 d2 d6     p..^awF9..;+-...
    1f31:	6f 9b e3 63 60 76 48 3c a5 85 3f 2b 29 bc d1 d5     o..c`vH<..?+)...
    1f41:	6f 9b e3 62 60 76 59 19 9b 85 3f 2b 29 bc d1 d5     o..b`vY...?+)...
    1f51:	7d b3 c7 58 6c 7e 48 31 a3 8d 33 2f 31 c7 cd cd     }..Xl~H1..3/1...

00001f61 <LSHOOT_RuntimePGain>:
    1f61:	14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14     ................

00001f71 <LSHOOT_RuntimeDGain>:
    1f71:	1e 1e 1e 1e 1e 1e 1e 1e 1e 1e 1e 1e 1e 1e 1e 1e     ................

00001f81 <LSHOOT_RuntimeIGain>:
	...

00001f91 <LSHOOT_Frames>:
    1f91:	01 00 01 00 01 00 01 00 01 00 01 00                 ............

00001f9d <LSHOOT_TrTime>:
    1f9d:	14 00 14 00 40 01 14 00 40 01 14 00                 ....@...@...

00001fa9 <LSHOOT_Position>:
    1fa9:	7d b3 c7 58 6c 7e 48 31 a3 8d 33 2f 31 c7 cd cd     }..Xl~H1..3/1...
    1fb9:	7d b3 c7 58 6c 7e 48 31 a3 8d 33 2f 31 c7 cd cd     }..Xl~H1..3/1...
    1fc9:	73 b3 c7 58 5f 74 48 31 a3 80 33 2f 31 c7 cd cd     s..X_tH1..3/1...
    1fd9:	63 db ce 82 54 72 43 39 a1 7b 22 55 6e 76 c3 c9     c...TrC9.{"Unv..
    1fe9:	65 81 cb 2b 55 78 24 51 b4 7e 82 31 4c cf c7 e4     e..+Ux$Q.~.1L...
    1ff9:	65 81 cb 2a 55 78 24 51 b4 7b 82 31 4c cf c7 e4     e..*Ux$Q.{.1L...
    2009:	7d b3 c7 58 6c 7e 48 31 a3 8d 33 2f 31 c7 cd cd     }..Xl~H1..3/1...

00002019 <LSHOOT_Torque>:
    2019:	02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02     ................
    2029:	02 02 02 02 02 00 02 02 02 00 02 02 02 02 02 02     ................
	...
    2069:	02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02     ................

00002079 <LSHOOT_Port>:
	...

000020d9 <RSHOOT_RuntimePGain>:
    20d9:	14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14     ................

000020e9 <RSHOOT_RuntimeDGain>:
    20e9:	1e 1e 1e 1e 1e 1e 1e 1e 1e 1e 1e 1e 1e 1e 1e 1e     ................

000020f9 <RSHOOT_RuntimeIGain>:
	...

00002109 <RSHOOT_Frames>:
    2109:	01 00 01 00 01 00 01 00 01 00 0a 00                 ............

00002115 <RSHOOT_TrTime>:
    2115:	14 00 14 00 40 01 14 00 a4 01 dc 00                 ....@.......

00002121 <RSHOOT_Position>:
    2121:	7d b3 c7 58 6c 7e 48 31 a3 8d 33 2f 31 c7 cd cd     }..Xl~H1..3/1...
    2131:	7d b3 c7 58 6c 7e 48 31 a3 8d 33 2f 31 c7 cd cd     }..Xl~H1..3/1...
    2141:	87 b3 c7 58 79 88 48 31 a3 9a 33 2f 31 c7 cd cd     ...Xy.H1..3/1...
    2151:	89 b8 bf 5a 7e 98 20 2a 78 a5 84 39 35 d8 a7 90     ...Z~. *x..95...
    2161:	83 c4 b6 4f 7a 96 7a 2d d0 a4 2b 35 50 78 cb b2     ...Oz.z-..+5Px..
    2171:	83 c4 b6 4f 80 96 7a 2d d0 a4 2b 35 50 78 cb b2     ...O..z-..+5Px..
    2181:	7d b3 c7 58 6c 7e 48 31 a3 8d 33 2f 31 c7 cd cd     }..Xl~H1..3/1...

00002191 <RSHOOT_Torque>:
    2191:	02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02     ................
    21a1:	02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02     ................
    21b1:	00 02 02 02 00 02 02 02 02 02 02 02 02 02 02 02     ................
	...
    21e1:	02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02     ................

000021f1 <RSHOOT_Port>:
	...

00002251 <LSIDEWALK_RuntimePGain>:
    2251:	28 28 28 28 28 28 28 28 28 28 14 14 14 14 14 14     ((((((((((......

00002261 <LSIDEWALK_RuntimeDGain>:
    2261:	3c 3c 3c 3c 3c 3c 3c 3c 3c 3c 1e 1e 1e 1e 1e 1e     <<<<<<<<<<......

00002271 <LSIDEWALK_RuntimeIGain>:
	...

00002281 <LSIDEWALK_Frames>:
    2281:	05 00 01 00 01 00 03 00                             ........

00002289 <LSIDEWALK_TrTime>:
    2289:	64 00 dc 00 64 00 3c 00                             d...d.<.

00002291 <LSIDEWALK_Position>:
    2291:	7d a8 c7 55 6c 7e 53 2f a7 8f 33 2f 31 c7 cd cd     }..Ul~S/..3/1...
    22a1:	6b 92 e9 63 5f 6c 64 1b 9f 83 38 3e 28 a6 ce d0     k..c_ld...8>(...
    22b1:	6b 96 e9 66 5f 8f 57 26 a1 8c 38 3e 28 a6 ce d0     k..f_.W&..8>(...
    22c1:	7e 96 de 5c 6b 7d 62 1b 9f 90 4f 2c 28 a6 ce d0     ~..\k}b...O,(...
    22d1:	7d a5 c7 55 6c 7e 55 2f a7 8f 33 2f 31 c7 cd cd     }..Ul~U/..3/1...

000022e1 <LSIDEWALK_Torque>:
    22e1:	02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02     ................
    22f1:	02 02 02 02 02 00 00 00 00 00 03 03 03 03 03 03     ................
	...
    2309:	00 00 04 04 04 04 04 03 04 04 04 04 04 04 04 04     ................
    2319:	04 04 04 04 04 04 04 04                             ........

00002321 <LSIDEWALK_Port>:
	...
    2331:	01 01 01 01 01 00 00 00 00 00 01 01 01 00 00 00     ................
	...

00002361 <RSIDEWALK_RuntimePGain>:
    2361:	28 28 28 28 28 28 28 28 28 28 14 14 14 14 14 14     ((((((((((......

00002371 <RSIDEWALK_RuntimeDGain>:
    2371:	3c 3c 3c 3c 3c 3c 3c 3c 3c 3c 1e 1e 1e 1e 1e 1e     <<<<<<<<<<......

00002381 <RSIDEWALK_RuntimeIGain>:
	...

00002391 <RSIDEWALK_Frames>:
    2391:	05 00 01 00 01 00 03 00                             ........

00002399 <RSIDEWALK_TrTime>:
    2399:	64 00 dc 00 64 00 3c 00                             d...d.<.

000023a1 <RSIDEWALK_Position>:
    23a1:	7d a5 c7 55 6c 7e 57 2f a7 8f 33 2f 31 c7 cd cd     }..Ul~W/..3/1...
    23b1:	8b 96 e6 61 78 8e 65 10 9a 9c 4f 2c 28 b7 bc d0     ...ax.e...O,(...
    23c1:	64 9a e0 61 6b 8e 64 13 9a a1 4f 2c 28 b7 bc d0     d..ak.d...O,(...
    23d1:	79 9a de 5f 5d 7d 5e 20 9c 90 4f 2c 28 a6 ce d0     y.._]}^ ..O,(...
    23e1:	7d a7 c7 55 6c 7e 54 2f a7 8f 33 2f 31 c7 cd cd     }..Ul~T/..3/1...

000023f1 <RSIDEWALK_Torque>:
    23f1:	02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02     ................
    2401:	00 00 00 00 00 02 02 02 02 02 04 04 04 04 04 04     ................
    2411:	00 00 00 00 00 02 02 02 02 02 04 04 04 04 04 04     ................
    2421:	04 04 04 04 04 04 04 04 04 04 04 04 04 04 04 04     ................

00002431 <RSIDEWALK_Port>:
	...
    2445:	00 01 01 01 01 01 00 00 00 01 01 01 00 00 00 00     ................
	...

00002471 <STANDUPF_RuntimePGain>:
    2471:	14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14     ................

00002481 <STANDUPF_RuntimeDGain>:
    2481:	1e 1e 1e 1e 1e 1e 1e 1e 1e 1e 1e 1e 1e 1e 1e 1e     ................

00002491 <STANDUPF_RuntimeIGain>:
	...

000024a1 <STANDUPF_Frames>:
    24a1:	01 00 01 00 01 00 0a 00 0a 00                       ..........

000024ab <STANDUPF_TrTime>:
    24ab:	14 00 08 02 40 01 2c 01 08 02                       ....@.,...

000024b5 <STANDUPF_Position>:
    24b5:	7d b3 c7 58 6c 7e 48 31 a3 8d 33 2f 31 c7 cd cd     }..Xl~H1..3/1...
    24c5:	7d b3 c7 58 6c 7e 48 31 a3 8d 33 2f 31 c7 cd cd     }..Xl~H1..3/1...
    24d5:	7d 5e cd 59 6c 7a 99 33 a8 8c 0a 67 69 f1 92 8f     }^.Ylz.3...gi...
    24e5:	77 df f9 72 6b 7c 1d 02 8e 8f 0b 31 69 e9 ca 8b     w..rk|.....1i...
    24f5:	7d b9 f9 82 6c 7c 43 01 7c 91 2d 41 45 c9 bd af     }...l|C.|.-AE...
    2505:	7d b3 c7 58 6c 7e 48 31 a3 8d 33 2f 31 c7 cd cd     }..Xl~H1..3/1...

00002515 <STANDUPF_Torque>:
    2515:	02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02     ................
    2525:	02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02     ................
	...
    2555:	02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02     ................

00002565 <STANDUPF_Port>:
	...

000025b5 <STANDUPR_RuntimePGain>:
    25b5:	14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14     ................

000025c5 <STANDUPR_RuntimeDGain>:
    25c5:	1e 1e 1e 1e 1e 1e 1e 1e 1e 1e 1e 1e 1e 1e 1e 1e     ................

000025d5 <STANDUPR_RuntimeIGain>:
	...

000025e5 <STANDUPR_Frames>:
    25e5:	01 00 01 00 01 00 01 00 1e 00                       ..........

000025ef <STANDUPR_TrTime>:
    25ef:	14 00 dc 00 a4 01 5e 01 58 02                       ......^.X.

000025f9 <STANDUPR_Position>:
    25f9:	7d b3 c7 58 6c 7e 48 31 a3 8d 33 2f 31 c7 cd cd     }..Xl~H1..3/1...
    2609:	7d b3 c7 58 6c 7e 48 31 a3 8d 33 2f 31 c7 cd cd     }..Xl~H1..3/1...
    2619:	7a b3 c8 57 6c 7a 46 30 a3 8d 14 83 2a ee 6f c9     z..WlzF0....*.o.
    2629:	7a 85 c8 6e 67 80 76 2f 8d 8d 16 c8 6c e8 2f 85     z..ng.v/....l./.
    2639:	74 59 ed 51 68 84 a0 10 ad 92 01 d2 77 fe 27 79     tY.Qh.......w.'y
    2649:	7d b3 c7 58 6c 7e 48 31 a3 8d 33 2f 31 c7 cd cd     }..Xl~H1..3/1...

00002659 <STANDUPR_Torque>:
    2659:	02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02     ................
	...
    2699:	02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02     ................

000026a9 <STANDUPR_Port>:
	...

000026f9 <HUNODEMO_SITDOWN_RuntimePGain>:
    26f9:	14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14     ................

00002709 <HUNODEMO_SITDOWN_RuntimeDGain>:
    2709:	1e 1e 1e 1e 1e 1e 1e 1e 1e 1e 1e 1e 1e 1e 1e 1e     ................

00002719 <HUNODEMO_SITDOWN_RuntimeIGain>:
	...

00002729 <HUNODEMO_SITDOWN_Frames>:
    2729:	0a 00 28 00 0a 00 28 00                             ..(...(.

00002731 <HUNODEMO_SITDOWN_TrTime>:
    2731:	f4 01 e8 03 d0 07 e8 03                             ........

00002739 <HUNODEMO_SITDOWN_Position>:
    2739:	7d b3 c7 58 6c 7e 48 31 a3 8d 33 2f 31 c7 cd cd     }..Xl~H1..3/1...
    2749:	7d b3 c7 58 6c 7e 48 31 a3 8d 33 2f 31 c7 cd cd     }..Xl~H1..3/1...
    2759:	7d 93 f7 6a 6c 7e 66 04 91 8d 33 2f 31 c7 cd cd     }..jl~f...3/1...
    2769:	7d 93 f7 6a 6c 7e 66 04 91 8d 33 2f 31 c7 cd cd     }..jl~f...3/1...
    2779:	7d b3 c7 58 6c 7e 48 31 a3 8d 33 2f 31 c7 cd cd     }..Xl~H1..3/1...

00002789 <HUNODEMO_SITDOWN_Torque>:
    2789:	02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02     ................
    2799:	02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02     ................
	...
    27b9:	04 04 04 04 04 04 04 04 04 04 04 04 04 04 04 04     ................

000027c9 <HUNODEMO_SITDOWN_Port>:
	...
    27d9:	01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01     ................
    27e9:	03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03     ................
	...

00002809 <HUNODEMO_HI_RuntimePGain>:
    2809:	14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14     ................

00002819 <HUNODEMO_HI_RuntimeDGain>:
    2819:	1e 1e 1e 1e 1e 1e 1e 1e 1e 1e 1e 1e 1e 1e 1e 1e     ................

00002829 <HUNODEMO_HI_RuntimeIGain>:
	...

00002839 <HUNODEMO_HI_Frames>:
    2839:	0a 00 28 00 0a 00 0a 00 28 00                       ..(.....(.

00002843 <HUNODEMO_HI_TrTime>:
    2843:	f4 01 e8 03 f4 01 f4 01 e8 03                       ..........

0000284d <HUNODEMO_HI_Position>:
    284d:	7d b3 c7 58 6c 7e 48 31 a3 8d 33 2f 31 c7 cd cd     }..Xl~H1..3/1...
    285d:	7d b3 c7 58 6c 7e 48 31 a3 8d 33 2f 31 c7 cd cd     }..Xl~H1..3/1...
    286d:	7d b3 c7 58 6c 7e 48 31 a3 8d bb 3a 2e c7 cd cd     }..Xl~H1...:....
    287d:	7d b3 c7 58 6c 7e 48 31 a3 8d ba 67 2e c7 cd cd     }..Xl~H1...g....
    288d:	7d b3 c7 58 6c 7e 48 31 a3 8d bb 3a 2e c7 cd cd     }..Xl~H1...:....
    289d:	7d b3 c7 58 6c 7e 48 31 a3 8d 33 2f 31 c7 cd cd     }..Xl~H1..3/1...

000028ad <HUNODEMO_HI_Torque>:
    28ad:	02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02     ................
    28bd:	02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02     ................
    28cd:	02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02     ................
    28dd:	02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02     ................
    28ed:	04 04 04 04 04 04 04 04 04 04 04 04 04 04 04 04     ................

000028fd <HUNODEMO_HI_Port>:
	...

0000294d <HUNODEMO_KICKLEFTFRONTTURN_RuntimePGain>:
    294d:	14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14     ................

0000295d <HUNODEMO_KICKLEFTFRONTTURN_RuntimeDGain>:
    295d:	1e 1e 1e 1e 1e 1e 1e 1e 1e 1e 1e 1e 1e 1e 1e 1e     ................

0000296d <HUNODEMO_KICKLEFTFRONTTURN_RuntimeIGain>:
	...

0000297d <HUNODEMO_KICKLEFTFRONTTURN_Frames>:
    297d:	28 00 0a 00 14 00 14 00 01 00 01 00 0a 00 0a 00     (...............
    298d:	19 00 14 00 14 00 1e 00                             ........

00002995 <HUNODEMO_KICKLEFTFRONTTURN_TrTime>:
    2995:	84 03 c8 00 90 01 90 01 78 00 08 02 90 01 90 01     ........x.......
    29a5:	f4 01 90 01 90 01 58 02                             ......X.

000029ad <HUNODEMO_KICKLEFTFRONTTURN_Position>:
    29ad:	7d b3 c7 58 6c 7e 48 31 a3 8d 33 2f 31 c7 cd cd     }..Xl~H1..3/1...
    29bd:	7d b3 c7 58 6c 7e 48 31 a3 8d 33 2f 31 c7 cd cd     }..Xl~H1..3/1...
    29cd:	7d b0 f7 79 6c 7e 47 02 82 8d 33 2f 31 c7 cd cd     }..yl~G...3/1...
    29dd:	81 b4 ec 6a 4b 8b 47 02 82 74 03 32 4d ef 9d a0     ...jK.G..t.2M...
    29ed:	33 b4 ec 6a 5f 8b 47 02 82 74 01 32 4a e8 9e a0     3..j_.G..t.2J...
    29fd:	33 98 ed 2d 5f 8b 47 02 82 74 02 32 31 e8 98 a0     3..-_.G..t.21...
    2a0d:	33 85 95 2d 5f 8b 47 02 82 74 02 32 33 e8 8f a0     3..-_.G..t.23...
    2a1d:	33 8e ea 30 5f 8b 47 02 82 74 02 32 31 e8 9a a0     3..0_.G..t.21...
    2a2d:	7b c2 d2 56 52 8b 47 02 82 74 02 32 31 e8 95 a0     {..VR.G..t.21...
    2a3d:	84 ca dc 69 5b 90 3f 04 7d 8a 44 34 31 e8 aa a0     ...i[.?.}.D41...
    2a4d:	7b ae f8 76 6a 81 4c 04 87 8f 34 32 31 db c2 d5     {..vj.L...421...
    2a5d:	7b 9b f8 76 6a 81 5f 04 87 8f 34 32 31 db c2 d5     {..vj._...421...
    2a6d:	7d b3 c7 58 6c 7e 48 31 a3 8d 33 2f 31 c7 cd cd     }..Xl~H1..3/1...

00002a7d <HUNODEMO_KICKLEFTFRONTTURN_Torque>:
    2a7d:	04 04 04 04 04 04 04 04 04 04 04 04 04 04 04 04     ................
    2a8d:	04 04 04 04 04 04 04 04 04 04 04 04 04 04 04 04     ................
    2a9d:	04 04 04 04 04 04 04 04 04 04 04 04 04 04 04 04     ................
    2aad:	04 04 04 04 04 04 04 04 04 04 04 04 04 04 04 04     ................
    2abd:	00 00 00 00 00 04 04 04 04 04 04 04 04 04 04 04     ................
    2acd:	00 00 00 00 00 04 04 04 04 04 04 04 04 04 04 04     ................
    2add:	00 00 00 00 00 04 04 04 04 04 04 04 04 04 04 04     ................
    2aed:	04 04 04 03 04 04 04 04 04 04 04 04 04 04 04 04     ................
    2afd:	04 04 04 03 04 04 04 04 04 04 04 04 04 04 04 04     ................
    2b0d:	04 04 04 03 04 04 04 04 04 04 04 04 04 04 04 04     ................
    2b1d:	04 04 04 03 04 04 04 04 04 04 04 04 04 04 04 04     ................
    2b2d:	04 04 04 04 04 04 04 04 04 04 04 04 04 04 04 04     ................

00002b3d <HUNODEMO_KICKLEFTFRONTTURN_Port>:
	...
    2b4d:	02 02 02 02 02 00 00 00 00 00 00 00 00 00 00 00     ................
	...
    2b6d:	02 02 02 02 02 00 00 00 00 00 00 00 00 00 00 00     ................
    2b7d:	03 03 03 03 03 00 00 00 00 00 00 00 00 00 00 00     ................
    2b8d:	03 03 03 03 03 00 00 00 00 00 00 00 00 00 00 00     ................
    2b9d:	02 02 02 02 02 00 00 00 00 00 00 00 00 00 00 00     ................
    2bad:	02 02 02 02 02 00 00 00 00 00 00 00 00 00 00 00     ................
	...

00002bfd <HANDSTANDS1_RuntimePGain>:
    2bfd:	28 28 28 28 28 28 28 28 28 28 14 14 14 14 14 14     ((((((((((......

00002c0d <HANDSTANDS1_RuntimeDGain>:
    2c0d:	3c 3c 3c 3c 3c 3c 3c 3c 3c 3c 1e 1e 1e 1e 1e 1e     <<<<<<<<<<......

00002c1d <HANDSTANDS1_RuntimeIGain>:
	...

00002c2d <HANDSTANDS1_Frames>:
    2c2d:	14 00 14 00 14 00 14 00 14 00 14 00 14 00 01 00     ................
    2c3d:	01 00 0a 00 28 00 0f 00 0f 00 05 00 32 00 32 00     ....(.......2.2.
    2c4d:	32 00 01 00 2d 00 2d 00 0a 00 0a 00 0a 00 0a 00     2...-.-.........
    2c5d:	2d 00 0a 00 0a 00 0a 00 0a 00 2d 00 50 00 1e 00     -.........-.P...
    2c6d:	0f 00 0f 00 0f 00 0f 00 0f 00 0f 00 0f 00 0f 00     ................

00002c7d <HANDSTANDS1_TrTime>:
    2c7d:	84 03 84 03 84 03 84 03 84 03 84 03 84 03 08 02     ................
    2c8d:	08 02 f4 01 40 06 58 02 58 02 34 08 fc 03 fc 03     ....@.X.X.4.....
    2c9d:	fc 03 e4 07 84 03 84 03 f4 01 f4 01 f4 01 f4 01     ................
    2cad:	84 03 f4 01 f4 01 f4 01 f4 01 84 03 40 06 40 06     ............@.@.
    2cbd:	58 02 58 02 58 02 58 02 58 02 58 02 58 02 58 02     X.X.X.X.X.X.X.X.

00002ccd <HANDSTANDS1_Position>:
    2ccd:	7d b3 c7 58 6c 7e 48 31 a3 8d 33 2f 31 c7 cd cd     }..Xl~H1..3/1...
    2cdd:	7d b3 c7 58 6c 7e 48 31 a3 8d 33 2f 31 c7 cd cd     }..Xl~H1..3/1...
    2ced:	7c b5 f7 7c 6c 7e 47 04 7f 8d 33 2f 31 c7 cd cd     |..|l~G...3/1...
    2cfd:	7c 77 f7 7c 6c 7e 83 04 7f 8d 87 30 4c 6c cd a7     |w.|l~.....0Ll..
    2d0d:	7c 4e f7 7c 6c 7e b9 04 7f 8d 87 30 04 6c cd ef     |N.|l~.....0.l..
    2d1d:	79 dd fa 68 6c 7e 9f 42 9b 8d be 30 04 36 cd ef     y..hl~.B...0.6..
    2d2d:	79 dd fa 68 6c 7e 9f 5a c6 8d ce 39 08 35 b6 f4     y..hl~.Z...9.5..
    2d3d:	79 dd fa 68 6c 7e 9f 42 b9 8d be 30 04 0f 5e 8d     y..hl~.B...0..^.
    2d4d:	79 dd fa 68 6c 7e 9f 42 b9 8d be 30 04 ae 7d 8d     y..hl~.B...0..}.
    2d5d:	79 dd fa 68 6c 7e 9f 42 b9 8d be 30 04 b4 72 e3     y..hl~.B...0..r.
    2d6d:	79 dd fa 68 6c 7e 9f 6c ca 8d cd 30 04 ab 32 ca     y..hl~.l...0..2.
    2d7d:	36 9f fa 68 6c 7e 1c 0e 9c 8d cd 30 04 ab 32 ca     6..hl~.....0..2.
    2d8d:	7e 9f fa 68 6c 81 1c 0e 9c 8d cd 2b 04 97 28 e6     ~..hl......+..(.
    2d9d:	7e c6 c6 6d 6c 81 37 3e 9c 8d cd 2b 04 97 28 e6     ~..ml.7>...+..(.
    2dad:	58 d9 81 7e 6c a7 1c 71 7f 8d cd 2b 04 97 28 e6     X..~l..q...+..(.
    2dbd:	35 d9 89 7e 6c c4 1c 71 7f 8d cd 2b 04 97 28 e6     5..~l..q...+..(.
    2dcd:	16 d9 8a 7e 6c ea 1c 71 7f 8d cd 2b 04 97 28 e6     ...~l..q...+..(.
    2ddd:	58 d9 86 7e 6c a7 1c 71 7f 8d cd 2b 04 97 28 e6     X..~l..q...+..(.
    2ded:	58 d9 86 7e 6c a7 1c 71 7f 8d cd 2b 04 97 28 e6     X..~l..q...+..(.
    2dfd:	7c c2 f7 6d 6b 81 38 04 93 90 cd 2b 04 97 28 e6     |..mk.8....+..(.
    2e0d:	7c cb d9 6d 6b 81 2f 23 93 90 cd 2b 04 97 28 e6     |..mk./#...+..(.
    2e1d:	7c b0 b2 61 6b 81 1d 14 93 90 cf 2b 04 8f 28 e6     |..ak......+..(.
    2e2d:	7c bd cb 61 6b 81 16 31 93 90 cd 2b 04 97 28 e6     |..ak..1...+..(.
    2e3d:	7c d8 c9 62 6b 81 3c 2a 9f 90 cd 2b 04 97 28 e6     |..bk.<*...+..(.
    2e4d:	7c e4 d2 68 6b 81 53 3a b3 90 cd 2b 04 97 28 e6     |..hk.S:...+..(.
    2e5d:	7c cb d9 6d 6b 81 2f 23 93 90 cd 2b 04 97 28 e6     |..mk./#...+..(.
    2e6d:	7c b0 b2 61 6b 81 1d 14 93 90 cf 2b 04 8f 28 e6     |..ak......+..(.
    2e7d:	7c bd cb 61 6b 81 16 31 93 90 cd 2b 04 97 28 e6     |..ak..1...+..(.
    2e8d:	7c d8 c9 62 6b 81 3c 2a 9f 90 cd 2b 04 97 28 e6     |..bk.<*...+..(.
    2e9d:	7c e4 d2 68 6b 81 53 3a b3 90 cd 2b 04 97 28 e6     |..hk.S:...+..(.
    2ead:	7c cb d9 6d 6b 81 2f 23 93 90 cd 2b 04 97 28 e6     |..mk./#...+..(.
    2ebd:	81 bf f7 6d 6b 82 9a 79 83 90 cd 2b 04 97 28 e6     ...mk..y...+..(.
    2ecd:	81 5e 81 3a 6e 80 a2 71 c4 88 cd 4e 04 97 79 e6     .^.:n..q...N..y.
    2edd:	81 5e 8a 3b 6e 80 99 78 c4 88 cd 4e 04 c2 84 8d     .^.;n..x...N....
    2eed:	81 5c 81 39 6e 80 a2 79 c4 88 cd 4e 04 40 84 8d     .\.9n..y...N.@..
    2efd:	81 5a 84 38 6e 80 a2 79 c4 88 d0 24 2e 34 d0 de     .Z.8n..y...$.4..
    2f0d:	81 5e b7 64 6e 80 a2 6e ba 88 a7 2d 57 5a ca a7     .^.dn..n...-WZ..
    2f1d:	81 57 c5 47 6e 80 a2 39 ba 8f 82 2d 53 74 cb a7     .W.Gn..9...-St..
    2f2d:	81 7d c5 47 6e 80 78 3b b8 8f 8f 24 59 74 cb a7     .}.Gn.x;...$Yt..
    2f3d:	7b a6 df 5e 6a 7d 51 23 a2 8d 8f 24 59 74 cb a7     {..^j}Q#...$Yt..
    2f4d:	7d b3 c7 58 6c 7e 48 31 a3 8d 33 2f 31 c7 cd cd     }..Xl~H1..3/1...

00002f5d <HANDSTANDS1_Torque>:
    2f5d:	04 04 04 04 04 04 04 04 04 04 04 04 04 04 04 04     ................
    2f6d:	04 04 04 04 04 04 04 04 04 04 04 04 04 04 04 04     ................
    2f7d:	04 04 04 04 04 04 04 04 04 04 04 04 04 04 04 04     ................
    2f8d:	04 04 04 04 04 04 04 04 04 04 04 04 04 04 04 04     ................
    2f9d:	04 04 04 04 04 04 04 04 00 00 04 04 04 04 04 04     ................
    2fad:	04 04 04 04 04 04 04 04 00 00 04 04 04 04 04 04     ................
    2fbd:	04 04 04 04 04 04 04 04 00 00 04 04 04 04 04 04     ................
    2fcd:	04 04 04 04 04 04 04 04 00 00 01 01 01 01 01 01     ................
    2fdd:	04 04 04 04 04 04 04 04 00 00 01 01 01 01 01 01     ................
    2fed:	04 04 04 04 04 04 04 04 00 00 01 01 01 01 01 01     ................
    2ffd:	01 01 01 01 01 01 01 01 00 00 01 01 01 01 01 01     ................
    300d:	01 01 01 01 01 01 01 01 00 00 01 01 01 01 01 01     ................
    301d:	04 04 04 04 04 04 04 04 00 00 04 04 04 04 04 04     ................
    302d:	04 04 04 04 04 04 04 04 00 00 01 01 01 01 01 01     ................
	...
    307d:	02 02 02 02 02 02 02 02 02 02 04 04 04 04 04 04     ................
    308d:	02 02 02 02 02 02 02 02 02 02 04 04 04 04 04 04     ................
    309d:	02 02 02 02 02 02 02 02 02 02 04 04 04 04 04 04     ................
    30ad:	02 02 02 02 02 02 02 02 02 02 04 04 04 04 04 04     ................
    30bd:	02 02 02 02 02 02 02 02 02 02 04 04 04 04 04 04     ................
    30cd:	02 02 02 02 02 02 02 02 02 02 04 04 04 04 04 04     ................
    30dd:	02 02 02 02 02 02 02 02 02 02 04 04 04 04 04 04     ................
    30ed:	02 02 02 02 02 02 02 02 02 02 04 04 04 04 04 04     ................
    30fd:	02 02 02 02 02 02 02 02 02 02 04 04 04 04 04 04     ................
    310d:	02 02 02 02 02 02 02 02 02 02 04 04 04 04 04 04     ................
    311d:	02 02 02 02 02 02 02 02 02 02 04 04 04 04 04 04     ................
    312d:	02 02 02 02 02 02 02 02 02 02 04 04 04 04 04 04     ................
    313d:	02 02 02 02 02 02 02 02 02 02 04 04 04 04 04 04     ................
    314d:	02 02 02 02 02 02 02 02 02 02 04 04 04 04 04 04     ................
    315d:	02 02 02 02 02 02 02 02 02 02 04 04 04 04 04 04     ................
    316d:	02 02 02 02 02 02 02 02 02 02 04 04 04 04 04 04     ................
    317d:	02 02 02 02 02 02 02 02 02 02 04 04 04 04 04 04     ................
    318d:	02 02 02 02 02 02 02 02 02 02 04 04 04 04 04 04     ................
    319d:	02 02 02 02 02 02 02 02 02 02 04 04 04 04 04 04     ................
    31ad:	02 02 02 02 02 02 02 02 02 02 04 04 04 04 04 04     ................
    31bd:	02 02 02 02 02 02 02 02 02 02 04 04 04 04 04 04     ................
    31cd:	02 02 02 02 02 02 02 02 02 02 04 04 04 04 04 04     ................

000031dd <HANDSTANDS1_Port>:
	...
    32ad:	01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01     ................
    32bd:	03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03     ................
    32cd:	01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01     ................
	...
    32ed:	03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03     ................
	...
    330d:	00 00 02 00 00 00 00 02 00 00 00 00 00 00 00 00     ................
	...
    332d:	00 03 00 00 03 00 03 00 00 03 00 00 00 00 00 00     ................
    333d:	02 00 00 00 00 02 00 00 00 00 00 00 00 00 00 00     ................
	...

0000345d <wCK_IDs>:
    345d:	00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f     ................

0000346d <__c.2350>:
    346d:	0d 0a 00                                            ...

00003470 <__c.2345>:
    3470:	20 25 64 20 25 78 2c 00                              %d %x,.

00003478 <HexChars>:
    3478:	30 31 32 33 34 35 36 37 38 39 41 42 43 44 45 46     0123456789ABCDEF
	...

00003489 <__c.1610>:
    3489:	25 64 0d 0a 00                                      %d...

0000348e <__c.1608>:
    348e:	20 4d 49 43 3d 00                                    MIC=.

00003494 <__c.1606>:
    3494:	25 64 6d 56 00                                      %dmV.

00003499 <__c.1604>:
    3499:	20 56 4f 4c 54 3d 00                                 VOLT=.

000034a0 <__c.1602>:
    34a0:	25 78 00                                            %x.

000034a3 <__c.1600>:
    34a3:	50 53 44 3d 00                                      PSD=.

000034a8 <__c.1799>:
    34a8:	20 7a 3d 25 64 0d 0a 00                              z=%d...

000034b0 <__c.1797>:
    34b0:	2c 20 79 3d 25 64 2c 00                             , y=%d,.

000034b8 <__c.1795>:
    34b8:	56 61 6c 75 65 73 20 78 3d 20 25 64 00              Values x= %d.

000034c5 <__c.1462>:
    34c5:	0a 49 64 6c 65 20 6d 6f 64 65 0a 00                 .Idle mode..

000034d1 <__c.2351>:
    34d1:	45 78 70 65 72 69 6d 65 6e 74 61 6c 20 6d 6f 64     Experimental mod
    34e1:	65 0d 0a 00                                         e...

000034e5 <__c.2294>:
    34e5:	65 6c 70 0d 0a 4c 20 20 6c 65 66 74 0d 0a 52 20     elp..L  left..R 
    34f5:	20 72 69 67 68 74 0d 0a 46 20 20 66 6f 72 77 61      right..F  forwa
    3505:	72 64 0d 0a 42 20 20 62 61 63 6b 0d 0a 7a 20 20     rd..B  back..z  
    3515:	74 69 6c 74 20 6f 6e 2f 6f 66 66 0d 0a 69 20 20     tilt on/off..i  
    3525:	41 44 43 20 74 65 73 74 20 28 50 53 44 2c 20 4d     ADC test (PSD, M
    3535:	69 63 2c 20 42 61 74 20 4c 65 76 65 6c 29 0d 0a     ic, Bat Level)..
    3545:	74 20 20 54 69 6c 74 20 74 65 73 74 20 28 6c 6f     t  Tilt test (lo
    3555:	6f 70 20 73 68 6f 77 69 6e 67 20 61 63 63 65 6c     op showing accel
    3565:	65 72 6f 6d 65 74 65 72 20 76 61 6c 75 65 73 20     erometer values 
    3575:	75 6e 74 69 6c 20 49 52 20 70 72 65 73 73 65 64     until IR pressed
    3585:	0d 0a 70 20 20 42 61 73 69 63 20 70 6f 73 65 0d     ..p  Basic pose.
    3595:	0a 71 20 20 44 69 73 70 6c 61 79 20 61 6c 6c 20     .q  Display all 
    35a5:	73 65 72 76 6f 20 70 6f 73 69 74 69 6f 6e 73 0d     servo positions.
    35b5:	0a 77 20 20 6c 65 61 6e 20 66 77 64 0d 0a 61 20     .w  lean fwd..a 
    35c5:	20 6c 65 61 6e 20 6c 65 66 74 0d 0a 64 20 20 6c      lean left..d  l
    35d5:	65 61 6e 20 72 69 67 68 74 0d 0a 73 20 20 6c 65     ean right..s  le
    35e5:	61 6e 20 62 61 63 6b 0d 0a 76 20 20 76 65 72 73     an back..v  vers
    35f5:	69 6f 6e 20 6e 75 6d 62 65 72 0d 0a 4d 20 20 6d     ion number..M  m
    3605:	6f 64 69 66 79 20 70 61 72 61 6d 20 5b 6e 5d 5b     odify param [n][
    3615:	2b 7c 2d 7c 3d 5d 20 5b 6e 6e 5d 0d 0a 72 20 20     +|-|=] [nn]..r  
    3625:	72 65 73 70 6f 6e 64 20 74 6f 20 65 76 65 6e 74     respond to event
    3635:	20 6f 6e 2f 6f 66 66 0d 0a 6c 20 20 6c 69 67 68      on/off..l  ligh
    3645:	74 20 66 6c 61 73 68 20 74 65 73 74 0d 0a 65 09     t flash test..e.
    3655:	5b 6e 6e 5d 20 73 65 74 20 61 63 74 69 6f 6e 20     [nn] set action 
    3665:	65 76 65 6e 74 20 6e 6e 20 28 74 77 6f 20 64 69     event nn (two di
    3675:	67 69 74 73 29 0d 0a 78 09 5b 6e 6e 5d 5b 2e 2e     gits)..x.[nn][..
    3685:	2e 5d 20 74 72 61 6e 73 6d 69 74 20 74 6f 20 77     .] transmit to w
    3695:	43 4b 20 62 75 73 20 5b 6e 6e 5d 20 62 79 74 65     CK bus [nn] byte
    36a5:	73 20 61 6e 73 20 77 61 69 74 20 66 6f 72 20 32     s ans wait for 2
    36b5:	20 6e 79 74 65 20 72 65 73 70 6f 6e 73 65 0d 0a      nyte response..
    36c5:	58 09 61 73 20 61 62 6f 76 65 20 62 75 74 20 6e     X.as above but n
    36d5:	6f 20 72 65 70 6f 6e 73 65 20 70 61 63 6b 65 74     o reponse packet
    36e5:	73 0d 0a 6d 20 20 6d 6f 76 65 20 2d 20 73 79 6e     s..m  move - syn
    36f5:	63 68 72 6f 6e 6f 75 73 20 6d 6f 76 65 20 2d 20     chronous move - 
    3705:	61 73 20 73 65 72 69 61 6c 73 6c 61 76 65 65 20     as serialslavee 
    3715:	6d 6f 64 65 20 62 75 74 20 77 61 69 74 73 0d 0a     mode but waits..
    3725:	26 20 20 45 6e 74 65 72 20 61 20 6e 65 77 20 70     &  Enter a new p
    3735:	72 6f 67 72 61 6d 0d 0a 3f 20 20 44 69 73 70 6c     rogram..?  Displ
    3745:	61 79 20 63 75 72 72 65 6e 74 20 6d 6f 64 65 0d     ay current mode.
    3755:	0a 21 20 20 52 75 6e 20 63 75 72 72 65 6e 74 20     .!  Run current 
    3765:	70 72 6f 67 72 61 6d 20 69 6e 20 6d 65 6d 6f 72     program in memor
    3775:	79 0d 0a 23 20 20 62 69 6e 61 72 79 20 6d 6f 64     y..#  binary mod
    3785:	65 0d 0a 00                                         e...

00003789 <__c.2289>:
    3789:	73 65 74 20 52 6f 62 6f 74 20 74 79 70 65 20 4f     set Robot type O
    3799:	74 68 65 72 0d 0a 00                                ther...

000037a0 <__c.2286>:
    37a0:	73 65 74 20 52 6f 62 6f 74 20 74 79 70 65 20 41     set Robot type A
    37b0:	64 76 0d 0a 00                                      dv...

000037b5 <__c.2283>:
    37b5:	73 65 74 20 52 6f 62 6f 74 20 74 79 70 65 20 48     set Robot type H
    37c5:	75 6e 6f 0d 0a 00                                   uno...

000037cb <__c.2280>:
    37cb:	52 6f 62 6f 74 20 74 79 70 65 20 2d 20 4f 54 48     Robot type - OTH
    37db:	45 52 0d 0a 00                                      ER...

000037e0 <__c.2277>:
    37e0:	52 6f 62 6f 74 20 74 79 70 65 20 2d 20 41 44 41     Robot type - ADA
    37f0:	4e 43 45 44 0d 0a 00                                NCED...

000037f7 <__c.2273>:
    37f7:	52 6f 62 6f 74 20 74 79 70 65 20 2d 20 42 41 53     Robot type - BAS
    3807:	49 43 0d 0a 00                                      IC...

0000380c <__c.2262>:
    380c:	0d 0a 00                                            ...

0000380f <__c.2260>:
    380f:	25 64 20 20 00                                      %d  .

00003814 <__c.2258>:
    3814:	25 64 2c 00                                         %d,.

00003818 <__c.2256>:
    3818:	25 64 2c 00                                         %d,.

0000381c <__c.2254>:
    381c:	25 64 2c 00                                         %d,.

00003820 <__c.2252>:
    3820:	25 64 2c 00                                         %d,.

00003824 <__c.2250>:
    3824:	25 64 2c 00                                         %d,.

00003828 <__c.2245>:
    3828:	25 64 2c 00                                         %d,.

0000382c <__c.2242>:
    382c:	25 64 2c 00                                         %d,.

00003830 <__c.2238>:
    3830:	0d 0a 00                                            ...

00003833 <__c.2236>:
    3833:	25 78 20 20 00                                      %x  .

00003838 <__c.2234>:
    3838:	25 78 00                                            %x.

0000383b <__c.2232>:
    383b:	25 78 00                                            %x.

0000383e <__c.2230>:
    383e:	25 78 00                                            %x.

00003841 <__c.2228>:
    3841:	25 78 00                                            %x.

00003844 <__c.2226>:
    3844:	25 78 00                                            %x.

00003847 <__c.2221>:
    3847:	25 78 00                                            %x.

0000384a <__c.2218>:
    384a:	25 78 2c 00                                         %x,.

0000384e <__c.2214>:
    384e:	42 75 69 6c 74 3a 20 41 70 72 20 32 32 20 32 30     Built: Apr 22 20
    385e:	31 30 0d 0a 00                                      10...

00003863 <__c.2212>:
    3863:	65 72 3d 00                                         er=.

00003867 <__c.2209>:
    3867:	44 79 6e 61 6d 69 63 20 42 61 6c 61 6e 63 65 20     Dynamic Balance 
    3877:	54 65 73 74 20 4c 2f 52 20 28 25 78 29 0d 0a 00     Test L/R (%x)...

00003887 <__c.2205>:
    3887:	4d 6f 76 65 50 6f 73 20 28 25 64 29 20 20 25 78     MovePos (%d)  %x
    3897:	20 2d 20 25 78 0d 0a 00                              - %x...

0000389f <__c.2203>:
    389f:	52 65 61 64 50 6f 73 20 28 32 29 28 37 29 20 25     ReadPos (2)(7) %
    38af:	78 20 2d 20 25 78 2c 20 00                          x - %x, .

000038b8 <__c.2201>:
    38b8:	44 79 6e 61 6d 69 63 20 42 61 6c 61 6e 63 65 20     Dynamic Balance 
    38c8:	54 65 73 74 20 46 2f 42 20 28 25 78 29 0d 0a 00     Test F/B (%x)...

000038d8 <__c.2197>:
    38d8:	52 65 73 70 6f 6e 73 65 20 28 25 78 29 0d 0a 00     Response (%x)...

000038e8 <__c.2194>:
    38e8:	41 63 63 65 6c 20 6f 6e 20 2d 20 5a 65 72 6f 28     Accel on - Zero(
    38f8:	25 64 2c 25 64 2c 25 64 29 0d 0a 00                 %d,%d,%d)...

00003904 <__c.2192>:
    3904:	41 63 63 65 6c 20 6f 66 66 0d 0a 00                 Accel off...

00003910 <__c.2186>:
    3910:	54 69 6c 74 20 54 65 73 74 20 2d 20 6c 6f 6f 70     Tilt Test - loop
    3920:	73 20 75 6e 74 69 6c 20 61 6e 79 20 62 75 74 74     s until any butt
    3930:	6f 6e 20 6f 6e 20 49 52 20 70 72 65 73 73 65 64     on on IR pressed
    3940:	0d 0a 00                                            ...

00003943 <__c.2180>:
    3943:	41 44 43 20 54 65 73 74 20 2d 20 6c 6f 6f 70 73     ADC Test - loops
    3953:	20 75 6e 74 69 6c 20 61 6e 79 20 62 75 74 74 6f      until any butto
    3963:	6e 20 6f 6e 20 49 52 20 70 72 65 73 73 65 64 0d     n on IR pressed.
    3973:	0a 00                                               ..

00003975 <__c.2172>:
    3975:	4e 2f 41 0d 0a 00                                   N/A...

0000397b <__c.2170>:
    397b:	42 61 73 69 63 20 50 6f 73 65 0d 0a 00              Basic Pose...

00003988 <__c.2167>:
    3988:	4f 6e 6c 79 20 77 68 65 6e 20 69 6e 20 48 55 4e     Only when in HUN
    3998:	4f 20 42 41 53 49 43 20 6d 6f 64 65 0d 0a 00        O BASIC mode...

000039a7 <__c.2165>:
    39a7:	44 6f 20 4d 6f 74 69 6f 6e 20 25 78 0d 0a 00        Do Motion %x...

000039b6 <__c.2125>:
    39b6:	54 69 6c 74 20 65 76 65 6e 74 20 7a 20 5b 25 64     Tilt event z [%d
    39c6:	5d 20 28 25 64 2c 25 64 2c 25 64 29 0d 0a 00        ] (%d,%d,%d)...

000039d5 <__c.2123>:
    39d5:	54 69 6c 74 20 65 76 65 6e 74 20 79 20 5b 25 64     Tilt event y [%d
    39e5:	5d 20 28 25 64 2c 25 64 2c 25 64 29 0d 0a 00        ] (%d,%d,%d)...

000039f4 <__c.2121>:
    39f4:	54 69 6c 74 20 65 76 65 6e 74 20 58 20 5b 25 64     Tilt event X [%d
    3a04:	5d 20 28 25 64 2c 25 64 2c 25 64 29 0d 0a 00        ] (%d,%d,%d)...

00003a13 <__c.2067>:
    3a13:	44 6f 6e 65 0d 0a 00                                Done...

00003a1a <__c.2065>:
    3a1a:	52 65 63 65 69 76 65 64 20 25 64 20 62 79 74 65     Received %d byte
    3a2a:	73 0d 0a 00                                         s...

00003a2e <__c.2057>:
    3a2e:	5e 00                                               ^.

00003a30 <__c.2045>:
    3a30:	20 50 5b 25 64 5d 3d 25 78 0d 0a 00                  P[%d]=%x...

00003a3c <__c.2043>:
    3a3c:	25 63 00                                            %c.

00003a3f <__c.2035>:
    3a3f:	20 53 70 65 63 69 61 6c 20 65 76 65 6e 74 20 5b      Special event [
    3a4f:	25 78 5d 0d 0a 00                                   %x]...

00003a55 <__c.2030>:
    3a55:	25 64 0d 0a 00                                      %d...

00003a5a <__c.2027>:
    3a5a:	25 63 00                                            %c.

00003a5d <__c.2022>:
    3a5d:	77 63 4b 20 69 6e 74 65 72 61 63 74 69 76 65 20     wcK interactive 
    3a6d:	28 61 74 20 39 36 30 30 29 20 3a 20 00              (at 9600) : .

00003a7a <__c.2019>:
    3a7a:	20 6f 6b 0d 0a 00                                    ok...

00003a80 <__c.2017>:
    3a80:	3d 25 78 25 78 0d 0a 00                             =%x%x...

00003a88 <__c.2007>:
    3a88:	45 78 70 65 72 69 6d 65 6e 74 61 6c 20 4d 6f 64     Experimental Mod
    3a98:	65 20 28 27 68 27 20 66 6f 72 20 68 65 6c 70 29     e ('h' for help)
    3aa8:	0d 0a 00                                            ...

00003aab <__c.2005>:
    3aab:	25 63 00                                            %c.

00003aae <__c.1984>:
    3aae:	4d 49 43 20 65 76 65 6e 74 20 25 78 0d 0a 00        MIC event %x...

00003abd <__c.1963>:
    3abd:	20 49 52 20 52 65 63 65 69 76 65 64 20 25 78 20      IR Received %x 
    3acd:	66 72 6f 6d 20 25 78 0d 0a 00                       from %x...

00003ad7 <__c.1939>:
    3ad7:	25 63 00                                            %c.

00003ada <__c.1919>:
    3ada:	25 63 00                                            %c.

00003add <__c.1901>:
    3add:	25 64 3a 25 64 3a 25 64 2d 25 64 20 00              %d:%d:%d-%d .

00003aea <__c.1761>:
    3aea:	56 6f 6c 74 61 67 65 20 3d 20 25 64 20 28 25 64     Voltage = %d (%d
    3afa:	29 0a 00                                            )..

00003afd <__c.1759>:
    3afd:	43 68 61 72 67 65 20 6d 6f 64 65 0a 00              Charge mode..

00003b0a <__c.1748>:
    3b0a:	45 78 69 74 69 6e 67 20 63 68 61 72 67 65 20 6d     Exiting charge m
    3b1a:	6f 64 65 0a 00                                      ode..

00003b1f <__c.1745>:
    3b1f:	49 6e 69 74 69 61 74 69 6e 67 20 63 68 61 72 67     Initiating charg
    3b2f:	65 20 63 79 63 6c 65 0a 00                          e cycle..

00003b38 <__c.1742>:
    3b38:	56 6f 6c 74 61 67 65 20 3d 20 25 64 6d 76 20 28     Voltage = %dmv (
    3b48:	25 64 29 0a 00                                      %d)..

00003b4d <__c.1738>:
    3b4d:	43 68 61 72 67 65 20 6d 6f 64 65 0a 00              Charge mode..

00003b5a <__c.1700>:
    3b5a:	43 68 61 72 67 69 6e 67 20 63 6f 6d 70 6c 65 74     Charging complet
    3b6a:	65 20 2d 20 25 64 6d 56 0d 0a 00                    e - %dmV...

00003b75 <__c.1692>:
    3b75:	42 61 74 74 65 72 79 20 63 68 61 72 67 69 6e 67     Battery charging
    3b85:	0d 0a 00                                            ...

00003b88 <__c.2129>:
    3b88:	53 65 72 69 61 6c 20 53 6c 61 76 65 20 6d 6f 64     Serial Slave mod
    3b98:	65 0a 00                                            e..

00003b9b <__c.1882>:
    3b9b:	be ad 25 63 25 63 25 63 00                          ..%c%c%c.

00003ba4 <__c.2082>:
    3ba4:	42 61 74 74 65 72 79 20 76 6f 6c 74 61 67 65 3a     Battery voltage:
    3bb4:	20 25 64 20 6d 56 0a 00                              %d mV..

00003bbc <__c.2054>:
    3bbc:	20 6f 6b 0a 00                                       ok..

00003bc1 <__c.2052>:
    3bc1:	3d 25 78 25 78 0a 00                                =%x%x..

00003bc8 <__c.2017>:
    3bc8:	4c 6f 61 64 69 6e 67 20 6d 6f 74 69 6f 6e 20 62     Loading motion b
    3bd8:	75 66 20 25 64 0a 00                                uf %d..

00003bdf <__c.2015>:
    3bdf:	4e 65 78 74 20 6d 6f 74 69 6f 6e 20 69 6e 63 6f     Next motion inco
    3bef:	6d 70 6c 65 74 65 3a 20 25 64 20 3c 20 25 64 0a     mplete: %d < %d.
	...

00003c00 <__c.2013>:
    3c00:	4e 6f 20 6e 65 78 74 20 6d 6f 74 69 6f 6e 3b 20     No next motion; 
    3c10:	25 64 20 3d 3d 20 25 64 0a 00                       %d == %d..

00003c1a <__c.1992>:
    3c1a:	4e 6f 74 20 6c 6f 61 64 69 6e 67 20 6d 6f 74 69     Not loading moti
    3c2a:	6f 6e 20 62 65 63 61 75 73 65 20 77 65 27 72 65     on because we're
    3c3a:	20 61 6c 72 65 61 64 79 20 69 6e 20 6d 6f 74 69      already in moti
    3c4a:	6f 6e 00                                            on.

00003c4d <__c.1990>:
    3c4d:	4c 6f 61 64 69 6e 67 20 6d 6f 74 69 6f 6e 20 62     Loading motion b
    3c5d:	75 66 20 25 64 0a 00                                uf %d..

00003c64 <__c.1985>:
    3c64:	54 69 6d 65 64 20 6f 75 74 20 61 66 74 65 72 20     Timed out after 
    3c74:	72 65 63 65 69 76 69 6e 67 20 25 64 2f 25 64 20     receiving %d/%d 
    3c84:	62 79 74 65 73 0a 00                                bytes..

00003c8b <__c.1979>:
    3c8b:	45 72 72 6f 72 3a 20 72 65 71 75 65 73 74 65 64     Error: requested
    3c9b:	20 62 75 66 66 65 72 20 73 69 7a 65 20 28 25 64      buffer size (%d
    3cab:	29 20 65 78 63 65 65 64 73 20 6d 61 78 20 28 25     ) exceeds max (%
    3cbb:	64 29 0a 00                                         d)..

00003cbf <__c.1955>:
    3cbf:	6d 6f 74 69 6f 6e 42 75 66 3a 20 00                 motionBuf: .

00003ccb <__c.3003>:
    3ccb:	0d 0a 00                                            ...

00003cce <__c.3001>:
    3cce:	25 64 00                                            %d.

00003cd1 <__c.2999>:
    3cd1:	25 63 00                                            %c.

00003cd4 <__c.2997>:
    3cd4:	23 20 00                                            # .

00003cd7 <__c.2995>:
    3cd7:	25 64 20 3d 20 00                                   %d = .

00003cdd <__c.2993>:
    3cdd:	50 4f 52 54 3a 25 63 3a 25 63 00                    PORT:%c:%c.

00003ce8 <__c.2989>:
    3ce8:	25 63 20 3d 20 00                                   %c = .

00003cee <__c.2987>:
    3cee:	20 00                                                .

00003cf0 <__c.2985>:
    3cf0:	25 64 20 00                                         %d .

00003cf4 <__c.2963>:
    3cf4:	25 78 20 00                                         %x .

00003cf8 <__c.2960>:
    3cf8:	25 78 20 00                                         %x .

00003cfc <__c.2940>:
    3cfc:	25 78 20 00                                         %x .

00003d00 <__c.2937>:
    3d00:	25 78 20 00                                         %x .

00003d04 <__c.2928>:
    3d04:	43 6c 65 61 72 65 64 20 25 64 20 62 79 74 65 73     Cleared %d bytes
    3d14:	20 0d 0a 00                                          ...

00003d18 <__c.2786>:
    3d18:	25 64 00                                            %d.

00003d1b <__c.2771>:
    3d1b:	55 73 65 72 20 42 72 65 61 6b 20 6f 6e 20 6c 69     User Break on li
    3d2b:	6e 65 20 25 64 0d 0a 00                             ne %d...

00003d33 <__c.2769>:
    3d33:	3a 20 25 64 20 2d 20 00                             : %d - .

00003d3b <__c.2766>:
    3d3b:	52 75 6e 74 69 6d 65 20 65 72 72 6f 72 20 25 64     Runtime error %d
    3d4b:	0d 0a 00                                            ...

00003d4e <__c.2731>:
    3d4e:	3f 20 73 70 65 63 69 61 6c 20 25 64 20 69 73 20     ? special %d is 
    3d5e:	72 65 61 64 20 6f 6e 6c 79 0d 0a 00                 read only...

00003d6a <__c.2701>:
    3d6a:	47 6f 74 6f 20 6c 69 6e 65 20 6d 69 73 73 69 6e     Goto line missin
    3d7a:	67 20 3f 3f 0d 0a 00                                g ??...

00003d81 <__c.2657>:
    3d81:	65 76 61 6c 20 65 72 72 6f 72 20 25 64 2c 20 25     eval error %d, %
    3d91:	64 0d 0a 00                                         d...

00003d95 <__c.2517>:
    3d95:	70 61 6e 69 63 20 65 72 72 6f 72 0d 0a 00           panic error...

00003da3 <__c.2368>:
    3da3:	0d 0a 25 64 20 6c 69 6e 65 73 20 65 6e 74 65 72     ..%d lines enter
    3db3:	65 64 2c 20 5b 25 64 2f 25 64 5d 20 42 79 74 65     ed, [%d/%d] Byte
    3dc3:	73 0d 0a 00                                         s...

00003dc7 <__c.2366>:
    3dc7:	50 61 6e 69 63 20 25 64 0d 0a 00                    Panic %d...

00003dd2 <__c.2364>:
    3dd2:	50 6f 73 3d 25 64 20 5b 25 63 5d 0d 0a 00           Pos=%d [%c]...

00003de0 <__c.2339>:
    3de0:	50 72 6f 67 72 61 6d 20 65 6e 74 72 79 20 6d 6f     Program entry mo
    3df0:	64 65 20 28 2e 20 74 6f 20 65 78 69 74 29 0d 0a     de (. to exit)..
	...

00003e01 <__c.2336>:
    3e01:	0d 0a 00                                            ...

00003e04 <__c.2235>:
    3e04:	42 55 53 3d 25 64 0d 0a 00 00                       BUS=%d....

00003e0e <__ctors_end>:
    3e0e:	11 24       	eor	r1, r1
    3e10:	1f be       	out	0x3f, r1	; 63
    3e12:	cf ef       	ldi	r28, 0xFF	; 255
    3e14:	d0 e1       	ldi	r29, 0x10	; 16
    3e16:	de bf       	out	0x3e, r29	; 62
    3e18:	cd bf       	out	0x3d, r28	; 61

00003e1a <__do_copy_data>:
    3e1a:	15 e0       	ldi	r17, 0x05	; 5
    3e1c:	a0 e0       	ldi	r26, 0x00	; 0
    3e1e:	b1 e0       	ldi	r27, 0x01	; 1
    3e20:	e4 ed       	ldi	r30, 0xD4	; 212
    3e22:	fe ed       	ldi	r31, 0xDE	; 222
    3e24:	00 e0       	ldi	r16, 0x00	; 0
    3e26:	0b bf       	out	0x3b, r16	; 59
    3e28:	02 c0       	rjmp	.+4      	; 0x3e2e <__do_copy_data+0x14>
    3e2a:	07 90       	elpm	r0, Z+
    3e2c:	0d 92       	st	X+, r0
    3e2e:	a2 38       	cpi	r26, 0x82	; 130
    3e30:	b1 07       	cpc	r27, r17
    3e32:	d9 f7       	brne	.-10     	; 0x3e2a <__do_copy_data+0x10>

00003e34 <__do_clear_bss>:
    3e34:	1e e0       	ldi	r17, 0x0E	; 14
    3e36:	a2 e8       	ldi	r26, 0x82	; 130
    3e38:	b5 e0       	ldi	r27, 0x05	; 5
    3e3a:	01 c0       	rjmp	.+2      	; 0x3e3e <.do_clear_bss_start>

00003e3c <.do_clear_bss_loop>:
    3e3c:	1d 92       	st	X+, r1

00003e3e <.do_clear_bss_start>:
    3e3e:	ad 3b       	cpi	r26, 0xBD	; 189
    3e40:	b1 07       	cpc	r27, r17
    3e42:	e1 f7       	brne	.-8      	; 0x3e3c <.do_clear_bss_loop>
    3e44:	0e 94 22 21 	call	0x4244	; 0x4244 <main>
    3e48:	0c 94 68 6f 	jmp	0xded0	; 0xded0 <_exit>

00003e4c <__bad_interrupt>:
    3e4c:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00003e50 <__vector_20>:

//------------------------------------------------------------------------------
// UART0 wCK Transmit Interrupt Routine
//------------------------------------------------------------------------------
ISR(USART0_TX_vect)
{
    3e50:	1f 92       	push	r1
    3e52:	0f 92       	push	r0
    3e54:	0f b6       	in	r0, 0x3f	; 63
    3e56:	0f 92       	push	r0
    3e58:	0b b6       	in	r0, 0x3b	; 59
    3e5a:	0f 92       	push	r0
    3e5c:	11 24       	eor	r1, r1
    3e5e:	8f 93       	push	r24
    3e60:	9f 93       	push	r25
    3e62:	ef 93       	push	r30
    3e64:	ff 93       	push	r31
	if(gTx0BufIdx<gTx0Cnt){				// is pointer still less than length ?
    3e66:	90 91 b4 0a 	lds	r25, 0x0AB4
    3e6a:	80 91 7e 0b 	lds	r24, 0x0B7E
    3e6e:	98 17       	cp	r25, r24
    3e70:	78 f4       	brcc	.+30     	; 0x3e90 <__vector_20+0x40>
    	while(!(UCSR0A&(1<<UDRE))); 	// while data register empty
    3e72:	5d 9b       	sbis	0x0b, 5	; 11
    3e74:	fe cf       	rjmp	.-4      	; 0x3e72 <__vector_20+0x22>
		UDR0=gTx0Buf[gTx0BufIdx];		// send next character
    3e76:	e0 91 b4 0a 	lds	r30, 0x0AB4
    3e7a:	f0 e0       	ldi	r31, 0x00	; 0
    3e7c:	ee 53       	subi	r30, 0x3E	; 62
    3e7e:	f5 4f       	sbci	r31, 0xF5	; 245
    3e80:	80 81       	ld	r24, Z
    3e82:	8c b9       	out	0x0c, r24	; 12
    	gTx0BufIdx++;      				// increment pointer
    3e84:	80 91 b4 0a 	lds	r24, 0x0AB4
    3e88:	8f 5f       	subi	r24, 0xFF	; 255
    3e8a:	80 93 b4 0a 	sts	0x0AB4, r24
    3e8e:	0a c0       	rjmp	.+20     	; 0x3ea4 <__vector_20+0x54>
	}
	else if(gTx0BufIdx==gTx0Cnt){		// all sent
    3e90:	90 91 b4 0a 	lds	r25, 0x0AB4
    3e94:	80 91 7e 0b 	lds	r24, 0x0B7E
    3e98:	98 17       	cp	r25, r24
    3e9a:	21 f4       	brne	.+8      	; 0x3ea4 <__vector_20+0x54>
		gTx0BufIdx = 0;					// clear pointer
    3e9c:	10 92 b4 0a 	sts	0x0AB4, r1
		gTx0Cnt = 0;					// clear length
    3ea0:	10 92 7e 0b 	sts	0x0B7E, r1
	}
}
    3ea4:	ff 91       	pop	r31
    3ea6:	ef 91       	pop	r30
    3ea8:	9f 91       	pop	r25
    3eaa:	8f 91       	pop	r24
    3eac:	0f 90       	pop	r0
    3eae:	0b be       	out	0x3b, r0	; 59
    3eb0:	0f 90       	pop	r0
    3eb2:	0f be       	out	0x3f, r0	; 63
    3eb4:	0f 90       	pop	r0
    3eb6:	1f 90       	pop	r1
    3eb8:	18 95       	reti

00003eba <__vector_18>:

//------------------------------------------------------------------------------
// UART0 wCK Receive Interrupt Routine
//------------------------------------------------------------------------------
ISR(USART0_RX_vect)
{
    3eba:	1f 92       	push	r1
    3ebc:	0f 92       	push	r0
    3ebe:	0f b6       	in	r0, 0x3f	; 63
    3ec0:	0f 92       	push	r0
    3ec2:	0b b6       	in	r0, 0x3b	; 59
    3ec4:	0f 92       	push	r0
    3ec6:	11 24       	eor	r1, r1
    3ec8:	2f 93       	push	r18
    3eca:	3f 93       	push	r19
    3ecc:	8f 93       	push	r24
    3ece:	9f 93       	push	r25
    3ed0:	ef 93       	push	r30
    3ed2:	ff 93       	push	r31
	int		i;
    char	data;
	
	data=UDR0;		// get the data
    3ed4:	9c b1       	in	r25, 0x0c	; 12
	gRx0Cnt++;		// increment the pointer
    3ed6:	80 91 bb 0a 	lds	r24, 0x0ABB
    3eda:	8f 5f       	subi	r24, 0xFF	; 255
    3edc:	80 93 bb 0a 	sts	0x0ABB, r24
    3ee0:	21 e0       	ldi	r18, 0x01	; 1
    3ee2:	30 e0       	ldi	r19, 0x00	; 0
    // move the fifo down and store data at top of fifo
   	for(i=1; i<RX0_BUF_SIZE; i++) gRx0Buf[i-1] = gRx0Buf[i];
    3ee4:	f9 01       	movw	r30, r18
    3ee6:	ed 56       	subi	r30, 0x6D	; 109
    3ee8:	f5 4f       	sbci	r31, 0xF5	; 245
    3eea:	80 81       	ld	r24, Z
    3eec:	f9 01       	movw	r30, r18
    3eee:	ee 56       	subi	r30, 0x6E	; 110
    3ef0:	f5 4f       	sbci	r31, 0xF5	; 245
    3ef2:	80 83       	st	Z, r24
    3ef4:	2f 5f       	subi	r18, 0xFF	; 255
    3ef6:	3f 4f       	sbci	r19, 0xFF	; 255
    3ef8:	28 30       	cpi	r18, 0x08	; 8
    3efa:	31 05       	cpc	r19, r1
    3efc:	99 f7       	brne	.-26     	; 0x3ee4 <__vector_18+0x2a>
   	gRx0Buf[RX0_BUF_SIZE-1] = data;
    3efe:	90 93 9a 0a 	sts	0x0A9A, r25

}
    3f02:	ff 91       	pop	r31
    3f04:	ef 91       	pop	r30
    3f06:	9f 91       	pop	r25
    3f08:	8f 91       	pop	r24
    3f0a:	3f 91       	pop	r19
    3f0c:	2f 91       	pop	r18
    3f0e:	0f 90       	pop	r0
    3f10:	0b be       	out	0x3b, r0	; 59
    3f12:	0f 90       	pop	r0
    3f14:	0f be       	out	0x3f, r0	; 63
    3f16:	0f 90       	pop	r0
    3f18:	1f 90       	pop	r1
    3f1a:	18 95       	reti

00003f1c <__vector_16>:

//------------------------------------------------------------------------------
// Timer0 one millisec clock interrupt routine (0.998ms)
//------------------------------------------------------------------------------
ISR(TIMER0_OVF_vect)
{
    3f1c:	1f 92       	push	r1
    3f1e:	0f 92       	push	r0
    3f20:	0f b6       	in	r0, 0x3f	; 63
    3f22:	0f 92       	push	r0
    3f24:	11 24       	eor	r1, r1
    3f26:	2f 93       	push	r18
    3f28:	5f 93       	push	r21
    3f2a:	6f 93       	push	r22
    3f2c:	7f 93       	push	r23
    3f2e:	8f 93       	push	r24
    3f30:	9f 93       	push	r25
    3f32:	af 93       	push	r26
    3f34:	bf 93       	push	r27
	TCNT0 = 25; 		//reset the timer
    3f36:	89 e1       	ldi	r24, 0x19	; 25
    3f38:	82 bf       	out	0x32, r24	; 50
	// 1ms 
    if(++gMSEC>999){
    3f3a:	80 91 be 0a 	lds	r24, 0x0ABE
    3f3e:	90 91 bf 0a 	lds	r25, 0x0ABF
    3f42:	01 96       	adiw	r24, 0x01	; 1
    3f44:	90 93 bf 0a 	sts	0x0ABF, r25
    3f48:	80 93 be 0a 	sts	0x0ABE, r24
    3f4c:	80 91 be 0a 	lds	r24, 0x0ABE
    3f50:	90 91 bf 0a 	lds	r25, 0x0ABF
    3f54:	88 5e       	subi	r24, 0xE8	; 232
    3f56:	93 40       	sbci	r25, 0x03	; 3
    3f58:	08 f4       	brcc	.+2      	; 0x3f5c <__vector_16+0x40>
    3f5a:	43 c0       	rjmp	.+134    	; 0x3fe2 <__vector_16+0xc6>
		// 1s 
        gMSEC=0;
    3f5c:	10 92 bf 0a 	sts	0x0ABF, r1
    3f60:	10 92 be 0a 	sts	0x0ABE, r1
		
        if(gSEC_DCOUNT > 0)	gSEC_DCOUNT--;
    3f64:	80 91 bc 0a 	lds	r24, 0x0ABC
    3f68:	90 91 bd 0a 	lds	r25, 0x0ABD
    3f6c:	89 2b       	or	r24, r25
    3f6e:	49 f0       	breq	.+18     	; 0x3f82 <__vector_16+0x66>
    3f70:	80 91 bc 0a 	lds	r24, 0x0ABC
    3f74:	90 91 bd 0a 	lds	r25, 0x0ABD
    3f78:	01 97       	sbiw	r24, 0x01	; 1
    3f7a:	90 93 bd 0a 	sts	0x0ABD, r25
    3f7e:	80 93 bc 0a 	sts	0x0ABC, r24

        if(++gSEC>59){
    3f82:	80 91 ba 0a 	lds	r24, 0x0ABA
    3f86:	8f 5f       	subi	r24, 0xFF	; 255
    3f88:	80 93 ba 0a 	sts	0x0ABA, r24
    3f8c:	80 91 ba 0a 	lds	r24, 0x0ABA
    3f90:	8c 33       	cpi	r24, 0x3C	; 60
    3f92:	38 f1       	brcs	.+78     	; 0x3fe2 <__vector_16+0xc6>
			// 1m 
            gSEC=0;
    3f94:	10 92 ba 0a 	sts	0x0ABA, r1
			if(gMIN_DCOUNT > 0)	gMIN_DCOUNT--;
    3f98:	80 91 81 0b 	lds	r24, 0x0B81
    3f9c:	90 91 82 0b 	lds	r25, 0x0B82
    3fa0:	89 2b       	or	r24, r25
    3fa2:	49 f0       	breq	.+18     	; 0x3fb6 <__vector_16+0x9a>
    3fa4:	80 91 81 0b 	lds	r24, 0x0B81
    3fa8:	90 91 82 0b 	lds	r25, 0x0B82
    3fac:	01 97       	sbiw	r24, 0x01	; 1
    3fae:	90 93 82 0b 	sts	0x0B82, r25
    3fb2:	80 93 81 0b 	sts	0x0B81, r24
			
           if(++gMIN>59){
    3fb6:	80 91 9d 0a 	lds	r24, 0x0A9D
    3fba:	8f 5f       	subi	r24, 0xFF	; 255
    3fbc:	80 93 9d 0a 	sts	0x0A9D, r24
    3fc0:	80 91 9d 0a 	lds	r24, 0x0A9D
    3fc4:	8c 33       	cpi	r24, 0x3C	; 60
    3fc6:	68 f0       	brcs	.+26     	; 0x3fe2 <__vector_16+0xc6>
				// 1h 
                gMIN=0;
    3fc8:	10 92 9d 0a 	sts	0x0A9D, r1
                if(++gHOUR>23)
    3fcc:	80 91 b5 0a 	lds	r24, 0x0AB5
    3fd0:	8f 5f       	subi	r24, 0xFF	; 255
    3fd2:	80 93 b5 0a 	sts	0x0AB5, r24
    3fd6:	80 91 b5 0a 	lds	r24, 0x0AB5
    3fda:	88 31       	cpi	r24, 0x18	; 24
    3fdc:	10 f0       	brcs	.+4      	; 0x3fe2 <__vector_16+0xc6>
                    gHOUR=0;
    3fde:	10 92 b5 0a 	sts	0x0AB5, r1
            }
        }
    }
    
    if (!(gMSEC % 100)) gTicks++;
    3fe2:	80 91 be 0a 	lds	r24, 0x0ABE
    3fe6:	90 91 bf 0a 	lds	r25, 0x0ABF
    3fea:	64 e6       	ldi	r22, 0x64	; 100
    3fec:	70 e0       	ldi	r23, 0x00	; 0
    3fee:	0e 94 1d 6e 	call	0xdc3a	; 0xdc3a <__udivmodhi4>
    3ff2:	89 2b       	or	r24, r25
    3ff4:	49 f4       	brne	.+18     	; 0x4008 <__vector_16+0xec>
    3ff6:	80 91 82 05 	lds	r24, 0x0582
    3ffa:	90 91 83 05 	lds	r25, 0x0583
    3ffe:	01 96       	adiw	r24, 0x01	; 1
    4000:	90 93 83 05 	sts	0x0583, r25
    4004:	80 93 82 05 	sts	0x0582, r24
}
    4008:	bf 91       	pop	r27
    400a:	af 91       	pop	r26
    400c:	9f 91       	pop	r25
    400e:	8f 91       	pop	r24
    4010:	7f 91       	pop	r23
    4012:	6f 91       	pop	r22
    4014:	5f 91       	pop	r21
    4016:	2f 91       	pop	r18
    4018:	0f 90       	pop	r0
    401a:	0f be       	out	0x3f, r0	; 63
    401c:	0f 90       	pop	r0
    401e:	1f 90       	pop	r1
    4020:	18 95       	reti

00004022 <__vector_14>:

//------------------------------------------------------------------------------
// Timer1 Send Frame to wCK interrupt routine
//------------------------------------------------------------------------------
ISR(TIMER1_OVF_vect) 
{
    4022:	1f 92       	push	r1
    4024:	0f 92       	push	r0
    4026:	0f b6       	in	r0, 0x3f	; 63
    4028:	0f 92       	push	r0
    402a:	11 24       	eor	r1, r1
    402c:	2f 93       	push	r18
    402e:	3f 93       	push	r19
    4030:	8f 93       	push	r24
    4032:	9f 93       	push	r25
	if (gFrameIdx == gNumOfFrame) {   // are we at the end of the scene ?
    4034:	20 91 06 06 	lds	r18, 0x0606
    4038:	30 91 07 06 	lds	r19, 0x0607
    403c:	80 91 9d 0b 	lds	r24, 0x0B9D
    4040:	90 91 9e 0b 	lds	r25, 0x0B9E
    4044:	28 17       	cp	r18, r24
    4046:	39 07       	cpc	r19, r25
    4048:	61 f4       	brne	.+24     	; 0x4062 <__vector_14+0x40>
		gFrameIdx = 0;
    404a:	10 92 07 06 	sts	0x0607, r1
    404e:	10 92 06 06 	sts	0x0606, r1
		RUN_LED1_OFF;
    4052:	dd 9a       	sbi	0x1b, 5	; 27
		F_PLAYING=0;						// clear F_PLAYING state
    4054:	10 92 85 0b 	sts	0x0B85, r1
		TIMSK &= 0xfb;  					// Timer1 Overflow Interrupt disable
    4058:	87 b7       	in	r24, 0x37	; 55
    405a:	8b 7f       	andi	r24, 0xFB	; 251
    405c:	87 bf       	out	0x37, r24	; 55
		TCCR1B=0x00;
    405e:	1e bc       	out	0x2e, r1	; 46
    4060:	0f c0       	rjmp	.+30     	; 0x4080 <__vector_14+0x5e>
		return;
	}

	TCNT1=TxInterval;
    4062:	80 91 08 06 	lds	r24, 0x0608
    4066:	90 91 09 06 	lds	r25, 0x0609
    406a:	9d bd       	out	0x2d, r25	; 45
    406c:	8c bd       	out	0x2c, r24	; 44
	TIFR |= 0x04;							// restart timer
    406e:	86 b7       	in	r24, 0x36	; 54
    4070:	84 60       	ori	r24, 0x04	; 4
    4072:	86 bf       	out	0x36, r24	; 54
	TIMSK |= 0x04;							// Timer1 Overflow Interrupt enable
    4074:	87 b7       	in	r24, 0x37	; 55
    4076:	84 60       	ori	r24, 0x04	; 4
    4078:	87 bf       	out	0x37, r24	; 55
	
	F_NEXTFRAME = TRUE;			// trigger start of next frame (in process_frames)
    407a:	8f ef       	ldi	r24, 0xFF	; 255
    407c:	80 93 86 0b 	sts	0x0B86, r24
}
    4080:	9f 91       	pop	r25
    4082:	8f 91       	pop	r24
    4084:	3f 91       	pop	r19
    4086:	2f 91       	pop	r18
    4088:	0f 90       	pop	r0
    408a:	0f be       	out	0x3f, r0	; 63
    408c:	0f 90       	pop	r0
    408e:	1f 90       	pop	r1
    4090:	18 95       	reti

00004092 <HW_init>:


//------------------------------------------------------------------------------
// Initialise Ports
//------------------------------------------------------------------------------
void HW_init(void) {
    4092:	93 e0       	ldi	r25, 0x03	; 3
    4094:	9b bb       	out	0x1b, r25	; 27
	// Input/Output Ports initialization
	// Port A initialization
	// Func7=Out Func6=Out Func5=Out Func4=Out Func3=Out Func2=Out Func1=In Func0=In 
	// State7=0 State6=0 State5=0 State4=0 State3=0 State2=0 State1=P State0=P 
	PORTA=0x03;
	DDRA=0xFC;
    4096:	8c ef       	ldi	r24, 0xFC	; 252
    4098:	8a bb       	out	0x1a, r24	; 26

	// Port B initialization
	// Func7=In Func6=Out Func5=Out Func4=Out Func3=In Func2=Out Func1=In Func0=In 
	// State7=T State6=0 State5=0 State4=0 State3=T State2=0 State1=T State0=T 
	PORTB=0x00;
    409a:	18 ba       	out	0x18, r1	; 24
	DDRB=0x74;
    409c:	84 e7       	ldi	r24, 0x74	; 116
    409e:	87 bb       	out	0x17, r24	; 23

	// Port C initialization
	// Func7=Out Func6=In Func5=In Func4=In Func3=In Func2=In Func1=In Func0=In 
	// State7=0 State6=T State5=T State4=T State3=T State2=T State1=T State0=T 
	PORTC=0x00;
    40a0:	15 ba       	out	0x15, r1	; 21
	DDRC=0x80;
    40a2:	40 e8       	ldi	r20, 0x80	; 128
    40a4:	44 bb       	out	0x14, r20	; 20

	// Port D initialization
	// Func7=In Func6=In Func5=In Func4=In Func3=In Func2=In Func1=In Func0=In 
	// State7=T State6=T State5=T State4=T State3=T State2=T State1=P State0=P 
	PORTD=0x03;
    40a6:	92 bb       	out	0x12, r25	; 18
	DDRD=0x00;
    40a8:	11 ba       	out	0x11, r1	; 17

	// Port E initialization
	// Func7=In Func6=In Func5=In Func4=In Func3=Out Func2=In Func1=In Func0=In 
	// State7=T State6=P State5=P State4=P State3=0 State2=T State1=T State0=T 
	PORTE=0x70;
    40aa:	80 e7       	ldi	r24, 0x70	; 112
    40ac:	83 b9       	out	0x03, r24	; 3
	DDRE=0x08;
    40ae:	88 e0       	ldi	r24, 0x08	; 8
    40b0:	82 b9       	out	0x02, r24	; 2

	// Port F initialization
	// Func7=In Func6=In Func5=In Func4=In Func3=In Func2=In Func1=In Func0=In 
	// State7=T State6=T State5=T State4=T State3=T State2=T State1=T State0=T 
	PORTF=0x00;
    40b2:	10 92 62 00 	sts	0x0062, r1
	DDRF=0x00;
    40b6:	10 92 61 00 	sts	0x0061, r1

	// Port G initialization
	// Func4=In Func3=In Func2=Out Func1=In Func0=In 
	// State4=T State3=T State2=0 State1=T State0=T 
	PORTG=0x00;
    40ba:	10 92 65 00 	sts	0x0065, r1
	DDRG=0x04;
    40be:	84 e0       	ldi	r24, 0x04	; 4
    40c0:	80 93 64 00 	sts	0x0064, r24
	// Clock period = 1/230400 = 4.34us
	// Overflow time = 255*1/230400 = 1.107ms
	// 1ms overflow value =  255-230 = 25
	// Mode: Normal top=FFh
	// OC0 output: Disconnected
	ASSR=0x00;
    40c4:	10 be       	out	0x30, r1	; 48
	TCCR0=0x04;
    40c6:	83 bf       	out	0x33, r24	; 51
	TCNT0=0x00;
    40c8:	12 be       	out	0x32, r1	; 50
	OCR0=0x00;
    40ca:	11 be       	out	0x31, r1	; 49
	// Timer 1 Overflow Interrupt: On
	// Input Capture Interrupt: Off
	// Compare A Match Interrupt: Off
	// Compare B Match Interrupt: Off
	// Compare C Match Interrupt: Off
	TCCR1A=0x00;
    40cc:	1f bc       	out	0x2f, r1	; 47
	TCCR1B=0x05;
    40ce:	85 e0       	ldi	r24, 0x05	; 5
    40d0:	8e bd       	out	0x2e, r24	; 46
	TCNT1H=0x00;
    40d2:	1d bc       	out	0x2d, r1	; 45
	TCNT1L=0x00;
    40d4:	1c bc       	out	0x2c, r1	; 44
	ICR1H=0x00;
    40d6:	17 bc       	out	0x27, r1	; 39
	ICR1L=0x00;
    40d8:	16 bc       	out	0x26, r1	; 38
	OCR1AH=0x00;
    40da:	1b bc       	out	0x2b, r1	; 43
	OCR1AL=0x00;
    40dc:	1a bc       	out	0x2a, r1	; 42
	OCR1BH=0x00;
    40de:	19 bc       	out	0x29, r1	; 41
	OCR1BL=0x00;
    40e0:	18 bc       	out	0x28, r1	; 40
	OCR1CH=0x00;
    40e2:	10 92 79 00 	sts	0x0079, r1
	OCR1CL=0x00;
    40e6:	10 92 78 00 	sts	0x0078, r1
	// Clock source: System Clock
	// Clock freq: 14.400 kHz
	// Clock period = 1/14400 = 69.4us
	// Mode: Normal top=FFh
	// OC2 output: Disconnected
	TCCR2=0x05;
    40ea:	85 bd       	out	0x25, r24	; 37
	TCNT2=0x00;
    40ec:	14 bc       	out	0x24, r1	; 36
	OCR2=0x00;
    40ee:	13 bc       	out	0x23, r1	; 35

	// Timer 3---------------------------------------------------------------
	// Not used
	TCCR3A=0x00;
    40f0:	10 92 8b 00 	sts	0x008B, r1
	TCCR3B=0x03;
    40f4:	90 93 8a 00 	sts	0x008A, r25
	TCNT3H=0x00;
    40f8:	10 92 89 00 	sts	0x0089, r1
	TCNT3L=0x00;
    40fc:	10 92 88 00 	sts	0x0088, r1
	ICR3H=0x00;
    4100:	10 92 81 00 	sts	0x0081, r1
	ICR3L=0x00;
    4104:	10 92 80 00 	sts	0x0080, r1
	OCR3AH=0x00;
    4108:	10 92 87 00 	sts	0x0087, r1
	OCR3AL=0x00;
    410c:	10 92 86 00 	sts	0x0086, r1
	OCR3BH=0x00;
    4110:	10 92 85 00 	sts	0x0085, r1
	OCR3BL=0x00;
    4114:	10 92 84 00 	sts	0x0084, r1
	OCR3CH=0x00;
    4118:	10 92 83 00 	sts	0x0083, r1
	OCR3CL=0x00;
    411c:	10 92 82 00 	sts	0x0082, r1
	// INT3: Off
	// INT4: Off
	// INT5: Off
	// INT6: IR Remote falling edge
	// INT7: Off
	EICRA=0x00;
    4120:	10 92 6a 00 	sts	0x006A, r1
	EICRB=0x20;
    4124:	30 e2       	ldi	r19, 0x20	; 32
    4126:	3a bf       	out	0x3a, r19	; 58
	EIMSK=0x40;
    4128:	80 e4       	ldi	r24, 0x40	; 64
    412a:	89 bf       	out	0x39, r24	; 57

	// Timer(s)/Counter(s) Interrupt(s) initialization
	TIMSK=0x00;
    412c:	17 be       	out	0x37, r1	; 55
	ETIMSK=0x00;
    412e:	10 92 7d 00 	sts	0x007D, r1
	// Communication Parameters: 8 Data, 1 Stop, No Parity
	// USART0 Receiver: Off
	// USART0 Transmitter: On
	// USART0 Mode: Asynchronous
	// USART0 Baud rate: 115200
	UCSR0A=0x00;
    4132:	1b b8       	out	0x0b, r1	; 11
	//UCSR0B=0x98;
	//UCSR0B=0x48;
	UCSR0B = (1<<RXEN)|(1<<TXEN) |(1<<TXCIE); //enable reads for GetPos !!
    4134:	88 e5       	ldi	r24, 0x58	; 88
    4136:	8a b9       	out	0x0a, r24	; 10
	UCSR0C=0x06;
    4138:	26 e0       	ldi	r18, 0x06	; 6
    413a:	20 93 95 00 	sts	0x0095, r18
	UBRR0H=0x00;
    413e:	10 92 90 00 	sts	0x0090, r1
	UBRR0L=0x07;
    4142:	97 e0       	ldi	r25, 0x07	; 7
    4144:	99 b9       	out	0x09, r25	; 9
	// Communication Parameters: 8 Data, 1 Stop, No Parity
	// USART1 Receiver: On
	// USART1 Transmitter: On
	// USART1 Mode: Asynchronous
	// USART1 Baud rate: 115200
	UCSR1A=0x00;
    4146:	10 92 9b 00 	sts	0x009B, r1
	UCSR1B=0x18;		
    414a:	88 e1       	ldi	r24, 0x18	; 24
    414c:	80 93 9a 00 	sts	0x009A, r24
	UCSR1C=0x06;
    4150:	20 93 9d 00 	sts	0x009D, r18
	UBRR1H=0x00;
    4154:	10 92 98 00 	sts	0x0098, r1
	UBRR1L=BR115200;
    4158:	90 93 99 00 	sts	0x0099, r25

	// Analog Comparator initialization
	// Analog Comparator: Off
	// Analog Comparator Input Capture by Timer/Counter 1: Off
	// Analog Comparator Output: Off
	ACSR=0x80;
    415c:	48 b9       	out	0x08, r20	; 8
	SFIOR=0x00;
    415e:	10 bc       	out	0x20, r1	; 32
    //ADC initialization
    //ADC Clock frequency: 460.800 kHz
    //ADC Voltage Reference: AREF pin
    //Only the 8 most significant bits of
    //the AD conversion result are used
    ADMUX=ADC_VREF_TYPE;
    4160:	37 b9       	out	0x07, r19	; 7
    ADCSRA=0x00;	
    4162:	16 b8       	out	0x06, r1	; 6

	TWCR = 0;
    4164:	10 92 74 00 	sts	0x0074, r1
}
    4168:	08 95       	ret

0000416a <SW_init>:


//------------------------------------------------------------------------------
// Initialise software states
//------------------------------------------------------------------------------
void SW_init(void) {
    416a:	da 9a       	sbi	0x1b, 2	; 27

	PF1_LED1_OFF;			// LED states
	PF1_LED2_OFF;
    416c:	db 9a       	sbi	0x1b, 3	; 27
	PF2_LED_OFF;
    416e:	dc 9a       	sbi	0x1b, 4	; 27
	PWR_LED1_OFF;
    4170:	e5 e6       	ldi	r30, 0x65	; 101
    4172:	f0 e0       	ldi	r31, 0x00	; 0
    4174:	80 81       	ld	r24, Z
    4176:	84 60       	ori	r24, 0x04	; 4
    4178:	80 83       	st	Z, r24
	PWR_LED2_OFF;
    417a:	af 9a       	sbi	0x15, 7	; 21
	RUN_LED1_OFF;
    417c:	dd 9a       	sbi	0x1b, 5	; 27
	RUN_LED2_OFF;
    417e:	de 9a       	sbi	0x1b, 6	; 27
	ERR_LED_OFF;
    4180:	df 9a       	sbi	0x1b, 7	; 27

	F_PLAYING = 0;          // clear F_Playing
    4182:	10 92 85 0b 	sts	0x0B85, r1
	F_NEXTFRAME = 0;		// clear the next-frame trigger
    4186:	10 92 86 0b 	sts	0x0B86, r1

	gTx0Cnt = 0;			// UART0 clear length
    418a:	10 92 7e 0b 	sts	0x0B7E, r1
	gTx0BufIdx = 0;			// TX0 clear pointer
    418e:	10 92 b4 0a 	sts	0x0AB4, r1

	PSD_OFF;                // PSD distance sensor off
    4192:	c5 98       	cbi	0x18, 5	; 24

	gIRReady = FALSE;			// clear IR vales
    4194:	10 92 9d 0d 	sts	0x0D9D, r1
	IRState = IR_IDLE;
    4198:	10 92 9f 0d 	sts	0x0D9F, r1

	gMSEC=0;
    419c:	10 92 bf 0a 	sts	0x0ABF, r1
    41a0:	10 92 be 0a 	sts	0x0ABE, r1
	gSEC=0;
    41a4:	10 92 ba 0a 	sts	0x0ABA, r1
	gMIN=0;
    41a8:	10 92 9d 0a 	sts	0x0A9D, r1
	gHOUR=0;
    41ac:	10 92 b5 0a 	sts	0x0AB5, r1
}
    41b0:	08 95       	ret

000041b2 <initparams>:
// Main Routine
//------------------------------------------------------------------------------


void initparams()
{
    41b2:	84 e1       	ldi	r24, 0x14	; 20
    41b4:	90 e0       	ldi	r25, 0x00	; 0
    41b6:	90 93 9f 0a 	sts	0x0A9F, r25
    41ba:	80 93 9e 0a 	sts	0x0A9E, r24
/* TIMR  0, TLT   1, TORQ  2, PSDL  3
   PSDL2 4, PSDL3 5, MICL  6, MICL2 7
   MICL3 8, VOLT  9
*/	
    params[TIMR] = 20;    // t seconds
	params[TLT]  = 4;     // tlt
    41be:	84 e0       	ldi	r24, 0x04	; 4
    41c0:	90 e0       	ldi	r25, 0x00	; 0
    41c2:	90 93 a1 0a 	sts	0x0AA1, r25
    41c6:	80 93 a0 0a 	sts	0x0AA0, r24
	params[TORQ] = 2;     // -
    41ca:	82 e0       	ldi	r24, 0x02	; 2
    41cc:	90 e0       	ldi	r25, 0x00	; 0
    41ce:	90 93 a3 0a 	sts	0x0AA3, r25
    41d2:	80 93 a2 0a 	sts	0x0AA2, r24
#ifdef PSD_SENSOR
	params[PSDL] = 0x40;  // Distance -
	params[PSDL2]= 0x60;  // -
	params[PSDL3]= 0x80;  // -
#else
	params[PSDL] = 0x00;  // Distance -
    41d6:	10 92 a5 0a 	sts	0x0AA5, r1
    41da:	10 92 a4 0a 	sts	0x0AA4, r1
	params[PSDL2]= 0x00;  // -
    41de:	10 92 a7 0a 	sts	0x0AA7, r1
    41e2:	10 92 a6 0a 	sts	0x0AA6, r1
	params[PSDL3]= 0x00;  // -
    41e6:	10 92 a9 0a 	sts	0x0AA9, r1
    41ea:	10 92 a8 0a 	sts	0x0AA8, r1
#endif
	
	params[MICL] = 0x79;  // -
    41ee:	89 e7       	ldi	r24, 0x79	; 121
    41f0:	90 e0       	ldi	r25, 0x00	; 0
    41f2:	90 93 ab 0a 	sts	0x0AAB, r25
    41f6:	80 93 aa 0a 	sts	0x0AAA, r24
	params[MICL2]= 0x99;  // -
	params[MICL2]= 0x99;  // -
    41fa:	89 e9       	ldi	r24, 0x99	; 153
    41fc:	90 e0       	ldi	r25, 0x00	; 0
    41fe:	90 93 ad 0a 	sts	0x0AAD, r25
    4202:	80 93 ac 0a 	sts	0x0AAC, r24
	params[VOLT]=  8100;// -voltage level
    4206:	84 ea       	ldi	r24, 0xA4	; 164
    4208:	9f e1       	ldi	r25, 0x1F	; 31
    420a:	90 93 b1 0a 	sts	0x0AB1, r25
    420e:	80 93 b0 0a 	sts	0x0AB0, r24
	
	autobalance=0;	//dynamic blance off
    4212:	10 92 7d 0b 	sts	0x0B7D, r1
    4216:	10 92 7c 0b 	sts	0x0B7C, r1
	response=0;		//event response off
    421a:	10 92 9c 0a 	sts	0x0A9C, r1
    421e:	10 92 9b 0a 	sts	0x0A9B, r1
}
    4222:	08 95       	ret

00004224 <pversion>:

void pversion()
{
    4224:	8e e4       	ldi	r24, 0x4E	; 78
    4226:	91 e0       	ldi	r25, 0x01	; 1
    4228:	9f 93       	push	r25
    422a:	8f 93       	push	r24
    422c:	81 e0       	ldi	r24, 0x01	; 1
    422e:	8f 93       	push	r24
    4230:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
	rprintf("Robos ");
	rprintfProgStr(version);
    4234:	8a e3       	ldi	r24, 0x3A	; 58
    4236:	91 e0       	ldi	r25, 0x01	; 1
    4238:	0e 94 36 2a 	call	0x546c	; 0x546c <rprintfProgStr>
    423c:	0f 90       	pop	r0
    423e:	0f 90       	pop	r0
    4240:	0f 90       	pop	r0
}
    4242:	08 95       	ret

00004244 <main>:

	
int main(void) 
{
    4244:	0e 94 49 20 	call	0x4092	; 0x4092 <HW_init>
	HW_init();					// Initialise ATMega Ports
	SW_init();					// Initialise software states
    4248:	0e 94 b5 20 	call	0x416a	; 0x416a <SW_init>
	uartInit();					// initialize UART (serial port)
    424c:	0e 94 c3 22 	call	0x4586	; 0x4586 <uartInit>
	uartSetBaudRate(115200);	// set UART speed to 115200 baud
    4250:	60 e0       	ldi	r22, 0x00	; 0
    4252:	72 ec       	ldi	r23, 0xC2	; 194
    4254:	81 e0       	ldi	r24, 0x01	; 1
    4256:	90 e0       	ldi	r25, 0x00	; 0
    4258:	0e 94 af 21 	call	0x435e	; 0x435e <uartSetBaudRate>
	rprintfInit(uartSendByte);  // configure rprintf to use UART for output
    425c:	82 ed       	ldi	r24, 0xD2	; 210
    425e:	91 e2       	ldi	r25, 0x21	; 33
    4260:	0e 94 e2 29 	call	0x53c4	; 0x53c4 <rprintfInit>
			
	sei();						// enable interrupts
    4264:	78 94       	sei
	TIMSK |= 0x01;				// Timer0 Overflow Interrupt enable
    4266:	87 b7       	in	r24, 0x37	; 55
    4268:	81 60       	ori	r24, 0x01	; 1
    426a:	87 bf       	out	0x37, r24	; 55
		
	pversion();
    426c:	0e 94 12 21 	call	0x4224	; 0x4224 <pversion>
	
	PWR_LED1_ON; 				// Power green light on
    4270:	80 91 65 00 	lds	r24, 0x0065
    4274:	8b 7f       	andi	r24, 0xFB	; 251
    4276:	80 93 65 00 	sts	0x0065, r24
	
//	adc_init();		
	tilt_setup();				// initialise acceleromter
    427a:	0e 94 c3 2e 	call	0x5d86	; 0x5d86 <tilt_setup>
    427e:	80 ed       	ldi	r24, 0xD0	; 208
    4280:	97 e0       	ldi	r25, 0x07	; 7
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    4282:	20 e7       	ldi	r18, 0x70	; 112
    4284:	31 e0       	ldi	r19, 0x01	; 1
    4286:	f9 01       	movw	r30, r18
    4288:	31 97       	sbiw	r30, 0x01	; 1
    428a:	f1 f7       	brne	.-4      	; 0x4288 <main+0x44>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    428c:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    428e:	d9 f7       	brne	.-10     	; 0x4286 <main+0x42>

/* TIMR  0, TLT   1, TORQ  2, PSDL  3
   PSDL2 4, PSDL3 5, MICL  6, MICL2 7
   MICL3 8, VOLT  9
*/	
    params[TIMR] = 20;    // t seconds
    4290:	84 e1       	ldi	r24, 0x14	; 20
    4292:	90 e0       	ldi	r25, 0x00	; 0
    4294:	90 93 9f 0a 	sts	0x0A9F, r25
    4298:	80 93 9e 0a 	sts	0x0A9E, r24
	params[TLT]  = 4;     // tlt
    429c:	84 e0       	ldi	r24, 0x04	; 4
    429e:	90 e0       	ldi	r25, 0x00	; 0
    42a0:	90 93 a1 0a 	sts	0x0AA1, r25
    42a4:	80 93 a0 0a 	sts	0x0AA0, r24
	params[TORQ] = 2;     // -
    42a8:	82 e0       	ldi	r24, 0x02	; 2
    42aa:	90 e0       	ldi	r25, 0x00	; 0
    42ac:	90 93 a3 0a 	sts	0x0AA3, r25
    42b0:	80 93 a2 0a 	sts	0x0AA2, r24
#ifdef PSD_SENSOR
	params[PSDL] = 0x40;  // Distance -
	params[PSDL2]= 0x60;  // -
	params[PSDL3]= 0x80;  // -
#else
	params[PSDL] = 0x00;  // Distance -
    42b4:	10 92 a5 0a 	sts	0x0AA5, r1
    42b8:	10 92 a4 0a 	sts	0x0AA4, r1
	params[PSDL2]= 0x00;  // -
    42bc:	10 92 a7 0a 	sts	0x0AA7, r1
    42c0:	10 92 a6 0a 	sts	0x0AA6, r1
	params[PSDL3]= 0x00;  // -
    42c4:	10 92 a9 0a 	sts	0x0AA9, r1
    42c8:	10 92 a8 0a 	sts	0x0AA8, r1
#endif
	
	params[MICL] = 0x79;  // -
    42cc:	89 e7       	ldi	r24, 0x79	; 121
    42ce:	90 e0       	ldi	r25, 0x00	; 0
    42d0:	90 93 ab 0a 	sts	0x0AAB, r25
    42d4:	80 93 aa 0a 	sts	0x0AAA, r24
	params[MICL2]= 0x99;  // -
	params[MICL2]= 0x99;  // -
    42d8:	89 e9       	ldi	r24, 0x99	; 153
    42da:	90 e0       	ldi	r25, 0x00	; 0
    42dc:	90 93 ad 0a 	sts	0x0AAD, r25
    42e0:	80 93 ac 0a 	sts	0x0AAC, r24
	params[VOLT]=  8100;// -voltage level
    42e4:	84 ea       	ldi	r24, 0xA4	; 164
    42e6:	9f e1       	ldi	r25, 0x1F	; 31
    42e8:	90 93 b1 0a 	sts	0x0AB1, r25
    42ec:	80 93 b0 0a 	sts	0x0AB0, r24
	
	autobalance=0;	//dynamic blance off
    42f0:	10 92 7d 0b 	sts	0x0B7D, r1
    42f4:	10 92 7c 0b 	sts	0x0B7C, r1
	response=0;		//event response off
    42f8:	10 92 9c 0a 	sts	0x0A9C, r1
    42fc:	10 92 9b 0a 	sts	0x0A9B, r1
	tilt_setup();				// initialise acceleromter
	_delay_ms(200);
	
	initparams();
	
	gNextMode = kIdleMode;
    4300:	10 92 80 0b 	sts	0x0B80, r1
    4304:	10 92 7f 0b 	sts	0x0B7F, r1
	while (1) {
		switch (gNextMode) {
    4308:	80 91 7f 0b 	lds	r24, 0x0B7F
    430c:	90 91 80 0b 	lds	r25, 0x0B80
    4310:	82 30       	cpi	r24, 0x02	; 2
    4312:	91 05       	cpc	r25, r1
    4314:	b1 f0       	breq	.+44     	; 0x4342 <main+0xfe>
    4316:	83 30       	cpi	r24, 0x03	; 3
    4318:	91 05       	cpc	r25, r1
    431a:	34 f4       	brge	.+12     	; 0x4328 <main+0xe4>
    431c:	00 97       	sbiw	r24, 0x00	; 0
    431e:	59 f0       	breq	.+22     	; 0x4336 <main+0xf2>
    4320:	81 30       	cpi	r24, 0x01	; 1
    4322:	91 05       	cpc	r25, r1
    4324:	a9 f7       	brne	.-22     	; 0x4310 <main+0xcc>
    4326:	0a c0       	rjmp	.+20     	; 0x433c <main+0xf8>
    4328:	84 30       	cpi	r24, 0x04	; 4
    432a:	91 05       	cpc	r25, r1
    432c:	69 f0       	breq	.+26     	; 0x4348 <main+0x104>
    432e:	86 30       	cpi	r24, 0x06	; 6
    4330:	91 05       	cpc	r25, r1
    4332:	71 f7       	brne	.-36     	; 0x4310 <main+0xcc>
    4334:	0c c0       	rjmp	.+24     	; 0x434e <main+0x10a>
			case kIdleMode:
				idle_mainloop();
    4336:	0e 94 4a 30 	call	0x6094	; 0x6094 <idle_mainloop>
    433a:	e6 cf       	rjmp	.-52     	; 0x4308 <main+0xc4>
				//compatability_mode();
				break;
			case kExperimentalMode:
				experimental_mainloop();
    433c:	0e 94 d4 3b 	call	0x77a8	; 0x77a8 <experimental_mainloop>
    4340:	e3 cf       	rjmp	.-58     	; 0x4308 <main+0xc4>
				break;
			case kChargeMode:
				charge_mainloop();
    4342:	0e 94 ee 3c 	call	0x79dc	; 0x79dc <charge_mainloop>
    4346:	e0 cf       	rjmp	.-64     	; 0x4308 <main+0xc4>
				break;
			case kSerialSlaveMode:
				serialslave_mainloop();
    4348:	0e 94 ff 41 	call	0x83fe	; 0x83fe <serialslave_mainloop>
    434c:	dd cf       	rjmp	.-70     	; 0x4308 <main+0xc4>
				break;				
			case kBinMode:
				experimental_binloop();
    434e:	0e 94 bd 5b 	call	0xb77a	; 0xb77a <experimental_binloop>
    4352:	da cf       	rjmp	.-76     	; 0x4308 <main+0xc4>

00004354 <uartSetRxHandler>:
	#endif
}

// redirects received data to a user function
void uartSetRxHandler(void (*rx_func)(unsigned char c))
{
    4354:	90 93 05 06 	sts	0x0605, r25
    4358:	80 93 04 06 	sts	0x0604, r24
	// set the receive interrupt to run the supplied user function
	UartRxFunc = rx_func;
}
    435c:	08 95       	ret

0000435e <uartSetBaudRate>:

// set the uart baud rate
void uartSetBaudRate(u32 baudrate)
{
    435e:	9b 01       	movw	r18, r22
    4360:	ac 01       	movw	r20, r24
	// calculate division factor for requested baud rate, and set it
	u16 bauddiv = ((F_CPU+(baudrate*8L))/(baudrate*16L)-1);
    4362:	6b 54       	subi	r22, 0x4B	; 75
    4364:	70 4e       	sbci	r23, 0xE0	; 224
    4366:	83 4e       	sbci	r24, 0xE3	; 227
    4368:	9f 4f       	sbci	r25, 0xFF	; 255
    436a:	f3 e0       	ldi	r31, 0x03	; 3
    436c:	66 0f       	add	r22, r22
    436e:	77 1f       	adc	r23, r23
    4370:	88 1f       	adc	r24, r24
    4372:	99 1f       	adc	r25, r25
    4374:	fa 95       	dec	r31
    4376:	d1 f7       	brne	.-12     	; 0x436c <uartSetBaudRate+0xe>
    4378:	e4 e0       	ldi	r30, 0x04	; 4
    437a:	22 0f       	add	r18, r18
    437c:	33 1f       	adc	r19, r19
    437e:	44 1f       	adc	r20, r20
    4380:	55 1f       	adc	r21, r21
    4382:	ea 95       	dec	r30
    4384:	d1 f7       	brne	.-12     	; 0x437a <uartSetBaudRate+0x1c>
    4386:	0e 94 44 6e 	call	0xdc88	; 0xdc88 <__udivmodsi4>
    438a:	21 50       	subi	r18, 0x01	; 1
    438c:	30 40       	sbci	r19, 0x00	; 0
	outb(UBRRL, bauddiv);
    438e:	20 93 99 00 	sts	0x0099, r18
	#ifdef UBRRH
	outb(UBRRH, bauddiv>>8);
    4392:	30 93 98 00 	sts	0x0098, r19
	#endif
}
    4396:	08 95       	ret

00004398 <uartGetRxBuffer>:

// returns the receive buffer structure 
cBuffer* uartGetRxBuffer(void)
{
    4398:	88 e8       	ldi	r24, 0x88	; 136
    439a:	9b e0       	ldi	r25, 0x0B	; 11
    439c:	08 95       	ret

0000439e <uartGetTxBuffer>:
	return &uartRxBuffer;
}

// returns the transmit buffer structure 
cBuffer* uartGetTxBuffer(void)
{
    439e:	81 e9       	ldi	r24, 0x91	; 145
    43a0:	9b e0       	ldi	r25, 0x0B	; 11
    43a2:	08 95       	ret

000043a4 <uartSendByte>:
	return &uartTxBuffer;
}

// transmits a byte over the uart
void uartSendByte(u08 txData)
{
    43a4:	98 2f       	mov	r25, r24
	// wait for the transmitter to be ready
	while(!uartReadyTx);
    43a6:	80 91 87 0b 	lds	r24, 0x0B87
    43aa:	88 23       	and	r24, r24
    43ac:	e1 f3       	breq	.-8      	; 0x43a6 <uartSendByte+0x2>
	// send byte
	outb(UDR, txData);
    43ae:	90 93 9c 00 	sts	0x009C, r25
	// set ready state to FALSE
	uartReadyTx = FALSE;
    43b2:	10 92 87 0b 	sts	0x0B87, r1
}
    43b6:	08 95       	ret

000043b8 <uartFlushReceiveBuffer>:
	}
}

// flush all data out of the receive buffer
void uartFlushReceiveBuffer(void)
{
    43b8:	10 92 8d 0b 	sts	0x0B8D, r1
    43bc:	10 92 8c 0b 	sts	0x0B8C, r1
	// flush all data from receive buffer
	//bufferFlush(&uartRxBuffer);
	// same effect as above
	uartRxBuffer.datalength = 0;
}
    43c0:	08 95       	ret

000043c2 <uartReceiveBufferIsEmpty>:

// return true if uart receive buffer is empty
u08 uartReceiveBufferIsEmpty(void)
{
    43c2:	80 91 8c 0b 	lds	r24, 0x0B8C
    43c6:	90 91 8d 0b 	lds	r25, 0x0B8D
    43ca:	89 2b       	or	r24, r25
    43cc:	11 f0       	breq	.+4      	; 0x43d2 <uartReceiveBufferIsEmpty+0x10>
    43ce:	80 e0       	ldi	r24, 0x00	; 0
    43d0:	08 95       	ret
    43d2:	8f ef       	ldi	r24, 0xFF	; 255
	}
	else
	{
		return FALSE;
	}
}
    43d4:	08 95       	ret

000043d6 <__vector_30>:
	}
}

// UART Receive Complete Interrupt Handler
UART_INTERRUPT_HANDLER(SIG_UART_RECV)
{
    43d6:	1f 92       	push	r1
    43d8:	0f 92       	push	r0
    43da:	0f b6       	in	r0, 0x3f	; 63
    43dc:	0f 92       	push	r0
    43de:	0b b6       	in	r0, 0x3b	; 59
    43e0:	0f 92       	push	r0
    43e2:	11 24       	eor	r1, r1
    43e4:	2f 93       	push	r18
    43e6:	3f 93       	push	r19
    43e8:	4f 93       	push	r20
    43ea:	5f 93       	push	r21
    43ec:	6f 93       	push	r22
    43ee:	7f 93       	push	r23
    43f0:	8f 93       	push	r24
    43f2:	9f 93       	push	r25
    43f4:	af 93       	push	r26
    43f6:	bf 93       	push	r27
    43f8:	ef 93       	push	r30
    43fa:	ff 93       	push	r31
	u08 c;
	
	// get received char
	c = inb(UDR);
    43fc:	60 91 9c 00 	lds	r22, 0x009C

	// if there's a user function to handle this receive event
	if(UartRxFunc)
    4400:	80 91 04 06 	lds	r24, 0x0604
    4404:	90 91 05 06 	lds	r25, 0x0605
    4408:	89 2b       	or	r24, r25
    440a:	39 f0       	breq	.+14     	; 0x441a <__vector_30+0x44>
	{
		// call it and pass the received data
		UartRxFunc(c);
    440c:	e0 91 04 06 	lds	r30, 0x0604
    4410:	f0 91 05 06 	lds	r31, 0x0605
    4414:	86 2f       	mov	r24, r22
    4416:	09 95       	icall
    4418:	0f c0       	rjmp	.+30     	; 0x4438 <__vector_30+0x62>
	else
	{
		// otherwise do default processing
		// put received char in buffer
		// check if there's space
		if( !bufferAddToEnd(&uartRxBuffer, c) )
    441a:	88 e8       	ldi	r24, 0x88	; 136
    441c:	9b e0       	ldi	r25, 0x0B	; 11
    441e:	0e 94 53 23 	call	0x46a6	; 0x46a6 <bufferAddToEnd>
    4422:	88 23       	and	r24, r24
    4424:	49 f4       	brne	.+18     	; 0x4438 <__vector_30+0x62>
		{
			// no space in buffer
			// count overflow
			uartRxOverflow++;
    4426:	80 91 99 0b 	lds	r24, 0x0B99
    442a:	90 91 9a 0b 	lds	r25, 0x0B9A
    442e:	01 96       	adiw	r24, 0x01	; 1
    4430:	90 93 9a 0b 	sts	0x0B9A, r25
    4434:	80 93 99 0b 	sts	0x0B99, r24
		}
	}
}
    4438:	ff 91       	pop	r31
    443a:	ef 91       	pop	r30
    443c:	bf 91       	pop	r27
    443e:	af 91       	pop	r26
    4440:	9f 91       	pop	r25
    4442:	8f 91       	pop	r24
    4444:	7f 91       	pop	r23
    4446:	6f 91       	pop	r22
    4448:	5f 91       	pop	r21
    444a:	4f 91       	pop	r20
    444c:	3f 91       	pop	r19
    444e:	2f 91       	pop	r18
    4450:	0f 90       	pop	r0
    4452:	0b be       	out	0x3b, r0	; 59
    4454:	0f 90       	pop	r0
    4456:	0f be       	out	0x3f, r0	; 63
    4458:	0f 90       	pop	r0
    445a:	1f 90       	pop	r1
    445c:	18 95       	reti

0000445e <uartAddToTxBuffer>:
	}
}

// add byte to end of uart Tx buffer
u08 uartAddToTxBuffer(u08 data)
{
    445e:	68 2f       	mov	r22, r24
    4460:	81 e9       	ldi	r24, 0x91	; 145
    4462:	9b e0       	ldi	r25, 0x0B	; 11
    4464:	0e 94 53 23 	call	0x46a6	; 0x46a6 <bufferAddToEnd>
	// add data byte to the end of the tx buffer
	return bufferAddToEnd(&uartTxBuffer, data);
}
    4468:	08 95       	ret

0000446a <__vector_32>:
	}
}
*/
// UART Transmit Complete Interrupt Handler
UART_INTERRUPT_HANDLER(SIG_UART_TRANS)
{
    446a:	1f 92       	push	r1
    446c:	0f 92       	push	r0
    446e:	0f b6       	in	r0, 0x3f	; 63
    4470:	0f 92       	push	r0
    4472:	0b b6       	in	r0, 0x3b	; 59
    4474:	0f 92       	push	r0
    4476:	11 24       	eor	r1, r1
    4478:	2f 93       	push	r18
    447a:	3f 93       	push	r19
    447c:	4f 93       	push	r20
    447e:	5f 93       	push	r21
    4480:	6f 93       	push	r22
    4482:	7f 93       	push	r23
    4484:	8f 93       	push	r24
    4486:	9f 93       	push	r25
    4488:	af 93       	push	r26
    448a:	bf 93       	push	r27
    448c:	ef 93       	push	r30
    448e:	ff 93       	push	r31
	// check if buffered tx is enabled
	if(uartBufferedTx)
    4490:	80 91 90 0b 	lds	r24, 0x0B90
    4494:	88 23       	and	r24, r24
    4496:	79 f0       	breq	.+30     	; 0x44b6 <__vector_32+0x4c>
	{
		// check if there's data left in the buffer
		if(uartTxBuffer.datalength)
    4498:	80 91 95 0b 	lds	r24, 0x0B95
    449c:	90 91 96 0b 	lds	r25, 0x0B96
    44a0:	89 2b       	or	r24, r25
    44a2:	39 f0       	breq	.+14     	; 0x44b2 <__vector_32+0x48>
		{
			// send byte from top of buffer
			outb(UDR, bufferGetFromFront(&uartTxBuffer));
    44a4:	81 e9       	ldi	r24, 0x91	; 145
    44a6:	9b e0       	ldi	r25, 0x0B	; 11
    44a8:	0e 94 ea 22 	call	0x45d4	; 0x45d4 <bufferGetFromFront>
    44ac:	80 93 9c 00 	sts	0x009C, r24
    44b0:	05 c0       	rjmp	.+10     	; 0x44bc <__vector_32+0x52>
		}
		else
		{
			// no data left
			uartBufferedTx = FALSE;
    44b2:	10 92 90 0b 	sts	0x0B90, r1
	}
	else
	{
		// we're using single-byte tx mode
		// indicate transmit complete, back to ready
		uartReadyTx = TRUE;
    44b6:	8f ef       	ldi	r24, 0xFF	; 255
    44b8:	80 93 87 0b 	sts	0x0B87, r24
	}
}
    44bc:	ff 91       	pop	r31
    44be:	ef 91       	pop	r30
    44c0:	bf 91       	pop	r27
    44c2:	af 91       	pop	r26
    44c4:	9f 91       	pop	r25
    44c6:	8f 91       	pop	r24
    44c8:	7f 91       	pop	r23
    44ca:	6f 91       	pop	r22
    44cc:	5f 91       	pop	r21
    44ce:	4f 91       	pop	r20
    44d0:	3f 91       	pop	r19
    44d2:	2f 91       	pop	r18
    44d4:	0f 90       	pop	r0
    44d6:	0b be       	out	0x3b, r0	; 59
    44d8:	0f 90       	pop	r0
    44da:	0f be       	out	0x3f, r0	; 63
    44dc:	0f 90       	pop	r0
    44de:	1f 90       	pop	r1
    44e0:	18 95       	reti

000044e2 <uartSendTxBuffer>:
	return bufferAddToEnd(&uartTxBuffer, data);
}

// start transmission of the current uart Tx buffer contents
void uartSendTxBuffer(void)
{
    44e2:	8f ef       	ldi	r24, 0xFF	; 255
    44e4:	80 93 90 0b 	sts	0x0B90, r24
	// turn on buffered transmit
	uartBufferedTx = TRUE;
	// send the first byte to get things going by interrupts
	uartSendByte(bufferGetFromFront(&uartTxBuffer));
    44e8:	81 e9       	ldi	r24, 0x91	; 145
    44ea:	9b e0       	ldi	r25, 0x0B	; 11
    44ec:	0e 94 ea 22 	call	0x45d4	; 0x45d4 <bufferGetFromFront>
    44f0:	98 2f       	mov	r25, r24

// transmits a byte over the uart
void uartSendByte(u08 txData)
{
	// wait for the transmitter to be ready
	while(!uartReadyTx);
    44f2:	80 91 87 0b 	lds	r24, 0x0B87
    44f6:	88 23       	and	r24, r24
    44f8:	e1 f3       	breq	.-8      	; 0x44f2 <uartSendTxBuffer+0x10>
	// send byte
	outb(UDR, txData);
    44fa:	90 93 9c 00 	sts	0x009C, r25
	// set ready state to FALSE
	uartReadyTx = FALSE;
    44fe:	10 92 87 0b 	sts	0x0B87, r1
{
	// turn on buffered transmit
	uartBufferedTx = TRUE;
	// send the first byte to get things going by interrupts
	uartSendByte(bufferGetFromFront(&uartTxBuffer));
}
    4502:	08 95       	ret

00004504 <uartReceiveByte>:
		return -1;
}

// gets a byte (if available) from the uart receive buffer
u08 uartReceiveByte(u08* rxData)
{
    4504:	cf 93       	push	r28
    4506:	df 93       	push	r29
    4508:	ec 01       	movw	r28, r24
	// make sure we have a receive buffer
	if(uartRxBuffer.size)
    450a:	80 91 8a 0b 	lds	r24, 0x0B8A
    450e:	90 91 8b 0b 	lds	r25, 0x0B8B
    4512:	89 2b       	or	r24, r25
    4514:	69 f0       	breq	.+26     	; 0x4530 <uartReceiveByte+0x2c>
	{
		// make sure we have data
		if(uartRxBuffer.datalength)
    4516:	80 91 8c 0b 	lds	r24, 0x0B8C
    451a:	90 91 8d 0b 	lds	r25, 0x0B8D
    451e:	89 2b       	or	r24, r25
    4520:	39 f0       	breq	.+14     	; 0x4530 <uartReceiveByte+0x2c>
		{
			// get byte from beginning of buffer
			*rxData = bufferGetFromFront(&uartRxBuffer);
    4522:	88 e8       	ldi	r24, 0x88	; 136
    4524:	9b e0       	ldi	r25, 0x0B	; 11
    4526:	0e 94 ea 22 	call	0x45d4	; 0x45d4 <bufferGetFromFront>
    452a:	88 83       	st	Y, r24
    452c:	8f ef       	ldi	r24, 0xFF	; 255
    452e:	01 c0       	rjmp	.+2      	; 0x4532 <uartReceiveByte+0x2e>
			return TRUE;
    4530:	80 e0       	ldi	r24, 0x00	; 0
	else
	{
		// no buffer
		return FALSE;
	}
}
    4532:	df 91       	pop	r29
    4534:	cf 91       	pop	r28
    4536:	08 95       	ret

00004538 <uartGetByte>:
	uartReadyTx = FALSE;
}

// gets a single byte from the uart receive buffer (getchar-style)
int uartGetByte(void)
{
    4538:	df 93       	push	r29
    453a:	cf 93       	push	r28
    453c:	0f 92       	push	r0
    453e:	cd b7       	in	r28, 0x3d	; 61
    4540:	de b7       	in	r29, 0x3e	; 62
	u08 c;
	if(uartReceiveByte(&c))
    4542:	ce 01       	movw	r24, r28
    4544:	01 96       	adiw	r24, 0x01	; 1
    4546:	0e 94 82 22 	call	0x4504	; 0x4504 <uartReceiveByte>
    454a:	88 23       	and	r24, r24
    454c:	19 f4       	brne	.+6      	; 0x4554 <uartGetByte+0x1c>
    454e:	2f ef       	ldi	r18, 0xFF	; 255
    4550:	3f ef       	ldi	r19, 0xFF	; 255
    4552:	03 c0       	rjmp	.+6      	; 0x455a <uartGetByte+0x22>
		return c;
    4554:	89 81       	ldd	r24, Y+1	; 0x01
    4556:	28 2f       	mov	r18, r24
    4558:	30 e0       	ldi	r19, 0x00	; 0
	else
		return -1;
}
    455a:	c9 01       	movw	r24, r18
    455c:	0f 90       	pop	r0
    455e:	cf 91       	pop	r28
    4560:	df 91       	pop	r29
    4562:	08 95       	ret

00004564 <uartInitBuffers>:
	sei();
}

// create and initialize the uart transmit and receive buffers
void uartInitBuffers(void)
{
    4564:	40 e4       	ldi	r20, 0x40	; 64
    4566:	50 e0       	ldi	r21, 0x00	; 0
    4568:	64 e8       	ldi	r22, 0x84	; 132
    456a:	75 e0       	ldi	r23, 0x05	; 5
    456c:	88 e8       	ldi	r24, 0x88	; 136
    456e:	9b e0       	ldi	r25, 0x0B	; 11
    4570:	0e 94 dd 22 	call	0x45ba	; 0x45ba <bufferInit>
	#ifndef UART_BUFFERS_EXTERNAL_RAM
		// initialize the UART receive buffer
		bufferInit(&uartRxBuffer, uartRxData, UART_RX_BUFFER_SIZE);
		// initialize the UART transmit buffer
		bufferInit(&uartTxBuffer, uartTxData, UART_TX_BUFFER_SIZE);
    4574:	40 e4       	ldi	r20, 0x40	; 64
    4576:	50 e0       	ldi	r21, 0x00	; 0
    4578:	64 ec       	ldi	r22, 0xC4	; 196
    457a:	75 e0       	ldi	r23, 0x05	; 5
    457c:	81 e9       	ldi	r24, 0x91	; 145
    457e:	9b e0       	ldi	r25, 0x0B	; 11
    4580:	0e 94 dd 22 	call	0x45ba	; 0x45ba <bufferInit>
		// initialize the UART receive buffer
		bufferInit(&uartRxBuffer, (u08*) UART_RX_BUFFER_ADDR, UART_RX_BUFFER_SIZE);
		// initialize the UART transmit buffer
		bufferInit(&uartTxBuffer, (u08*) UART_TX_BUFFER_ADDR, UART_TX_BUFFER_SIZE);
	#endif
}
    4584:	08 95       	ret

00004586 <uartInit>:
typedef void (*voidFuncPtru08)(unsigned char);
volatile static voidFuncPtru08 UartRxFunc;

// enable and initialize the uart
void uartInit(void)
{
    4586:	0e 94 b2 22 	call	0x4564	; 0x4564 <uartInitBuffers>
	// initialize the buffers
	uartInitBuffers();
	// initialize user receive handler
	UartRxFunc = 0;
    458a:	10 92 05 06 	sts	0x0605, r1
    458e:	10 92 04 06 	sts	0x0604, r1

	// enable RxD/TxD and interrupts
	outb(UCR, BV(RXCIE)|BV(TXCIE)|BV(RXEN)|BV(TXEN));
    4592:	88 ed       	ldi	r24, 0xD8	; 216
    4594:	80 93 9a 00 	sts	0x009A, r24

	// set default baud rate
	uartSetBaudRate(UART_DEFAULT_BAUD_RATE);  
    4598:	60 e8       	ldi	r22, 0x80	; 128
    459a:	75 e2       	ldi	r23, 0x25	; 37
    459c:	80 e0       	ldi	r24, 0x00	; 0
    459e:	90 e0       	ldi	r25, 0x00	; 0
    45a0:	0e 94 af 21 	call	0x435e	; 0x435e <uartSetBaudRate>
	// initialize states
	uartReadyTx = TRUE;
    45a4:	8f ef       	ldi	r24, 0xFF	; 255
    45a6:	80 93 87 0b 	sts	0x0B87, r24
	uartBufferedTx = FALSE;
    45aa:	10 92 90 0b 	sts	0x0B90, r1
	// clear overflow count
	uartRxOverflow = 0;
    45ae:	10 92 9a 0b 	sts	0x0B9A, r1
    45b2:	10 92 99 0b 	sts	0x0B99, r1
	// enable interrupts
	sei();
    45b6:	78 94       	sei
}
    45b8:	08 95       	ret

000045ba <bufferInit>:
// global variables

// initialization

void bufferInit(cBuffer* buffer, unsigned char *start, unsigned short size)
{
    45ba:	fc 01       	movw	r30, r24
	// begin critical section
	CRITICAL_SECTION_START;
    45bc:	8f b7       	in	r24, 0x3f	; 63
    45be:	f8 94       	cli
	// set start pointer of the buffer
	buffer->dataptr = start;
    45c0:	71 83       	std	Z+1, r23	; 0x01
    45c2:	60 83       	st	Z, r22
	buffer->size = size;
    45c4:	53 83       	std	Z+3, r21	; 0x03
    45c6:	42 83       	std	Z+2, r20	; 0x02
	// initialize index and length
	buffer->dataindex = 0;
    45c8:	17 82       	std	Z+7, r1	; 0x07
    45ca:	16 82       	std	Z+6, r1	; 0x06
	buffer->datalength = 0;
    45cc:	15 82       	std	Z+5, r1	; 0x05
    45ce:	14 82       	std	Z+4, r1	; 0x04
	// end critical section
	CRITICAL_SECTION_END;
    45d0:	8f bf       	out	0x3f, r24	; 63
}
    45d2:	08 95       	ret

000045d4 <bufferGetFromFront>:

// access routines
unsigned char  bufferGetFromFront(cBuffer* buffer)
{
    45d4:	dc 01       	movw	r26, r24
	unsigned char data = 0;
	// begin critical section
	CRITICAL_SECTION_START;
    45d6:	4f b7       	in	r20, 0x3f	; 63
    45d8:	f8 94       	cli
	// check to see if there's data in the buffer
	if(buffer->datalength)
    45da:	14 96       	adiw	r26, 0x04	; 4
    45dc:	8d 91       	ld	r24, X+
    45de:	9c 91       	ld	r25, X
    45e0:	15 97       	sbiw	r26, 0x05	; 5
    45e2:	89 2b       	or	r24, r25
    45e4:	11 f4       	brne	.+4      	; 0x45ea <bufferGetFromFront+0x16>
    45e6:	e0 e0       	ldi	r30, 0x00	; 0
    45e8:	25 c0       	rjmp	.+74     	; 0x4634 <bufferGetFromFront+0x60>
	{
		// get the first character from buffer
		data = buffer->dataptr[buffer->dataindex];
    45ea:	16 96       	adiw	r26, 0x06	; 6
    45ec:	8d 91       	ld	r24, X+
    45ee:	9c 91       	ld	r25, X
    45f0:	17 97       	sbiw	r26, 0x07	; 7
    45f2:	ed 91       	ld	r30, X+
    45f4:	fc 91       	ld	r31, X
    45f6:	11 97       	sbiw	r26, 0x01	; 1
    45f8:	e8 0f       	add	r30, r24
    45fa:	f9 1f       	adc	r31, r25
    45fc:	e0 81       	ld	r30, Z
		// move index down and decrement length
		buffer->dataindex++;
    45fe:	01 96       	adiw	r24, 0x01	; 1
    4600:	17 96       	adiw	r26, 0x07	; 7
    4602:	9c 93       	st	X, r25
    4604:	8e 93       	st	-X, r24
    4606:	16 97       	sbiw	r26, 0x06	; 6
		if(buffer->dataindex >= buffer->size)
    4608:	12 96       	adiw	r26, 0x02	; 2
    460a:	2d 91       	ld	r18, X+
    460c:	3c 91       	ld	r19, X
    460e:	13 97       	sbiw	r26, 0x03	; 3
    4610:	82 17       	cp	r24, r18
    4612:	93 07       	cpc	r25, r19
    4614:	30 f0       	brcs	.+12     	; 0x4622 <bufferGetFromFront+0x4e>
		{
			buffer->dataindex -= buffer->size;
    4616:	82 1b       	sub	r24, r18
    4618:	93 0b       	sbc	r25, r19
    461a:	17 96       	adiw	r26, 0x07	; 7
    461c:	9c 93       	st	X, r25
    461e:	8e 93       	st	-X, r24
    4620:	16 97       	sbiw	r26, 0x06	; 6
		}
		buffer->datalength--;
    4622:	14 96       	adiw	r26, 0x04	; 4
    4624:	8d 91       	ld	r24, X+
    4626:	9c 91       	ld	r25, X
    4628:	15 97       	sbiw	r26, 0x05	; 5
    462a:	01 97       	sbiw	r24, 0x01	; 1
    462c:	15 96       	adiw	r26, 0x05	; 5
    462e:	9c 93       	st	X, r25
    4630:	8e 93       	st	-X, r24
    4632:	14 97       	sbiw	r26, 0x04	; 4
	}
	// end critical section
	CRITICAL_SECTION_END;
    4634:	4f bf       	out	0x3f, r20	; 63
	// return
	return data;
}
    4636:	8e 2f       	mov	r24, r30
    4638:	08 95       	ret

0000463a <bufferDumpFromFront>:

void bufferDumpFromFront(cBuffer* buffer, unsigned short numbytes)
{
    463a:	fc 01       	movw	r30, r24
	// begin critical section
	CRITICAL_SECTION_START;
    463c:	4f b7       	in	r20, 0x3f	; 63
    463e:	f8 94       	cli
	// dump numbytes from the front of the buffer
	// are we dumping less than the entire buffer?
	if(numbytes < buffer->datalength)
    4640:	84 81       	ldd	r24, Z+4	; 0x04
    4642:	95 81       	ldd	r25, Z+5	; 0x05
    4644:	68 17       	cp	r22, r24
    4646:	79 07       	cpc	r23, r25
    4648:	b0 f4       	brcc	.+44     	; 0x4676 <bufferDumpFromFront+0x3c>
	{
		// move index down by numbytes and decrement length by numbytes
		buffer->dataindex += numbytes;
    464a:	86 81       	ldd	r24, Z+6	; 0x06
    464c:	97 81       	ldd	r25, Z+7	; 0x07
    464e:	86 0f       	add	r24, r22
    4650:	97 1f       	adc	r25, r23
    4652:	97 83       	std	Z+7, r25	; 0x07
    4654:	86 83       	std	Z+6, r24	; 0x06
		if(buffer->dataindex >= buffer->size)
    4656:	22 81       	ldd	r18, Z+2	; 0x02
    4658:	33 81       	ldd	r19, Z+3	; 0x03
    465a:	82 17       	cp	r24, r18
    465c:	93 07       	cpc	r25, r19
    465e:	20 f0       	brcs	.+8      	; 0x4668 <bufferDumpFromFront+0x2e>
		{
			buffer->dataindex -= buffer->size;
    4660:	82 1b       	sub	r24, r18
    4662:	93 0b       	sbc	r25, r19
    4664:	97 83       	std	Z+7, r25	; 0x07
    4666:	86 83       	std	Z+6, r24	; 0x06
		}
		buffer->datalength -= numbytes;
    4668:	84 81       	ldd	r24, Z+4	; 0x04
    466a:	95 81       	ldd	r25, Z+5	; 0x05
    466c:	86 1b       	sub	r24, r22
    466e:	97 0b       	sbc	r25, r23
    4670:	95 83       	std	Z+5, r25	; 0x05
    4672:	84 83       	std	Z+4, r24	; 0x04
    4674:	02 c0       	rjmp	.+4      	; 0x467a <bufferDumpFromFront+0x40>
	}
	else
	{
		// flush the whole buffer
		buffer->datalength = 0;
    4676:	15 82       	std	Z+5, r1	; 0x05
    4678:	14 82       	std	Z+4, r1	; 0x04
	}
	// end critical section
	CRITICAL_SECTION_END;
    467a:	4f bf       	out	0x3f, r20	; 63
}
    467c:	08 95       	ret

0000467e <bufferGetAtIndex>:

unsigned char bufferGetAtIndex(cBuffer* buffer, unsigned short index)
{
    467e:	fc 01       	movw	r30, r24
    4680:	cb 01       	movw	r24, r22
	// begin critical section
	CRITICAL_SECTION_START;
    4682:	2f b7       	in	r18, 0x3f	; 63
    4684:	f8 94       	cli
	// return character at index in buffer
	unsigned char data = buffer->dataptr[(buffer->dataindex+index)%(buffer->size)];
	// end critical section
	CRITICAL_SECTION_END;
    4686:	2f bf       	out	0x3f, r18	; 63
    4688:	26 81       	ldd	r18, Z+6	; 0x06
    468a:	37 81       	ldd	r19, Z+7	; 0x07
    468c:	62 81       	ldd	r22, Z+2	; 0x02
    468e:	73 81       	ldd	r23, Z+3	; 0x03
    4690:	82 0f       	add	r24, r18
    4692:	93 1f       	adc	r25, r19
    4694:	0e 94 1d 6e 	call	0xdc3a	; 0xdc3a <__udivmodhi4>
    4698:	01 90       	ld	r0, Z+
    469a:	f0 81       	ld	r31, Z
    469c:	e0 2d       	mov	r30, r0
    469e:	e8 0f       	add	r30, r24
    46a0:	f9 1f       	adc	r31, r25
	return data;
}
    46a2:	80 81       	ld	r24, Z
    46a4:	08 95       	ret

000046a6 <bufferAddToEnd>:

unsigned char bufferAddToEnd(cBuffer* buffer, unsigned char data)
{
    46a6:	1f 93       	push	r17
    46a8:	cf 93       	push	r28
    46aa:	df 93       	push	r29
    46ac:	ec 01       	movw	r28, r24
    46ae:	16 2f       	mov	r17, r22
	// begin critical section
	CRITICAL_SECTION_START;
    46b0:	4f b7       	in	r20, 0x3f	; 63
    46b2:	f8 94       	cli
	// make sure the buffer has room
	if(buffer->datalength < buffer->size)
    46b4:	2c 81       	ldd	r18, Y+4	; 0x04
    46b6:	3d 81       	ldd	r19, Y+5	; 0x05
    46b8:	6a 81       	ldd	r22, Y+2	; 0x02
    46ba:	7b 81       	ldd	r23, Y+3	; 0x03
    46bc:	26 17       	cp	r18, r22
    46be:	37 07       	cpc	r19, r23
    46c0:	98 f4       	brcc	.+38     	; 0x46e8 <bufferAddToEnd+0x42>
	{
		// save data byte at end of buffer
		buffer->dataptr[(buffer->dataindex + buffer->datalength) % buffer->size] = data;
    46c2:	8e 81       	ldd	r24, Y+6	; 0x06
    46c4:	9f 81       	ldd	r25, Y+7	; 0x07
    46c6:	82 0f       	add	r24, r18
    46c8:	93 1f       	adc	r25, r19
    46ca:	0e 94 1d 6e 	call	0xdc3a	; 0xdc3a <__udivmodhi4>
    46ce:	e8 81       	ld	r30, Y
    46d0:	f9 81       	ldd	r31, Y+1	; 0x01
    46d2:	e8 0f       	add	r30, r24
    46d4:	f9 1f       	adc	r31, r25
    46d6:	10 83       	st	Z, r17
		// increment the length
		buffer->datalength++;
    46d8:	8c 81       	ldd	r24, Y+4	; 0x04
    46da:	9d 81       	ldd	r25, Y+5	; 0x05
    46dc:	01 96       	adiw	r24, 0x01	; 1
    46de:	9d 83       	std	Y+5, r25	; 0x05
    46e0:	8c 83       	std	Y+4, r24	; 0x04
		// end critical section
		CRITICAL_SECTION_END;
    46e2:	4f bf       	out	0x3f, r20	; 63
    46e4:	8f ef       	ldi	r24, 0xFF	; 255
    46e6:	02 c0       	rjmp	.+4      	; 0x46ec <bufferAddToEnd+0x46>
		// return success
		return -1;
	}
	// end critical section
	CRITICAL_SECTION_END;
    46e8:	4f bf       	out	0x3f, r20	; 63
    46ea:	80 e0       	ldi	r24, 0x00	; 0
	// return failure
	return 0;
}
    46ec:	df 91       	pop	r29
    46ee:	cf 91       	pop	r28
    46f0:	1f 91       	pop	r17
    46f2:	08 95       	ret

000046f4 <bufferIsNotFull>:

unsigned short bufferIsNotFull(cBuffer* buffer)
{
    46f4:	fc 01       	movw	r30, r24
	// begin critical section
	CRITICAL_SECTION_START;
    46f6:	8f b7       	in	r24, 0x3f	; 63
    46f8:	f8 94       	cli
	// check to see if the buffer has room
	// return true if there is room
	unsigned short bytesleft = (buffer->size - buffer->datalength);
	// end critical section
	CRITICAL_SECTION_END;
    46fa:	8f bf       	out	0x3f, r24	; 63
    46fc:	22 81       	ldd	r18, Z+2	; 0x02
    46fe:	33 81       	ldd	r19, Z+3	; 0x03
    4700:	84 81       	ldd	r24, Z+4	; 0x04
    4702:	95 81       	ldd	r25, Z+5	; 0x05
    4704:	28 1b       	sub	r18, r24
    4706:	39 0b       	sbc	r19, r25
	return bytesleft;
}
    4708:	c9 01       	movw	r24, r18
    470a:	08 95       	ret

0000470c <bufferFlush>:

void bufferFlush(cBuffer* buffer)
{
    470c:	fc 01       	movw	r30, r24
	// begin critical section
	CRITICAL_SECTION_START;
    470e:	8f b7       	in	r24, 0x3f	; 63
    4710:	f8 94       	cli
	// flush contents of the buffer
	buffer->datalength = 0;
    4712:	15 82       	std	Z+5, r1	; 0x05
    4714:	14 82       	std	Z+4, r1	; 0x04
	// end critical section
	CRITICAL_SECTION_END;
    4716:	8f bf       	out	0x3f, r24	; 63
}
    4718:	08 95       	ret

0000471a <GetNextMotionBuffer>:
static unsigned char *curMotionBuf = motionBuf2;	// buffer of motion currently being played
static unsigned char *nextMotionBuf = motionBuf2;	// next motion buffer, or the one being written to


unsigned char* GetNextMotionBuffer(void)
{
    471a:	80 91 92 02 	lds	r24, 0x0292
    471e:	90 91 93 02 	lds	r25, 0x0293
    4722:	8a 50       	subi	r24, 0x0A	; 10
    4724:	96 40       	sbci	r25, 0x06	; 6
    4726:	19 f0       	breq	.+6      	; 0x472e <GetNextMotionBuffer+0x14>
    4728:	2a e0       	ldi	r18, 0x0A	; 10
    472a:	36 e0       	ldi	r19, 0x06	; 6
    472c:	02 c0       	rjmp	.+4      	; 0x4732 <GetNextMotionBuffer+0x18>
    472e:	24 e4       	ldi	r18, 0x44	; 68
    4730:	38 e0       	ldi	r19, 0x08	; 8
    4732:	30 93 93 02 	sts	0x0293, r19
    4736:	20 93 92 02 	sts	0x0292, r18
	nextMotionBuf = (nextMotionBuf == motionBuf1 ? motionBuf2 : motionBuf1);
	return nextMotionBuf;
}
    473a:	c9 01       	movw	r24, r18
    473c:	08 95       	ret

0000473e <sciTx0Data>:

//------------------------------------------------------------------------------
// Transmit char to UART when UART is ready
//------------------------------------------------------------------------------
void sciTx0Data(BYTE td)
{
    473e:	5d 9b       	sbis	0x0b, 5	; 11
    4740:	fe cf       	rjmp	.-4      	; 0x473e <sciTx0Data>
	while(!(UCSR0A&(1<<UDRE))); 	// wait until data register is empty
	UDR0=td;
    4742:	8c b9       	out	0x0c, r24	; 12
}
    4744:	08 95       	ret

00004746 <sciRx0Ready>:

//------------------------------------------------------------------------------
// Get character when received. or timeout
//------------------------------------------------------------------------------
BYTE sciRx0Ready(void)
{
    4746:	20 91 be 0a 	lds	r18, 0x0ABE
    474a:	30 91 bf 0a 	lds	r19, 0x0ABF
    474e:	17 c0       	rjmp	.+46     	; 0x477e <sciRx0Ready+0x38>
	WORD	startT;
	startT = gMSEC;
	while(!(UCSR0A&(1<<RXC)) ){ 	// test for received character
        if(gMSEC<startT){
    4750:	80 91 be 0a 	lds	r24, 0x0ABE
    4754:	90 91 bf 0a 	lds	r25, 0x0ABF
    4758:	82 17       	cp	r24, r18
    475a:	93 07       	cpc	r25, r19
    475c:	38 f4       	brcc	.+14     	; 0x476c <sciRx0Ready+0x26>
			// wait RX_T_OUT for a character
            if((1000 - startT + gMSEC)>RX_T_OUT) break;
    475e:	80 91 be 0a 	lds	r24, 0x0ABE
    4762:	90 91 bf 0a 	lds	r25, 0x0ABF
    4766:	88 51       	subi	r24, 0x18	; 24
    4768:	9c 4f       	sbci	r25, 0xFC	; 252
    476a:	04 c0       	rjmp	.+8      	; 0x4774 <sciRx0Ready+0x2e>
        }
		else if((gMSEC-startT)>RX_T_OUT) break;
    476c:	80 91 be 0a 	lds	r24, 0x0ABE
    4770:	90 91 bf 0a 	lds	r25, 0x0ABF
    4774:	82 1b       	sub	r24, r18
    4776:	93 0b       	sbc	r25, r19
    4778:	85 36       	cpi	r24, 0x65	; 101
    477a:	91 05       	cpc	r25, r1
    477c:	10 f4       	brcc	.+4      	; 0x4782 <sciRx0Ready+0x3c>
//------------------------------------------------------------------------------
BYTE sciRx0Ready(void)
{
	WORD	startT;
	startT = gMSEC;
	while(!(UCSR0A&(1<<RXC)) ){ 	// test for received character
    477e:	5f 9b       	sbis	0x0b, 7	; 11
    4780:	e7 cf       	rjmp	.-50     	; 0x4750 <sciRx0Ready+0xa>
			// wait RX_T_OUT for a character
            if((1000 - startT + gMSEC)>RX_T_OUT) break;
        }
		else if((gMSEC-startT)>RX_T_OUT) break;
	}
	return UDR0;
    4782:	8c b1       	in	r24, 0x0c	; 12
}
    4784:	08 95       	ret

00004786 <set_break_mode>:
	gTx0Buf[gTx0Cnt]=CheckSum;
	gTx0Cnt++;			// put into transmit buffer
} 

void set_break_mode()
{
    4786:	5d 9b       	sbis	0x0b, 5	; 11
    4788:	fe cf       	rjmp	.-4      	; 0x4786 <set_break_mode>
// Transmit char to UART when UART is ready
//------------------------------------------------------------------------------
void sciTx0Data(BYTE td)
{
	while(!(UCSR0A&(1<<UDRE))); 	// wait until data register is empty
	UDR0=td;
    478a:	8f ef       	ldi	r24, 0xFF	; 255
    478c:	8c b9       	out	0x0c, r24	; 12
//------------------------------------------------------------------------------
// Transmit char to UART when UART is ready
//------------------------------------------------------------------------------
void sciTx0Data(BYTE td)
{
	while(!(UCSR0A&(1<<UDRE))); 	// wait until data register is empty
    478e:	5d 9b       	sbis	0x0b, 5	; 11
    4790:	fe cf       	rjmp	.-4      	; 0x478e <set_break_mode+0x8>
	UDR0=td;
    4792:	8f ed       	ldi	r24, 0xDF	; 223
    4794:	8c b9       	out	0x0c, r24	; 12
//------------------------------------------------------------------------------
// Transmit char to UART when UART is ready
//------------------------------------------------------------------------------
void sciTx0Data(BYTE td)
{
	while(!(UCSR0A&(1<<UDRE))); 	// wait until data register is empty
    4796:	5d 9b       	sbis	0x0b, 5	; 11
    4798:	fe cf       	rjmp	.-4      	; 0x4796 <set_break_mode+0x10>
	UDR0=td;
    479a:	80 e2       	ldi	r24, 0x20	; 32
    479c:	8c b9       	out	0x0c, r24	; 12
//------------------------------------------------------------------------------
// Transmit char to UART when UART is ready
//------------------------------------------------------------------------------
void sciTx0Data(BYTE td)
{
	while(!(UCSR0A&(1<<UDRE))); 	// wait until data register is empty
    479e:	5d 9b       	sbis	0x0b, 5	; 11
    47a0:	fe cf       	rjmp	.-4      	; 0x479e <set_break_mode+0x18>
	UDR0=td;
    47a2:	8f e7       	ldi	r24, 0x7F	; 127
    47a4:	8c b9       	out	0x0c, r24	; 12
// Get character when received. or timeout
//------------------------------------------------------------------------------
BYTE sciRx0Ready(void)
{
	WORD	startT;
	startT = gMSEC;
    47a6:	20 91 be 0a 	lds	r18, 0x0ABE
    47aa:	30 91 bf 0a 	lds	r19, 0x0ABF
    47ae:	17 c0       	rjmp	.+46     	; 0x47de <set_break_mode+0x58>
	while(!(UCSR0A&(1<<RXC)) ){ 	// test for received character
        if(gMSEC<startT){
    47b0:	80 91 be 0a 	lds	r24, 0x0ABE
    47b4:	90 91 bf 0a 	lds	r25, 0x0ABF
    47b8:	82 17       	cp	r24, r18
    47ba:	93 07       	cpc	r25, r19
    47bc:	38 f4       	brcc	.+14     	; 0x47cc <set_break_mode+0x46>
			// wait RX_T_OUT for a character
            if((1000 - startT + gMSEC)>RX_T_OUT) break;
    47be:	80 91 be 0a 	lds	r24, 0x0ABE
    47c2:	90 91 bf 0a 	lds	r25, 0x0ABF
    47c6:	88 51       	subi	r24, 0x18	; 24
    47c8:	9c 4f       	sbci	r25, 0xFC	; 252
    47ca:	04 c0       	rjmp	.+8      	; 0x47d4 <set_break_mode+0x4e>
        }
		else if((gMSEC-startT)>RX_T_OUT) break;
    47cc:	80 91 be 0a 	lds	r24, 0x0ABE
    47d0:	90 91 bf 0a 	lds	r25, 0x0ABF
    47d4:	82 1b       	sub	r24, r18
    47d6:	93 0b       	sbc	r25, r19
    47d8:	85 36       	cpi	r24, 0x65	; 101
    47da:	91 05       	cpc	r25, r1
    47dc:	10 f4       	brcc	.+4      	; 0x47e2 <set_break_mode+0x5c>
//------------------------------------------------------------------------------
BYTE sciRx0Ready(void)
{
	WORD	startT;
	startT = gMSEC;
	while(!(UCSR0A&(1<<RXC)) ){ 	// test for received character
    47de:	5f 9b       	sbis	0x0b, 7	; 11
    47e0:	e7 cf       	rjmp	.-50     	; 0x47b0 <set_break_mode+0x2a>
			// wait RX_T_OUT for a character
            if((1000 - startT + gMSEC)>RX_T_OUT) break;
        }
		else if((gMSEC-startT)>RX_T_OUT) break;
	}
	return UDR0;
    47e2:	8c b1       	in	r24, 0x0c	; 12
// Get character when received. or timeout
//------------------------------------------------------------------------------
BYTE sciRx0Ready(void)
{
	WORD	startT;
	startT = gMSEC;
    47e4:	20 91 be 0a 	lds	r18, 0x0ABE
    47e8:	30 91 bf 0a 	lds	r19, 0x0ABF
    47ec:	17 c0       	rjmp	.+46     	; 0x481c <set_break_mode+0x96>
	while(!(UCSR0A&(1<<RXC)) ){ 	// test for received character
        if(gMSEC<startT){
    47ee:	80 91 be 0a 	lds	r24, 0x0ABE
    47f2:	90 91 bf 0a 	lds	r25, 0x0ABF
    47f6:	82 17       	cp	r24, r18
    47f8:	93 07       	cpc	r25, r19
    47fa:	38 f4       	brcc	.+14     	; 0x480a <set_break_mode+0x84>
			// wait RX_T_OUT for a character
            if((1000 - startT + gMSEC)>RX_T_OUT) break;
    47fc:	80 91 be 0a 	lds	r24, 0x0ABE
    4800:	90 91 bf 0a 	lds	r25, 0x0ABF
    4804:	88 51       	subi	r24, 0x18	; 24
    4806:	9c 4f       	sbci	r25, 0xFC	; 252
    4808:	04 c0       	rjmp	.+8      	; 0x4812 <set_break_mode+0x8c>
        }
		else if((gMSEC-startT)>RX_T_OUT) break;
    480a:	80 91 be 0a 	lds	r24, 0x0ABE
    480e:	90 91 bf 0a 	lds	r25, 0x0ABF
    4812:	82 1b       	sub	r24, r18
    4814:	93 0b       	sbc	r25, r19
    4816:	85 36       	cpi	r24, 0x65	; 101
    4818:	91 05       	cpc	r25, r1
    481a:	10 f4       	brcc	.+4      	; 0x4820 <set_break_mode+0x9a>
//------------------------------------------------------------------------------
BYTE sciRx0Ready(void)
{
	WORD	startT;
	startT = gMSEC;
	while(!(UCSR0A&(1<<RXC)) ){ 	// test for received character
    481c:	5f 9b       	sbis	0x0b, 7	; 11
    481e:	e7 cf       	rjmp	.-50     	; 0x47ee <set_break_mode+0x68>
			// wait RX_T_OUT for a character
            if((1000 - startT + gMSEC)>RX_T_OUT) break;
        }
		else if((gMSEC-startT)>RX_T_OUT) break;
	}
	return UDR0;
    4820:	8c b1       	in	r24, 0x0c	; 12
	sciTx0Data((0xDF^0x20)&0x7f);
	
	sciRx0Ready();
	sciRx0Ready();
	return;
}
    4822:	08 95       	ret

00004824 <CalcFrameInterval>:
//------------------------------------------------------------------------------
// Set the Timer1 interrupt based on the number of frames and the run time of the scene
// 		
//------------------------------------------------------------------------------
static void CalcFrameInterval(void)
{
    4824:	ef 92       	push	r14
    4826:	ff 92       	push	r15
    4828:	0f 93       	push	r16
    482a:	1f 93       	push	r17
    482c:	cf 93       	push	r28
    482e:	df 93       	push	r29
	float tmp;
	if((Scene.RTime / Scene.NumOfFrame)<20){ // is each scene < 20 ms ?
    4830:	20 91 f3 0c 	lds	r18, 0x0CF3
    4834:	30 91 f4 0c 	lds	r19, 0x0CF4
    4838:	c0 91 f1 0c 	lds	r28, 0x0CF1
    483c:	d0 91 f2 0c 	lds	r29, 0x0CF2
    4840:	c9 01       	movw	r24, r18
    4842:	be 01       	movw	r22, r28
    4844:	0e 94 1d 6e 	call	0xdc3a	; 0xdc3a <__udivmodhi4>
    4848:	64 31       	cpi	r22, 0x14	; 20
    484a:	71 05       	cpc	r23, r1
    484c:	c8 f1       	brcs	.+114    	; 0x48c0 <CalcFrameInterval+0x9c>
		return;
	}
	tmp = (float)Scene.RTime * 14.4;		// Timer  is clocked at 14.4KHz
    484e:	b9 01       	movw	r22, r18
    4850:	80 e0       	ldi	r24, 0x00	; 0
    4852:	90 e0       	ldi	r25, 0x00	; 0
    4854:	0e 94 aa 6a 	call	0xd554	; 0xd554 <__floatunsisf>
    4858:	26 e6       	ldi	r18, 0x66	; 102
    485a:	36 e6       	ldi	r19, 0x66	; 102
    485c:	46 e6       	ldi	r20, 0x66	; 102
    485e:	51 e4       	ldi	r21, 0x41	; 65
    4860:	0e 94 c4 67 	call	0xcf88	; 0xcf88 <__mulsf3>
    4864:	7b 01       	movw	r14, r22
    4866:	8c 01       	movw	r16, r24
	tmp = tmp  / (float)Scene.NumOfFrame;
	TxInterval = 65535 - (WORD)tmp - 43;
    4868:	be 01       	movw	r22, r28
    486a:	80 e0       	ldi	r24, 0x00	; 0
    486c:	90 e0       	ldi	r25, 0x00	; 0
    486e:	0e 94 aa 6a 	call	0xd554	; 0xd554 <__floatunsisf>
    4872:	9b 01       	movw	r18, r22
    4874:	ac 01       	movw	r20, r24
    4876:	c8 01       	movw	r24, r16
    4878:	b7 01       	movw	r22, r14
    487a:	0e 94 be 68 	call	0xd17c	; 0xd17c <__divsf3>
    487e:	0e 94 ee 65 	call	0xcbdc	; 0xcbdc <__fixunssfsi>
    4882:	24 ed       	ldi	r18, 0xD4	; 212
    4884:	3f ef       	ldi	r19, 0xFF	; 255
    4886:	26 1b       	sub	r18, r22
    4888:	37 0b       	sbc	r19, r23
    488a:	30 93 09 06 	sts	0x0609, r19
    488e:	20 93 08 06 	sts	0x0608, r18

	RUN_LED1_ON;
    4892:	dd 98       	cbi	0x1b, 5	; 27
	F_PLAYING=1;		// set flag to say we are busy playing frames
    4894:	81 e0       	ldi	r24, 0x01	; 1
    4896:	80 93 85 0b 	sts	0x0B85, r24
	TCCR1B=0x05;		// clock on div 1024
    489a:	85 e0       	ldi	r24, 0x05	; 5
    489c:	8e bd       	out	0x2e, r24	; 46

	if(TxInterval<=65509)	
    489e:	8f ef       	ldi	r24, 0xFF	; 255
    48a0:	26 3e       	cpi	r18, 0xE6	; 230
    48a2:	38 07       	cpc	r19, r24
    48a4:	18 f4       	brcc	.+6      	; 0x48ac <CalcFrameInterval+0x88>
		TCNT1=TxInterval+26;
    48a6:	c9 01       	movw	r24, r18
    48a8:	4a 96       	adiw	r24, 0x1a	; 26
    48aa:	02 c0       	rjmp	.+4      	; 0x48b0 <CalcFrameInterval+0x8c>
	else
		TCNT1=65535;
    48ac:	8f ef       	ldi	r24, 0xFF	; 255
    48ae:	9f ef       	ldi	r25, 0xFF	; 255
    48b0:	9d bd       	out	0x2d, r25	; 45
    48b2:	8c bd       	out	0x2c, r24	; 44

	TIFR |= 0x04;		// Clear the overflow flag
    48b4:	86 b7       	in	r24, 0x36	; 54
    48b6:	84 60       	ori	r24, 0x04	; 4
    48b8:	86 bf       	out	0x36, r24	; 54
	TIMSK |= 0x04;		// Timer1 Overflow Interrupt Enable
    48ba:	87 b7       	in	r24, 0x37	; 55
    48bc:	84 60       	ori	r24, 0x04	; 4
    48be:	87 bf       	out	0x37, r24	; 55
}
    48c0:	df 91       	pop	r29
    48c2:	cf 91       	pop	r28
    48c4:	1f 91       	pop	r17
    48c6:	0f 91       	pop	r16
    48c8:	ff 90       	pop	r15
    48ca:	ef 90       	pop	r14
    48cc:	08 95       	ret

000048ce <CalcUnitMove>:
//------------------------------------------------------------------------------
// Calculate the interpolation steps
// gUnitD[] is in range -254 to +254
//------------------------------------------------------------------------------
static void CalcUnitMove(void)
{
    48ce:	4f 92       	push	r4
    48d0:	5f 92       	push	r5
    48d2:	6f 92       	push	r6
    48d4:	7f 92       	push	r7
    48d6:	8f 92       	push	r8
    48d8:	9f 92       	push	r9
    48da:	af 92       	push	r10
    48dc:	bf 92       	push	r11
    48de:	cf 92       	push	r12
    48e0:	df 92       	push	r13
    48e2:	ef 92       	push	r14
    48e4:	ff 92       	push	r15
    48e6:	0f 93       	push	r16
    48e8:	1f 93       	push	r17
    48ea:	cf 93       	push	r28
    48ec:	df 93       	push	r29
	for(i=0;i<MAX_wCK;i++){
		if(Scene.wCK[i].Exist){	// if the wCK exists
			if(Scene.wCK[i].SPos!=Scene.wCK[i].DPos){
				// if any movement is required
				gUnitD[i] = (float)((int)Scene.wCK[i].DPos-(int)Scene.wCK[i].SPos);
				gUnitD[i] = (float)(gUnitD[i]/Scene.NumOfFrame);
    48ee:	80 91 f1 0c 	lds	r24, 0x0CF1
    48f2:	90 91 f2 0c 	lds	r25, 0x0CF2
    48f6:	25 ef       	ldi	r18, 0xF5	; 245
    48f8:	c2 2e       	mov	r12, r18
    48fa:	2c e0       	ldi	r18, 0x0C	; 12
    48fc:	d2 2e       	mov	r13, r18
    48fe:	cf e6       	ldi	r28, 0x6F	; 111
    4900:	dc e0       	ldi	r29, 0x0C	; 12
    4902:	4c 01       	movw	r8, r24
    4904:	aa 24       	eor	r10, r10
    4906:	bb 24       	eor	r11, r11
				if(gUnitD[i]>253)	gUnitD[i]=254;
    4908:	0f 2e       	mov	r0, r31
    490a:	f0 e0       	ldi	r31, 0x00	; 0
    490c:	4f 2e       	mov	r4, r31
    490e:	f0 e0       	ldi	r31, 0x00	; 0
    4910:	5f 2e       	mov	r5, r31
    4912:	fe e7       	ldi	r31, 0x7E	; 126
    4914:	6f 2e       	mov	r6, r31
    4916:	f3 e4       	ldi	r31, 0x43	; 67
    4918:	7f 2e       	mov	r7, r31
    491a:	f0 2d       	mov	r31, r0
static void CalcUnitMove(void)
{
	WORD i;

	for(i=0;i<MAX_wCK;i++){
		if(Scene.wCK[i].Exist){	// if the wCK exists
    491c:	d6 01       	movw	r26, r12
    491e:	8c 91       	ld	r24, X
    4920:	88 23       	and	r24, r24
    4922:	09 f4       	brne	.+2      	; 0x4926 <CalcUnitMove+0x58>
    4924:	46 c0       	rjmp	.+140    	; 0x49b2 <CalcUnitMove+0xe4>
			if(Scene.wCK[i].SPos!=Scene.wCK[i].DPos){
    4926:	11 96       	adiw	r26, 0x01	; 1
    4928:	8c 91       	ld	r24, X
    492a:	11 97       	sbiw	r26, 0x01	; 1
    492c:	12 96       	adiw	r26, 0x02	; 2
    492e:	6c 91       	ld	r22, X
    4930:	86 17       	cp	r24, r22
    4932:	b9 f1       	breq	.+110    	; 0x49a2 <CalcUnitMove+0xd4>
				// if any movement is required
				gUnitD[i] = (float)((int)Scene.wCK[i].DPos-(int)Scene.wCK[i].SPos);
				gUnitD[i] = (float)(gUnitD[i]/Scene.NumOfFrame);
    4934:	70 e0       	ldi	r23, 0x00	; 0
    4936:	68 1b       	sub	r22, r24
    4938:	71 09       	sbc	r23, r1
    493a:	88 27       	eor	r24, r24
    493c:	77 fd       	sbrc	r23, 7
    493e:	80 95       	com	r24
    4940:	98 2f       	mov	r25, r24
    4942:	0e 94 f8 69 	call	0xd3f0	; 0xd3f0 <__floatsisf>
    4946:	7b 01       	movw	r14, r22
    4948:	8c 01       	movw	r16, r24
    494a:	c5 01       	movw	r24, r10
    494c:	b4 01       	movw	r22, r8
    494e:	0e 94 aa 6a 	call	0xd554	; 0xd554 <__floatunsisf>
    4952:	9b 01       	movw	r18, r22
    4954:	ac 01       	movw	r20, r24
    4956:	c8 01       	movw	r24, r16
    4958:	b7 01       	movw	r22, r14
    495a:	0e 94 be 68 	call	0xd17c	; 0xd17c <__divsf3>
    495e:	7b 01       	movw	r14, r22
    4960:	8c 01       	movw	r16, r24
    4962:	68 83       	st	Y, r22
    4964:	79 83       	std	Y+1, r23	; 0x01
    4966:	8a 83       	std	Y+2, r24	; 0x02
    4968:	9b 83       	std	Y+3, r25	; 0x03
				if(gUnitD[i]>253)	gUnitD[i]=254;
    496a:	20 e0       	ldi	r18, 0x00	; 0
    496c:	30 e0       	ldi	r19, 0x00	; 0
    496e:	4d e7       	ldi	r20, 0x7D	; 125
    4970:	53 e4       	ldi	r21, 0x43	; 67
    4972:	0e 94 68 69 	call	0xd2d0	; 0xd2d0 <__gtsf2>
    4976:	18 16       	cp	r1, r24
    4978:	2c f4       	brge	.+10     	; 0x4984 <CalcUnitMove+0xb6>
    497a:	48 82       	st	Y, r4
    497c:	59 82       	std	Y+1, r5	; 0x01
    497e:	6a 82       	std	Y+2, r6	; 0x02
    4980:	7b 82       	std	Y+3, r7	; 0x03
    4982:	17 c0       	rjmp	.+46     	; 0x49b2 <CalcUnitMove+0xe4>
				else if(gUnitD[i]<-253)	gUnitD[i]=-254;
    4984:	20 e0       	ldi	r18, 0x00	; 0
    4986:	30 e0       	ldi	r19, 0x00	; 0
    4988:	4d e7       	ldi	r20, 0x7D	; 125
    498a:	53 ec       	ldi	r21, 0xC3	; 195
    498c:	c8 01       	movw	r24, r16
    498e:	b7 01       	movw	r22, r14
    4990:	0e 94 c8 69 	call	0xd390	; 0xd390 <__ltsf2>
    4994:	88 23       	and	r24, r24
    4996:	6c f4       	brge	.+26     	; 0x49b2 <CalcUnitMove+0xe4>
    4998:	80 e0       	ldi	r24, 0x00	; 0
    499a:	90 e0       	ldi	r25, 0x00	; 0
    499c:	ae e7       	ldi	r26, 0x7E	; 126
    499e:	b3 ec       	ldi	r27, 0xC3	; 195
    49a0:	04 c0       	rjmp	.+8      	; 0x49aa <CalcUnitMove+0xdc>
			}
			else
				gUnitD[i] = 0;
    49a2:	80 e0       	ldi	r24, 0x00	; 0
    49a4:	90 e0       	ldi	r25, 0x00	; 0
    49a6:	a0 e0       	ldi	r26, 0x00	; 0
    49a8:	b0 e0       	ldi	r27, 0x00	; 0
    49aa:	88 83       	st	Y, r24
    49ac:	99 83       	std	Y+1, r25	; 0x01
    49ae:	aa 83       	std	Y+2, r26	; 0x02
    49b0:	bb 83       	std	Y+3, r27	; 0x03
    49b2:	a5 e0       	ldi	r26, 0x05	; 5
    49b4:	b0 e0       	ldi	r27, 0x00	; 0
    49b6:	ca 0e       	add	r12, r26
    49b8:	db 1e       	adc	r13, r27
    49ba:	24 96       	adiw	r28, 0x04	; 4
//------------------------------------------------------------------------------
static void CalcUnitMove(void)
{
	WORD i;

	for(i=0;i<MAX_wCK;i++){
    49bc:	b0 e9       	ldi	r27, 0x90	; 144
    49be:	cb 16       	cp	r12, r27
    49c0:	bd e0       	ldi	r27, 0x0D	; 13
    49c2:	db 06       	cpc	r13, r27
    49c4:	09 f0       	breq	.+2      	; 0x49c8 <CalcUnitMove+0xfa>
    49c6:	aa cf       	rjmp	.-172    	; 0x491c <CalcUnitMove+0x4e>
			}
			else
				gUnitD[i] = 0;
		}
	}
	gFrameIdx=0;				// reset frame to start of scene
    49c8:	10 92 07 06 	sts	0x0607, r1
    49cc:	10 92 06 06 	sts	0x0606, r1
}
    49d0:	df 91       	pop	r29
    49d2:	cf 91       	pop	r28
    49d4:	1f 91       	pop	r17
    49d6:	0f 91       	pop	r16
    49d8:	ff 90       	pop	r15
    49da:	ef 90       	pop	r14
    49dc:	df 90       	pop	r13
    49de:	cf 90       	pop	r12
    49e0:	bf 90       	pop	r11
    49e2:	af 90       	pop	r10
    49e4:	9f 90       	pop	r9
    49e6:	8f 90       	pop	r8
    49e8:	7f 90       	pop	r7
    49ea:	6f 90       	pop	r6
    49ec:	5f 90       	pop	r5
    49ee:	4f 90       	pop	r4
    49f0:	08 95       	ret

000049f2 <MakeFrame>:
//------------------------------------------------------------------------------
// Build a frame to send: that is, stuff the next frame into our transmit
// buffer.
//------------------------------------------------------------------------------
static void MakeFrame(void)
{
    49f2:	ff 92       	push	r15
    49f4:	0f 93       	push	r16
    49f6:	1f 93       	push	r17
    49f8:	cf 93       	push	r28
    49fa:	df 93       	push	r29
	while(gTx0Cnt);			// wait until the transmit buffer is empty
    49fc:	80 91 7e 0b 	lds	r24, 0x0B7E
    4a00:	88 23       	and	r24, r24
    4a02:	e1 f7       	brne	.-8      	; 0x49fc <MakeFrame+0xa>
	gFrameIdx++;			// next frame
    4a04:	80 91 06 06 	lds	r24, 0x0606
    4a08:	90 91 07 06 	lds	r25, 0x0607
    4a0c:	01 96       	adiw	r24, 0x01	; 1
    4a0e:	90 93 07 06 	sts	0x0607, r25
    4a12:	80 93 06 06 	sts	0x0606, r24
{
	int lwtmp;
	BYTE CheckSum; 
	BYTE i, tmp, Data;

	Data = (Scene.wCK[0].Torq<<5) | 31; // get the torque for the scene
    4a16:	90 91 f8 0c 	lds	r25, 0x0CF8
    4a1a:	92 95       	swap	r25
    4a1c:	99 0f       	add	r25, r25
    4a1e:	90 7e       	andi	r25, 0xE0	; 224
    4a20:	9f 61       	ori	r25, 0x1F	; 31

	gTx0Buf[gTx0Cnt]=HEADER;
    4a22:	e0 91 7e 0b 	lds	r30, 0x0B7E
    4a26:	f0 e0       	ldi	r31, 0x00	; 0
    4a28:	ee 53       	subi	r30, 0x3E	; 62
    4a2a:	f5 4f       	sbci	r31, 0xF5	; 245
    4a2c:	8f ef       	ldi	r24, 0xFF	; 255
    4a2e:	80 83       	st	Z, r24
	gTx0Cnt++;		
    4a30:	80 91 7e 0b 	lds	r24, 0x0B7E
    4a34:	8f 5f       	subi	r24, 0xFF	; 255
    4a36:	80 93 7e 0b 	sts	0x0B7E, r24

	gTx0Buf[gTx0Cnt]=Data;
    4a3a:	e0 91 7e 0b 	lds	r30, 0x0B7E
    4a3e:	f0 e0       	ldi	r31, 0x00	; 0
    4a40:	ee 53       	subi	r30, 0x3E	; 62
    4a42:	f5 4f       	sbci	r31, 0xF5	; 245
    4a44:	90 83       	st	Z, r25
	gTx0Cnt++;		
    4a46:	80 91 7e 0b 	lds	r24, 0x0B7E
    4a4a:	8f 5f       	subi	r24, 0xFF	; 255
    4a4c:	80 93 7e 0b 	sts	0x0B7E, r24

	gTx0Buf[gTx0Cnt]=16;  // This is the (last ID - 1) why is it hardcoded ?
    4a50:	e0 91 7e 0b 	lds	r30, 0x0B7E
    4a54:	f0 e0       	ldi	r31, 0x00	; 0
    4a56:	ee 53       	subi	r30, 0x3E	; 62
    4a58:	f5 4f       	sbci	r31, 0xF5	; 245
    4a5a:	80 e1       	ldi	r24, 0x10	; 16
    4a5c:	80 83       	st	Z, r24
	gTx0Cnt++;		
    4a5e:	80 91 7e 0b 	lds	r24, 0x0B7E
    4a62:	8f 5f       	subi	r24, 0xFF	; 255
    4a64:	80 93 7e 0b 	sts	0x0B7E, r24
    4a68:	c5 ef       	ldi	r28, 0xF5	; 245
    4a6a:	dc e0       	ldi	r29, 0x0C	; 12
    4a6c:	0f e6       	ldi	r16, 0x6F	; 111
    4a6e:	1c e0       	ldi	r17, 0x0C	; 12
    4a70:	ff 24       	eor	r15, r15

	CheckSum = 0;
	for(i=0;i<MAX_wCK;i++){	// for all wCK 
		if(Scene.wCK[i].Exist){	// if wCK exists add the interpolation step
    4a72:	88 81       	ld	r24, Y
    4a74:	88 23       	and	r24, r24
    4a76:	59 f1       	breq	.+86     	; 0x4ace <MakeFrame+0xdc>
			lwtmp = (int)Scene.wCK[i].SPos + (int)((float)gFrameIdx*gUnitD[i]);
    4a78:	60 91 06 06 	lds	r22, 0x0606
    4a7c:	70 91 07 06 	lds	r23, 0x0607
    4a80:	80 e0       	ldi	r24, 0x00	; 0
    4a82:	90 e0       	ldi	r25, 0x00	; 0
    4a84:	0e 94 aa 6a 	call	0xd554	; 0xd554 <__floatunsisf>
    4a88:	f8 01       	movw	r30, r16
    4a8a:	20 81       	ld	r18, Z
    4a8c:	31 81       	ldd	r19, Z+1	; 0x01
    4a8e:	42 81       	ldd	r20, Z+2	; 0x02
    4a90:	53 81       	ldd	r21, Z+3	; 0x03
    4a92:	0e 94 c4 67 	call	0xcf88	; 0xcf88 <__mulsf3>
    4a96:	0e 94 56 6a 	call	0xd4ac	; 0xd4ac <__fixsfsi>
    4a9a:	89 81       	ldd	r24, Y+1	; 0x01
    4a9c:	68 0f       	add	r22, r24
    4a9e:	71 1d       	adc	r23, r1
			if(lwtmp>254)		lwtmp = 254; // bound result 1 to 254
    4aa0:	6f 3f       	cpi	r22, 0xFF	; 255
    4aa2:	71 05       	cpc	r23, r1
    4aa4:	1c f0       	brlt	.+6      	; 0x4aac <MakeFrame+0xba>
    4aa6:	6e ef       	ldi	r22, 0xFE	; 254
    4aa8:	70 e0       	ldi	r23, 0x00	; 0
    4aaa:	05 c0       	rjmp	.+10     	; 0x4ab6 <MakeFrame+0xc4>
			else if(lwtmp<1)	lwtmp = 1;
    4aac:	16 16       	cp	r1, r22
    4aae:	17 06       	cpc	r1, r23
    4ab0:	14 f0       	brlt	.+4      	; 0x4ab6 <MakeFrame+0xc4>
    4ab2:	61 e0       	ldi	r22, 0x01	; 1
    4ab4:	70 e0       	ldi	r23, 0x00	; 0
			tmp = (BYTE)lwtmp;
			gTx0Buf[gTx0Cnt] = tmp;
    4ab6:	e0 91 7e 0b 	lds	r30, 0x0B7E
    4aba:	f0 e0       	ldi	r31, 0x00	; 0
    4abc:	ee 53       	subi	r30, 0x3E	; 62
    4abe:	f5 4f       	sbci	r31, 0xF5	; 245
    4ac0:	60 83       	st	Z, r22
			gTx0Cnt++;			// put into transmit buffer
    4ac2:	80 91 7e 0b 	lds	r24, 0x0B7E
    4ac6:	8f 5f       	subi	r24, 0xFF	; 255
    4ac8:	80 93 7e 0b 	sts	0x0B7E, r24
			CheckSum = CheckSum^tmp;
    4acc:	f6 26       	eor	r15, r22
    4ace:	25 96       	adiw	r28, 0x05	; 5
    4ad0:	0c 5f       	subi	r16, 0xFC	; 252
    4ad2:	1f 4f       	sbci	r17, 0xFF	; 255

	gTx0Buf[gTx0Cnt]=16;  // This is the (last ID - 1) why is it hardcoded ?
	gTx0Cnt++;		

	CheckSum = 0;
	for(i=0;i<MAX_wCK;i++){	// for all wCK 
    4ad4:	fd e0       	ldi	r31, 0x0D	; 13
    4ad6:	c0 39       	cpi	r28, 0x90	; 144
    4ad8:	df 07       	cpc	r29, r31
    4ada:	59 f6       	brne	.-106    	; 0x4a72 <MakeFrame+0x80>
			gTx0Buf[gTx0Cnt] = tmp;
			gTx0Cnt++;			// put into transmit buffer
			CheckSum = CheckSum^tmp;
		}
	}
	CheckSum = CheckSum & 0x7f;
    4adc:	8f e7       	ldi	r24, 0x7F	; 127
    4ade:	f8 22       	and	r15, r24

	gTx0Buf[gTx0Cnt]=CheckSum;
    4ae0:	e0 91 7e 0b 	lds	r30, 0x0B7E
    4ae4:	f0 e0       	ldi	r31, 0x00	; 0
    4ae6:	ee 53       	subi	r30, 0x3E	; 62
    4ae8:	f5 4f       	sbci	r31, 0xF5	; 245
    4aea:	f0 82       	st	Z, r15
	gTx0Cnt++;			// put into transmit buffer
    4aec:	80 91 7e 0b 	lds	r24, 0x0B7E
    4af0:	8f 5f       	subi	r24, 0xFF	; 255
    4af2:	80 93 7e 0b 	sts	0x0B7E, r24
static void MakeFrame(void)
{
	while(gTx0Cnt);			// wait until the transmit buffer is empty
	gFrameIdx++;			// next frame
	SyncPosSend();			// build new frame
}
    4af6:	df 91       	pop	r29
    4af8:	cf 91       	pop	r28
    4afa:	1f 91       	pop	r17
    4afc:	0f 91       	pop	r16
    4afe:	ff 90       	pop	r15
    4b00:	08 95       	ret

00004b02 <PlaySceneFromBuffer>:
//------------------------------------------------------------------------------
// Begin playing one scene of the motion previously loaded with
// LoadMotionFromBuffer.  Return immediately, without waiting for it to finish.
//------------------------------------------------------------------------------
void PlaySceneFromBuffer(unsigned char *motionBuf, WORD sceneIndex)
{
    4b02:	ef 92       	push	r14
    4b04:	ff 92       	push	r15
    4b06:	1f 93       	push	r17
    4b08:	cf 93       	push	r28
    4b0a:	df 93       	push	r29
    4b0c:	fc 01       	movw	r30, r24
	gSceneIndex = sceneIndex;
    4b0e:	70 93 01 01 	sts	0x0101, r23
    4b12:	60 93 00 01 	sts	0x0100, r22
{
	WORD i, NumOfwCK;
	unsigned char *sceneBuffer;
	unsigned char *prevScene;

	NumOfwCK = Motion.NumOfwCK;
    4b16:	40 91 b1 0b 	lds	r20, 0x0BB1
    4b1a:	50 91 b2 0b 	lds	r21, 0x0BB2
	sceneBuffer = motionBuffer + (3 + 3 * gSceneIndex) * NumOfwCK + (4 * gSceneIndex) + 2;
    4b1e:	20 91 00 01 	lds	r18, 0x0100
    4b22:	30 91 01 01 	lds	r19, 0x0101
    4b26:	c0 91 00 01 	lds	r28, 0x0100
    4b2a:	d0 91 01 01 	lds	r29, 0x0101
    4b2e:	cc 0f       	add	r28, r28
    4b30:	dd 1f       	adc	r29, r29
    4b32:	cc 0f       	add	r28, r28
    4b34:	dd 1f       	adc	r29, r29
    4b36:	22 96       	adiw	r28, 0x02	; 2
    4b38:	ca 01       	movw	r24, r20
    4b3a:	88 0f       	add	r24, r24
    4b3c:	99 1f       	adc	r25, r25
    4b3e:	84 0f       	add	r24, r20
    4b40:	95 1f       	adc	r25, r21
    4b42:	2f 5f       	subi	r18, 0xFF	; 255
    4b44:	3f 4f       	sbci	r19, 0xFF	; 255
    4b46:	bc 01       	movw	r22, r24
    4b48:	62 9f       	mul	r22, r18
    4b4a:	c0 01       	movw	r24, r0
    4b4c:	63 9f       	mul	r22, r19
    4b4e:	90 0d       	add	r25, r0
    4b50:	72 9f       	mul	r23, r18
    4b52:	90 0d       	add	r25, r0
    4b54:	11 24       	eor	r1, r1
    4b56:	c8 0f       	add	r28, r24
    4b58:	d9 1f       	adc	r29, r25
    4b5a:	ce 0f       	add	r28, r30
    4b5c:	df 1f       	adc	r29, r31
		
	Scene.NumOfFrame = *((WORD*)(sceneBuffer+2));	// get the number of frames in scene
    4b5e:	8a 81       	ldd	r24, Y+2	; 0x02
    4b60:	9b 81       	ldd	r25, Y+3	; 0x03
    4b62:	90 93 f2 0c 	sts	0x0CF2, r25
    4b66:	80 93 f1 0c 	sts	0x0CF1, r24
	gNumOfFrame = Scene.NumOfFrame;
    4b6a:	90 93 9e 0b 	sts	0x0B9E, r25
    4b6e:	80 93 9d 0b 	sts	0x0B9D, r24
			
	Scene.RTime = *((WORD*)(sceneBuffer+0));		// get the run time of scene[msec]
    4b72:	88 81       	ld	r24, Y
    4b74:	99 81       	ldd	r25, Y+1	; 0x01
    4b76:	90 93 f4 0c 	sts	0x0CF4, r25
    4b7a:	80 93 f3 0c 	sts	0x0CF3, r24
	
	// Get the starting position for each wCK -- this will be the previous
	// scene destination, unless we're on scene 0, in which case we'll
	// assume the starting positions have been set by LoadMotionFromBuffer.
	if (gSceneIndex > 0) {
    4b7e:	80 91 00 01 	lds	r24, 0x0100
    4b82:	90 91 01 01 	lds	r25, 0x0101
    4b86:	89 2b       	or	r24, r25
    4b88:	71 f4       	brne	.+28     	; 0x4ba6 <PlaySceneFromBuffer+0xa4>
    4b8a:	7e 01       	movw	r14, r28
    4b8c:	be 01       	movw	r22, r28
    4b8e:	64 0f       	add	r22, r20
    4b90:	75 1f       	adc	r23, r21
    4b92:	da 01       	movw	r26, r20
    4b94:	12 96       	adiw	r26, 0x02	; 2
    4b96:	aa 0f       	add	r26, r26
    4b98:	bb 1f       	adc	r27, r27
    4b9a:	ac 0f       	add	r26, r28
    4b9c:	bd 1f       	adc	r27, r29
    4b9e:	20 e0       	ldi	r18, 0x00	; 0
    4ba0:	30 e0       	ldi	r19, 0x00	; 0
		}		
	}

	// Now get rest of the scene data for each wCK, including the destination position.
	for (i = 0; i < NumOfwCK; i++) {						
		Scene.wCK[pgm_read_byte(&(wCK_IDs[i]))].Exist	= 1;
    4ba2:	11 e0       	ldi	r17, 0x01	; 1
    4ba4:	57 c0       	rjmp	.+174    	; 0x4c54 <PlaySceneFromBuffer+0x152>
	
	// Get the starting position for each wCK -- this will be the previous
	// scene destination, unless we're on scene 0, in which case we'll
	// assume the starting positions have been set by LoadMotionFromBuffer.
	if (gSceneIndex > 0) {
		prevScene = motionBuffer + (3 + 3 * (gSceneIndex-1)) * NumOfwCK + (4 * (gSceneIndex-1)) + 2;
    4ba6:	80 91 00 01 	lds	r24, 0x0100
    4baa:	90 91 01 01 	lds	r25, 0x0101
    4bae:	20 91 00 01 	lds	r18, 0x0100
    4bb2:	30 91 01 01 	lds	r19, 0x0101
    4bb6:	bc 01       	movw	r22, r24
    4bb8:	46 9f       	mul	r20, r22
    4bba:	c0 01       	movw	r24, r0
    4bbc:	47 9f       	mul	r20, r23
    4bbe:	90 0d       	add	r25, r0
    4bc0:	56 9f       	mul	r21, r22
    4bc2:	90 0d       	add	r25, r0
    4bc4:	11 24       	eor	r1, r1
    4bc6:	dc 01       	movw	r26, r24
    4bc8:	aa 0f       	add	r26, r26
    4bca:	bb 1f       	adc	r27, r27
    4bcc:	a8 0f       	add	r26, r24
    4bce:	b9 1f       	adc	r27, r25
    4bd0:	21 50       	subi	r18, 0x01	; 1
    4bd2:	30 4c       	sbci	r19, 0xC0	; 192
    4bd4:	22 0f       	add	r18, r18
    4bd6:	33 1f       	adc	r19, r19
    4bd8:	22 0f       	add	r18, r18
    4bda:	33 1f       	adc	r19, r19
    4bdc:	a2 0f       	add	r26, r18
    4bde:	b3 1f       	adc	r27, r19
    4be0:	12 96       	adiw	r26, 0x02	; 2
    4be2:	ae 0f       	add	r26, r30
    4be4:	bf 1f       	adc	r27, r31
    4be6:	20 e0       	ldi	r18, 0x00	; 0
    4be8:	30 e0       	ldi	r19, 0x00	; 0
    4bea:	15 c0       	rjmp	.+42     	; 0x4c16 <PlaySceneFromBuffer+0x114>
		for (i = 0; i < Motion.NumOfwCK; i++) {						
			Scene.wCK[pgm_read_byte(&(wCK_IDs[i]))].SPos = prevScene[ 4 + i ];
    4bec:	f9 01       	movw	r30, r18
    4bee:	e3 5a       	subi	r30, 0xA3	; 163
    4bf0:	fb 4c       	sbci	r31, 0xCB	; 203
    4bf2:	e4 91       	lpm	r30, Z+
    4bf4:	8e 2f       	mov	r24, r30
    4bf6:	90 e0       	ldi	r25, 0x00	; 0
    4bf8:	fc 01       	movw	r30, r24
    4bfa:	ee 0f       	add	r30, r30
    4bfc:	ff 1f       	adc	r31, r31
    4bfe:	ee 0f       	add	r30, r30
    4c00:	ff 1f       	adc	r31, r31
    4c02:	e8 0f       	add	r30, r24
    4c04:	f9 1f       	adc	r31, r25
    4c06:	e1 51       	subi	r30, 0x11	; 17
    4c08:	f3 4f       	sbci	r31, 0xF3	; 243
    4c0a:	13 96       	adiw	r26, 0x03	; 3
    4c0c:	8c 91       	ld	r24, X
    4c0e:	13 97       	sbiw	r26, 0x03	; 3
    4c10:	87 83       	std	Z+7, r24	; 0x07
	// Get the starting position for each wCK -- this will be the previous
	// scene destination, unless we're on scene 0, in which case we'll
	// assume the starting positions have been set by LoadMotionFromBuffer.
	if (gSceneIndex > 0) {
		prevScene = motionBuffer + (3 + 3 * (gSceneIndex-1)) * NumOfwCK + (4 * (gSceneIndex-1)) + 2;
		for (i = 0; i < Motion.NumOfwCK; i++) {						
    4c12:	2f 5f       	subi	r18, 0xFF	; 255
    4c14:	3f 4f       	sbci	r19, 0xFF	; 255
    4c16:	11 96       	adiw	r26, 0x01	; 1
    4c18:	24 17       	cp	r18, r20
    4c1a:	35 07       	cpc	r19, r21
    4c1c:	38 f3       	brcs	.-50     	; 0x4bec <PlaySceneFromBuffer+0xea>
    4c1e:	b5 cf       	rjmp	.-150    	; 0x4b8a <PlaySceneFromBuffer+0x88>
    4c20:	f9 01       	movw	r30, r18
    4c22:	e3 5a       	subi	r30, 0xA3	; 163
    4c24:	fb 4c       	sbci	r31, 0xCB	; 203
		}		
	}

	// Now get rest of the scene data for each wCK, including the destination position.
	for (i = 0; i < NumOfwCK; i++) {						
		Scene.wCK[pgm_read_byte(&(wCK_IDs[i]))].Exist	= 1;
    4c26:	e4 91       	lpm	r30, Z+
    4c28:	8e 2f       	mov	r24, r30
    4c2a:	90 e0       	ldi	r25, 0x00	; 0
    4c2c:	fc 01       	movw	r30, r24
    4c2e:	ee 0f       	add	r30, r30
    4c30:	ff 1f       	adc	r31, r31
    4c32:	ee 0f       	add	r30, r30
    4c34:	ff 1f       	adc	r31, r31
    4c36:	e8 0f       	add	r30, r24
    4c38:	f9 1f       	adc	r31, r25
    4c3a:	e1 51       	subi	r30, 0x11	; 17
    4c3c:	f3 4f       	sbci	r31, 0xF3	; 243
    4c3e:	16 83       	std	Z+6, r17	; 0x06
		Scene.wCK[pgm_read_byte(&(wCK_IDs[i]))].DPos	= sceneBuffer[ 4 + i ];
    4c40:	e7 01       	movw	r28, r14
    4c42:	8b 81       	ldd	r24, Y+3	; 0x03
    4c44:	80 87       	std	Z+8, r24	; 0x08
		Scene.wCK[pgm_read_byte(&(wCK_IDs[i]))].Torq	= sceneBuffer[ NumOfwCK + 4 + i ];
    4c46:	eb 01       	movw	r28, r22
    4c48:	8b 81       	ldd	r24, Y+3	; 0x03
    4c4a:	81 87       	std	Z+9, r24	; 0x09
		Scene.wCK[pgm_read_byte(&(wCK_IDs[i]))].ExPortD	= sceneBuffer[ 2 * NumOfwCK + 4 + i ];
    4c4c:	8d 91       	ld	r24, X+
    4c4e:	82 87       	std	Z+10, r24	; 0x0a
			Scene.wCK[pgm_read_byte(&(wCK_IDs[i]))].SPos = prevScene[ 4 + i ];
		}		
	}

	// Now get rest of the scene data for each wCK, including the destination position.
	for (i = 0; i < NumOfwCK; i++) {						
    4c50:	2f 5f       	subi	r18, 0xFF	; 255
    4c52:	3f 4f       	sbci	r19, 0xFF	; 255
    4c54:	08 94       	sec
    4c56:	e1 1c       	adc	r14, r1
    4c58:	f1 1c       	adc	r15, r1
    4c5a:	6f 5f       	subi	r22, 0xFF	; 255
    4c5c:	7f 4f       	sbci	r23, 0xFF	; 255
    4c5e:	24 17       	cp	r18, r20
    4c60:	35 07       	cpc	r19, r21
    4c62:	f0 f2       	brcs	.-68     	; 0x4c20 <PlaySceneFromBuffer+0x11e>
	//rprintf("Servo %d: %d to %d\r\n", i, Scene.wCK[pgm_read_byte(&(wCK_IDs[i]))].SPos,
	//	Scene.wCK[pgm_read_byte(&(wCK_IDs[i]))].DPos);
	}
	
	// Serial port preparations (?).
	UCSR0B &= 0x7F;   		// UART0 RxInterrupt disable
    4c64:	57 98       	cbi	0x0a, 7	; 10
	UCSR0B |= 0x40;   		// UART0 TxInterrupt enable
    4c66:	56 9a       	sbi	0x0a, 6	; 10
    4c68:	88 eb       	ldi	r24, 0xB8	; 184
    4c6a:	92 e1       	ldi	r25, 0x12	; 18
    4c6c:	01 97       	sbiw	r24, 0x01	; 1
    4c6e:	f1 f7       	brne	.-4      	; 0x4c6c <PlaySceneFromBuffer+0x16a>
void PlaySceneFromBuffer(unsigned char *motionBuf, WORD sceneIndex)
{
	gSceneIndex = sceneIndex;
	GetSceneFromBuffer( motionBuf );	// Load scene into global structure
//	SendExPortD();						// Set external port data (commented out for now -- not needed)
	CalcFrameInterval();				// Set the interrupt for the frames
    4c70:	0e 94 12 24 	call	0x4824	; 0x4824 <CalcFrameInterval>
	CalcUnitMove();						// Calculate the interpolation steps
    4c74:	0e 94 67 24 	call	0x48ce	; 0x48ce <CalcUnitMove>
	MakeFrame();						// build a frame to send
    4c78:	0e 94 f9 24 	call	0x49f2	; 0x49f2 <MakeFrame>
// Start sending the frame (or whatever else happens to be in our transmit
// buffer, gTx0Buf).
//------------------------------------------------------------------------------
static void SendFrame(void)
{
	if(gTx0Cnt==0)	return;	// return if no frame to send
    4c7c:	80 91 7e 0b 	lds	r24, 0x0B7E
    4c80:	88 23       	and	r24, r24
    4c82:	71 f0       	breq	.+28     	; 0x4ca0 <PlaySceneFromBuffer+0x19e>
	gTx0BufIdx++;
    4c84:	80 91 b4 0a 	lds	r24, 0x0AB4
    4c88:	8f 5f       	subi	r24, 0xFF	; 255
    4c8a:	80 93 b4 0a 	sts	0x0AB4, r24
	sciTx0Data(gTx0Buf[gTx0BufIdx-1]);		// send first byte to start frame send
    4c8e:	e0 91 b4 0a 	lds	r30, 0x0AB4
    4c92:	f0 e0       	ldi	r31, 0x00	; 0
    4c94:	ef 53       	subi	r30, 0x3F	; 63
    4c96:	f5 4f       	sbci	r31, 0xF5	; 245
    4c98:	e0 81       	ld	r30, Z
//------------------------------------------------------------------------------
// Transmit char to UART when UART is ready
//------------------------------------------------------------------------------
void sciTx0Data(BYTE td)
{
	while(!(UCSR0A&(1<<UDRE))); 	// wait until data register is empty
    4c9a:	5d 9b       	sbis	0x0b, 5	; 11
    4c9c:	fe cf       	rjmp	.-4      	; 0x4c9a <PlaySceneFromBuffer+0x198>
	UDR0=td;
    4c9e:	ec b9       	out	0x0c, r30	; 12
//	SendExPortD();						// Set external port data (commented out for now -- not needed)
	CalcFrameInterval();				// Set the interrupt for the frames
	CalcUnitMove();						// Calculate the interpolation steps
	MakeFrame();						// build a frame to send
	SendFrame();						// start sending frame
}
    4ca0:	df 91       	pop	r29
    4ca2:	cf 91       	pop	r28
    4ca4:	1f 91       	pop	r17
    4ca6:	ff 90       	pop	r15
    4ca8:	ef 90       	pop	r14
    4caa:	08 95       	ret

00004cac <process_frames>:
// Check the F_NEXTFRAME flag, and if it's set (which is done by an interrupt
// scheduled to fire at the desired frame interval), make and send the next
// frame of the current scene.
//------------------------------------------------------------------------------
void process_frames()
{
    4cac:	80 91 86 0b 	lds	r24, 0x0B86
    4cb0:	88 23       	and	r24, r24
    4cb2:	b1 f0       	breq	.+44     	; 0x4ce0 <process_frames+0x34>
	if (F_NEXTFRAME) {
		MakeFrame();
    4cb4:	0e 94 f9 24 	call	0x49f2	; 0x49f2 <MakeFrame>
// Start sending the frame (or whatever else happens to be in our transmit
// buffer, gTx0Buf).
//------------------------------------------------------------------------------
static void SendFrame(void)
{
	if(gTx0Cnt==0)	return;	// return if no frame to send
    4cb8:	80 91 7e 0b 	lds	r24, 0x0B7E
    4cbc:	88 23       	and	r24, r24
    4cbe:	71 f0       	breq	.+28     	; 0x4cdc <process_frames+0x30>
	gTx0BufIdx++;
    4cc0:	80 91 b4 0a 	lds	r24, 0x0AB4
    4cc4:	8f 5f       	subi	r24, 0xFF	; 255
    4cc6:	80 93 b4 0a 	sts	0x0AB4, r24
	sciTx0Data(gTx0Buf[gTx0BufIdx-1]);		// send first byte to start frame send
    4cca:	e0 91 b4 0a 	lds	r30, 0x0AB4
    4cce:	f0 e0       	ldi	r31, 0x00	; 0
    4cd0:	ef 53       	subi	r30, 0x3F	; 63
    4cd2:	f5 4f       	sbci	r31, 0xF5	; 245
    4cd4:	e0 81       	ld	r30, Z
//------------------------------------------------------------------------------
// Transmit char to UART when UART is ready
//------------------------------------------------------------------------------
void sciTx0Data(BYTE td)
{
	while(!(UCSR0A&(1<<UDRE))); 	// wait until data register is empty
    4cd6:	5d 9b       	sbis	0x0b, 5	; 11
    4cd8:	fe cf       	rjmp	.-4      	; 0x4cd6 <process_frames+0x2a>
	UDR0=td;
    4cda:	ec b9       	out	0x0c, r30	; 12
void process_frames()
{
	if (F_NEXTFRAME) {
		MakeFrame();
		SendFrame();
		F_NEXTFRAME = 0;
    4cdc:	10 92 86 0b 	sts	0x0B86, r1
    4ce0:	08 95       	ret

00004ce2 <complete_motion>:
// This is a blocking routine which keeps the frames and scenes going until
// the whole motion is complete.  (It's not used in serial slave mode, but
// may be useful in other modes.)
//------------------------------------------------------------------------------
void complete_motion(unsigned char *motionBuf)
{
    4ce2:	0f 93       	push	r16
    4ce4:	1f 93       	push	r17
    4ce6:	cf 93       	push	r28
    4ce8:	df 93       	push	r29
    4cea:	ec 01       	movw	r28, r24
    4cec:	06 e6       	ldi	r16, 0x66	; 102
    4cee:	1e e0       	ldi	r17, 0x0E	; 14
    4cf0:	02 c0       	rjmp	.+4      	; 0x4cf6 <complete_motion+0x14>
	while (1) {
	
		// wait for the current scene to end
		while (F_PLAYING) process_frames();
    4cf2:	0e 94 56 26 	call	0x4cac	; 0x4cac <process_frames>
    4cf6:	80 91 85 0b 	lds	r24, 0x0B85
    4cfa:	88 23       	and	r24, r24
    4cfc:	d1 f7       	brne	.-12     	; 0x4cf2 <complete_motion+0x10>
		
		// if no more scenes, then we're done
		if (gSceneIndex+1 >= motionBuf[0]) return;
    4cfe:	20 91 00 01 	lds	r18, 0x0100
    4d02:	30 91 01 01 	lds	r19, 0x0101
    4d06:	2f 5f       	subi	r18, 0xFF	; 255
    4d08:	3f 4f       	sbci	r19, 0xFF	; 255
    4d0a:	88 81       	ld	r24, Y
    4d0c:	90 e0       	ldi	r25, 0x00	; 0
    4d0e:	28 17       	cp	r18, r24
    4d10:	39 07       	cpc	r19, r25
    4d12:	68 f4       	brcc	.+26     	; 0x4d2e <complete_motion+0x4c>

		// Otherwise, start the next scene.
		PlaySceneFromBuffer(motionBuf, gSceneIndex+1);
    4d14:	60 91 00 01 	lds	r22, 0x0100
    4d18:	70 91 01 01 	lds	r23, 0x0101
    4d1c:	6f 5f       	subi	r22, 0xFF	; 255
    4d1e:	7f 4f       	sbci	r23, 0xFF	; 255
    4d20:	ce 01       	movw	r24, r28
    4d22:	0e 94 81 25 	call	0x4b02	; 0x4b02 <PlaySceneFromBuffer>
    4d26:	c8 01       	movw	r24, r16
    4d28:	01 97       	sbiw	r24, 0x01	; 1
    4d2a:	f1 f7       	brne	.-4      	; 0x4d28 <complete_motion+0x46>
    4d2c:	e4 cf       	rjmp	.-56     	; 0x4cf6 <complete_motion+0x14>
		_delay_ms(1);
	}
}
    4d2e:	df 91       	pop	r29
    4d30:	cf 91       	pop	r28
    4d32:	1f 91       	pop	r17
    4d34:	0f 91       	pop	r16
    4d36:	08 95       	ret

00004d38 <BasicPose>:

//------------------------------------------------------------------------------
// Assume the basic standing position.
//------------------------------------------------------------------------------
void BasicPose()
{
    4d38:	ef 92       	push	r14
    4d3a:	ff 92       	push	r15
    4d3c:	0f 93       	push	r16
    4d3e:	1f 93       	push	r17
    4d40:	cf 93       	push	r28
    4d42:	df 93       	push	r29
	PF1_LED1_ON;
    4d44:	da 98       	cbi	0x1b, 2	; 27
	
	UCSR0B &= 0x7F;   		// UART0 Rx Interrupt disable
    4d46:	57 98       	cbi	0x0a, 7	; 10
	UCSR0B |= 0x40;   		// UART0 Tx Interrupt enable
    4d48:	56 9a       	sbi	0x0a, 6	; 10
	BYTE CheckSum; 
	BYTE i, tmp, Data;

	Data = (3<<5) | 31; // get the torque for the scene

	gTx0Buf[gTx0Cnt]=HEADER;
    4d4a:	e0 91 7e 0b 	lds	r30, 0x0B7E
    4d4e:	f0 e0       	ldi	r31, 0x00	; 0
    4d50:	ee 53       	subi	r30, 0x3E	; 62
    4d52:	f5 4f       	sbci	r31, 0xF5	; 245
    4d54:	8f ef       	ldi	r24, 0xFF	; 255
    4d56:	80 83       	st	Z, r24
	gTx0Cnt++;		
    4d58:	80 91 7e 0b 	lds	r24, 0x0B7E
    4d5c:	8f 5f       	subi	r24, 0xFF	; 255
    4d5e:	80 93 7e 0b 	sts	0x0B7E, r24

	gTx0Buf[gTx0Cnt]=Data;
    4d62:	e0 91 7e 0b 	lds	r30, 0x0B7E
    4d66:	f0 e0       	ldi	r31, 0x00	; 0
    4d68:	ee 53       	subi	r30, 0x3E	; 62
    4d6a:	f5 4f       	sbci	r31, 0xF5	; 245
    4d6c:	8f e7       	ldi	r24, 0x7F	; 127
    4d6e:	80 83       	st	Z, r24
	gTx0Cnt++;		
    4d70:	80 91 7e 0b 	lds	r24, 0x0B7E
    4d74:	8f 5f       	subi	r24, 0xFF	; 255
    4d76:	80 93 7e 0b 	sts	0x0B7E, r24

	gTx0Buf[gTx0Cnt]=16;  // This is the (last ID - 1) why is it hardcoded ?
    4d7a:	e0 91 7e 0b 	lds	r30, 0x0B7E
    4d7e:	f0 e0       	ldi	r31, 0x00	; 0
    4d80:	ee 53       	subi	r30, 0x3E	; 62
    4d82:	f5 4f       	sbci	r31, 0xF5	; 245
    4d84:	80 e1       	ldi	r24, 0x10	; 16
    4d86:	80 83       	st	Z, r24
	gTx0Cnt++;		
    4d88:	80 91 7e 0b 	lds	r24, 0x0B7E
    4d8c:	8f 5f       	subi	r24, 0xFF	; 255
    4d8e:	80 93 7e 0b 	sts	0x0B7E, r24
    4d92:	10 e0       	ldi	r17, 0x00	; 0
    4d94:	c0 e0       	ldi	r28, 0x00	; 0
    4d96:	d0 e0       	ldi	r29, 0x00	; 0
		
		gTx0Buf[gTx0Cnt] = tmp;
		gTx0Cnt++;						// put into transmit buffer
		CheckSum = CheckSum^tmp;
		
		rprintf (" %d %x,", i, tmp);
    4d98:	e0 e7       	ldi	r30, 0x70	; 112
    4d9a:	ee 2e       	mov	r14, r30
    4d9c:	e4 e3       	ldi	r30, 0x34	; 52
    4d9e:	fe 2e       	mov	r15, r30
    4da0:	01 e0       	ldi	r16, 0x01	; 1
	gTx0Buf[gTx0Cnt]=16;  // This is the (last ID - 1) why is it hardcoded ?
	gTx0Cnt++;		

	CheckSum = 0;
	for(i=0;i<16;i++){				// for all wCK 		
		tmp = pgm_read_byte((PGM_P) HunoBasicPose +i);
    4da2:	fe 01       	movw	r30, r28
    4da4:	eb 59       	subi	r30, 0x9B	; 155
    4da6:	fe 4f       	sbci	r31, 0xFE	; 254
    4da8:	94 91       	lpm	r25, Z+
		
		gTx0Buf[gTx0Cnt] = tmp;
    4daa:	e0 91 7e 0b 	lds	r30, 0x0B7E
    4dae:	f0 e0       	ldi	r31, 0x00	; 0
    4db0:	ee 53       	subi	r30, 0x3E	; 62
    4db2:	f5 4f       	sbci	r31, 0xF5	; 245
    4db4:	90 83       	st	Z, r25
		gTx0Cnt++;						// put into transmit buffer
    4db6:	80 91 7e 0b 	lds	r24, 0x0B7E
    4dba:	8f 5f       	subi	r24, 0xFF	; 255
    4dbc:	80 93 7e 0b 	sts	0x0B7E, r24
		CheckSum = CheckSum^tmp;
    4dc0:	19 27       	eor	r17, r25
		
		rprintf (" %d %x,", i, tmp);
    4dc2:	89 2f       	mov	r24, r25
    4dc4:	90 e0       	ldi	r25, 0x00	; 0
    4dc6:	9f 93       	push	r25
    4dc8:	8f 93       	push	r24
    4dca:	df 93       	push	r29
    4dcc:	cf 93       	push	r28
    4dce:	ff 92       	push	r15
    4dd0:	ef 92       	push	r14
    4dd2:	0f 93       	push	r16
    4dd4:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
    4dd8:	21 96       	adiw	r28, 0x01	; 1

	gTx0Buf[gTx0Cnt]=16;  // This is the (last ID - 1) why is it hardcoded ?
	gTx0Cnt++;		

	CheckSum = 0;
	for(i=0;i<16;i++){				// for all wCK 		
    4dda:	8d b7       	in	r24, 0x3d	; 61
    4ddc:	9e b7       	in	r25, 0x3e	; 62
    4dde:	07 96       	adiw	r24, 0x07	; 7
    4de0:	0f b6       	in	r0, 0x3f	; 63
    4de2:	f8 94       	cli
    4de4:	9e bf       	out	0x3e, r25	; 62
    4de6:	0f be       	out	0x3f, r0	; 63
    4de8:	8d bf       	out	0x3d, r24	; 61
    4dea:	c0 31       	cpi	r28, 0x10	; 16
    4dec:	d1 05       	cpc	r29, r1
    4dee:	c9 f6       	brne	.-78     	; 0x4da2 <BasicPose+0x6a>
		gTx0Cnt++;						// put into transmit buffer
		CheckSum = CheckSum^tmp;
		
		rprintf (" %d %x,", i, tmp);
	}
	CheckSum = CheckSum & 0x7f;
    4df0:	1f 77       	andi	r17, 0x7F	; 127

	gTx0Buf[gTx0Cnt]=CheckSum;
    4df2:	e0 91 7e 0b 	lds	r30, 0x0B7E
    4df6:	f0 e0       	ldi	r31, 0x00	; 0
    4df8:	ee 53       	subi	r30, 0x3E	; 62
    4dfa:	f5 4f       	sbci	r31, 0xF5	; 245
    4dfc:	10 83       	st	Z, r17
	gTx0Cnt++;								// put into transmit buffer
    4dfe:	80 91 7e 0b 	lds	r24, 0x0B7E
    4e02:	8f 5f       	subi	r24, 0xFF	; 255
    4e04:	80 93 7e 0b 	sts	0x0B7E, r24

	gTx0BufIdx++;
    4e08:	80 91 b4 0a 	lds	r24, 0x0AB4
    4e0c:	8f 5f       	subi	r24, 0xFF	; 255
    4e0e:	80 93 b4 0a 	sts	0x0AB4, r24
	sciTx0Data(gTx0Buf[gTx0BufIdx-1]);		// send first byte to start frame send
    4e12:	e0 91 b4 0a 	lds	r30, 0x0AB4
    4e16:	f0 e0       	ldi	r31, 0x00	; 0
    4e18:	ef 53       	subi	r30, 0x3F	; 63
    4e1a:	f5 4f       	sbci	r31, 0xF5	; 245
    4e1c:	e0 81       	ld	r30, Z
//------------------------------------------------------------------------------
// Transmit char to UART when UART is ready
//------------------------------------------------------------------------------
void sciTx0Data(BYTE td)
{
	while(!(UCSR0A&(1<<UDRE))); 	// wait until data register is empty
    4e1e:	5d 9b       	sbis	0x0b, 5	; 11
    4e20:	fe cf       	rjmp	.-4      	; 0x4e1e <BasicPose+0xe6>
	UDR0=td;
    4e22:	ec b9       	out	0x0c, r30	; 12
	gTx0Cnt++;								// put into transmit buffer

	gTx0BufIdx++;
	sciTx0Data(gTx0Buf[gTx0BufIdx-1]);		// send first byte to start frame send
	
	PF1_LED1_OFF;
    4e24:	da 9a       	sbi	0x1b, 2	; 27
	rprintf ("\r\n");
    4e26:	8d e6       	ldi	r24, 0x6D	; 109
    4e28:	94 e3       	ldi	r25, 0x34	; 52
    4e2a:	9f 93       	push	r25
    4e2c:	8f 93       	push	r24
    4e2e:	81 e0       	ldi	r24, 0x01	; 1
    4e30:	8f 93       	push	r24
    4e32:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
    4e36:	0f 90       	pop	r0
    4e38:	0f 90       	pop	r0
    4e3a:	0f 90       	pop	r0
}
    4e3c:	df 91       	pop	r29
    4e3e:	cf 91       	pop	r28
    4e40:	1f 91       	pop	r17
    4e42:	0f 91       	pop	r16
    4e44:	ff 90       	pop	r15
    4e46:	ef 90       	pop	r14
    4e48:	08 95       	ret

00004e4a <SendExPortD>:
//------------------------------------------------------------------------------
// Send external data for a scene
// 		
//------------------------------------------------------------------------------
void SendExPortD(void)
{
    4e4a:	1f 93       	push	r17
    4e4c:	cf 93       	push	r28
    4e4e:	df 93       	push	r29
    4e50:	c5 ef       	ldi	r28, 0xF5	; 245
    4e52:	dc e0       	ldi	r29, 0x0C	; 12
    4e54:	10 e0       	ldi	r17, 0x00	; 0
	WORD i;
	WORD TIME_OUT2 = 250;

	for(i=0;i<MAX_wCK;i++){					// external data set from Motion structure
		if(Scene.wCK[i].Exist) {			// set external data if wCK exists
    4e56:	88 81       	ld	r24, Y
    4e58:	88 23       	and	r24, r24
    4e5a:	79 f0       	breq	.+30     	; 0x4e7a <SendExPortD+0x30>
			wckSendSetCommand((7<<5)|i, 100, Scene.wCK[i].ExPortD, Scene.wCK[i].ExPortD);
    4e5c:	4c 81       	ldd	r20, Y+4	; 0x04
    4e5e:	24 2f       	mov	r18, r20
    4e60:	64 e6       	ldi	r22, 0x64	; 100
    4e62:	81 2f       	mov	r24, r17
    4e64:	80 6e       	ori	r24, 0xE0	; 224
    4e66:	0e 94 fc 52 	call	0xa5f8	; 0xa5f8 <wckSendSetCommand>

			wckGetByte(TIME_OUT2);
    4e6a:	8a ef       	ldi	r24, 0xFA	; 250
    4e6c:	90 e0       	ldi	r25, 0x00	; 0
    4e6e:	0e 94 ca 52 	call	0xa594	; 0xa594 <wckGetByte>
			wckGetByte(TIME_OUT2);			
    4e72:	8a ef       	ldi	r24, 0xFA	; 250
    4e74:	90 e0       	ldi	r25, 0x00	; 0
    4e76:	0e 94 ca 52 	call	0xa594	; 0xa594 <wckGetByte>
    4e7a:	25 96       	adiw	r28, 0x05	; 5
    4e7c:	1f 5f       	subi	r17, 0xFF	; 255
void SendExPortD(void)
{
	WORD i;
	WORD TIME_OUT2 = 250;

	for(i=0;i<MAX_wCK;i++){					// external data set from Motion structure
    4e7e:	1f 31       	cpi	r17, 0x1F	; 31
    4e80:	51 f7       	brne	.-44     	; 0x4e56 <SendExPortD+0xc>

			wckGetByte(TIME_OUT2);
			wckGetByte(TIME_OUT2);			
		}
	}
}
    4e82:	df 91       	pop	r29
    4e84:	cf 91       	pop	r28
    4e86:	1f 91       	pop	r17
    4e88:	08 95       	ret

00004e8a <SendTGain>:
//------------------------------------------------------------------------------
// Set P,D,I parameters of each servo's PID loop from current Motion data.
// 	
//------------------------------------------------------------------------------
void SendTGain(void)
{
    4e8a:	0f 93       	push	r16
    4e8c:	1f 93       	push	r17
    4e8e:	cf 93       	push	r28
    4e90:	df 93       	push	r29
    4e92:	c3 eb       	ldi	r28, 0xB3	; 179
    4e94:	db e0       	ldi	r29, 0x0B	; 11
    4e96:	00 e0       	ldi	r16, 0x00	; 0
	char reply1, reply2;
	WORD TIME_OUT2 = 250;
	for (int i=0; i<MAX_wCK;i++) {
		if (Motion.wCK[i].Exist) {
    4e98:	88 81       	ld	r24, Y
    4e9a:	88 23       	and	r24, r24
    4e9c:	f1 f0       	breq	.+60     	; 0x4eda <SendTGain+0x50>
			char servoID = i;
			wckSendSetCommand((7<<5)|servoID, 11, Motion.wCK[i].RPgain, Motion.wCK[i].RDgain);
    4e9e:	10 2f       	mov	r17, r16
    4ea0:	10 6e       	ori	r17, 0xE0	; 224
    4ea2:	2a 81       	ldd	r18, Y+2	; 0x02
    4ea4:	49 81       	ldd	r20, Y+1	; 0x01
    4ea6:	6b e0       	ldi	r22, 0x0B	; 11
    4ea8:	81 2f       	mov	r24, r17
    4eaa:	0e 94 fc 52 	call	0xa5f8	; 0xa5f8 <wckSendSetCommand>
			reply1 = wckGetByte(TIME_OUT2);		// should match the P gain we just set
    4eae:	8a ef       	ldi	r24, 0xFA	; 250
    4eb0:	90 e0       	ldi	r25, 0x00	; 0
    4eb2:	0e 94 ca 52 	call	0xa594	; 0xa594 <wckGetByte>
			reply2 = wckGetByte(TIME_OUT2);		// should match the D gain we just set
    4eb6:	8a ef       	ldi	r24, 0xFA	; 250
    4eb8:	90 e0       	ldi	r25, 0x00	; 0
    4eba:	0e 94 ca 52 	call	0xa594	; 0xa594 <wckGetByte>

			wckSendSetCommand((7<<5)|servoID, 24, Motion.wCK[i].RIgain, Motion.wCK[i].RIgain);
    4ebe:	4b 81       	ldd	r20, Y+3	; 0x03
    4ec0:	24 2f       	mov	r18, r20
    4ec2:	68 e1       	ldi	r22, 0x18	; 24
    4ec4:	81 2f       	mov	r24, r17
    4ec6:	0e 94 fc 52 	call	0xa5f8	; 0xa5f8 <wckSendSetCommand>
			reply1 = wckGetByte(TIME_OUT2);		// P gain again
    4eca:	8a ef       	ldi	r24, 0xFA	; 250
    4ecc:	90 e0       	ldi	r25, 0x00	; 0
    4ece:	0e 94 ca 52 	call	0xa594	; 0xa594 <wckGetByte>
			reply2 = wckGetByte(TIME_OUT2);		// D gain again
    4ed2:	8a ef       	ldi	r24, 0xFA	; 250
    4ed4:	90 e0       	ldi	r25, 0x00	; 0
    4ed6:	0e 94 ca 52 	call	0xa594	; 0xa594 <wckGetByte>
    4eda:	26 96       	adiw	r28, 0x06	; 6
    4edc:	0f 5f       	subi	r16, 0xFF	; 255
//------------------------------------------------------------------------------
void SendTGain(void)
{
	char reply1, reply2;
	WORD TIME_OUT2 = 250;
	for (int i=0; i<MAX_wCK;i++) {
    4ede:	0f 31       	cpi	r16, 0x1F	; 31
    4ee0:	d9 f6       	brne	.-74     	; 0x4e98 <SendTGain+0xe>
			wckSendSetCommand((7<<5)|servoID, 24, Motion.wCK[i].RIgain, Motion.wCK[i].RIgain);
			reply1 = wckGetByte(TIME_OUT2);		// P gain again
			reply2 = wckGetByte(TIME_OUT2);		// D gain again
		}
	}
}
    4ee2:	df 91       	pop	r29
    4ee4:	cf 91       	pop	r28
    4ee6:	1f 91       	pop	r17
    4ee8:	0f 91       	pop	r16
    4eea:	08 95       	ret

00004eec <LoadMotionFromBuffer>:

//------------------------------------------------------------------------------
// Load a motion from a buffer in RAM, and return immediately.
//------------------------------------------------------------------------------
void LoadMotionFromBuffer(unsigned char *motionBuf)
{
    4eec:	df 92       	push	r13
    4eee:	ef 92       	push	r14
    4ef0:	ff 92       	push	r15
    4ef2:	0f 93       	push	r16
    4ef4:	1f 93       	push	r17
    4ef6:	cf 93       	push	r28
    4ef8:	df 93       	push	r29
    4efa:	dc 01       	movw	r26, r24
    4efc:	e3 eb       	ldi	r30, 0xB3	; 179
    4efe:	fb e0       	ldi	r31, 0x0B	; 11

void ClearMotionData(void)
{
	WORD i;
	for (i = 0; i < MAX_wCK; i++) {				// clear the wCK motion data
		Motion.wCK[i].Exist		= 0;
    4f00:	10 82       	st	Z, r1
		Motion.wCK[i].RPgain	= 0;
    4f02:	11 82       	std	Z+1, r1	; 0x01
		Motion.wCK[i].RDgain	= 0;
    4f04:	12 82       	std	Z+2, r1	; 0x02
		Motion.wCK[i].RIgain	= 0;
    4f06:	13 82       	std	Z+3, r1	; 0x03
		Motion.wCK[i].PortEn	= 0;
    4f08:	14 82       	std	Z+4, r1	; 0x04
		Motion.wCK[i].InitPos	= 0;
    4f0a:	15 82       	std	Z+5, r1	; 0x05
    4f0c:	36 96       	adiw	r30, 0x06	; 6


void ClearMotionData(void)
{
	WORD i;
	for (i = 0; i < MAX_wCK; i++) {				// clear the wCK motion data
    4f0e:	8c e0       	ldi	r24, 0x0C	; 12
    4f10:	ed 36       	cpi	r30, 0x6D	; 109
    4f12:	f8 07       	cpc	r31, r24
    4f14:	a9 f7       	brne	.-22     	; 0x4f00 <LoadMotionFromBuffer+0x14>
	unsigned char *dGains;
	unsigned char *iGains;
	
	ClearMotionData();
	
	Motion.NumOfScene = motionBuf[0];  // (See "Motion Buffer Layout" at top of file)
    4f16:	8c 91       	ld	r24, X
    4f18:	80 93 af 0b 	sts	0x0BAF, r24
    4f1c:	10 92 b0 0b 	sts	0x0BB0, r1
	Motion.NumOfwCK = motionBuf[1];
    4f20:	11 96       	adiw	r26, 0x01	; 1
    4f22:	8c 91       	ld	r24, X
    4f24:	11 97       	sbiw	r26, 0x01	; 1
    4f26:	48 2f       	mov	r20, r24
    4f28:	50 e0       	ldi	r21, 0x00	; 0
    4f2a:	50 93 b2 0b 	sts	0x0BB2, r21
    4f2e:	40 93 b1 0b 	sts	0x0BB1, r20
	
	//rprintf("GMBF: %d, %d\n", Motion.NumOfScene, Motion.NumOfwCK );

	pGains = motionBuf + 2;
	dGains = pGains + Motion.NumOfwCK;
    4f32:	12 96       	adiw	r26, 0x02	; 2
    4f34:	bd 01       	movw	r22, r26
    4f36:	64 0f       	add	r22, r20
    4f38:	75 1f       	adc	r23, r21
    4f3a:	12 97       	sbiw	r26, 0x02	; 2
	iGains = dGains + Motion.NumOfwCK;
    4f3c:	7b 01       	movw	r14, r22
    4f3e:	e4 0e       	add	r14, r20
    4f40:	f5 1e       	adc	r15, r21
		Motion.wCK[pgm_read_byte(&(wCK_IDs[i]))].Exist	= 1;
		Motion.wCK[pgm_read_byte(&(wCK_IDs[i]))].RPgain	= pGains[i];
		Motion.wCK[pgm_read_byte(&(wCK_IDs[i]))].RDgain	= dGains[i];
		Motion.wCK[pgm_read_byte(&(wCK_IDs[i]))].RIgain	= iGains[i];
		Motion.wCK[pgm_read_byte(&(wCK_IDs[i]))].PortEn	= 1;
		Motion.wCK[pgm_read_byte(&(wCK_IDs[i]))].InitPos = pgm_read_byte(gpZero_Table+i);
    4f42:	00 91 a7 0b 	lds	r16, 0x0BA7
    4f46:	10 91 a8 0b 	lds	r17, 0x0BA8
    4f4a:	ed 01       	movw	r28, r26
    4f4c:	20 e0       	ldi	r18, 0x00	; 0
    4f4e:	30 e0       	ldi	r19, 0x00	; 0
	pGains = motionBuf + 2;
	dGains = pGains + Motion.NumOfwCK;
	iGains = dGains + Motion.NumOfwCK;
	
	for (i = 0; i < Motion.NumOfwCK; i++) {		// fill the wCK motion data
		Motion.wCK[pgm_read_byte(&(wCK_IDs[i]))].Exist	= 1;
    4f50:	dd 24       	eor	r13, r13
    4f52:	d3 94       	inc	r13
    4f54:	2f c0       	rjmp	.+94     	; 0x4fb4 <LoadMotionFromBuffer+0xc8>
		Motion.wCK[pgm_read_byte(&(wCK_IDs[i]))].RPgain	= pGains[i];
		Motion.wCK[pgm_read_byte(&(wCK_IDs[i]))].RDgain	= dGains[i];
		Motion.wCK[pgm_read_byte(&(wCK_IDs[i]))].RIgain	= iGains[i];
		Motion.wCK[pgm_read_byte(&(wCK_IDs[i]))].PortEn	= 1;
		Motion.wCK[pgm_read_byte(&(wCK_IDs[i]))].InitPos = pgm_read_byte(gpZero_Table+i);
    4f56:	f9 01       	movw	r30, r18
    4f58:	e3 5a       	subi	r30, 0xA3	; 163
    4f5a:	fb 4c       	sbci	r31, 0xCB	; 203
	pGains = motionBuf + 2;
	dGains = pGains + Motion.NumOfwCK;
	iGains = dGains + Motion.NumOfwCK;
	
	for (i = 0; i < Motion.NumOfwCK; i++) {		// fill the wCK motion data
		Motion.wCK[pgm_read_byte(&(wCK_IDs[i]))].Exist	= 1;
    4f5c:	e4 91       	lpm	r30, Z+
    4f5e:	8e 2f       	mov	r24, r30
    4f60:	90 e0       	ldi	r25, 0x00	; 0
    4f62:	dc 01       	movw	r26, r24
    4f64:	aa 0f       	add	r26, r26
    4f66:	bb 1f       	adc	r27, r27
    4f68:	a8 0f       	add	r26, r24
    4f6a:	b9 1f       	adc	r27, r25
    4f6c:	aa 0f       	add	r26, r26
    4f6e:	bb 1f       	adc	r27, r27
    4f70:	a7 55       	subi	r26, 0x57	; 87
    4f72:	b4 4f       	sbci	r27, 0xF4	; 244
    4f74:	1a 96       	adiw	r26, 0x0a	; 10
    4f76:	dc 92       	st	X, r13
    4f78:	1a 97       	sbiw	r26, 0x0a	; 10
		Motion.wCK[pgm_read_byte(&(wCK_IDs[i]))].RPgain	= pGains[i];
    4f7a:	89 81       	ldd	r24, Y+1	; 0x01
    4f7c:	1b 96       	adiw	r26, 0x0b	; 11
    4f7e:	8c 93       	st	X, r24
    4f80:	1b 97       	sbiw	r26, 0x0b	; 11
		Motion.wCK[pgm_read_byte(&(wCK_IDs[i]))].RDgain	= dGains[i];
    4f82:	fb 01       	movw	r30, r22
    4f84:	e2 0f       	add	r30, r18
    4f86:	f3 1f       	adc	r31, r19
    4f88:	80 81       	ld	r24, Z
    4f8a:	1c 96       	adiw	r26, 0x0c	; 12
    4f8c:	8c 93       	st	X, r24
    4f8e:	1c 97       	sbiw	r26, 0x0c	; 12
		Motion.wCK[pgm_read_byte(&(wCK_IDs[i]))].RIgain	= iGains[i];
    4f90:	f7 01       	movw	r30, r14
    4f92:	e2 0f       	add	r30, r18
    4f94:	f3 1f       	adc	r31, r19
    4f96:	80 81       	ld	r24, Z
    4f98:	1d 96       	adiw	r26, 0x0d	; 13
    4f9a:	8c 93       	st	X, r24
    4f9c:	1d 97       	sbiw	r26, 0x0d	; 13
		Motion.wCK[pgm_read_byte(&(wCK_IDs[i]))].PortEn	= 1;
    4f9e:	1e 96       	adiw	r26, 0x0e	; 14
    4fa0:	dc 92       	st	X, r13
    4fa2:	1e 97       	sbiw	r26, 0x0e	; 14
		Motion.wCK[pgm_read_byte(&(wCK_IDs[i]))].InitPos = pgm_read_byte(gpZero_Table+i);
    4fa4:	f8 01       	movw	r30, r16
    4fa6:	e2 0f       	add	r30, r18
    4fa8:	f3 1f       	adc	r31, r19
    4faa:	e4 91       	lpm	r30, Z+
    4fac:	1f 96       	adiw	r26, 0x0f	; 15
    4fae:	ec 93       	st	X, r30

	pGains = motionBuf + 2;
	dGains = pGains + Motion.NumOfwCK;
	iGains = dGains + Motion.NumOfwCK;
	
	for (i = 0; i < Motion.NumOfwCK; i++) {		// fill the wCK motion data
    4fb0:	2f 5f       	subi	r18, 0xFF	; 255
    4fb2:	3f 4f       	sbci	r19, 0xFF	; 255
    4fb4:	21 96       	adiw	r28, 0x01	; 1
    4fb6:	24 17       	cp	r18, r20
    4fb8:	35 07       	cpc	r19, r21
    4fba:	68 f2       	brcs	.-102    	; 0x4f56 <LoadMotionFromBuffer+0x6a>
    4fbc:	c0 e0       	ldi	r28, 0x00	; 0
    4fbe:	d0 e0       	ldi	r29, 0x00	; 0
    4fc0:	14 c0       	rjmp	.+40     	; 0x4fea <LoadMotionFromBuffer+0xfe>
	GetMotionFromBuffer( motionBuf );	// Load motion data into our Motion global
	
	// Initialize the starting positions of the first scene
	// to the current servo positions
	for (int i = 0; i < Motion.NumOfwCK; i++) {
		BYTE id = pgm_read_byte(&(wCK_IDs[i]));
    4fc2:	fe 01       	movw	r30, r28
    4fc4:	e3 5a       	subi	r30, 0xA3	; 163
    4fc6:	fb 4c       	sbci	r31, 0xCB	; 203
    4fc8:	14 91       	lpm	r17, Z+
		Scene.wCK[id].SPos = wckPosRead(id);
    4fca:	81 2f       	mov	r24, r17
    4fcc:	0e 94 62 53 	call	0xa6c4	; 0xa6c4 <wckPosRead>
    4fd0:	21 2f       	mov	r18, r17
    4fd2:	30 e0       	ldi	r19, 0x00	; 0
    4fd4:	f9 01       	movw	r30, r18
    4fd6:	ee 0f       	add	r30, r30
    4fd8:	ff 1f       	adc	r31, r31
    4fda:	ee 0f       	add	r30, r30
    4fdc:	ff 1f       	adc	r31, r31
    4fde:	e2 0f       	add	r30, r18
    4fe0:	f3 1f       	adc	r31, r19
    4fe2:	e1 51       	subi	r30, 0x11	; 17
    4fe4:	f3 4f       	sbci	r31, 0xF3	; 243
    4fe6:	87 83       	std	Z+7, r24	; 0x07
{
	GetMotionFromBuffer( motionBuf );	// Load motion data into our Motion global
	
	// Initialize the starting positions of the first scene
	// to the current servo positions
	for (int i = 0; i < Motion.NumOfwCK; i++) {
    4fe8:	21 96       	adiw	r28, 0x01	; 1
    4fea:	80 91 b1 0b 	lds	r24, 0x0BB1
    4fee:	90 91 b2 0b 	lds	r25, 0x0BB2
    4ff2:	c8 17       	cp	r28, r24
    4ff4:	d9 07       	cpc	r29, r25
    4ff6:	28 f3       	brcs	.-54     	; 0x4fc2 <LoadMotionFromBuffer+0xd6>
		Scene.wCK[id].SPos = wckPosRead(id);
		
		//rprintf("SPos %d = %d\r\n", id, Scene.wCK[id].SPos);
	}
	
 	SendTGain();						// set the runtime PID gain from motion structure
    4ff8:	0e 94 45 27 	call	0x4e8a	; 0x4e8a <SendTGain>
}
    4ffc:	df 91       	pop	r29
    4ffe:	cf 91       	pop	r28
    5000:	1f 91       	pop	r17
    5002:	0f 91       	pop	r16
    5004:	ff 90       	pop	r15
    5006:	ef 90       	pop	r14
    5008:	df 90       	pop	r13
    500a:	08 95       	ret

0000500c <M_PlayFlash>:
// global data (Motion.NumOfScene and Motion.NumOfwCK), and partially defined
// by a bunch of global pointers into flash data (gpPos_Table, gpT_Table, etc.).
// This method blocks until the whole motion is done playing.
//------------------------------------------------------------------------------
void M_PlayFlash(void)
{
    500c:	bf 92       	push	r11
    500e:	cf 92       	push	r12
    5010:	df 92       	push	r13
    5012:	ef 92       	push	r14
    5014:	ff 92       	push	r15
    5016:	0f 93       	push	r16
    5018:	1f 93       	push	r17
    501a:	cf 93       	push	r28
    501c:	df 93       	push	r29
    501e:	e3 eb       	ldi	r30, 0xB3	; 179
    5020:	fb e0       	ldi	r31, 0x0B	; 11

void ClearMotionData(void)
{
	WORD i;
	for (i = 0; i < MAX_wCK; i++) {				// clear the wCK motion data
		Motion.wCK[i].Exist		= 0;
    5022:	10 82       	st	Z, r1
		Motion.wCK[i].RPgain	= 0;
    5024:	11 82       	std	Z+1, r1	; 0x01
		Motion.wCK[i].RDgain	= 0;
    5026:	12 82       	std	Z+2, r1	; 0x02
		Motion.wCK[i].RIgain	= 0;
    5028:	13 82       	std	Z+3, r1	; 0x03
		Motion.wCK[i].PortEn	= 0;
    502a:	14 82       	std	Z+4, r1	; 0x04
		Motion.wCK[i].InitPos	= 0;
    502c:	15 82       	std	Z+5, r1	; 0x05
    502e:	36 96       	adiw	r30, 0x06	; 6


void ClearMotionData(void)
{
	WORD i;
	for (i = 0; i < MAX_wCK; i++) {				// clear the wCK motion data
    5030:	8c e0       	ldi	r24, 0x0C	; 12
    5032:	ed 36       	cpi	r30, 0x6D	; 109
    5034:	f8 07       	cpc	r31, r24
    5036:	a9 f7       	brne	.-22     	; 0x5022 <M_PlayFlash+0x16>
{
	WORD i;

	ClearMotionData();
	
	for(i=0;i<Motion.NumOfwCK;i++){		// fill the wCK motion data
    5038:	e0 90 b1 0b 	lds	r14, 0x0BB1
    503c:	f0 90 b2 0b 	lds	r15, 0x0BB2
		Motion.wCK[pgm_read_byte(&(wCK_IDs[i]))].Exist	= 1;
		Motion.wCK[pgm_read_byte(&(wCK_IDs[i]))].RPgain	= pgm_read_byte(gpPg_Table+i);
    5040:	00 91 eb 0c 	lds	r16, 0x0CEB
    5044:	10 91 ec 0c 	lds	r17, 0x0CEC
		Motion.wCK[pgm_read_byte(&(wCK_IDs[i]))].RDgain	= pgm_read_byte(gpDg_Table+i);
    5048:	c0 91 90 0d 	lds	r28, 0x0D90
    504c:	d0 91 91 0d 	lds	r29, 0x0D91
		Motion.wCK[pgm_read_byte(&(wCK_IDs[i]))].RIgain	= pgm_read_byte(gpIg_Table+i);
    5050:	60 91 9f 0b 	lds	r22, 0x0B9F
    5054:	70 91 a0 0b 	lds	r23, 0x0BA0
		Motion.wCK[pgm_read_byte(&(wCK_IDs[i]))].PortEn	= 1;
		Motion.wCK[pgm_read_byte(&(wCK_IDs[i]))].InitPos = pgm_read_byte(gpZero_Table+i);
    5058:	40 91 a7 0b 	lds	r20, 0x0BA7
    505c:	50 91 a8 0b 	lds	r21, 0x0BA8
    5060:	20 e0       	ldi	r18, 0x00	; 0
    5062:	30 e0       	ldi	r19, 0x00	; 0
	WORD i;

	ClearMotionData();
	
	for(i=0;i<Motion.NumOfwCK;i++){		// fill the wCK motion data
		Motion.wCK[pgm_read_byte(&(wCK_IDs[i]))].Exist	= 1;
    5064:	dd 24       	eor	r13, r13
    5066:	d3 94       	inc	r13
    5068:	32 c0       	rjmp	.+100    	; 0x50ce <M_PlayFlash+0xc2>
		Motion.wCK[pgm_read_byte(&(wCK_IDs[i]))].RPgain	= pgm_read_byte(gpPg_Table+i);
		Motion.wCK[pgm_read_byte(&(wCK_IDs[i]))].RDgain	= pgm_read_byte(gpDg_Table+i);
		Motion.wCK[pgm_read_byte(&(wCK_IDs[i]))].RIgain	= pgm_read_byte(gpIg_Table+i);
		Motion.wCK[pgm_read_byte(&(wCK_IDs[i]))].PortEn	= 1;
		Motion.wCK[pgm_read_byte(&(wCK_IDs[i]))].InitPos = pgm_read_byte(gpZero_Table+i);
    506a:	f9 01       	movw	r30, r18
    506c:	e3 5a       	subi	r30, 0xA3	; 163
    506e:	fb 4c       	sbci	r31, 0xCB	; 203
	WORD i;

	ClearMotionData();
	
	for(i=0;i<Motion.NumOfwCK;i++){		// fill the wCK motion data
		Motion.wCK[pgm_read_byte(&(wCK_IDs[i]))].Exist	= 1;
    5070:	e4 91       	lpm	r30, Z+
    5072:	8e 2f       	mov	r24, r30
    5074:	90 e0       	ldi	r25, 0x00	; 0
    5076:	dc 01       	movw	r26, r24
    5078:	aa 0f       	add	r26, r26
    507a:	bb 1f       	adc	r27, r27
    507c:	a8 0f       	add	r26, r24
    507e:	b9 1f       	adc	r27, r25
    5080:	aa 0f       	add	r26, r26
    5082:	bb 1f       	adc	r27, r27
    5084:	a7 55       	subi	r26, 0x57	; 87
    5086:	b4 4f       	sbci	r27, 0xF4	; 244
    5088:	1a 96       	adiw	r26, 0x0a	; 10
    508a:	dc 92       	st	X, r13
    508c:	1a 97       	sbiw	r26, 0x0a	; 10
		Motion.wCK[pgm_read_byte(&(wCK_IDs[i]))].RPgain	= pgm_read_byte(gpPg_Table+i);
    508e:	f8 01       	movw	r30, r16
    5090:	e2 0f       	add	r30, r18
    5092:	f3 1f       	adc	r31, r19
    5094:	e4 91       	lpm	r30, Z+
    5096:	1b 96       	adiw	r26, 0x0b	; 11
    5098:	ec 93       	st	X, r30
    509a:	1b 97       	sbiw	r26, 0x0b	; 11
		Motion.wCK[pgm_read_byte(&(wCK_IDs[i]))].RDgain	= pgm_read_byte(gpDg_Table+i);
    509c:	fe 01       	movw	r30, r28
    509e:	e2 0f       	add	r30, r18
    50a0:	f3 1f       	adc	r31, r19
    50a2:	e4 91       	lpm	r30, Z+
    50a4:	1c 96       	adiw	r26, 0x0c	; 12
    50a6:	ec 93       	st	X, r30
    50a8:	1c 97       	sbiw	r26, 0x0c	; 12
		Motion.wCK[pgm_read_byte(&(wCK_IDs[i]))].RIgain	= pgm_read_byte(gpIg_Table+i);
    50aa:	fb 01       	movw	r30, r22
    50ac:	e2 0f       	add	r30, r18
    50ae:	f3 1f       	adc	r31, r19
    50b0:	e4 91       	lpm	r30, Z+
    50b2:	1d 96       	adiw	r26, 0x0d	; 13
    50b4:	ec 93       	st	X, r30
    50b6:	1d 97       	sbiw	r26, 0x0d	; 13
		Motion.wCK[pgm_read_byte(&(wCK_IDs[i]))].PortEn	= 1;
    50b8:	1e 96       	adiw	r26, 0x0e	; 14
    50ba:	dc 92       	st	X, r13
    50bc:	1e 97       	sbiw	r26, 0x0e	; 14
		Motion.wCK[pgm_read_byte(&(wCK_IDs[i]))].InitPos = pgm_read_byte(gpZero_Table+i);
    50be:	fa 01       	movw	r30, r20
    50c0:	e2 0f       	add	r30, r18
    50c2:	f3 1f       	adc	r31, r19
    50c4:	e4 91       	lpm	r30, Z+
    50c6:	1f 96       	adiw	r26, 0x0f	; 15
    50c8:	ec 93       	st	X, r30
{
	WORD i;

	ClearMotionData();
	
	for(i=0;i<Motion.NumOfwCK;i++){		// fill the wCK motion data
    50ca:	2f 5f       	subi	r18, 0xFF	; 255
    50cc:	3f 4f       	sbci	r19, 0xFF	; 255
    50ce:	2e 15       	cp	r18, r14
    50d0:	3f 05       	cpc	r19, r15
    50d2:	08 f4       	brcc	.+2      	; 0x50d6 <M_PlayFlash+0xca>
    50d4:	ca cf       	rjmp	.-108    	; 0x506a <M_PlayFlash+0x5e>
void M_PlayFlash(void)
{
	WORD i;

	GetMotionFromFlash();		// Get the motion data from flash
	SendTGain();				// set the runtime P,D and I from motion structure
    50d6:	0e 94 45 27 	call	0x4e8a	; 0x4e8a <SendTGain>
    50da:	c0 e0       	ldi	r28, 0x00	; 0
    50dc:	d0 e0       	ldi	r29, 0x00	; 0
		Scene.wCK[i].DPos		= 0;
		Scene.wCK[i].Torq		= 0;
		Scene.wCK[i].ExPortD	= 0;
	}
	for(i=0;i<Motion.NumOfwCK;i++){			// get the flash data for the wCK
		Scene.wCK[pgm_read_byte(&(wCK_IDs[i]))].Exist		= 1;
    50de:	bb 24       	eor	r11, r11
    50e0:	b3 94       	inc	r11
    50e2:	08 eb       	ldi	r16, 0xB8	; 184
    50e4:	c0 2e       	mov	r12, r16
    50e6:	02 e1       	ldi	r16, 0x12	; 18
    50e8:	d0 2e       	mov	r13, r16
    50ea:	d8 c0       	rjmp	.+432    	; 0x529c <M_PlayFlash+0x290>
	WORD i;

	GetMotionFromFlash();		// Get the motion data from flash
	SendTGain();				// set the runtime P,D and I from motion structure
	for(i=0;i<Motion.NumOfScene;i++){
		gSceneIndex = i;
    50ec:	d0 93 01 01 	sts	0x0101, r29
    50f0:	c0 93 00 01 	sts	0x0100, r28
//------------------------------------------------------------------------------
static void GetSceneFromFlash(void)
{
	WORD i;
	
	Scene.NumOfFrame = pgm_read_word(gpFN_Table+(gSceneIndex * 2));	// get the number of frames in scene
    50f4:	80 91 00 01 	lds	r24, 0x0100
    50f8:	90 91 01 01 	lds	r25, 0x0101
    50fc:	88 0f       	add	r24, r24
    50fe:	99 1f       	adc	r25, r25
    5100:	e0 91 9b 0b 	lds	r30, 0x0B9B
    5104:	f0 91 9c 0b 	lds	r31, 0x0B9C
    5108:	e8 0f       	add	r30, r24
    510a:	f9 1f       	adc	r31, r25
    510c:	85 91       	lpm	r24, Z+
    510e:	94 91       	lpm	r25, Z+
    5110:	90 93 f2 0c 	sts	0x0CF2, r25
    5114:	80 93 f1 0c 	sts	0x0CF1, r24
	gNumOfFrame = Scene.NumOfFrame;
    5118:	90 93 9e 0b 	sts	0x0B9E, r25
    511c:	80 93 9d 0b 	sts	0x0B9D, r24
	Scene.RTime = pgm_read_word(gpRT_Table+(gSceneIndex * 2));		// get the run time of scene[msec]
    5120:	80 91 00 01 	lds	r24, 0x0100
    5124:	90 91 01 01 	lds	r25, 0x0101
    5128:	88 0f       	add	r24, r24
    512a:	99 1f       	adc	r25, r25
    512c:	e0 91 ed 0c 	lds	r30, 0x0CED
    5130:	f0 91 ee 0c 	lds	r31, 0x0CEE
    5134:	e8 0f       	add	r30, r24
    5136:	f9 1f       	adc	r31, r25
    5138:	85 91       	lpm	r24, Z+
    513a:	94 91       	lpm	r25, Z+
    513c:	90 93 f4 0c 	sts	0x0CF4, r25
    5140:	80 93 f3 0c 	sts	0x0CF3, r24
	for(i=0;i<Motion.NumOfwCK;i++){			// clear the data for the wCK in scene
    5144:	40 91 b1 0b 	lds	r20, 0x0BB1
    5148:	50 91 b2 0b 	lds	r21, 0x0BB2
    514c:	e5 ef       	ldi	r30, 0xF5	; 245
    514e:	fc e0       	ldi	r31, 0x0C	; 12
    5150:	ca 01       	movw	r24, r20
    5152:	88 0f       	add	r24, r24
    5154:	99 1f       	adc	r25, r25
    5156:	88 0f       	add	r24, r24
    5158:	99 1f       	adc	r25, r25
    515a:	84 0f       	add	r24, r20
    515c:	95 1f       	adc	r25, r21
    515e:	8e 0f       	add	r24, r30
    5160:	9f 1f       	adc	r25, r31
    5162:	06 c0       	rjmp	.+12     	; 0x5170 <M_PlayFlash+0x164>
		Scene.wCK[i].Exist		= 0;
    5164:	10 82       	st	Z, r1
		Scene.wCK[i].SPos		= 0;
    5166:	11 82       	std	Z+1, r1	; 0x01
		Scene.wCK[i].DPos		= 0;
    5168:	12 82       	std	Z+2, r1	; 0x02
		Scene.wCK[i].Torq		= 0;
    516a:	13 82       	std	Z+3, r1	; 0x03
		Scene.wCK[i].ExPortD	= 0;
    516c:	14 82       	std	Z+4, r1	; 0x04
    516e:	35 96       	adiw	r30, 0x05	; 5
	WORD i;
	
	Scene.NumOfFrame = pgm_read_word(gpFN_Table+(gSceneIndex * 2));	// get the number of frames in scene
	gNumOfFrame = Scene.NumOfFrame;
	Scene.RTime = pgm_read_word(gpRT_Table+(gSceneIndex * 2));		// get the run time of scene[msec]
	for(i=0;i<Motion.NumOfwCK;i++){			// clear the data for the wCK in scene
    5170:	e8 17       	cp	r30, r24
    5172:	f9 07       	cpc	r31, r25
    5174:	b9 f7       	brne	.-18     	; 0x5164 <M_PlayFlash+0x158>
		Scene.wCK[i].Torq		= 0;
		Scene.wCK[i].ExPortD	= 0;
	}
	for(i=0;i<Motion.NumOfwCK;i++){			// get the flash data for the wCK
		Scene.wCK[pgm_read_byte(&(wCK_IDs[i]))].Exist		= 1;
		Scene.wCK[pgm_read_byte(&(wCK_IDs[i]))].SPos		= pgm_read_byte(gpPos_Table+(Motion.NumOfwCK*gSceneIndex+i));
    5176:	60 91 a3 0b 	lds	r22, 0x0BA3
    517a:	70 91 a4 0b 	lds	r23, 0x0BA4
		Scene.wCK[pgm_read_byte(&(wCK_IDs[i]))].DPos		= pgm_read_byte(gpPos_Table+(Motion.NumOfwCK*(gSceneIndex+1)+i));
		Scene.wCK[pgm_read_byte(&(wCK_IDs[i]))].Torq		= pgm_read_byte(gpT_Table+(Motion.NumOfwCK*gSceneIndex+i));
    517e:	e0 90 a5 0b 	lds	r14, 0x0BA5
    5182:	f0 90 a6 0b 	lds	r15, 0x0BA6
		Scene.wCK[pgm_read_byte(&(wCK_IDs[i]))].ExPortD		= pgm_read_byte(gpE_Table+(Motion.NumOfwCK*gSceneIndex+i));
    5186:	00 91 a1 0b 	lds	r16, 0x0BA1
    518a:	10 91 a2 0b 	lds	r17, 0x0BA2
    518e:	20 e0       	ldi	r18, 0x00	; 0
    5190:	30 e0       	ldi	r19, 0x00	; 0
    5192:	60 c0       	rjmp	.+192    	; 0x5254 <M_PlayFlash+0x248>
    5194:	f9 01       	movw	r30, r18
    5196:	e3 5a       	subi	r30, 0xA3	; 163
    5198:	fb 4c       	sbci	r31, 0xCB	; 203
		Scene.wCK[i].DPos		= 0;
		Scene.wCK[i].Torq		= 0;
		Scene.wCK[i].ExPortD	= 0;
	}
	for(i=0;i<Motion.NumOfwCK;i++){			// get the flash data for the wCK
		Scene.wCK[pgm_read_byte(&(wCK_IDs[i]))].Exist		= 1;
    519a:	e4 91       	lpm	r30, Z+
    519c:	8e 2f       	mov	r24, r30
    519e:	90 e0       	ldi	r25, 0x00	; 0
    51a0:	dc 01       	movw	r26, r24
    51a2:	aa 0f       	add	r26, r26
    51a4:	bb 1f       	adc	r27, r27
    51a6:	aa 0f       	add	r26, r26
    51a8:	bb 1f       	adc	r27, r27
    51aa:	a8 0f       	add	r26, r24
    51ac:	b9 1f       	adc	r27, r25
    51ae:	a1 51       	subi	r26, 0x11	; 17
    51b0:	b3 4f       	sbci	r27, 0xF3	; 243
    51b2:	16 96       	adiw	r26, 0x06	; 6
    51b4:	bc 92       	st	X, r11
    51b6:	16 97       	sbiw	r26, 0x06	; 6
		Scene.wCK[pgm_read_byte(&(wCK_IDs[i]))].SPos		= pgm_read_byte(gpPos_Table+(Motion.NumOfwCK*gSceneIndex+i));
    51b8:	80 91 00 01 	lds	r24, 0x0100
    51bc:	90 91 01 01 	lds	r25, 0x0101
    51c0:	48 9f       	mul	r20, r24
    51c2:	f0 01       	movw	r30, r0
    51c4:	49 9f       	mul	r20, r25
    51c6:	f0 0d       	add	r31, r0
    51c8:	58 9f       	mul	r21, r24
    51ca:	f0 0d       	add	r31, r0
    51cc:	11 24       	eor	r1, r1
    51ce:	e2 0f       	add	r30, r18
    51d0:	f3 1f       	adc	r31, r19
    51d2:	e6 0f       	add	r30, r22
    51d4:	f7 1f       	adc	r31, r23
    51d6:	e4 91       	lpm	r30, Z+
    51d8:	17 96       	adiw	r26, 0x07	; 7
    51da:	ec 93       	st	X, r30
    51dc:	17 97       	sbiw	r26, 0x07	; 7
		Scene.wCK[pgm_read_byte(&(wCK_IDs[i]))].DPos		= pgm_read_byte(gpPos_Table+(Motion.NumOfwCK*(gSceneIndex+1)+i));
    51de:	80 91 00 01 	lds	r24, 0x0100
    51e2:	90 91 01 01 	lds	r25, 0x0101
    51e6:	01 96       	adiw	r24, 0x01	; 1
    51e8:	84 9f       	mul	r24, r20
    51ea:	f0 01       	movw	r30, r0
    51ec:	85 9f       	mul	r24, r21
    51ee:	f0 0d       	add	r31, r0
    51f0:	94 9f       	mul	r25, r20
    51f2:	f0 0d       	add	r31, r0
    51f4:	11 24       	eor	r1, r1
    51f6:	e2 0f       	add	r30, r18
    51f8:	f3 1f       	adc	r31, r19
    51fa:	e6 0f       	add	r30, r22
    51fc:	f7 1f       	adc	r31, r23
    51fe:	e4 91       	lpm	r30, Z+
    5200:	18 96       	adiw	r26, 0x08	; 8
    5202:	ec 93       	st	X, r30
    5204:	18 97       	sbiw	r26, 0x08	; 8
		Scene.wCK[pgm_read_byte(&(wCK_IDs[i]))].Torq		= pgm_read_byte(gpT_Table+(Motion.NumOfwCK*gSceneIndex+i));
    5206:	80 91 00 01 	lds	r24, 0x0100
    520a:	90 91 01 01 	lds	r25, 0x0101
    520e:	48 9f       	mul	r20, r24
    5210:	f0 01       	movw	r30, r0
    5212:	49 9f       	mul	r20, r25
    5214:	f0 0d       	add	r31, r0
    5216:	58 9f       	mul	r21, r24
    5218:	f0 0d       	add	r31, r0
    521a:	11 24       	eor	r1, r1
    521c:	e2 0f       	add	r30, r18
    521e:	f3 1f       	adc	r31, r19
    5220:	ee 0d       	add	r30, r14
    5222:	ff 1d       	adc	r31, r15
    5224:	e4 91       	lpm	r30, Z+
    5226:	19 96       	adiw	r26, 0x09	; 9
    5228:	ec 93       	st	X, r30
    522a:	19 97       	sbiw	r26, 0x09	; 9
		Scene.wCK[pgm_read_byte(&(wCK_IDs[i]))].ExPortD		= pgm_read_byte(gpE_Table+(Motion.NumOfwCK*gSceneIndex+i));
    522c:	80 91 00 01 	lds	r24, 0x0100
    5230:	90 91 01 01 	lds	r25, 0x0101
    5234:	48 9f       	mul	r20, r24
    5236:	f0 01       	movw	r30, r0
    5238:	49 9f       	mul	r20, r25
    523a:	f0 0d       	add	r31, r0
    523c:	58 9f       	mul	r21, r24
    523e:	f0 0d       	add	r31, r0
    5240:	11 24       	eor	r1, r1
    5242:	e2 0f       	add	r30, r18
    5244:	f3 1f       	adc	r31, r19
    5246:	e0 0f       	add	r30, r16
    5248:	f1 1f       	adc	r31, r17
    524a:	e4 91       	lpm	r30, Z+
    524c:	1a 96       	adiw	r26, 0x0a	; 10
    524e:	ec 93       	st	X, r30
		Scene.wCK[i].SPos		= 0;
		Scene.wCK[i].DPos		= 0;
		Scene.wCK[i].Torq		= 0;
		Scene.wCK[i].ExPortD	= 0;
	}
	for(i=0;i<Motion.NumOfwCK;i++){			// get the flash data for the wCK
    5250:	2f 5f       	subi	r18, 0xFF	; 255
    5252:	3f 4f       	sbci	r19, 0xFF	; 255
    5254:	24 17       	cp	r18, r20
    5256:	35 07       	cpc	r19, r21
    5258:	08 f4       	brcc	.+2      	; 0x525c <M_PlayFlash+0x250>
    525a:	9c cf       	rjmp	.-200    	; 0x5194 <M_PlayFlash+0x188>
		Scene.wCK[pgm_read_byte(&(wCK_IDs[i]))].SPos		= pgm_read_byte(gpPos_Table+(Motion.NumOfwCK*gSceneIndex+i));
		Scene.wCK[pgm_read_byte(&(wCK_IDs[i]))].DPos		= pgm_read_byte(gpPos_Table+(Motion.NumOfwCK*(gSceneIndex+1)+i));
		Scene.wCK[pgm_read_byte(&(wCK_IDs[i]))].Torq		= pgm_read_byte(gpT_Table+(Motion.NumOfwCK*gSceneIndex+i));
		Scene.wCK[pgm_read_byte(&(wCK_IDs[i]))].ExPortD		= pgm_read_byte(gpE_Table+(Motion.NumOfwCK*gSceneIndex+i));
	}
	UCSR0B &= 0x7F;   		// UART0 RxInterrupt disable
    525c:	57 98       	cbi	0x0a, 7	; 10
	UCSR0B |= 0x40;   		// UART0 TxInterrupt enable
    525e:	56 9a       	sbi	0x0a, 6	; 10
    5260:	c6 01       	movw	r24, r12
    5262:	01 97       	sbiw	r24, 0x01	; 1
    5264:	f1 f7       	brne	.-4      	; 0x5262 <M_PlayFlash+0x256>
	GetMotionFromFlash();		// Get the motion data from flash
	SendTGain();				// set the runtime P,D and I from motion structure
	for(i=0;i<Motion.NumOfScene;i++){
		gSceneIndex = i;
		GetSceneFromFlash();	// Get the scene data from flash
		SendExPortD();			// Set external port data
    5266:	0e 94 25 27 	call	0x4e4a	; 0x4e4a <SendExPortD>
		CalcFrameInterval();	// Set the interrupt for the frames
    526a:	0e 94 12 24 	call	0x4824	; 0x4824 <CalcFrameInterval>
		CalcUnitMove();			// Calculate the interpolation steps
    526e:	0e 94 67 24 	call	0x48ce	; 0x48ce <CalcUnitMove>
		MakeFrame();			// build a frame to send
    5272:	0e 94 f9 24 	call	0x49f2	; 0x49f2 <MakeFrame>
// Start sending the frame (or whatever else happens to be in our transmit
// buffer, gTx0Buf).
//------------------------------------------------------------------------------
static void SendFrame(void)
{
	if(gTx0Cnt==0)	return;	// return if no frame to send
    5276:	80 91 7e 0b 	lds	r24, 0x0B7E
    527a:	88 23       	and	r24, r24
    527c:	71 f0       	breq	.+28     	; 0x529a <M_PlayFlash+0x28e>
	gTx0BufIdx++;
    527e:	80 91 b4 0a 	lds	r24, 0x0AB4
    5282:	8f 5f       	subi	r24, 0xFF	; 255
    5284:	80 93 b4 0a 	sts	0x0AB4, r24
	sciTx0Data(gTx0Buf[gTx0BufIdx-1]);		// send first byte to start frame send
    5288:	e0 91 b4 0a 	lds	r30, 0x0AB4
    528c:	f0 e0       	ldi	r31, 0x00	; 0
    528e:	ef 53       	subi	r30, 0x3F	; 63
    5290:	f5 4f       	sbci	r31, 0xF5	; 245
    5292:	e0 81       	ld	r30, Z
//------------------------------------------------------------------------------
// Transmit char to UART when UART is ready
//------------------------------------------------------------------------------
void sciTx0Data(BYTE td)
{
	while(!(UCSR0A&(1<<UDRE))); 	// wait until data register is empty
    5294:	5d 9b       	sbis	0x0b, 5	; 11
    5296:	fe cf       	rjmp	.-4      	; 0x5294 <M_PlayFlash+0x288>
	UDR0=td;
    5298:	ec b9       	out	0x0c, r30	; 12
{
	WORD i;

	GetMotionFromFlash();		// Get the motion data from flash
	SendTGain();				// set the runtime P,D and I from motion structure
	for(i=0;i<Motion.NumOfScene;i++){
    529a:	21 96       	adiw	r28, 0x01	; 1
    529c:	80 91 af 0b 	lds	r24, 0x0BAF
    52a0:	90 91 b0 0b 	lds	r25, 0x0BB0
    52a4:	c8 17       	cp	r28, r24
    52a6:	d9 07       	cpc	r29, r25
    52a8:	08 f4       	brcc	.+2      	; 0x52ac <M_PlayFlash+0x2a0>
    52aa:	20 cf       	rjmp	.-448    	; 0x50ec <M_PlayFlash+0xe0>
		MakeFrame();			// build a frame to send
		SendFrame();			// start sending frame
		//while(F_PLAYING)
		//	process_frames();		// wait till scene interpolation complete
	}
}
    52ac:	df 91       	pop	r29
    52ae:	cf 91       	pop	r28
    52b0:	1f 91       	pop	r17
    52b2:	0f 91       	pop	r16
    52b4:	ff 90       	pop	r15
    52b6:	ef 90       	pop	r14
    52b8:	df 90       	pop	r13
    52ba:	cf 90       	pop	r12
    52bc:	bf 90       	pop	r11
    52be:	08 95       	ret

000052c0 <SampleMotion>:
	};



void SampleMotion(int sm)	// Perform SampleMotion(s)
{
    52c0:	dc 98       	cbi	0x1b, 4	; 27
	PF2_LED_ON;
	gpT_Table			= mlist[sm].TT;
    52c2:	42 e0       	ldi	r20, 0x02	; 2
    52c4:	51 e0       	ldi	r21, 0x01	; 1
    52c6:	24 e1       	ldi	r18, 0x14	; 20
    52c8:	30 e0       	ldi	r19, 0x00	; 0
    52ca:	82 9f       	mul	r24, r18
    52cc:	d0 01       	movw	r26, r0
    52ce:	83 9f       	mul	r24, r19
    52d0:	b0 0d       	add	r27, r0
    52d2:	92 9f       	mul	r25, r18
    52d4:	b0 0d       	add	r27, r0
    52d6:	11 24       	eor	r1, r1
    52d8:	a4 0f       	add	r26, r20
    52da:	b5 1f       	adc	r27, r21
    52dc:	2d 91       	ld	r18, X+
    52de:	3c 91       	ld	r19, X
    52e0:	11 97       	sbiw	r26, 0x01	; 1
    52e2:	30 93 a6 0b 	sts	0x0BA6, r19
    52e6:	20 93 a5 0b 	sts	0x0BA5, r18
	gpE_Table			= mlist[sm].ET;
    52ea:	fc 01       	movw	r30, r24
    52ec:	ee 0f       	add	r30, r30
    52ee:	ff 1f       	adc	r31, r31
    52f0:	9c 01       	movw	r18, r24
    52f2:	63 e0       	ldi	r22, 0x03	; 3
    52f4:	22 0f       	add	r18, r18
    52f6:	33 1f       	adc	r19, r19
    52f8:	6a 95       	dec	r22
    52fa:	e1 f7       	brne	.-8      	; 0x52f4 <SampleMotion+0x34>
    52fc:	e2 0f       	add	r30, r18
    52fe:	f3 1f       	adc	r31, r19
    5300:	31 96       	adiw	r30, 0x01	; 1
    5302:	ee 0f       	add	r30, r30
    5304:	ff 1f       	adc	r31, r31
    5306:	e4 0f       	add	r30, r20
    5308:	f5 1f       	adc	r31, r21
    530a:	20 81       	ld	r18, Z
    530c:	31 81       	ldd	r19, Z+1	; 0x01
    530e:	30 93 a2 0b 	sts	0x0BA2, r19
    5312:	20 93 a1 0b 	sts	0x0BA1, r18
	gpPg_Table 			= mlist[sm].PT;
    5316:	9c 01       	movw	r18, r24
    5318:	22 0f       	add	r18, r18
    531a:	33 1f       	adc	r19, r19
    531c:	22 0f       	add	r18, r18
    531e:	33 1f       	adc	r19, r19
    5320:	28 0f       	add	r18, r24
    5322:	39 1f       	adc	r19, r25
    5324:	2f 5f       	subi	r18, 0xFF	; 255
    5326:	3f 4f       	sbci	r19, 0xFF	; 255
    5328:	22 0f       	add	r18, r18
    532a:	33 1f       	adc	r19, r19
    532c:	22 0f       	add	r18, r18
    532e:	33 1f       	adc	r19, r19
    5330:	42 0f       	add	r20, r18
    5332:	53 1f       	adc	r21, r19
    5334:	fa 01       	movw	r30, r20
    5336:	80 81       	ld	r24, Z
    5338:	91 81       	ldd	r25, Z+1	; 0x01
    533a:	90 93 ec 0c 	sts	0x0CEC, r25
    533e:	80 93 eb 0c 	sts	0x0CEB, r24
	gpDg_Table 			= mlist[sm].DT;
    5342:	16 96       	adiw	r26, 0x06	; 6
    5344:	8d 91       	ld	r24, X+
    5346:	9c 91       	ld	r25, X
    5348:	17 97       	sbiw	r26, 0x07	; 7
    534a:	90 93 91 0d 	sts	0x0D91, r25
    534e:	80 93 90 0d 	sts	0x0D90, r24
	gpIg_Table 			= mlist[sm].IT;
    5352:	18 96       	adiw	r26, 0x08	; 8
    5354:	8d 91       	ld	r24, X+
    5356:	9c 91       	ld	r25, X
    5358:	19 97       	sbiw	r26, 0x09	; 9
    535a:	90 93 a0 0b 	sts	0x0BA0, r25
    535e:	80 93 9f 0b 	sts	0x0B9F, r24
	gpFN_Table			= mlist[sm].FT;
    5362:	1a 96       	adiw	r26, 0x0a	; 10
    5364:	8d 91       	ld	r24, X+
    5366:	9c 91       	ld	r25, X
    5368:	1b 97       	sbiw	r26, 0x0b	; 11
    536a:	90 93 9c 0b 	sts	0x0B9C, r25
    536e:	80 93 9b 0b 	sts	0x0B9B, r24
	gpRT_Table			= mlist[sm].RT;
    5372:	1c 96       	adiw	r26, 0x0c	; 12
    5374:	8d 91       	ld	r24, X+
    5376:	9c 91       	ld	r25, X
    5378:	1d 97       	sbiw	r26, 0x0d	; 13
    537a:	90 93 ee 0c 	sts	0x0CEE, r25
    537e:	80 93 ed 0c 	sts	0x0CED, r24
	gpPos_Table			= mlist[sm].PoT;
    5382:	1e 96       	adiw	r26, 0x0e	; 14
    5384:	8d 91       	ld	r24, X+
    5386:	9c 91       	ld	r25, X
    5388:	1f 97       	sbiw	r26, 0x0f	; 15
    538a:	90 93 a4 0b 	sts	0x0BA4, r25
    538e:	80 93 a3 0b 	sts	0x0BA3, r24
	gpZero_Table		= (PGM_P) MotionZeroPos;
    5392:	85 e5       	ldi	r24, 0x55	; 85
    5394:	91 e0       	ldi	r25, 0x01	; 1
    5396:	90 93 a8 0b 	sts	0x0BA8, r25
    539a:	80 93 a7 0b 	sts	0x0BA7, r24
	Motion.NumOfScene 	= mlist[sm].NoS;
    539e:	50 96       	adiw	r26, 0x10	; 16
    53a0:	8d 91       	ld	r24, X+
    53a2:	9c 91       	ld	r25, X
    53a4:	51 97       	sbiw	r26, 0x11	; 17
    53a6:	90 93 b0 0b 	sts	0x0BB0, r25
    53aa:	80 93 af 0b 	sts	0x0BAF, r24
	Motion.NumOfwCK 	= mlist[sm].Now;
    53ae:	52 96       	adiw	r26, 0x12	; 18
    53b0:	8d 91       	ld	r24, X+
    53b2:	9c 91       	ld	r25, X
    53b4:	53 97       	sbiw	r26, 0x13	; 19
    53b6:	90 93 b2 0b 	sts	0x0BB2, r25
    53ba:	80 93 b1 0b 	sts	0x0BB1, r24
	
	M_PlayFlash();
    53be:	0e 94 06 28 	call	0x500c	; 0x500c <M_PlayFlash>
}
    53c2:	08 95       	ret

000053c4 <rprintfInit>:

// *** rprintf initialization ***
// you must call this function once and supply the character output
// routine before using other functions in this library
void rprintfInit(void (*putchar_func)(unsigned char c))
{
    53c4:	90 93 7f 0a 	sts	0x0A7F, r25
    53c8:	80 93 7e 0a 	sts	0x0A7E, r24
	rputchar = putchar_func;
}
    53cc:	08 95       	ret

000053ce <rprintfChar>:

// *** rprintfChar ***
// send a character/byte to the current output device
void rprintfChar(unsigned char c)
{
    53ce:	1f 93       	push	r17
    53d0:	18 2f       	mov	r17, r24
	// do LF -> CR/LF translation
	if(c == '\n')
    53d2:	8a 30       	cpi	r24, 0x0A	; 10
    53d4:	31 f4       	brne	.+12     	; 0x53e2 <rprintfChar+0x14>
		rputchar('\r');
    53d6:	e0 91 7e 0a 	lds	r30, 0x0A7E
    53da:	f0 91 7f 0a 	lds	r31, 0x0A7F
    53de:	8d e0       	ldi	r24, 0x0D	; 13
    53e0:	09 95       	icall
	// send character
	rputchar(c);
    53e2:	e0 91 7e 0a 	lds	r30, 0x0A7E
    53e6:	f0 91 7f 0a 	lds	r31, 0x0A7F
    53ea:	81 2f       	mov	r24, r17
    53ec:	09 95       	icall
}
    53ee:	1f 91       	pop	r17
    53f0:	08 95       	ret

000053f2 <rprintfStr>:

// *** rprintfStr ***
// prints a null-terminated string stored in RAM
void rprintfStr(char str[])
{
    53f2:	cf 93       	push	r28
    53f4:	df 93       	push	r29
    53f6:	ec 01       	movw	r28, r24
	// send a string stored in RAM
	// check to make sure we have a good pointer
	if (!str) return;
    53f8:	00 97       	sbiw	r24, 0x00	; 0
    53fa:	21 f4       	brne	.+8      	; 0x5404 <rprintfStr+0x12>
    53fc:	06 c0       	rjmp	.+12     	; 0x540a <rprintfStr+0x18>

	// print the string until a null-terminator
	while (*str)
		rprintfChar(*str++);
    53fe:	21 96       	adiw	r28, 0x01	; 1
    5400:	0e 94 e7 29 	call	0x53ce	; 0x53ce <rprintfChar>
	// send a string stored in RAM
	// check to make sure we have a good pointer
	if (!str) return;

	// print the string until a null-terminator
	while (*str)
    5404:	88 81       	ld	r24, Y
    5406:	88 23       	and	r24, r24
    5408:	d1 f7       	brne	.-12     	; 0x53fe <rprintfStr+0xc>
		rprintfChar(*str++);
}
    540a:	df 91       	pop	r29
    540c:	cf 91       	pop	r28
    540e:	08 95       	ret

00005410 <rprintfStrLen>:
// *** rprintfStrLen ***
// prints a section of a string stored in RAM
// begins printing at position indicated by <start>
// prints number of characters indicated by <len>
void rprintfStrLen(char str[], unsigned int start, unsigned int len)
{
    5410:	ef 92       	push	r14
    5412:	ff 92       	push	r15
    5414:	0f 93       	push	r16
    5416:	1f 93       	push	r17
    5418:	cf 93       	push	r28
    541a:	df 93       	push	r29
    541c:	8c 01       	movw	r16, r24
    541e:	7a 01       	movw	r14, r20
	register int i=0;

	// check to make sure we have a good pointer
	if (!str) return;
    5420:	00 97       	sbiw	r24, 0x00	; 0
    5422:	e9 f0       	breq	.+58     	; 0x545e <rprintfStrLen+0x4e>
    5424:	20 e0       	ldi	r18, 0x00	; 0
    5426:	30 e0       	ldi	r19, 0x00	; 0
	// spin through characters up to requested start
	// keep going as long as there's no null
	while((i++<start) && (*str++));
    5428:	26 17       	cp	r18, r22
    542a:	37 07       	cpc	r19, r23
    542c:	38 f4       	brcc	.+14     	; 0x543c <rprintfStrLen+0x2c>
    542e:	f8 01       	movw	r30, r16
    5430:	81 91       	ld	r24, Z+
    5432:	8f 01       	movw	r16, r30
    5434:	2f 5f       	subi	r18, 0xFF	; 255
    5436:	3f 4f       	sbci	r19, 0xFF	; 255
    5438:	88 23       	and	r24, r24
    543a:	b1 f7       	brne	.-20     	; 0x5428 <rprintfStrLen+0x18>
    543c:	c0 e0       	ldi	r28, 0x00	; 0
    543e:	d0 e0       	ldi	r29, 0x00	; 0
    5440:	0b c0       	rjmp	.+22     	; 0x5458 <rprintfStrLen+0x48>
	// then print exactly len characters
	for(i=0; i<len; i++)
	{
		// print data out of the string as long as we haven't reached a null yet
		// at the null, start printing spaces
		if(*str)
    5442:	f8 01       	movw	r30, r16
    5444:	80 81       	ld	r24, Z
    5446:	88 23       	and	r24, r24
    5448:	19 f0       	breq	.+6      	; 0x5450 <rprintfStrLen+0x40>
			rprintfChar(*str++);
    544a:	0f 5f       	subi	r16, 0xFF	; 255
    544c:	1f 4f       	sbci	r17, 0xFF	; 255
    544e:	01 c0       	rjmp	.+2      	; 0x5452 <rprintfStrLen+0x42>
		else
			rprintfChar(' ');
    5450:	80 e2       	ldi	r24, 0x20	; 32
    5452:	0e 94 e7 29 	call	0x53ce	; 0x53ce <rprintfChar>
//		// keep steping through string as long as there's no null
//		if(*str) str++;
//	}

	// then print exactly len characters
	for(i=0; i<len; i++)
    5456:	21 96       	adiw	r28, 0x01	; 1
    5458:	ce 15       	cp	r28, r14
    545a:	df 05       	cpc	r29, r15
    545c:	90 f3       	brcs	.-28     	; 0x5442 <rprintfStrLen+0x32>
			rprintfChar(*str++);
		else
			rprintfChar(' ');
	}

}
    545e:	df 91       	pop	r29
    5460:	cf 91       	pop	r28
    5462:	1f 91       	pop	r17
    5464:	0f 91       	pop	r16
    5466:	ff 90       	pop	r15
    5468:	ef 90       	pop	r14
    546a:	08 95       	ret

0000546c <rprintfProgStr>:

// *** rprintfProgStr ***
// prints a null-terminated string stored in program ROM
void rprintfProgStr(const prog_char str[])
{
    546c:	cf 93       	push	r28
    546e:	df 93       	push	r29
    5470:	ec 01       	movw	r28, r24
	// print a string stored in program memory
	register char c;

	// check to make sure we have a good pointer
	if (!str) return;
    5472:	00 97       	sbiw	r24, 0x00	; 0
    5474:	19 f4       	brne	.+6      	; 0x547c <rprintfProgStr+0x10>
    5476:	07 c0       	rjmp	.+14     	; 0x5486 <rprintfProgStr+0x1a>
	
	// print the string until the null-terminator
	while((c = pgm_read_byte(str++)))
		rprintfChar(c);
    5478:	0e 94 e7 29 	call	0x53ce	; 0x53ce <rprintfChar>
    547c:	fe 01       	movw	r30, r28

	// check to make sure we have a good pointer
	if (!str) return;
	
	// print the string until the null-terminator
	while((c = pgm_read_byte(str++)))
    547e:	21 96       	adiw	r28, 0x01	; 1
    5480:	84 91       	lpm	r24, Z+
    5482:	88 23       	and	r24, r24
    5484:	c9 f7       	brne	.-14     	; 0x5478 <rprintfProgStr+0xc>
		rprintfChar(c);
}
    5486:	df 91       	pop	r29
    5488:	cf 91       	pop	r28
    548a:	08 95       	ret

0000548c <rprintfCRLF>:

// *** rprintfCRLF ***
// prints carriage return and line feed
void rprintfCRLF(void)
{
    548c:	8a e0       	ldi	r24, 0x0A	; 10
    548e:	0e 94 e7 29 	call	0x53ce	; 0x53ce <rprintfChar>
	// print CR/LF
	//rprintfChar('\r');
	// LF -> CR/LF translation built-in to rprintfChar()
	rprintfChar('\n');
}
    5492:	08 95       	ret

00005494 <rprintfu04>:

// *** rprintfu04 ***
// prints an unsigned 4-bit number in hex (1 digit)
void rprintfu04(unsigned char data)
{
    5494:	e8 2f       	mov	r30, r24
    5496:	f0 e0       	ldi	r31, 0x00	; 0
    5498:	ef 70       	andi	r30, 0x0F	; 15
    549a:	f0 70       	andi	r31, 0x00	; 0
    549c:	e8 58       	subi	r30, 0x88	; 136
    549e:	fb 4c       	sbci	r31, 0xCB	; 203
    54a0:	e4 91       	lpm	r30, Z+
    54a2:	8e 2f       	mov	r24, r30
    54a4:	0e 94 e7 29 	call	0x53ce	; 0x53ce <rprintfChar>
//	if (Character>9)
//		Character+='A'-10;
//	else
//		Character+='0';
	rprintfChar(hexchar(data));
}
    54a8:	08 95       	ret

000054aa <rprintfu08>:

// *** rprintfu08 ***
// prints an unsigned 8-bit number in hex (2 digits)
void rprintfu08(unsigned char data)
{
    54aa:	1f 93       	push	r17
    54ac:	18 2f       	mov	r17, r24
	// print 8-bit hex value
	rprintfu04(data>>4);
    54ae:	82 95       	swap	r24
    54b0:	8f 70       	andi	r24, 0x0F	; 15
    54b2:	0e 94 4a 2a 	call	0x5494	; 0x5494 <rprintfu04>
	rprintfu04(data);
    54b6:	81 2f       	mov	r24, r17
    54b8:	0e 94 4a 2a 	call	0x5494	; 0x5494 <rprintfu04>
}
    54bc:	1f 91       	pop	r17
    54be:	08 95       	ret

000054c0 <rprintfu16>:

// *** rprintfu16 ***
// prints an unsigned 16-bit number in hex (4 digits)
void rprintfu16(unsigned short data)
{
    54c0:	1f 93       	push	r17
    54c2:	18 2f       	mov	r17, r24
	// print 16-bit hex value
	rprintfu08(data>>8);
    54c4:	89 2f       	mov	r24, r25
    54c6:	0e 94 55 2a 	call	0x54aa	; 0x54aa <rprintfu08>
	rprintfu08(data);
    54ca:	81 2f       	mov	r24, r17
    54cc:	0e 94 55 2a 	call	0x54aa	; 0x54aa <rprintfu08>
}
    54d0:	1f 91       	pop	r17
    54d2:	08 95       	ret

000054d4 <rprintfu32>:

// *** rprintfu32 ***
// prints an unsigned 32-bit number in hex (8 digits)
void rprintfu32(unsigned long data)
{
    54d4:	ef 92       	push	r14
    54d6:	ff 92       	push	r15
    54d8:	0f 93       	push	r16
    54da:	1f 93       	push	r17
    54dc:	7b 01       	movw	r14, r22
    54de:	8c 01       	movw	r16, r24
	// print 32-bit hex value
	rprintfu16(data>>16);
    54e0:	c8 01       	movw	r24, r16
    54e2:	aa 27       	eor	r26, r26
    54e4:	bb 27       	eor	r27, r27
    54e6:	0e 94 60 2a 	call	0x54c0	; 0x54c0 <rprintfu16>
	rprintfu16(data);
    54ea:	c7 01       	movw	r24, r14
    54ec:	0e 94 60 2a 	call	0x54c0	; 0x54c0 <rprintfu16>
}
    54f0:	1f 91       	pop	r17
    54f2:	0f 91       	pop	r16
    54f4:	ff 90       	pop	r15
    54f6:	ef 90       	pop	r14
    54f8:	08 95       	ret

000054fa <rprintfNum>:
//	Examples:
//	uartPrintfNum(10, 6,  TRUE, ' ',   1234);  -->  " +1234"
//	uartPrintfNum(10, 6, FALSE, '0',   1234);  -->  "001234"
//	uartPrintfNum(16, 6, FALSE, '.', 0x5AA5);  -->  "..5AA5"
void rprintfNum(char base, char numDigits, char isSigned, char padchar, long n)
{
    54fa:	2f 92       	push	r2
    54fc:	3f 92       	push	r3
    54fe:	4f 92       	push	r4
    5500:	5f 92       	push	r5
    5502:	6f 92       	push	r6
    5504:	7f 92       	push	r7
    5506:	8f 92       	push	r8
    5508:	9f 92       	push	r9
    550a:	af 92       	push	r10
    550c:	bf 92       	push	r11
    550e:	cf 92       	push	r12
    5510:	df 92       	push	r13
    5512:	ef 92       	push	r14
    5514:	ff 92       	push	r15
    5516:	0f 93       	push	r16
    5518:	1f 93       	push	r17
    551a:	df 93       	push	r29
    551c:	cf 93       	push	r28
    551e:	cd b7       	in	r28, 0x3d	; 61
    5520:	de b7       	in	r29, 0x3e	; 62
    5522:	a3 97       	sbiw	r28, 0x23	; 35
    5524:	0f b6       	in	r0, 0x3f	; 63
    5526:	f8 94       	cli
    5528:	de bf       	out	0x3e, r29	; 62
    552a:	0f be       	out	0x3f, r0	; 63
    552c:	cd bf       	out	0x3d, r28	; 61
    552e:	6a a3       	std	Y+34, r22	; 0x22
    5530:	24 2e       	mov	r2, r20
    5532:	2b a3       	std	Y+35, r18	; 0x23
    5534:	37 01       	movw	r6, r14
    5536:	48 01       	movw	r8, r16
	char *p, buf[32];
	unsigned long x;
	unsigned char count;

	// prepare negative number
	if( isSigned && (n < 0) )
    5538:	44 23       	and	r20, r20
    553a:	51 f0       	breq	.+20     	; 0x5550 <rprintfNum+0x56>
    553c:	17 ff       	sbrs	r17, 7
    553e:	08 c0       	rjmp	.+16     	; 0x5550 <rprintfNum+0x56>
	{
		x = -n;
    5540:	ee 24       	eor	r14, r14
    5542:	ff 24       	eor	r15, r15
    5544:	87 01       	movw	r16, r14
    5546:	e6 18       	sub	r14, r6
    5548:	f7 08       	sbc	r15, r7
    554a:	08 09       	sbc	r16, r8
    554c:	19 09       	sbc	r17, r9
    554e:	02 c0       	rjmp	.+4      	; 0x5554 <rprintfNum+0x5a>
	}
	else
	{
	 	x = n;
    5550:	84 01       	movw	r16, r8
    5552:	73 01       	movw	r14, r6
	}

	// setup little string buffer
	count = (numDigits-1)-(isSigned?1:0);
    5554:	2a a1       	ldd	r18, Y+34	; 0x22
    5556:	21 50       	subi	r18, 0x01	; 1
    5558:	90 e0       	ldi	r25, 0x00	; 0
    555a:	21 10       	cpse	r2, r1
    555c:	91 e0       	ldi	r25, 0x01	; 1
    555e:	29 1b       	sub	r18, r25
    5560:	29 a3       	std	Y+33, r18	; 0x21
  	p = buf + sizeof (buf);
  	*--p = '\0';
    5562:	18 a2       	std	Y+32, r1	; 0x20
	
	// force calculation of first digit
	// (to prevent zero from not printing at all!!!)
	*--p = hexchar(x%base); x /= base;
    5564:	a8 2e       	mov	r10, r24
    5566:	bb 24       	eor	r11, r11
    5568:	cc 24       	eor	r12, r12
    556a:	dd 24       	eor	r13, r13
    556c:	c8 01       	movw	r24, r16
    556e:	b7 01       	movw	r22, r14
    5570:	a6 01       	movw	r20, r12
    5572:	95 01       	movw	r18, r10
    5574:	0e 94 44 6e 	call	0xdc88	; 0xdc88 <__udivmodsi4>
    5578:	fb 01       	movw	r30, r22
    557a:	ef 70       	andi	r30, 0x0F	; 15
    557c:	f0 70       	andi	r31, 0x00	; 0
    557e:	e8 58       	subi	r30, 0x88	; 136
    5580:	fb 4c       	sbci	r31, 0xCB	; 203
    5582:	64 91       	lpm	r22, Z+
    5584:	6f 8f       	std	Y+31, r22	; 0x1f
    5586:	c8 01       	movw	r24, r16
    5588:	b7 01       	movw	r22, r14
    558a:	a6 01       	movw	r20, r12
    558c:	95 01       	movw	r18, r10
    558e:	0e 94 44 6e 	call	0xdc88	; 0xdc88 <__udivmodsi4>
    5592:	c9 01       	movw	r24, r18
    5594:	da 01       	movw	r26, r20
    5596:	7c 01       	movw	r14, r24
    5598:	8d 01       	movw	r16, r26
    559a:	9e e1       	ldi	r25, 0x1E	; 30
    559c:	49 2e       	mov	r4, r25
    559e:	51 2c       	mov	r5, r1
    55a0:	4c 0e       	add	r4, r28
    55a2:	5d 1e       	adc	r5, r29
    55a4:	39 a0       	ldd	r3, Y+33	; 0x21
    55a6:	25 c0       	rjmp	.+74     	; 0x55f2 <rprintfNum+0xf8>
	// calculate remaining digits
	while(count--)
	{
		if(x != 0)
    55a8:	e1 14       	cp	r14, r1
    55aa:	f1 04       	cpc	r15, r1
    55ac:	01 05       	cpc	r16, r1
    55ae:	11 05       	cpc	r17, r1
    55b0:	c9 f0       	breq	.+50     	; 0x55e4 <rprintfNum+0xea>
		{
			// calculate next digit
			*--p = hexchar(x%base); x /= base;
    55b2:	c8 01       	movw	r24, r16
    55b4:	b7 01       	movw	r22, r14
    55b6:	a6 01       	movw	r20, r12
    55b8:	95 01       	movw	r18, r10
    55ba:	0e 94 44 6e 	call	0xdc88	; 0xdc88 <__udivmodsi4>
    55be:	fb 01       	movw	r30, r22
    55c0:	ef 70       	andi	r30, 0x0F	; 15
    55c2:	f0 70       	andi	r31, 0x00	; 0
    55c4:	e8 58       	subi	r30, 0x88	; 136
    55c6:	fb 4c       	sbci	r31, 0xCB	; 203
    55c8:	64 91       	lpm	r22, Z+
    55ca:	f2 01       	movw	r30, r4
    55cc:	60 83       	st	Z, r22
    55ce:	c8 01       	movw	r24, r16
    55d0:	b7 01       	movw	r22, r14
    55d2:	a6 01       	movw	r20, r12
    55d4:	95 01       	movw	r18, r10
    55d6:	0e 94 44 6e 	call	0xdc88	; 0xdc88 <__udivmodsi4>
    55da:	c9 01       	movw	r24, r18
    55dc:	da 01       	movw	r26, r20
    55de:	7c 01       	movw	r14, r24
    55e0:	8d 01       	movw	r16, r26
    55e2:	03 c0       	rjmp	.+6      	; 0x55ea <rprintfNum+0xf0>
		}
		else
		{
			// no more digits left, pad out to desired length
			*--p = padchar;
    55e4:	2b a1       	ldd	r18, Y+35	; 0x23
    55e6:	f2 01       	movw	r30, r4
    55e8:	20 83       	st	Z, r18
    55ea:	3a 94       	dec	r3
    55ec:	08 94       	sec
    55ee:	41 08       	sbc	r4, r1
    55f0:	51 08       	sbc	r5, r1
	
	// force calculation of first digit
	// (to prevent zero from not printing at all!!!)
	*--p = hexchar(x%base); x /= base;
	// calculate remaining digits
	while(count--)
    55f2:	33 20       	and	r3, r3
    55f4:	c9 f6       	brne	.-78     	; 0x55a8 <rprintfNum+0xae>
    55f6:	ce 01       	movw	r24, r28
    55f8:	4f 96       	adiw	r24, 0x1f	; 31
    55fa:	8c 01       	movw	r16, r24
    55fc:	e9 a1       	ldd	r30, Y+33	; 0x21
    55fe:	0e 1b       	sub	r16, r30
    5600:	11 09       	sbc	r17, r1
			*--p = padchar;
		}
	}

	// apply signed notation if requested
	if( isSigned )
    5602:	22 20       	and	r2, r2
    5604:	f1 f0       	breq	.+60     	; 0x5642 <rprintfNum+0x148>
	{
		if(n < 0)
    5606:	97 fe       	sbrs	r9, 7
    5608:	05 c0       	rjmp	.+10     	; 0x5614 <rprintfNum+0x11a>
		{
   			*--p = '-';
    560a:	8d e2       	ldi	r24, 0x2D	; 45
    560c:	f8 01       	movw	r30, r16
    560e:	82 93       	st	-Z, r24
    5610:	8f 01       	movw	r16, r30
    5612:	17 c0       	rjmp	.+46     	; 0x5642 <rprintfNum+0x148>
    5614:	c8 01       	movw	r24, r16
    5616:	01 97       	sbiw	r24, 0x01	; 1
		}
		else if(n > 0)
    5618:	61 14       	cp	r6, r1
    561a:	71 04       	cpc	r7, r1
    561c:	81 04       	cpc	r8, r1
    561e:	91 04       	cpc	r9, r1
    5620:	19 f0       	breq	.+6      	; 0x5628 <rprintfNum+0x12e>
		{
	   		*--p = '+';
    5622:	8c 01       	movw	r16, r24
    5624:	8b e2       	ldi	r24, 0x2B	; 43
    5626:	02 c0       	rjmp	.+4      	; 0x562c <rprintfNum+0x132>
		}
		else
		{
	   		*--p = ' ';
    5628:	8c 01       	movw	r16, r24
    562a:	80 e2       	ldi	r24, 0x20	; 32
    562c:	f8 01       	movw	r30, r16
    562e:	80 83       	st	Z, r24
    5630:	08 c0       	rjmp	.+16     	; 0x5642 <rprintfNum+0x148>

	// print the string right-justified
	count = numDigits;
	while(count--)
	{
		rprintfChar(*p++);
    5632:	f8 01       	movw	r30, r16
    5634:	81 91       	ld	r24, Z+
    5636:	8f 01       	movw	r16, r30
    5638:	0e 94 e7 29 	call	0x53ce	; 0x53ce <rprintfChar>
    563c:	fa a1       	ldd	r31, Y+34	; 0x22
    563e:	f1 50       	subi	r31, 0x01	; 1
    5640:	fa a3       	std	Y+34, r31	; 0x22
		}
	}

	// print the string right-justified
	count = numDigits;
	while(count--)
    5642:	2a a1       	ldd	r18, Y+34	; 0x22
    5644:	22 23       	and	r18, r18
    5646:	a9 f7       	brne	.-22     	; 0x5632 <rprintfNum+0x138>
	{
		rprintfChar(*p++);
	}
}
    5648:	a3 96       	adiw	r28, 0x23	; 35
    564a:	0f b6       	in	r0, 0x3f	; 63
    564c:	f8 94       	cli
    564e:	de bf       	out	0x3e, r29	; 62
    5650:	0f be       	out	0x3f, r0	; 63
    5652:	cd bf       	out	0x3d, r28	; 61
    5654:	cf 91       	pop	r28
    5656:	df 91       	pop	r29
    5658:	1f 91       	pop	r17
    565a:	0f 91       	pop	r16
    565c:	ff 90       	pop	r15
    565e:	ef 90       	pop	r14
    5660:	df 90       	pop	r13
    5662:	cf 90       	pop	r12
    5664:	bf 90       	pop	r11
    5666:	af 90       	pop	r10
    5668:	9f 90       	pop	r9
    566a:	8f 90       	pop	r8
    566c:	7f 90       	pop	r7
    566e:	6f 90       	pop	r6
    5670:	5f 90       	pop	r5
    5672:	4f 90       	pop	r4
    5674:	3f 90       	pop	r3
    5676:	2f 90       	pop	r2
    5678:	08 95       	ret

0000567a <rprintf1RamRom>:
// Supports:
// %d - decimal
// %x - hex
// %c - character
int rprintf1RamRom(unsigned char stringInRom, const char *format, ...)
{
    567a:	7f 92       	push	r7
    567c:	8f 92       	push	r8
    567e:	9f 92       	push	r9
    5680:	af 92       	push	r10
    5682:	bf 92       	push	r11
    5684:	cf 92       	push	r12
    5686:	df 92       	push	r13
    5688:	ef 92       	push	r14
    568a:	ff 92       	push	r15
    568c:	0f 93       	push	r16
    568e:	1f 93       	push	r17
    5690:	df 93       	push	r29
    5692:	cf 93       	push	r28
    5694:	cd b7       	in	r28, 0x3d	; 61
    5696:	de b7       	in	r29, 0x3e	; 62
    5698:	78 88       	ldd	r7, Y+16	; 0x10
    569a:	c9 88       	ldd	r12, Y+17	; 0x11
    569c:	da 88       	ldd	r13, Y+18	; 0x12
    569e:	53 e1       	ldi	r21, 0x13	; 19
    56a0:	e5 2e       	mov	r14, r21
    56a2:	f1 2c       	mov	r15, r1
    56a4:	ec 0e       	add	r14, r28
    56a6:	fd 1e       	adc	r15, r29
    56a8:	14 c0       	rjmp	.+40     	; 0x56d2 <rprintf1RamRom+0x58>
	va_start(ap, format);
	for (;;)
	{
		while ((format_flag = READMEMBYTE(stringInRom,format++) ) != '%')
		{	// Until '%' or '\0'
			if (!format_flag)
    56aa:	88 23       	and	r24, r24
    56ac:	81 f4       	brne	.+32     	; 0x56ce <rprintf1RamRom+0x54>
				div_val /= base;
			} while (div_val);
		}
	}
	va_end(ap);
}
    56ae:	80 e0       	ldi	r24, 0x00	; 0
    56b0:	90 e0       	ldi	r25, 0x00	; 0
    56b2:	cf 91       	pop	r28
    56b4:	df 91       	pop	r29
    56b6:	1f 91       	pop	r17
    56b8:	0f 91       	pop	r16
    56ba:	ff 90       	pop	r15
    56bc:	ef 90       	pop	r14
    56be:	df 90       	pop	r13
    56c0:	cf 90       	pop	r12
    56c2:	bf 90       	pop	r11
    56c4:	af 90       	pop	r10
    56c6:	9f 90       	pop	r9
    56c8:	8f 90       	pop	r8
    56ca:	7f 90       	pop	r7
    56cc:	08 95       	ret
			if (!format_flag)
			{
				va_end(ap);
				return(0);
			}
			rprintfChar(format_flag);
    56ce:	0e 94 e7 29 	call	0x53ce	; 0x53ce <rprintfChar>
    56d2:	96 01       	movw	r18, r12
    56d4:	2f 5f       	subi	r18, 0xFF	; 255
    56d6:	3f 4f       	sbci	r19, 0xFF	; 255
	va_list ap;

	va_start(ap, format);
	for (;;)
	{
		while ((format_flag = READMEMBYTE(stringInRom,format++) ) != '%')
    56d8:	77 20       	and	r7, r7
    56da:	21 f0       	breq	.+8      	; 0x56e4 <rprintf1RamRom+0x6a>
    56dc:	f6 01       	movw	r30, r12
    56de:	69 01       	movw	r12, r18
    56e0:	84 91       	lpm	r24, Z+
    56e2:	03 c0       	rjmp	.+6      	; 0x56ea <rprintf1RamRom+0x70>
    56e4:	f6 01       	movw	r30, r12
    56e6:	80 81       	ld	r24, Z
    56e8:	69 01       	movw	r12, r18
    56ea:	85 32       	cpi	r24, 0x25	; 37
    56ec:	f1 f6       	brne	.-68     	; 0x56aa <rprintf1RamRom+0x30>
    56ee:	2f 5f       	subi	r18, 0xFF	; 255
    56f0:	3f 4f       	sbci	r19, 0xFF	; 255
				return(0);
			}
			rprintfChar(format_flag);
		}

		switch (format_flag = READMEMBYTE(stringInRom,format++) )
    56f2:	77 20       	and	r7, r7
    56f4:	21 f0       	breq	.+8      	; 0x56fe <rprintf1RamRom+0x84>
    56f6:	f6 01       	movw	r30, r12
    56f8:	69 01       	movw	r12, r18
    56fa:	84 91       	lpm	r24, Z+
    56fc:	03 c0       	rjmp	.+6      	; 0x5704 <rprintf1RamRom+0x8a>
    56fe:	f6 01       	movw	r30, r12
    5700:	80 81       	ld	r24, Z
    5702:	69 01       	movw	r12, r18
    5704:	84 36       	cpi	r24, 0x64	; 100
    5706:	29 f0       	breq	.+10     	; 0x5712 <rprintf1RamRom+0x98>
    5708:	88 37       	cpi	r24, 0x78	; 120
    570a:	81 f0       	breq	.+32     	; 0x572c <rprintf1RamRom+0xb2>
    570c:	83 36       	cpi	r24, 0x63	; 99
    570e:	f9 f6       	brne	.-66     	; 0x56ce <rprintf1RamRom+0x54>
    5710:	06 c0       	rjmp	.+12     	; 0x571e <rprintf1RamRom+0xa4>
    5712:	00 e1       	ldi	r16, 0x10	; 16
    5714:	17 e2       	ldi	r17, 0x27	; 39
    5716:	4a e0       	ldi	r20, 0x0A	; 10
    5718:	a4 2e       	mov	r10, r20
    571a:	b1 2c       	mov	r11, r1
    571c:	0c c0       	rjmp	.+24     	; 0x5736 <rprintf1RamRom+0xbc>
		{
			case 'c': format_flag = va_arg(ap,int);
    571e:	f7 01       	movw	r30, r14
    5720:	80 81       	ld	r24, Z
    5722:	22 e0       	ldi	r18, 0x02	; 2
    5724:	30 e0       	ldi	r19, 0x00	; 0
    5726:	e2 0e       	add	r14, r18
    5728:	f3 1e       	adc	r15, r19
    572a:	d1 cf       	rjmp	.-94     	; 0x56ce <rprintf1RamRom+0x54>
			default:  rprintfChar(format_flag); continue;
    572c:	00 e0       	ldi	r16, 0x00	; 0
    572e:	10 e1       	ldi	r17, 0x10	; 16
    5730:	30 e1       	ldi	r19, 0x10	; 16
    5732:	a3 2e       	mov	r10, r19
    5734:	b1 2c       	mov	r11, r1
			case 'd': base = 10; div_val = 10000; goto CONVERSION_LOOP;
//			case 'x': base = 16; div_val = 0x10;
			case 'x': base = 16; div_val = 0x1000;

			CONVERSION_LOOP:
			u_val = va_arg(ap,int);
    5736:	22 e0       	ldi	r18, 0x02	; 2
    5738:	82 2e       	mov	r8, r18
    573a:	91 2c       	mov	r9, r1
    573c:	8e 0c       	add	r8, r14
    573e:	9f 1c       	adc	r9, r15
    5740:	f7 01       	movw	r30, r14
    5742:	e0 80       	ld	r14, Z
    5744:	f1 80       	ldd	r15, Z+1	; 0x01
			if (format_flag == 'd')
    5746:	84 36       	cpi	r24, 0x64	; 100
    5748:	b1 f4       	brne	.+44     	; 0x5776 <rprintf1RamRom+0xfc>
			{
				if (((int)u_val) < 0)
    574a:	f7 fe       	sbrs	r15, 7
    574c:	11 c0       	rjmp	.+34     	; 0x5770 <rprintf1RamRom+0xf6>
				{
					u_val = - u_val;
    574e:	f0 94       	com	r15
    5750:	e1 94       	neg	r14
    5752:	f1 08       	sbc	r15, r1
    5754:	f3 94       	inc	r15
					rprintfChar('-');
    5756:	8d e2       	ldi	r24, 0x2D	; 45
    5758:	0e 94 e7 29 	call	0x53ce	; 0x53ce <rprintfChar>
    575c:	09 c0       	rjmp	.+18     	; 0x5770 <rprintf1RamRom+0xf6>
				}
				while (div_val > 1 && div_val > u_val) div_val /= 10;
    575e:	c8 01       	movw	r24, r16
    5760:	6a e0       	ldi	r22, 0x0A	; 10
    5762:	70 e0       	ldi	r23, 0x00	; 0
    5764:	0e 94 1d 6e 	call	0xdc3a	; 0xdc3a <__udivmodhi4>
    5768:	8b 01       	movw	r16, r22
    576a:	62 30       	cpi	r22, 0x02	; 2
    576c:	71 05       	cpc	r23, r1
    576e:	18 f0       	brcs	.+6      	; 0x5776 <rprintf1RamRom+0xfc>
    5770:	e0 16       	cp	r14, r16
    5772:	f1 06       	cpc	r15, r17
    5774:	a0 f3       	brcs	.-24     	; 0x575e <rprintf1RamRom+0xe4>
			}
			do
			{
				//rprintfChar(pgm_read_byte(HexChars+(u_val/div_val)));
				rprintfu04(u_val/div_val);
    5776:	c7 01       	movw	r24, r14
    5778:	b8 01       	movw	r22, r16
    577a:	0e 94 1d 6e 	call	0xdc3a	; 0xdc3a <__udivmodhi4>
    577e:	86 2f       	mov	r24, r22
    5780:	0e 94 4a 2a 	call	0x5494	; 0x5494 <rprintfu04>
				u_val %= div_val;
    5784:	c7 01       	movw	r24, r14
    5786:	b8 01       	movw	r22, r16
    5788:	0e 94 1d 6e 	call	0xdc3a	; 0xdc3a <__udivmodhi4>
    578c:	7c 01       	movw	r14, r24
				div_val /= base;
    578e:	c8 01       	movw	r24, r16
    5790:	b5 01       	movw	r22, r10
    5792:	0e 94 1d 6e 	call	0xdc3a	; 0xdc3a <__udivmodhi4>
    5796:	8b 01       	movw	r16, r22
			} while (div_val);
    5798:	61 15       	cp	r22, r1
    579a:	71 05       	cpc	r23, r1
    579c:	61 f7       	brne	.-40     	; 0x5776 <rprintf1RamRom+0xfc>
    579e:	74 01       	movw	r14, r8
    57a0:	98 cf       	rjmp	.-208    	; 0x56d2 <rprintf1RamRom+0x58>

000057a2 <adc_volt>:
	PSD_off();
	return gDistance;
}

WORD adc_volt()
{
    57a2:	80 91 81 0a 	lds	r24, 0x0A81
    57a6:	88 23       	and	r24, r24
    57a8:	69 f4       	brne	.+26     	; 0x57c4 <adc_volt+0x22>
//   A/D
//------------------------------------------------------------------------------
void Get_VOLTAGE(void)
{
	if(F_DOWNLOAD) return;
	gAD_Ch_Index = VOLTAGE_CH;
    57aa:	81 e0       	ldi	r24, 0x01	; 1
    57ac:	80 93 96 0d 	sts	0x0D96, r24
	F_AD_CONVERTING = 1;
    57b0:	80 93 80 0a 	sts	0x0A80, r24
	F_AD_CONVERTING = 0;    
}

void ADC_set(BYTE mode)
{                                    
	ADMUX=0x20 | gAD_Ch_Index;
    57b4:	81 e2       	ldi	r24, 0x21	; 33
    57b6:	87 b9       	out	0x07, r24	; 7
	ADCSRA=mode;     
    57b8:	8c ed       	ldi	r24, 0xDC	; 220
    57ba:	86 b9       	out	0x06, r24	; 6
{
	if(F_DOWNLOAD) return;
	gAD_Ch_Index = VOLTAGE_CH;
	F_AD_CONVERTING = 1;
   	ADC_set(ADC_MODE_SINGLE);
	while(F_AD_CONVERTING);
    57bc:	80 91 80 0a 	lds	r24, 0x0A80
    57c0:	88 23       	and	r24, r24
    57c2:	e1 f7       	brne	.-8      	; 0x57bc <adc_volt+0x1a>
	while (bit_is_set(ADCSRA, ADSC));	    // wait until value ready
	return volts;
	*/
	
	Get_VOLTAGE();
	return gVOLTAGE;
    57c4:	20 91 92 0d 	lds	r18, 0x0D92
    57c8:	30 91 93 0d 	lds	r19, 0x0D93
	
}
    57cc:	c9 01       	movw	r24, r18
    57ce:	08 95       	ret

000057d0 <__vector_21>:

/********************************************************************************/


ISR(ADC_vect)
{
    57d0:	1f 92       	push	r1
    57d2:	0f 92       	push	r0
    57d4:	0f b6       	in	r0, 0x3f	; 63
    57d6:	0f 92       	push	r0
    57d8:	11 24       	eor	r1, r1
    57da:	8f 93       	push	r24
    57dc:	9f 93       	push	r25
	WORD i;
	gAD_val=(signed char)ADCH;
    57de:	95 b1       	in	r25, 0x05	; 5
    57e0:	90 93 95 0d 	sts	0x0D95, r25
	switch(gAD_Ch_Index){
    57e4:	80 91 96 0d 	lds	r24, 0x0D96
    57e8:	81 30       	cpi	r24, 0x01	; 1
    57ea:	41 f0       	breq	.+16     	; 0x57fc <__vector_21+0x2c>
    57ec:	81 30       	cpi	r24, 0x01	; 1
    57ee:	18 f0       	brcs	.+6      	; 0x57f6 <__vector_21+0x26>
    57f0:	8f 30       	cpi	r24, 0x0F	; 15
    57f2:	a1 f4       	brne	.+40     	; 0x581c <__vector_21+0x4c>
    57f4:	0c c0       	rjmp	.+24     	; 0x580e <__vector_21+0x3e>
		case PSD_CH:
    	    gPSD_val = (BYTE)gAD_val;
    57f6:	90 93 94 0d 	sts	0x0D94, r25
    57fa:	10 c0       	rjmp	.+32     	; 0x581c <__vector_21+0x4c>
			break; 
		case VOLTAGE_CH:
			i = (BYTE)gAD_val;
			gVOLTAGE = i*57;
    57fc:	89 e3       	ldi	r24, 0x39	; 57
    57fe:	98 9f       	mul	r25, r24
    5800:	c0 01       	movw	r24, r0
    5802:	11 24       	eor	r1, r1
    5804:	90 93 93 0d 	sts	0x0D93, r25
    5808:	80 93 92 0d 	sts	0x0D92, r24
    580c:	07 c0       	rjmp	.+14     	; 0x581c <__vector_21+0x4c>
			break; 
		case MIC_CH:
			if((BYTE)gAD_val < 230)
    580e:	96 3e       	cpi	r25, 0xE6	; 230
    5810:	18 f4       	brcc	.+6      	; 0x5818 <__vector_21+0x48>
				gMIC_val = (BYTE)gAD_val;
    5812:	90 93 97 0d 	sts	0x0D97, r25
    5816:	02 c0       	rjmp	.+4      	; 0x581c <__vector_21+0x4c>
			else
				gMIC_val = 0;
    5818:	10 92 97 0d 	sts	0x0D97, r1
			break; 
	}  
	F_AD_CONVERTING = 0;    
    581c:	10 92 80 0a 	sts	0x0A80, r1
}
    5820:	9f 91       	pop	r25
    5822:	8f 91       	pop	r24
    5824:	0f 90       	pop	r0
    5826:	0f be       	out	0x3f, r0	; 63
    5828:	0f 90       	pop	r0
    582a:	1f 90       	pop	r1
    582c:	18 95       	reti

0000582e <ADC_set>:

void ADC_set(BYTE mode)
{                                    
    582e:	90 91 96 0d 	lds	r25, 0x0D96
    5832:	90 62       	ori	r25, 0x20	; 32
    5834:	97 b9       	out	0x07, r25	; 7
	ADMUX=0x20 | gAD_Ch_Index;
	ADCSRA=mode;     
    5836:	86 b9       	out	0x06, r24	; 6
}	
    5838:	08 95       	ret

0000583a <PSD_on>:

void PSD_on(void)
{
    583a:	c5 9a       	sbi	0x18, 5	; 24
    583c:	84 ef       	ldi	r24, 0xF4	; 244
    583e:	91 e0       	ldi	r25, 0x01	; 1
    5840:	20 e7       	ldi	r18, 0x70	; 112
    5842:	31 e0       	ldi	r19, 0x01	; 1
    5844:	f9 01       	movw	r30, r18
    5846:	31 97       	sbiw	r30, 0x01	; 1
    5848:	f1 f7       	brne	.-4      	; 0x5846 <PSD_on+0xc>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    584a:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    584c:	d9 f7       	brne	.-10     	; 0x5844 <PSD_on+0xa>
	PSD_ON;
   	_delay_ms(50);
}
    584e:	08 95       	ret

00005850 <PSD_off>:

void PSD_off(void)
{
    5850:	c5 98       	cbi	0x18, 5	; 24
	PSD_OFF;
}
    5852:	08 95       	ret

00005854 <Get_AD_PSD>:

void Get_AD_PSD(void)
{
    5854:	ef 92       	push	r14
    5856:	ff 92       	push	r15
    5858:	0f 93       	push	r16
    585a:	1f 93       	push	r17
	float	tmp = 0;
	float	dist;
	
	EIMSK &= 0xBF;
    585c:	89 b7       	in	r24, 0x39	; 57
    585e:	8f 7b       	andi	r24, 0xBF	; 191
    5860:	89 bf       	out	0x39, r24	; 57

	gAD_Ch_Index = PSD_CH;
    5862:	10 92 96 0d 	sts	0x0D96, r1
   	F_AD_CONVERTING = 1;
    5866:	81 e0       	ldi	r24, 0x01	; 1
    5868:	80 93 80 0a 	sts	0x0A80, r24
	F_AD_CONVERTING = 0;    
}

void ADC_set(BYTE mode)
{                                    
	ADMUX=0x20 | gAD_Ch_Index;
    586c:	80 e2       	ldi	r24, 0x20	; 32
    586e:	87 b9       	out	0x07, r24	; 7
	ADCSRA=mode;     
    5870:	8c ed       	ldi	r24, 0xDC	; 220
    5872:	86 b9       	out	0x06, r24	; 6
	EIMSK &= 0xBF;

	gAD_Ch_Index = PSD_CH;
   	F_AD_CONVERTING = 1;
   	ADC_set(ADC_MODE_SINGLE);
   	while(F_AD_CONVERTING);            
    5874:	80 91 80 0a 	lds	r24, 0x0A80
    5878:	88 23       	and	r24, r24
    587a:	e1 f7       	brne	.-8      	; 0x5874 <Get_AD_PSD+0x20>
   	tmp = tmp + gPSD_val;
    587c:	60 91 94 0d 	lds	r22, 0x0D94
	EIMSK |= 0x40;
    5880:	29 b7       	in	r18, 0x39	; 57
    5882:	20 64       	ori	r18, 0x40	; 64
    5884:	29 bf       	out	0x39, r18	; 57

	dist = 1117.2 / (tmp - 6.89);
    5886:	70 e0       	ldi	r23, 0x00	; 0
    5888:	88 27       	eor	r24, r24
    588a:	77 fd       	sbrc	r23, 7
    588c:	80 95       	com	r24
    588e:	98 2f       	mov	r25, r24
    5890:	0e 94 f8 69 	call	0xd3f0	; 0xd3f0 <__floatsisf>
    5894:	20 e0       	ldi	r18, 0x00	; 0
    5896:	30 e0       	ldi	r19, 0x00	; 0
    5898:	40 e0       	ldi	r20, 0x00	; 0
    589a:	50 e0       	ldi	r21, 0x00	; 0
    589c:	0e 94 97 67 	call	0xcf2e	; 0xcf2e <__addsf3>
    58a0:	21 ee       	ldi	r18, 0xE1	; 225
    58a2:	3a e7       	ldi	r19, 0x7A	; 122
    58a4:	4c ed       	ldi	r20, 0xDC	; 220
    58a6:	50 e4       	ldi	r21, 0x40	; 64
    58a8:	0e 94 66 67 	call	0xcecc	; 0xcecc <__subsf3>
    58ac:	9b 01       	movw	r18, r22
    58ae:	ac 01       	movw	r20, r24
    58b0:	66 e6       	ldi	r22, 0x66	; 102
    58b2:	76 ea       	ldi	r23, 0xA6	; 166
    58b4:	8b e8       	ldi	r24, 0x8B	; 139
    58b6:	94 e4       	ldi	r25, 0x44	; 68
    58b8:	0e 94 be 68 	call	0xd17c	; 0xd17c <__divsf3>
    58bc:	7b 01       	movw	r14, r22
    58be:	8c 01       	movw	r16, r24
	if(dist < 0) dist = 50;
    58c0:	20 e0       	ldi	r18, 0x00	; 0
    58c2:	30 e0       	ldi	r19, 0x00	; 0
    58c4:	40 e0       	ldi	r20, 0x00	; 0
    58c6:	50 e0       	ldi	r21, 0x00	; 0
    58c8:	0e 94 c8 69 	call	0xd390	; 0xd390 <__ltsf2>
    58cc:	88 23       	and	r24, r24
    58ce:	fc f0       	brlt	.+62     	; 0x590e <Get_AD_PSD+0xba>
	else if(dist < 10) dist = 10;
    58d0:	20 e0       	ldi	r18, 0x00	; 0
    58d2:	30 e0       	ldi	r19, 0x00	; 0
    58d4:	40 e2       	ldi	r20, 0x20	; 32
    58d6:	51 e4       	ldi	r21, 0x41	; 65
    58d8:	c8 01       	movw	r24, r16
    58da:	b7 01       	movw	r22, r14
    58dc:	0e 94 c8 69 	call	0xd390	; 0xd390 <__ltsf2>
    58e0:	88 23       	and	r24, r24
    58e2:	5c f4       	brge	.+22     	; 0x58fa <Get_AD_PSD+0xa6>
    58e4:	0f 2e       	mov	r0, r31
    58e6:	f0 e0       	ldi	r31, 0x00	; 0
    58e8:	ef 2e       	mov	r14, r31
    58ea:	f0 e0       	ldi	r31, 0x00	; 0
    58ec:	ff 2e       	mov	r15, r31
    58ee:	f0 e2       	ldi	r31, 0x20	; 32
    58f0:	0f 2f       	mov	r16, r31
    58f2:	f1 e4       	ldi	r31, 0x41	; 65
    58f4:	1f 2f       	mov	r17, r31
    58f6:	f0 2d       	mov	r31, r0
    58f8:	14 c0       	rjmp	.+40     	; 0x5922 <Get_AD_PSD+0xce>
	else if(dist > 50) dist = 50;
    58fa:	20 e0       	ldi	r18, 0x00	; 0
    58fc:	30 e0       	ldi	r19, 0x00	; 0
    58fe:	48 e4       	ldi	r20, 0x48	; 72
    5900:	52 e4       	ldi	r21, 0x42	; 66
    5902:	c8 01       	movw	r24, r16
    5904:	b7 01       	movw	r22, r14
    5906:	0e 94 68 69 	call	0xd2d0	; 0xd2d0 <__gtsf2>
    590a:	18 16       	cp	r1, r24
    590c:	54 f4       	brge	.+20     	; 0x5922 <Get_AD_PSD+0xce>
    590e:	0f 2e       	mov	r0, r31
    5910:	f0 e0       	ldi	r31, 0x00	; 0
    5912:	ef 2e       	mov	r14, r31
    5914:	f0 e0       	ldi	r31, 0x00	; 0
    5916:	ff 2e       	mov	r15, r31
    5918:	f8 e4       	ldi	r31, 0x48	; 72
    591a:	0f 2f       	mov	r16, r31
    591c:	f2 e4       	ldi	r31, 0x42	; 66
    591e:	1f 2f       	mov	r17, r31
    5920:	f0 2d       	mov	r31, r0
	gDistance = (BYTE)dist;
    5922:	c8 01       	movw	r24, r16
    5924:	b7 01       	movw	r22, r14
    5926:	0e 94 ee 65 	call	0xcbdc	; 0xcbdc <__fixunssfsi>
    592a:	60 93 99 0d 	sts	0x0D99, r22
}
    592e:	1f 91       	pop	r17
    5930:	0f 91       	pop	r16
    5932:	ff 90       	pop	r15
    5934:	ef 90       	pop	r14
    5936:	08 95       	ret

00005938 <adc_psd>:
volatile BYTE	gDistance;
volatile BYTE	gSoundLevel;


BYTE adc_psd()
{
    5938:	c5 9a       	sbi	0x18, 5	; 24
    593a:	84 ef       	ldi	r24, 0xF4	; 244
    593c:	91 e0       	ldi	r25, 0x01	; 1
    593e:	20 e7       	ldi	r18, 0x70	; 112
    5940:	31 e0       	ldi	r19, 0x01	; 1
    5942:	f9 01       	movw	r30, r18
    5944:	31 97       	sbiw	r30, 0x01	; 1
    5946:	f1 f7       	brne	.-4      	; 0x5944 <adc_psd+0xc>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5948:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    594a:	d9 f7       	brne	.-10     	; 0x5942 <adc_psd+0xa>
	while (bit_is_set(ADCSRA, ADSC));	    // wait until value ready
	PSD_OFF;	
	return psd_value;
*/
	PSD_on();
	Get_AD_PSD();
    594c:	0e 94 2a 2c 	call	0x5854	; 0x5854 <Get_AD_PSD>
   	_delay_ms(50);
}

void PSD_off(void)
{
	PSD_OFF;
    5950:	c5 98       	cbi	0x18, 5	; 24
	return psd_value;
*/
	PSD_on();
	Get_AD_PSD();
	PSD_off();
	return gDistance;
    5952:	80 91 99 0d 	lds	r24, 0x0D99
}
    5956:	08 95       	ret

00005958 <Get_AD_MIC>:

//------------------------------------------------------------------------------
// MIC  A/D
//------------------------------------------------------------------------------
void Get_AD_MIC(void)
{
    5958:	bf 92       	push	r11
    595a:	cf 92       	push	r12
    595c:	df 92       	push	r13
    595e:	ef 92       	push	r14
    5960:	ff 92       	push	r15
    5962:	0f 93       	push	r16
    5964:	1f 93       	push	r17
    5966:	cf 93       	push	r28
    5968:	df 93       	push	r29
	WORD	i;
	float	tmp = 0;
	
	gAD_Ch_Index = MIC_CH;
    596a:	8f e0       	ldi	r24, 0x0F	; 15
    596c:	80 93 96 0d 	sts	0x0D96, r24
    5970:	c0 e0       	ldi	r28, 0x00	; 0
    5972:	d0 e0       	ldi	r29, 0x00	; 0
    5974:	0f 2e       	mov	r0, r31
    5976:	f0 e0       	ldi	r31, 0x00	; 0
    5978:	ef 2e       	mov	r14, r31
    597a:	f0 e0       	ldi	r31, 0x00	; 0
    597c:	ff 2e       	mov	r15, r31
    597e:	f0 e0       	ldi	r31, 0x00	; 0
    5980:	0f 2f       	mov	r16, r31
    5982:	f0 e0       	ldi	r31, 0x00	; 0
    5984:	1f 2f       	mov	r17, r31
    5986:	f0 2d       	mov	r31, r0
	for(i = 0; i < 50; i++){
	
    	F_AD_CONVERTING = 1;
    5988:	bb 24       	eor	r11, r11
    598a:	b3 94       	inc	r11
	F_AD_CONVERTING = 0;    
}

void ADC_set(BYTE mode)
{                                    
	ADMUX=0x20 | gAD_Ch_Index;
    598c:	9f e2       	ldi	r25, 0x2F	; 47
    598e:	c9 2e       	mov	r12, r25
	ADCSRA=mode;     
    5990:	8c ed       	ldi	r24, 0xDC	; 220
    5992:	d8 2e       	mov	r13, r24
	float	tmp = 0;
	
	gAD_Ch_Index = MIC_CH;
	for(i = 0; i < 50; i++){
	
    	F_AD_CONVERTING = 1;
    5994:	b0 92 80 0a 	sts	0x0A80, r11
	F_AD_CONVERTING = 0;    
}

void ADC_set(BYTE mode)
{                                    
	ADMUX=0x20 | gAD_Ch_Index;
    5998:	c7 b8       	out	0x07, r12	; 7
	ADCSRA=mode;     
    599a:	d6 b8       	out	0x06, r13	; 6
	gAD_Ch_Index = MIC_CH;
	for(i = 0; i < 50; i++){
	
    	F_AD_CONVERTING = 1;
	   	ADC_set(ADC_MODE_SINGLE);
    	while(F_AD_CONVERTING);            
    599c:	80 91 80 0a 	lds	r24, 0x0A80
    59a0:	88 23       	and	r24, r24
    59a2:	e1 f7       	brne	.-8      	; 0x599c <Get_AD_MIC+0x44>
    	tmp = tmp + gMIC_val;
    59a4:	60 91 97 0d 	lds	r22, 0x0D97
    59a8:	70 e0       	ldi	r23, 0x00	; 0
    59aa:	88 27       	eor	r24, r24
    59ac:	77 fd       	sbrc	r23, 7
    59ae:	80 95       	com	r24
    59b0:	98 2f       	mov	r25, r24
    59b2:	0e 94 f8 69 	call	0xd3f0	; 0xd3f0 <__floatsisf>
    59b6:	9b 01       	movw	r18, r22
    59b8:	ac 01       	movw	r20, r24
    59ba:	c8 01       	movw	r24, r16
    59bc:	b7 01       	movw	r22, r14
    59be:	0e 94 97 67 	call	0xcf2e	; 0xcf2e <__addsf3>
    59c2:	7b 01       	movw	r14, r22
    59c4:	8c 01       	movw	r16, r24
{
	WORD	i;
	float	tmp = 0;
	
	gAD_Ch_Index = MIC_CH;
	for(i = 0; i < 50; i++){
    59c6:	21 96       	adiw	r28, 0x01	; 1
    59c8:	c2 33       	cpi	r28, 0x32	; 50
    59ca:	d1 05       	cpc	r29, r1
    59cc:	19 f7       	brne	.-58     	; 0x5994 <Get_AD_MIC+0x3c>
	   	ADC_set(ADC_MODE_SINGLE);
    	while(F_AD_CONVERTING);            
    	tmp = tmp + gMIC_val;
    }
    tmp = tmp / 10;
	gSoundLevel = (BYTE)tmp;
    59ce:	20 e0       	ldi	r18, 0x00	; 0
    59d0:	30 e0       	ldi	r19, 0x00	; 0
    59d2:	40 e2       	ldi	r20, 0x20	; 32
    59d4:	51 e4       	ldi	r21, 0x41	; 65
    59d6:	0e 94 be 68 	call	0xd17c	; 0xd17c <__divsf3>
    59da:	0e 94 ee 65 	call	0xcbdc	; 0xcbdc <__fixunssfsi>
    59de:	60 93 98 0d 	sts	0x0D98, r22
}
    59e2:	df 91       	pop	r29
    59e4:	cf 91       	pop	r28
    59e6:	1f 91       	pop	r17
    59e8:	0f 91       	pop	r16
    59ea:	ff 90       	pop	r15
    59ec:	ef 90       	pop	r14
    59ee:	df 90       	pop	r13
    59f0:	cf 90       	pop	r12
    59f2:	bf 90       	pop	r11
    59f4:	08 95       	ret

000059f6 <adc_mic>:
	return gVOLTAGE;
	
}

BYTE adc_mic()
{
    59f6:	0e 94 ac 2c 	call	0x5958	; 0x5958 <Get_AD_MIC>
		mic_vol = mic_vol + mic_value;	
	}
	return mic_vol;
	*/
	Get_AD_MIC();
	return gSoundLevel;
    59fa:	80 91 98 0d 	lds	r24, 0x0D98
	
}
    59fe:	08 95       	ret

00005a00 <Get_VOLTAGE>:

//------------------------------------------------------------------------------
//   A/D
//------------------------------------------------------------------------------
void Get_VOLTAGE(void)
{
    5a00:	80 91 81 0a 	lds	r24, 0x0A81
    5a04:	88 23       	and	r24, r24
    5a06:	69 f4       	brne	.+26     	; 0x5a22 <Get_VOLTAGE+0x22>
	if(F_DOWNLOAD) return;
	gAD_Ch_Index = VOLTAGE_CH;
    5a08:	81 e0       	ldi	r24, 0x01	; 1
    5a0a:	80 93 96 0d 	sts	0x0D96, r24
	F_AD_CONVERTING = 1;
    5a0e:	80 93 80 0a 	sts	0x0A80, r24
	F_AD_CONVERTING = 0;    
}

void ADC_set(BYTE mode)
{                                    
	ADMUX=0x20 | gAD_Ch_Index;
    5a12:	81 e2       	ldi	r24, 0x21	; 33
    5a14:	87 b9       	out	0x07, r24	; 7
	ADCSRA=mode;     
    5a16:	8c ed       	ldi	r24, 0xDC	; 220
    5a18:	86 b9       	out	0x06, r24	; 6
{
	if(F_DOWNLOAD) return;
	gAD_Ch_Index = VOLTAGE_CH;
	F_AD_CONVERTING = 1;
   	ADC_set(ADC_MODE_SINGLE);
	while(F_AD_CONVERTING);
    5a1a:	80 91 80 0a 	lds	r24, 0x0A80
    5a1e:	88 23       	and	r24, r24
    5a20:	e1 f7       	brne	.-8      	; 0x5a1a <Get_VOLTAGE+0x1a>
    5a22:	08 95       	ret

00005a24 <adc_test>:
	Get_AD_MIC();
	return gSoundLevel;
	
}

int adc_test(BYTE debug){	
    5a24:	1f 93       	push	r17
    5a26:	18 2f       	mov	r17, r24
	//read PSD	
	if (debug) rprintf("PSD=");
    5a28:	88 23       	and	r24, r24
    5a2a:	59 f0       	breq	.+22     	; 0x5a42 <adc_test+0x1e>
    5a2c:	83 ea       	ldi	r24, 0xA3	; 163
    5a2e:	94 e3       	ldi	r25, 0x34	; 52
    5a30:	9f 93       	push	r25
    5a32:	8f 93       	push	r24
    5a34:	81 e0       	ldi	r24, 0x01	; 1
    5a36:	8f 93       	push	r24
    5a38:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
    5a3c:	0f 90       	pop	r0
    5a3e:	0f 90       	pop	r0
    5a40:	0f 90       	pop	r0
	adc_psd();
    5a42:	0e 94 9c 2c 	call	0x5938	; 0x5938 <adc_psd>
	if (debug) rprintf("%x", gDistance);
    5a46:	11 23       	and	r17, r17
    5a48:	91 f0       	breq	.+36     	; 0x5a6e <adc_test+0x4a>
    5a4a:	80 91 99 0d 	lds	r24, 0x0D99
    5a4e:	90 e0       	ldi	r25, 0x00	; 0
    5a50:	9f 93       	push	r25
    5a52:	8f 93       	push	r24
    5a54:	80 ea       	ldi	r24, 0xA0	; 160
    5a56:	94 e3       	ldi	r25, 0x34	; 52
    5a58:	9f 93       	push	r25
    5a5a:	8f 93       	push	r24
    5a5c:	81 e0       	ldi	r24, 0x01	; 1
    5a5e:	8f 93       	push	r24
    5a60:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
    5a64:	0f 90       	pop	r0
    5a66:	0f 90       	pop	r0
    5a68:	0f 90       	pop	r0
    5a6a:	0f 90       	pop	r0
    5a6c:	0f 90       	pop	r0
    5a6e:	84 ef       	ldi	r24, 0xF4	; 244
    5a70:	91 e0       	ldi	r25, 0x01	; 1
    5a72:	20 e7       	ldi	r18, 0x70	; 112
    5a74:	31 e0       	ldi	r19, 0x01	; 1
    5a76:	f9 01       	movw	r30, r18
    5a78:	31 97       	sbiw	r30, 0x01	; 1
    5a7a:	f1 f7       	brne	.-4      	; 0x5a78 <adc_test+0x54>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5a7c:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    5a7e:	d9 f7       	brne	.-10     	; 0x5a76 <adc_test+0x52>
	
	//read Voltage	
	_delay_ms(50);	
	if (debug) rprintf(" VOLT=");
    5a80:	11 23       	and	r17, r17
    5a82:	59 f0       	breq	.+22     	; 0x5a9a <adc_test+0x76>
    5a84:	89 e9       	ldi	r24, 0x99	; 153
    5a86:	94 e3       	ldi	r25, 0x34	; 52
    5a88:	9f 93       	push	r25
    5a8a:	8f 93       	push	r24
    5a8c:	81 e0       	ldi	r24, 0x01	; 1
    5a8e:	8f 93       	push	r24
    5a90:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
    5a94:	0f 90       	pop	r0
    5a96:	0f 90       	pop	r0
    5a98:	0f 90       	pop	r0
//------------------------------------------------------------------------------
//   A/D
//------------------------------------------------------------------------------
void Get_VOLTAGE(void)
{
	if(F_DOWNLOAD) return;
    5a9a:	80 91 81 0a 	lds	r24, 0x0A81
    5a9e:	88 23       	and	r24, r24
    5aa0:	69 f4       	brne	.+26     	; 0x5abc <adc_test+0x98>
	gAD_Ch_Index = VOLTAGE_CH;
    5aa2:	81 e0       	ldi	r24, 0x01	; 1
    5aa4:	80 93 96 0d 	sts	0x0D96, r24
	F_AD_CONVERTING = 1;
    5aa8:	80 93 80 0a 	sts	0x0A80, r24
	F_AD_CONVERTING = 0;    
}

void ADC_set(BYTE mode)
{                                    
	ADMUX=0x20 | gAD_Ch_Index;
    5aac:	81 e2       	ldi	r24, 0x21	; 33
    5aae:	87 b9       	out	0x07, r24	; 7
	ADCSRA=mode;     
    5ab0:	8c ed       	ldi	r24, 0xDC	; 220
    5ab2:	86 b9       	out	0x06, r24	; 6
{
	if(F_DOWNLOAD) return;
	gAD_Ch_Index = VOLTAGE_CH;
	F_AD_CONVERTING = 1;
   	ADC_set(ADC_MODE_SINGLE);
	while(F_AD_CONVERTING);
    5ab4:	80 91 80 0a 	lds	r24, 0x0A80
    5ab8:	88 23       	and	r24, r24
    5aba:	e1 f7       	brne	.-8      	; 0x5ab4 <adc_test+0x90>
	while (bit_is_set(ADCSRA, ADSC));	    // wait until value ready
	return volts;
	*/
	
	Get_VOLTAGE();
	return gVOLTAGE;
    5abc:	80 91 92 0d 	lds	r24, 0x0D92
    5ac0:	90 91 93 0d 	lds	r25, 0x0D93
	
	//read Voltage	
	_delay_ms(50);	
	if (debug) rprintf(" VOLT=");
	adc_volt();
	if (debug) rprintf("%dmV", gVOLTAGE);
    5ac4:	11 23       	and	r17, r17
    5ac6:	99 f0       	breq	.+38     	; 0x5aee <adc_test+0xca>
    5ac8:	80 91 92 0d 	lds	r24, 0x0D92
    5acc:	90 91 93 0d 	lds	r25, 0x0D93
    5ad0:	9f 93       	push	r25
    5ad2:	8f 93       	push	r24
    5ad4:	84 e9       	ldi	r24, 0x94	; 148
    5ad6:	94 e3       	ldi	r25, 0x34	; 52
    5ad8:	9f 93       	push	r25
    5ada:	8f 93       	push	r24
    5adc:	81 e0       	ldi	r24, 0x01	; 1
    5ade:	8f 93       	push	r24
    5ae0:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
    5ae4:	0f 90       	pop	r0
    5ae6:	0f 90       	pop	r0
    5ae8:	0f 90       	pop	r0
    5aea:	0f 90       	pop	r0
    5aec:	0f 90       	pop	r0
    5aee:	84 ef       	ldi	r24, 0xF4	; 244
    5af0:	91 e0       	ldi	r25, 0x01	; 1
    5af2:	20 e7       	ldi	r18, 0x70	; 112
    5af4:	31 e0       	ldi	r19, 0x01	; 1
    5af6:	f9 01       	movw	r30, r18
    5af8:	31 97       	sbiw	r30, 0x01	; 1
    5afa:	f1 f7       	brne	.-4      	; 0x5af8 <adc_test+0xd4>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5afc:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    5afe:	d9 f7       	brne	.-10     	; 0x5af6 <adc_test+0xd2>

	//read MIC	
	_delay_ms(50);	
	if (debug) rprintf(" MIC=");
    5b00:	11 23       	and	r17, r17
    5b02:	59 f0       	breq	.+22     	; 0x5b1a <adc_test+0xf6>
    5b04:	8e e8       	ldi	r24, 0x8E	; 142
    5b06:	94 e3       	ldi	r25, 0x34	; 52
    5b08:	9f 93       	push	r25
    5b0a:	8f 93       	push	r24
    5b0c:	81 e0       	ldi	r24, 0x01	; 1
    5b0e:	8f 93       	push	r24
    5b10:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
    5b14:	0f 90       	pop	r0
    5b16:	0f 90       	pop	r0
    5b18:	0f 90       	pop	r0
	
		mic_vol = mic_vol + mic_value;	
	}
	return mic_vol;
	*/
	Get_AD_MIC();
    5b1a:	0e 94 ac 2c 	call	0x5958	; 0x5958 <Get_AD_MIC>
	return gSoundLevel;
    5b1e:	80 91 98 0d 	lds	r24, 0x0D98

	//read MIC	
	_delay_ms(50);	
	if (debug) rprintf(" MIC=");
	adc_mic();
	if (debug) rprintf("%d\r\n", gSoundLevel);		
    5b22:	11 23       	and	r17, r17
    5b24:	91 f0       	breq	.+36     	; 0x5b4a <adc_test+0x126>
    5b26:	80 91 98 0d 	lds	r24, 0x0D98
    5b2a:	90 e0       	ldi	r25, 0x00	; 0
    5b2c:	9f 93       	push	r25
    5b2e:	8f 93       	push	r24
    5b30:	89 e8       	ldi	r24, 0x89	; 137
    5b32:	94 e3       	ldi	r25, 0x34	; 52
    5b34:	9f 93       	push	r25
    5b36:	8f 93       	push	r24
    5b38:	81 e0       	ldi	r24, 0x01	; 1
    5b3a:	8f 93       	push	r24
    5b3c:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
    5b40:	0f 90       	pop	r0
    5b42:	0f 90       	pop	r0
    5b44:	0f 90       	pop	r0
    5b46:	0f 90       	pop	r0
    5b48:	0f 90       	pop	r0

	return 0;
}
    5b4a:	80 e0       	ldi	r24, 0x00	; 0
    5b4c:	90 e0       	ldi	r25, 0x00	; 0
    5b4e:	1f 91       	pop	r17
    5b50:	08 95       	ret

00005b52 <__vector_10>:

//------------------------------------------------------------------------------
// Timer2 IR Timeout interrupt routine
//------------------------------------------------------------------------------
ISR(TIMER2_OVF_vect) 
{
    5b52:	1f 92       	push	r1
    5b54:	0f 92       	push	r0
    5b56:	0f b6       	in	r0, 0x3f	; 63
    5b58:	0f 92       	push	r0
    5b5a:	11 24       	eor	r1, r1
    5b5c:	8f 93       	push	r24
	TIMSK &= 0xBF;			// disable timeout interrupt
    5b5e:	87 b7       	in	r24, 0x37	; 55
    5b60:	8f 7b       	andi	r24, 0xBF	; 191
    5b62:	87 bf       	out	0x37, r24	; 55
	IRState = IR_IDLE;
    5b64:	10 92 9f 0d 	sts	0x0D9F, r1
}
    5b68:	8f 91       	pop	r24
    5b6a:	0f 90       	pop	r0
    5b6c:	0f be       	out	0x3f, r0	; 63
    5b6e:	0f 90       	pop	r0
    5b70:	1f 90       	pop	r1
    5b72:	18 95       	reti

00005b74 <__vector_7>:

//------------------------------------------------------------------------------
// External Interrupt 6 IR Remote
//------------------------------------------------------------------------------
ISR(INT6_vect) 
{
    5b74:	1f 92       	push	r1
    5b76:	0f 92       	push	r0
    5b78:	0f b6       	in	r0, 0x3f	; 63
    5b7a:	0f 92       	push	r0
    5b7c:	0b b6       	in	r0, 0x3b	; 59
    5b7e:	0f 92       	push	r0
    5b80:	11 24       	eor	r1, r1
    5b82:	8f 93       	push	r24
    5b84:	9f 93       	push	r25
    5b86:	ef 93       	push	r30
    5b88:	ff 93       	push	r31
	switch(IRState) {
    5b8a:	80 91 9f 0d 	lds	r24, 0x0D9F
    5b8e:	81 30       	cpi	r24, 0x01	; 1
    5b90:	59 f0       	breq	.+22     	; 0x5ba8 <__vector_7+0x34>
    5b92:	81 30       	cpi	r24, 0x01	; 1
    5b94:	20 f0       	brcs	.+8      	; 0x5b9e <__vector_7+0x2a>
    5b96:	82 30       	cpi	r24, 0x02	; 2
    5b98:	09 f0       	breq	.+2      	; 0x5b9c <__vector_7+0x28>
    5b9a:	61 c0       	rjmp	.+194    	; 0x5c5e <__vector_7+0xea>
    5b9c:	23 c0       	rjmp	.+70     	; 0x5be4 <__vector_7+0x70>

	case IR_IDLE: 
		TCNT2 = 0;				// clear timer 2
    5b9e:	14 bc       	out	0x24, r1	; 36
		IRState = IR_START;
    5ba0:	81 e0       	ldi	r24, 0x01	; 1
    5ba2:	80 93 9f 0d 	sts	0x0D9F, r24
    5ba6:	55 c0       	rjmp	.+170    	; 0x5c52 <__vector_7+0xde>
		TIFR |= 0x40;			// clear overflow
		TIMSK |= 0x40;			// timeout interrupt
		break;

	case IR_START:
		pulse_width = TCNT2; 	// read timer
    5ba8:	84 b5       	in	r24, 0x24	; 36
    5baa:	80 93 9c 0d 	sts	0x0D9C, r24
		TCNT2 = 0;				// clear timer 2
    5bae:	14 bc       	out	0x24, r1	; 36
		if ((pulse_width < IR_START_SHORT) | (pulse_width > IR_START_LONG))
    5bb0:	8a 53       	subi	r24, 0x3A	; 58
    5bb2:	89 31       	cpi	r24, 0x19	; 25
    5bb4:	08 f0       	brcs	.+2      	; 0x5bb8 <__vector_7+0x44>
    5bb6:	4a c0       	rjmp	.+148    	; 0x5c4c <__vector_7+0xd8>
			IRState = IR_IDLE;
		
		else {
			IRBit = 0;
    5bb8:	10 92 9b 0d 	sts	0x0D9B, r1
			IRByte = 0;
    5bbc:	10 92 9e 0d 	sts	0x0D9E, r1
			IRState = IR_RECEIVE;
    5bc0:	82 e0       	ldi	r24, 0x02	; 2
    5bc2:	80 93 9f 0d 	sts	0x0D9F, r24
			TIFR |= 0x40;			// clear overflow
    5bc6:	86 b7       	in	r24, 0x36	; 54
    5bc8:	80 64       	ori	r24, 0x40	; 64
    5bca:	86 bf       	out	0x36, r24	; 54
			TIMSK |= 0x40;			// timeout interrupt
    5bcc:	87 b7       	in	r24, 0x37	; 55
    5bce:	80 64       	ori	r24, 0x40	; 64
    5bd0:	87 bf       	out	0x37, r24	; 55
			for (BYTE i=0; i < 4; i++) IRTemp[i] = 0;
    5bd2:	10 92 a1 0d 	sts	0x0DA1, r1
    5bd6:	10 92 a2 0d 	sts	0x0DA2, r1
    5bda:	10 92 a3 0d 	sts	0x0DA3, r1
    5bde:	10 92 a4 0d 	sts	0x0DA4, r1
    5be2:	3d c0       	rjmp	.+122    	; 0x5c5e <__vector_7+0xea>
			
		}
		break;

	case IR_RECEIVE:
		pulse_width = TCNT2;    // read time
    5be4:	94 b5       	in	r25, 0x24	; 36
    5be6:	90 93 9c 0d 	sts	0x0D9C, r25
		TCNT2 = 0;
    5bea:	14 bc       	out	0x24, r1	; 36

		if ((pulse_width < IR_BIT_SHORT) | (pulse_width > IR_BIT_LONG))
    5bec:	89 2f       	mov	r24, r25
    5bee:	8d 50       	subi	r24, 0x0D	; 13
    5bf0:	8e 30       	cpi	r24, 0x0E	; 14
    5bf2:	60 f5       	brcc	.+88     	; 0x5c4c <__vector_7+0xd8>
    5bf4:	e0 91 9e 0d 	lds	r30, 0x0D9E
			IRState = IR_IDLE;
			
		else {
			if (pulse_width > IR_ZERO_ONE)
    5bf8:	94 31       	cpi	r25, 0x14	; 20
    5bfa:	38 f0       	brcs	.+14     	; 0x5c0a <__vector_7+0x96>
				IRTemp[IRByte] = (IRTemp[IRByte] >> 1) | 0x80;
    5bfc:	f0 e0       	ldi	r31, 0x00	; 0
    5bfe:	ef 55       	subi	r30, 0x5F	; 95
    5c00:	f2 4f       	sbci	r31, 0xF2	; 242
    5c02:	80 81       	ld	r24, Z
    5c04:	86 95       	lsr	r24
    5c06:	80 68       	ori	r24, 0x80	; 128
    5c08:	05 c0       	rjmp	.+10     	; 0x5c14 <__vector_7+0xa0>
			else 
				IRTemp[IRByte] = IRTemp[IRByte] >> 1;
    5c0a:	f0 e0       	ldi	r31, 0x00	; 0
    5c0c:	ef 55       	subi	r30, 0x5F	; 95
    5c0e:	f2 4f       	sbci	r31, 0xF2	; 242
    5c10:	80 81       	ld	r24, Z
    5c12:	86 95       	lsr	r24
    5c14:	80 83       	st	Z, r24
			
			if (++IRBit == 8) {
    5c16:	80 91 9b 0d 	lds	r24, 0x0D9B
    5c1a:	8f 5f       	subi	r24, 0xFF	; 255
    5c1c:	80 93 9b 0d 	sts	0x0D9B, r24
    5c20:	88 30       	cpi	r24, 0x08	; 8
    5c22:	b9 f4       	brne	.+46     	; 0x5c52 <__vector_7+0xde>
				IRBit = 0;
    5c24:	10 92 9b 0d 	sts	0x0D9B, r1
				if(++IRByte == 4) {
    5c28:	80 91 9e 0d 	lds	r24, 0x0D9E
    5c2c:	8f 5f       	subi	r24, 0xFF	; 255
    5c2e:	80 93 9e 0d 	sts	0x0D9E, r24
    5c32:	84 30       	cpi	r24, 0x04	; 4
    5c34:	71 f4       	brne	.+28     	; 0x5c52 <__vector_7+0xde>
					gIRAddr = IRTemp[0];
    5c36:	80 91 a1 0d 	lds	r24, 0x0DA1
    5c3a:	80 93 9a 0d 	sts	0x0D9A, r24
					//if( IRTemp[0] == IR_ADDRESS){     // commented out address checking
						gIRData = IRTemp[3];
    5c3e:	80 91 a4 0d 	lds	r24, 0x0DA4
    5c42:	80 93 a0 0d 	sts	0x0DA0, r24
						gIRReady = TRUE;
    5c46:	8f ef       	ldi	r24, 0xFF	; 255
    5c48:	80 93 9d 0d 	sts	0x0D9D, r24
					//}
					IRState = IR_IDLE;
    5c4c:	10 92 9f 0d 	sts	0x0D9F, r1
    5c50:	06 c0       	rjmp	.+12     	; 0x5c5e <__vector_7+0xea>
					return;
				}

			}
			TIFR |= 0x40;			// clear overflow
    5c52:	86 b7       	in	r24, 0x36	; 54
    5c54:	80 64       	ori	r24, 0x40	; 64
    5c56:	86 bf       	out	0x36, r24	; 54
			TIMSK |= 0x40;			// timeout interrupt
    5c58:	87 b7       	in	r24, 0x37	; 55
    5c5a:	80 64       	ori	r24, 0x40	; 64
    5c5c:	87 bf       	out	0x37, r24	; 55
				
		}
		break;
	} // end switch
	
} // end int
    5c5e:	ff 91       	pop	r31
    5c60:	ef 91       	pop	r30
    5c62:	9f 91       	pop	r25
    5c64:	8f 91       	pop	r24
    5c66:	0f 90       	pop	r0
    5c68:	0b be       	out	0x3b, r0	; 59
    5c6a:	0f 90       	pop	r0
    5c6c:	0f be       	out	0x3f, r0	; 63
    5c6e:	0f 90       	pop	r0
    5c70:	1f 90       	pop	r1
    5c72:	18 95       	reti

00005c74 <irGetByte>:

//------------------------------------------------------------------------------
// get the next char from the IR receiver, or -1 if none (getchar-style)
//------------------------------------------------------------------------------
int irGetByte(void)
{
    5c74:	80 91 9d 0d 	lds	r24, 0x0D9D
    5c78:	88 23       	and	r24, r24
    5c7a:	19 f4       	brne	.+6      	; 0x5c82 <irGetByte+0xe>
    5c7c:	2f ef       	ldi	r18, 0xFF	; 255
    5c7e:	3f ef       	ldi	r19, 0xFF	; 255
    5c80:	06 c0       	rjmp	.+12     	; 0x5c8e <irGetByte+0x1a>
	if (!gIRReady) return -1;
	gIRReady = FALSE;
    5c82:	10 92 9d 0d 	sts	0x0D9D, r1
	return gIRData;
    5c86:	80 91 a0 0d 	lds	r24, 0x0DA0
    5c8a:	28 2f       	mov	r18, r24
    5c8c:	30 e0       	ldi	r19, 0x00	; 0
}
    5c8e:	c9 01       	movw	r24, r18
    5c90:	08 95       	ret

00005c92 <start_accel>:
volatile int z_value;



void start_accel()
{
    5c92:	14 9a       	sbi	0x02, 4	; 2
    SET_BIT4(DDRE);
	SET_BIT5(DDRE);	
    5c94:	15 9a       	sbi	0x02, 5	; 2
	DATA_HIGH;
    5c96:	1d 9a       	sbi	0x03, 5	; 3
	CLOCK_HIGH;	
    5c98:	1c 9a       	sbi	0x03, 4	; 3
	NOP;
    5c9a:	00 00       	nop
	NOP;
    5c9c:	00 00       	nop
	DATA_LOW;
    5c9e:	1d 98       	cbi	0x03, 5	; 3
	NOP;
    5ca0:	00 00       	nop
	NOP;
    5ca2:	00 00       	nop
	CLOCK_LOW;
    5ca4:	1c 98       	cbi	0x03, 4	; 3
	NOP;
    5ca6:	00 00       	nop
	NOP;
    5ca8:	00 00       	nop
}
    5caa:	08 95       	ret

00005cac <stop_accel>:

void stop_accel()
{
    5cac:	14 9a       	sbi	0x02, 4	; 2
    SET_BIT4(DDRE);
	SET_BIT5(DDRE);	
    5cae:	15 9a       	sbi	0x02, 5	; 2
	DATA_LOW;
    5cb0:	1d 98       	cbi	0x03, 5	; 3
	CLOCK_HIGH;	
    5cb2:	1c 9a       	sbi	0x03, 4	; 3
	NOP;
    5cb4:	00 00       	nop
	NOP;
    5cb6:	00 00       	nop
	DATA_HIGH;
    5cb8:	1d 9a       	sbi	0x03, 5	; 3
	NOP;
    5cba:	00 00       	nop
	NOP;
    5cbc:	00 00       	nop
    CLR_BIT4(DDRE);
    5cbe:	14 98       	cbi	0x02, 4	; 2
	CLR_BIT5(DDRE);	
    5cc0:	15 98       	cbi	0x02, 5	; 2
}
    5cc2:	08 95       	ret

00005cc4 <read_value>:

// reads from tilt
BYTE read_value()
{
    5cc4:	15 98       	cbi	0x02, 5	; 2
    5cc6:	90 e0       	ldi	r25, 0x00	; 0
    5cc8:	80 e0       	ldi	r24, 0x00	; 0
	BYTE b=0;
	CLR_BIT5(DDRE);	  		// I2C - input
  	BYTE i;
	for (i=0; i<8; i++)
	{
		b <<=(BYTE)1;
    5cca:	88 0f       	add	r24, r24
	...
		NOP;
		NOP;
		NOP;
		NOP;
		CLOCK_HIGH; 			
    5cd4:	1c 9a       	sbi	0x03, 4	; 3
		NOP;
    5cd6:	00 00       	nop
		NOP;
    5cd8:	00 00       	nop
		
		if (PINE & BV(PINE5)) 	
    5cda:	0d 99       	sbic	0x01, 5	; 1
		{
			b |= (BYTE)1;  
    5cdc:	81 60       	ori	r24, 0x01	; 1
		}

		NOP;
    5cde:	00 00       	nop
		NOP;
    5ce0:	00 00       	nop
		CLOCK_LOW; 	  
    5ce2:	1c 98       	cbi	0x03, 4	; 3
BYTE read_value()
{
	BYTE b=0;
	CLR_BIT5(DDRE);	  		// I2C - input
  	BYTE i;
	for (i=0; i<8; i++)
    5ce4:	9f 5f       	subi	r25, 0xFF	; 255
    5ce6:	98 30       	cpi	r25, 0x08	; 8
    5ce8:	81 f7       	brne	.-32     	; 0x5cca <read_value+0x6>

		NOP;
		NOP;
		CLOCK_LOW; 	  
	}  
	SET_BIT5(DDRE);		  // I2C - output
    5cea:	15 9a       	sbi	0x02, 5	; 2
	return b; 
}
    5cec:	08 95       	ret

00005cee <write_value>:

// write to tilt
void write_value(BYTE data)
{
    5cee:	15 9a       	sbi	0x02, 5	; 2
    5cf0:	90 e0       	ldi	r25, 0x00	; 0
	BYTE i;
	SET_BIT5(DDRE);	
	for (i=0; i<8; i++)
	{
		if (data & (BYTE)0x80)
    5cf2:	87 ff       	sbrs	r24, 7
    5cf4:	02 c0       	rjmp	.+4      	; 0x5cfa <write_value+0xc>
		{
			DATA_HIGH;
    5cf6:	1d 9a       	sbi	0x03, 5	; 3
    5cf8:	01 c0       	rjmp	.+2      	; 0x5cfc <write_value+0xe>
		}
		else
		{
			DATA_LOW;
    5cfa:	1d 98       	cbi	0x03, 5	; 3
		}
		NOP;
    5cfc:	00 00       	nop
		NOP;
    5cfe:	00 00       	nop
		CLOCK_HIGH;
    5d00:	1c 9a       	sbi	0x03, 4	; 3
	...
		NOP;
		NOP;
		NOP;
		NOP;
		CLOCK_LOW;
    5d0a:	1c 98       	cbi	0x03, 4	; 3
		NOP;
    5d0c:	00 00       	nop
		NOP;
    5d0e:	00 00       	nop
// write to tilt
void write_value(BYTE data)
{
	BYTE i;
	SET_BIT5(DDRE);	
	for (i=0; i<8; i++)
    5d10:	9f 5f       	subi	r25, 0xFF	; 255
    5d12:	98 30       	cpi	r25, 0x08	; 8
    5d14:	11 f0       	breq	.+4      	; 0x5d1a <write_value+0x2c>
		NOP;
		NOP;
		CLOCK_LOW;
		NOP;
		NOP;
		data <<= (BYTE)1;
    5d16:	88 0f       	add	r24, r24
    5d18:	ec cf       	rjmp	.-40     	; 0x5cf2 <write_value+0x4>
    5d1a:	08 95       	ret

00005d1c <ack>:
	}  
}

void ack()
{
    5d1c:	15 98       	cbi	0x02, 5	; 2
	CLR_BIT5(DDRE);	
	NOP;
    5d1e:	00 00       	nop
	NOP;
    5d20:	00 00       	nop
	DATA_HIGH;
    5d22:	1d 9a       	sbi	0x03, 5	; 3
	NOP;
    5d24:	00 00       	nop
	NOP;
    5d26:	00 00       	nop
	CLOCK_HIGH;
    5d28:	1c 9a       	sbi	0x03, 4	; 3
	NOP;
    5d2a:	00 00       	nop
	NOP;
    5d2c:	00 00       	nop
	CLOCK_LOW;
    5d2e:	1c 98       	cbi	0x03, 4	; 3
	NOP;
    5d30:	00 00       	nop
	NOP;
    5d32:	00 00       	nop
	SET_BIT5(DDRE);		
    5d34:	15 9a       	sbi	0x02, 5	; 2
	NOP;
    5d36:	00 00       	nop
	NOP;
    5d38:	00 00       	nop
}
    5d3a:	08 95       	ret

00005d3c <next_byte>:

void next_byte()
{
    5d3c:	15 9a       	sbi	0x02, 5	; 2
	SET_BIT5(DDRE);	
	NOP;
    5d3e:	00 00       	nop
	NOP;
    5d40:	00 00       	nop
	DATA_LOW; 		
    5d42:	1d 98       	cbi	0x03, 5	; 3
	NOP;
    5d44:	00 00       	nop
	NOP;
    5d46:	00 00       	nop
	CLOCK_HIGH; 	
    5d48:	1c 9a       	sbi	0x03, 4	; 3
	NOP;
    5d4a:	00 00       	nop
	NOP;
    5d4c:	00 00       	nop
	CLOCK_LOW; 		
    5d4e:	1c 98       	cbi	0x03, 4	; 3
	NOP;
    5d50:	00 00       	nop
	NOP;
    5d52:	00 00       	nop
	DATA_HIGH; 	   
    5d54:	1d 9a       	sbi	0x03, 5	; 3
	NOP;
    5d56:	00 00       	nop
	NOP;
    5d58:	00 00       	nop
}
    5d5a:	08 95       	ret

00005d5c <done_read>:

void done_read()
{
    5d5c:	15 9a       	sbi	0x02, 5	; 2
	SET_BIT5(DDRE);	
	NOP;
    5d5e:	00 00       	nop
	NOP;
    5d60:	00 00       	nop
	DATA_HIGH;  		
    5d62:	1d 9a       	sbi	0x03, 5	; 3
	NOP;
    5d64:	00 00       	nop
	NOP;
    5d66:	00 00       	nop
	CLOCK_HIGH; 		
    5d68:	1c 9a       	sbi	0x03, 4	; 3
	NOP;
    5d6a:	00 00       	nop
	NOP;
    5d6c:	00 00       	nop
	CLOCK_LOW;  		
    5d6e:	1c 98       	cbi	0x03, 4	; 3
	NOP;
    5d70:	00 00       	nop
	NOP;
    5d72:	00 00       	nop
}
    5d74:	08 95       	ret

00005d76 <cbyte>:

int cbyte(BYTE b)
{
    5d76:	28 2f       	mov	r18, r24
    5d78:	30 e0       	ldi	r19, 0x00	; 0
	int i;
	if (b>127) 
    5d7a:	87 ff       	sbrs	r24, 7
    5d7c:	02 c0       	rjmp	.+4      	; 0x5d82 <cbyte+0xc>
	{
		i=(int)b-256;
    5d7e:	20 50       	subi	r18, 0x00	; 0
    5d80:	31 40       	sbci	r19, 0x01	; 1
	else
	{
		i=(int)b;
	}
	return i;
}
    5d82:	c9 01       	movw	r24, r18
    5d84:	08 95       	ret

00005d86 <tilt_setup>:

	if (debug) rprintf (" z=%d\r\n", z_value);
}

void tilt_setup()
{
    5d86:	0e 94 49 2e 	call	0x5c92	; 0x5c92 <start_accel>
	start_accel();
	
	write_value(Slave_Addr);	 //write mode
    5d8a:	80 e7       	ldi	r24, 0x70	; 112
    5d8c:	0e 94 77 2e 	call	0x5cee	; 0x5cee <write_value>
	
	ack();
    5d90:	0e 94 8e 2e 	call	0x5d1c	; 0x5d1c <ack>
	 
	write_value(0x14);  		//0001 0100   (Guess - Data Rate and Resolution ?)
    5d94:	84 e1       	ldi	r24, 0x14	; 20
    5d96:	0e 94 77 2e 	call	0x5cee	; 0x5cee <write_value>
 
	ack();
    5d9a:	0e 94 8e 2e 	call	0x5d1c	; 0x5d1c <ack>

	write_value(0x03); 			//0000 0111   (Guess - Control register - enabel X, Y ,Z axis)
    5d9e:	83 e0       	ldi	r24, 0x03	; 3
    5da0:	0e 94 77 2e 	call	0x5cee	; 0x5cee <write_value>
	
	ack();
    5da4:	0e 94 8e 2e 	call	0x5d1c	; 0x5d1c <ack>

	stop_accel();
    5da8:	0e 94 56 2e 	call	0x5cac	; 0x5cac <stop_accel>
}
    5dac:	08 95       	ret

00005dae <AccStart>:

//==============================================================//
// Start
//==============================================================//
void AccStart(void)
{
    5dae:	15 9a       	sbi	0x02, 5	; 2
SDI_SET_OUTPUT;
SCK_SET_OUTPUT;
    5db0:	14 9a       	sbi	0x02, 4	; 2
	P_ACC_SDI(1);
    5db2:	1d 9a       	sbi	0x03, 5	; 3
	P_ACC_SCK(1);
    5db4:	1c 9a       	sbi	0x03, 4	; 3
	NOP;
    5db6:	00 00       	nop
	NOP;
    5db8:	00 00       	nop
	P_ACC_SDI(0);
    5dba:	1d 98       	cbi	0x03, 5	; 3
	NOP;
    5dbc:	00 00       	nop
	NOP;
    5dbe:	00 00       	nop
	P_ACC_SCK(0);
    5dc0:	1c 98       	cbi	0x03, 4	; 3
	NOP;
    5dc2:	00 00       	nop
	NOP;
    5dc4:	00 00       	nop
}
    5dc6:	08 95       	ret

00005dc8 <AccStop>:

//==============================================================//
// Stop
//==============================================================//
void AccStop(void)
{
    5dc8:	15 9a       	sbi	0x02, 5	; 2
	SDI_SET_OUTPUT;
	SCK_SET_OUTPUT;
    5dca:	14 9a       	sbi	0x02, 4	; 2
	P_ACC_SDI(0);
    5dcc:	1d 98       	cbi	0x03, 5	; 3
	P_ACC_SCK(1);
    5dce:	1c 9a       	sbi	0x03, 4	; 3
	NOP;
    5dd0:	00 00       	nop
	NOP;
    5dd2:	00 00       	nop
	P_ACC_SDI(1);
    5dd4:	1d 9a       	sbi	0x03, 5	; 3
	NOP;
    5dd6:	00 00       	nop
	NOP;
    5dd8:	00 00       	nop
	SDI_SET_INPUT;
    5dda:	15 98       	cbi	0x02, 5	; 2
	SCK_SET_INPUT;
    5ddc:	14 98       	cbi	0x02, 4	; 2
}
    5dde:	08 95       	ret

00005de0 <AccByteWrite>:

//==============================================================//
//
//==============================================================//
void AccByteWrite(BYTE bData)
{
    5de0:	15 9a       	sbi	0x02, 5	; 2
    5de2:	90 e0       	ldi	r25, 0x00	; 0
	BYTE	bTmp;

SDI_SET_OUTPUT;
	for(i=0; i<8; i++){
		bTmp = CHK_BIT7(bData);
    	if(bTmp){
    5de4:	87 ff       	sbrs	r24, 7
    5de6:	02 c0       	rjmp	.+4      	; 0x5dec <AccByteWrite+0xc>
			P_ACC_SDI(1);
    5de8:	1d 9a       	sbi	0x03, 5	; 3
    5dea:	01 c0       	rjmp	.+2      	; 0x5dee <AccByteWrite+0xe>
		}else{
			P_ACC_SDI(0);
    5dec:	1d 98       	cbi	0x03, 5	; 3
		}
		NOP;
    5dee:	00 00       	nop
		NOP;
    5df0:	00 00       	nop
		P_ACC_SCK(1);;
    5df2:	1c 9a       	sbi	0x03, 4	; 3
	...
		NOP;
		NOP;
		NOP;
		NOP;
		P_ACC_SCK(0);
    5dfc:	1c 98       	cbi	0x03, 4	; 3
		NOP;
    5dfe:	00 00       	nop
		NOP;
    5e00:	00 00       	nop
{
	BYTE	i;
	BYTE	bTmp;

SDI_SET_OUTPUT;
	for(i=0; i<8; i++){
    5e02:	9f 5f       	subi	r25, 0xFF	; 255
    5e04:	98 30       	cpi	r25, 0x08	; 8
    5e06:	11 f0       	breq	.+4      	; 0x5e0c <AccByteWrite+0x2c>
		NOP;
		NOP;
		P_ACC_SCK(0);
		NOP;
		NOP;
		bData =	bData << 1;
    5e08:	88 0f       	add	r24, r24
    5e0a:	ec cf       	rjmp	.-40     	; 0x5de4 <AccByteWrite+0x4>
    5e0c:	08 95       	ret

00005e0e <AccByteRead>:

//==============================================================//
//
//==============================================================//
char AccByteRead(void)
{
    5e0e:	15 98       	cbi	0x02, 5	; 2
    5e10:	90 e0       	ldi	r25, 0x00	; 0
    5e12:	80 e0       	ldi	r24, 0x00	; 0
	BYTE	i;
	char	bTmp = 0;

	SDI_SET_INPUT;
	for(i = 0; i < 8;	i++){
		bTmp = bTmp << 1;
    5e14:	88 0f       	add	r24, r24
	...
		NOP;
		NOP;
		NOP;
		NOP;
		P_ACC_SCK(1);
    5e1e:	1c 9a       	sbi	0x03, 4	; 3
		NOP;
    5e20:	00 00       	nop
		NOP;
    5e22:	00 00       	nop
		if(SDI_CHK)	bTmp |= 0x01;
    5e24:	0d 99       	sbic	0x01, 5	; 1
    5e26:	81 60       	ori	r24, 0x01	; 1
		NOP;
    5e28:	00 00       	nop
		NOP;
    5e2a:	00 00       	nop
		P_ACC_SCK(0);
    5e2c:	1c 98       	cbi	0x03, 4	; 3
{
	BYTE	i;
	char	bTmp = 0;

	SDI_SET_INPUT;
	for(i = 0; i < 8;	i++){
    5e2e:	9f 5f       	subi	r25, 0xFF	; 255
    5e30:	98 30       	cpi	r25, 0x08	; 8
    5e32:	81 f7       	brne	.-32     	; 0x5e14 <AccByteRead+0x6>
		if(SDI_CHK)	bTmp |= 0x01;
		NOP;
		NOP;
		P_ACC_SCK(0);
	}
	SDI_SET_OUTPUT;
    5e34:	15 9a       	sbi	0x02, 5	; 2

	return	bTmp;
}
    5e36:	08 95       	ret

00005e38 <AccAckRead>:

//==============================================================//
//
//==============================================================//
void AccAckRead(void)
{
    5e38:	15 98       	cbi	0x02, 5	; 2
SDI_SET_INPUT;
	NOP;
    5e3a:	00 00       	nop
	NOP;
    5e3c:	00 00       	nop
	P_ACC_SDI(1);
    5e3e:	1d 9a       	sbi	0x03, 5	; 3
	NOP;
    5e40:	00 00       	nop
	NOP;
    5e42:	00 00       	nop
	P_ACC_SCK(1);
    5e44:	1c 9a       	sbi	0x03, 4	; 3
	NOP;
    5e46:	00 00       	nop
	NOP;
    5e48:	00 00       	nop
	P_ACC_SCK(0);
    5e4a:	1c 98       	cbi	0x03, 4	; 3
	NOP;
    5e4c:	00 00       	nop
	NOP;
    5e4e:	00 00       	nop
SDI_SET_OUTPUT;
    5e50:	15 9a       	sbi	0x02, 5	; 2
	NOP;
    5e52:	00 00       	nop
	NOP;
    5e54:	00 00       	nop
}
    5e56:	08 95       	ret

00005e58 <AccAckWrite>:

//==============================================================//
//
//==============================================================//
void AccAckWrite(void)
{
    5e58:	15 9a       	sbi	0x02, 5	; 2
SDI_SET_OUTPUT;
	NOP;
    5e5a:	00 00       	nop
	NOP;
    5e5c:	00 00       	nop
	P_ACC_SDI(0);
    5e5e:	1d 98       	cbi	0x03, 5	; 3
	NOP;
    5e60:	00 00       	nop
	NOP;
    5e62:	00 00       	nop
	P_ACC_SCK(1);
    5e64:	1c 9a       	sbi	0x03, 4	; 3
	NOP;
    5e66:	00 00       	nop
	NOP;
    5e68:	00 00       	nop
	P_ACC_SCK(0);
    5e6a:	1c 98       	cbi	0x03, 4	; 3
	NOP;
    5e6c:	00 00       	nop
	NOP;
    5e6e:	00 00       	nop
	P_ACC_SDI(1);
    5e70:	1d 9a       	sbi	0x03, 5	; 3
	NOP;
    5e72:	00 00       	nop
	NOP;
    5e74:	00 00       	nop
}
    5e76:	08 95       	ret

00005e78 <AccNotAckWrite>:

//==============================================================//
//
//==============================================================//
void AccNotAckWrite(void)
{
    5e78:	15 9a       	sbi	0x02, 5	; 2
SDI_SET_OUTPUT;
	NOP;
    5e7a:	00 00       	nop
	NOP;
    5e7c:	00 00       	nop
	P_ACC_SDI(1);
    5e7e:	1d 9a       	sbi	0x03, 5	; 3
	NOP;
    5e80:	00 00       	nop
	NOP;
    5e82:	00 00       	nop
	P_ACC_SCK(1);
    5e84:	1c 9a       	sbi	0x03, 4	; 3
	NOP;
    5e86:	00 00       	nop
	NOP;
    5e88:	00 00       	nop
	P_ACC_SCK(0);
    5e8a:	1c 98       	cbi	0x03, 4	; 3
	NOP;
    5e8c:	00 00       	nop
	NOP;
    5e8e:	00 00       	nop
}
    5e90:	08 95       	ret

00005e92 <Acc_init>:


//==============================================================//
//==============================================================//
void Acc_init(void)
{
    5e92:	0e 94 d7 2e 	call	0x5dae	; 0x5dae <AccStart>
	AccStart();
	AccByteWrite(0x70);
    5e96:	80 e7       	ldi	r24, 0x70	; 112
    5e98:	0e 94 f0 2e 	call	0x5de0	; 0x5de0 <AccByteWrite>
	AccAckRead();
    5e9c:	0e 94 1c 2f 	call	0x5e38	; 0x5e38 <AccAckRead>
	AccByteWrite(0x14);
    5ea0:	84 e1       	ldi	r24, 0x14	; 20
    5ea2:	0e 94 f0 2e 	call	0x5de0	; 0x5de0 <AccByteWrite>
	AccAckRead();
    5ea6:	0e 94 1c 2f 	call	0x5e38	; 0x5e38 <AccAckRead>
	AccByteWrite(0x03);
    5eaa:	83 e0       	ldi	r24, 0x03	; 3
    5eac:	0e 94 f0 2e 	call	0x5de0	; 0x5de0 <AccByteWrite>
	AccAckRead();
    5eb0:	0e 94 1c 2f 	call	0x5e38	; 0x5e38 <AccAckRead>
	AccStop();
    5eb4:	0e 94 e4 2e 	call	0x5dc8	; 0x5dc8 <AccStop>
}
    5eb8:	08 95       	ret

00005eba <AccGetData>:

//==============================================================//
//==============================================================//
void AccGetData(void)
{
    5eba:	0f 93       	push	r16
    5ebc:	1f 93       	push	r17
	signed char	bTmp = 0;

	AccStart();
    5ebe:	0e 94 d7 2e 	call	0x5dae	; 0x5dae <AccStart>
	AccByteWrite(0x70);
    5ec2:	80 e7       	ldi	r24, 0x70	; 112
    5ec4:	0e 94 f0 2e 	call	0x5de0	; 0x5de0 <AccByteWrite>
	AccAckRead();
    5ec8:	0e 94 1c 2f 	call	0x5e38	; 0x5e38 <AccAckRead>
	AccByteWrite(0x02);
    5ecc:	82 e0       	ldi	r24, 0x02	; 2
    5ece:	0e 94 f0 2e 	call	0x5de0	; 0x5de0 <AccByteWrite>
	AccAckRead();
    5ed2:	0e 94 1c 2f 	call	0x5e38	; 0x5e38 <AccAckRead>
	AccStop();
    5ed6:	0e 94 e4 2e 	call	0x5dc8	; 0x5dc8 <AccStop>
	...
	NOP;
	NOP;
	NOP;
	NOP;

	AccStart();
    5ee2:	0e 94 d7 2e 	call	0x5dae	; 0x5dae <AccStart>
	AccByteWrite(0x71);
    5ee6:	81 e7       	ldi	r24, 0x71	; 113
    5ee8:	0e 94 f0 2e 	call	0x5de0	; 0x5de0 <AccByteWrite>
	AccAckRead();
    5eec:	0e 94 1c 2f 	call	0x5e38	; 0x5e38 <AccAckRead>

	bTmp = AccByteRead();
    5ef0:	0e 94 07 2f 	call	0x5e0e	; 0x5e0e <AccByteRead>
	AccAckWrite();
    5ef4:	0e 94 2c 2f 	call	0x5e58	; 0x5e58 <AccAckWrite>

	bTmp = AccByteRead();
    5ef8:	0e 94 07 2f 	call	0x5e0e	; 0x5e0e <AccByteRead>
    5efc:	08 2f       	mov	r16, r24
	AccAckWrite();
    5efe:	0e 94 2c 2f 	call	0x5e58	; 0x5e58 <AccAckWrite>
	gAccX = bTmp;
    5f02:	11 27       	eor	r17, r17
    5f04:	07 fd       	sbrc	r16, 7
    5f06:	10 95       	com	r17
    5f08:	10 93 aa 0d 	sts	0x0DAA, r17
    5f0c:	00 93 a9 0d 	sts	0x0DA9, r16

	bTmp = AccByteRead();
    5f10:	0e 94 07 2f 	call	0x5e0e	; 0x5e0e <AccByteRead>
	AccAckWrite();
    5f14:	0e 94 2c 2f 	call	0x5e58	; 0x5e58 <AccAckWrite>

	bTmp = AccByteRead();
    5f18:	0e 94 07 2f 	call	0x5e0e	; 0x5e0e <AccByteRead>
    5f1c:	08 2f       	mov	r16, r24
	AccAckWrite();
    5f1e:	0e 94 2c 2f 	call	0x5e58	; 0x5e58 <AccAckWrite>
	gAccY = bTmp;
    5f22:	11 27       	eor	r17, r17
    5f24:	07 fd       	sbrc	r16, 7
    5f26:	10 95       	com	r17
    5f28:	10 93 ac 0d 	sts	0x0DAC, r17
    5f2c:	00 93 ab 0d 	sts	0x0DAB, r16

	bTmp = AccByteRead();
    5f30:	0e 94 07 2f 	call	0x5e0e	; 0x5e0e <AccByteRead>
	AccAckWrite();
    5f34:	0e 94 2c 2f 	call	0x5e58	; 0x5e58 <AccAckWrite>

	bTmp = AccByteRead();
    5f38:	0e 94 07 2f 	call	0x5e0e	; 0x5e0e <AccByteRead>
    5f3c:	08 2f       	mov	r16, r24
	AccNotAckWrite();
    5f3e:	0e 94 3c 2f 	call	0x5e78	; 0x5e78 <AccNotAckWrite>
	gAccZ = bTmp;
    5f42:	11 27       	eor	r17, r17
    5f44:	07 fd       	sbrc	r16, 7
    5f46:	10 95       	com	r17
    5f48:	10 93 ae 0d 	sts	0x0DAE, r17
    5f4c:	00 93 ad 0d 	sts	0x0DAD, r16

	AccStop();
    5f50:	0e 94 e4 2e 	call	0x5dc8	; 0x5dc8 <AccStop>
}
    5f54:	1f 91       	pop	r17
    5f56:	0f 91       	pop	r16
    5f58:	08 95       	ret

00005f5a <tilt_read>:
	return i;
}


void tilt_read(BYTE debug)
{
    5f5a:	1f 93       	push	r17
    5f5c:	18 2f       	mov	r17, r24
	BYTE tmp;
	
	start_accel();
    5f5e:	0e 94 49 2e 	call	0x5c92	; 0x5c92 <start_accel>
	
	write_value(Slave_Addr);	  	//? slave Addr write mode
    5f62:	80 e7       	ldi	r24, 0x70	; 112
    5f64:	0e 94 77 2e 	call	0x5cee	; 0x5cee <write_value>
	ack();
    5f68:	0e 94 8e 2e 	call	0x5d1c	; 0x5d1c <ack>
	 
	write_value(0x02);  			//?   0000 0010
    5f6c:	82 e0       	ldi	r24, 0x02	; 2
    5f6e:	0e 94 77 2e 	call	0x5cee	; 0x5cee <write_value>

	ack();
    5f72:	0e 94 8e 2e 	call	0x5d1c	; 0x5d1c <ack>

	stop_accel();
    5f76:	0e 94 56 2e 	call	0x5cac	; 0x5cac <stop_accel>
	...
	
	NOP; NOP; NOP; NOP;

	start_accel();
    5f82:	0e 94 49 2e 	call	0x5c92	; 0x5c92 <start_accel>

	write_value(Slave_Addr+0x01);	  //Save_Addr + ReadBit
    5f86:	81 e7       	ldi	r24, 0x71	; 113
    5f88:	0e 94 77 2e 	call	0x5cee	; 0x5cee <write_value>
	
	ack();
    5f8c:	0e 94 8e 2e 	call	0x5d1c	; 0x5d1c <ack>

	tmp = read_value();
    5f90:	0e 94 62 2e 	call	0x5cc4	; 0x5cc4 <read_value>
	
	next_byte();
    5f94:	0e 94 9e 2e 	call	0x5d3c	; 0x5d3c <next_byte>

	x_value = cbyte(read_value());
    5f98:	0e 94 62 2e 	call	0x5cc4	; 0x5cc4 <read_value>
    5f9c:	28 2f       	mov	r18, r24
    5f9e:	30 e0       	ldi	r19, 0x00	; 0
}

int cbyte(BYTE b)
{
	int i;
	if (b>127) 
    5fa0:	87 ff       	sbrs	r24, 7
    5fa2:	04 c0       	rjmp	.+8      	; 0x5fac <tilt_read+0x52>
	{
		i=(int)b-256;
    5fa4:	c9 01       	movw	r24, r18
    5fa6:	80 50       	subi	r24, 0x00	; 0
    5fa8:	91 40       	sbci	r25, 0x01	; 1
    5faa:	01 c0       	rjmp	.+2      	; 0x5fae <tilt_read+0x54>
	}
	else
	{
		i=(int)b;
    5fac:	c9 01       	movw	r24, r18

	tmp = read_value();
	
	next_byte();

	x_value = cbyte(read_value());
    5fae:	90 93 a6 0d 	sts	0x0DA6, r25
    5fb2:	80 93 a5 0d 	sts	0x0DA5, r24

	if (debug) rprintf ("Values x= %d", x_value);
    5fb6:	11 23       	and	r17, r17
    5fb8:	99 f0       	breq	.+38     	; 0x5fe0 <tilt_read+0x86>
    5fba:	80 91 a5 0d 	lds	r24, 0x0DA5
    5fbe:	90 91 a6 0d 	lds	r25, 0x0DA6
    5fc2:	9f 93       	push	r25
    5fc4:	8f 93       	push	r24
    5fc6:	88 eb       	ldi	r24, 0xB8	; 184
    5fc8:	94 e3       	ldi	r25, 0x34	; 52
    5fca:	9f 93       	push	r25
    5fcc:	8f 93       	push	r24
    5fce:	81 e0       	ldi	r24, 0x01	; 1
    5fd0:	8f 93       	push	r24
    5fd2:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
    5fd6:	0f 90       	pop	r0
    5fd8:	0f 90       	pop	r0
    5fda:	0f 90       	pop	r0
    5fdc:	0f 90       	pop	r0
    5fde:	0f 90       	pop	r0

	next_byte();
    5fe0:	0e 94 9e 2e 	call	0x5d3c	; 0x5d3c <next_byte>

	tmp = read_value();
    5fe4:	0e 94 62 2e 	call	0x5cc4	; 0x5cc4 <read_value>

	next_byte();
    5fe8:	0e 94 9e 2e 	call	0x5d3c	; 0x5d3c <next_byte>

	y_value = cbyte(read_value());
    5fec:	0e 94 62 2e 	call	0x5cc4	; 0x5cc4 <read_value>
    5ff0:	28 2f       	mov	r18, r24
    5ff2:	30 e0       	ldi	r19, 0x00	; 0
}

int cbyte(BYTE b)
{
	int i;
	if (b>127) 
    5ff4:	87 ff       	sbrs	r24, 7
    5ff6:	04 c0       	rjmp	.+8      	; 0x6000 <tilt_read+0xa6>
	{
		i=(int)b-256;
    5ff8:	c9 01       	movw	r24, r18
    5ffa:	80 50       	subi	r24, 0x00	; 0
    5ffc:	91 40       	sbci	r25, 0x01	; 1
    5ffe:	01 c0       	rjmp	.+2      	; 0x6002 <tilt_read+0xa8>
	}
	else
	{
		i=(int)b;
    6000:	c9 01       	movw	r24, r18

	tmp = read_value();

	next_byte();

	y_value = cbyte(read_value());
    6002:	90 93 a8 0d 	sts	0x0DA8, r25
    6006:	80 93 a7 0d 	sts	0x0DA7, r24
	
	if (debug) rprintf (", y=%d,", y_value);
    600a:	11 23       	and	r17, r17
    600c:	99 f0       	breq	.+38     	; 0x6034 <tilt_read+0xda>
    600e:	80 91 a7 0d 	lds	r24, 0x0DA7
    6012:	90 91 a8 0d 	lds	r25, 0x0DA8
    6016:	9f 93       	push	r25
    6018:	8f 93       	push	r24
    601a:	80 eb       	ldi	r24, 0xB0	; 176
    601c:	94 e3       	ldi	r25, 0x34	; 52
    601e:	9f 93       	push	r25
    6020:	8f 93       	push	r24
    6022:	81 e0       	ldi	r24, 0x01	; 1
    6024:	8f 93       	push	r24
    6026:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
    602a:	0f 90       	pop	r0
    602c:	0f 90       	pop	r0
    602e:	0f 90       	pop	r0
    6030:	0f 90       	pop	r0
    6032:	0f 90       	pop	r0

	next_byte();
    6034:	0e 94 9e 2e 	call	0x5d3c	; 0x5d3c <next_byte>

	tmp = read_value();
    6038:	0e 94 62 2e 	call	0x5cc4	; 0x5cc4 <read_value>
	
	next_byte();
    603c:	0e 94 9e 2e 	call	0x5d3c	; 0x5d3c <next_byte>

	z_value = cbyte(read_value());
    6040:	0e 94 62 2e 	call	0x5cc4	; 0x5cc4 <read_value>
    6044:	28 2f       	mov	r18, r24
    6046:	30 e0       	ldi	r19, 0x00	; 0
}

int cbyte(BYTE b)
{
	int i;
	if (b>127) 
    6048:	87 ff       	sbrs	r24, 7
    604a:	04 c0       	rjmp	.+8      	; 0x6054 <tilt_read+0xfa>
	{
		i=(int)b-256;
    604c:	c9 01       	movw	r24, r18
    604e:	80 50       	subi	r24, 0x00	; 0
    6050:	91 40       	sbci	r25, 0x01	; 1
    6052:	01 c0       	rjmp	.+2      	; 0x6056 <tilt_read+0xfc>
	}
	else
	{
		i=(int)b;
    6054:	c9 01       	movw	r24, r18

	tmp = read_value();
	
	next_byte();

	z_value = cbyte(read_value());
    6056:	90 93 b0 0d 	sts	0x0DB0, r25
    605a:	80 93 af 0d 	sts	0x0DAF, r24

	done_read();
    605e:	0e 94 ae 2e 	call	0x5d5c	; 0x5d5c <done_read>
	

	stop_accel();
    6062:	0e 94 56 2e 	call	0x5cac	; 0x5cac <stop_accel>

	if (debug) rprintf (" z=%d\r\n", z_value);
    6066:	11 23       	and	r17, r17
    6068:	99 f0       	breq	.+38     	; 0x6090 <tilt_read+0x136>
    606a:	80 91 af 0d 	lds	r24, 0x0DAF
    606e:	90 91 b0 0d 	lds	r25, 0x0DB0
    6072:	9f 93       	push	r25
    6074:	8f 93       	push	r24
    6076:	88 ea       	ldi	r24, 0xA8	; 168
    6078:	94 e3       	ldi	r25, 0x34	; 52
    607a:	9f 93       	push	r25
    607c:	8f 93       	push	r24
    607e:	81 e0       	ldi	r24, 0x01	; 1
    6080:	8f 93       	push	r24
    6082:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
    6086:	0f 90       	pop	r0
    6088:	0f 90       	pop	r0
    608a:	0f 90       	pop	r0
    608c:	0f 90       	pop	r0
    608e:	0f 90       	pop	r0
}
    6090:	1f 91       	pop	r17
    6092:	08 95       	ret

00006094 <idle_mainloop>:

static void handle_ir(int cmd) {
	if (0x07 == cmd) exitToExperimental(); // (square button)
}

void idle_mainloop(void) {
    6094:	7f 92       	push	r7
    6096:	8f 92       	push	r8
    6098:	9f 92       	push	r9
    609a:	af 92       	push	r10
    609c:	bf 92       	push	r11
    609e:	cf 92       	push	r12
    60a0:	df 92       	push	r13
    60a2:	ef 92       	push	r14
    60a4:	ff 92       	push	r15
    60a6:	0f 93       	push	r16
    60a8:	1f 93       	push	r17
    60aa:	cf 93       	push	r28
    60ac:	df 93       	push	r29
	if ('p' == cmd || 'P' == cmd) exitToExperimental();
	if ('s' == cmd || 'S' == cmd) exitToSerialSlave();
	if ('r' == cmd || 'R' == cmd) basic_run(0);
	if ('c' == cmd || 'C' == cmd) gNextMode = kChargeMode;
	if ('?' == cmd) {
		rprintf("\nIdle mode\n");
    60ae:	35 ec       	ldi	r19, 0xC5	; 197
    60b0:	83 2e       	mov	r8, r19
    60b2:	34 e3       	ldi	r19, 0x34	; 52
    60b4:	93 2e       	mov	r9, r19
    60b6:	77 24       	eor	r7, r7
    60b8:	73 94       	inc	r7
static void handle_serial(int cmd) {
	if ('b' == cmd || 'b' == cmd) gNextMode = kBinMode;
	if ('p' == cmd || 'P' == cmd) exitToExperimental();
	if ('s' == cmd || 'S' == cmd) exitToSerialSlave();
	if ('r' == cmd || 'R' == cmd) basic_run(0);
	if ('c' == cmd || 'C' == cmd) gNextMode = kChargeMode;
    60ba:	22 e0       	ldi	r18, 0x02	; 2
    60bc:	a2 2e       	mov	r10, r18
    60be:	b1 2c       	mov	r11, r1
	gNextMode = kExperimentalMode;
}

static void exitToSerialSlave(void) {
	// Switch to serial-slave mode
	gNextMode = kSerialSlaveMode;
    60c0:	94 e0       	ldi	r25, 0x04	; 4
    60c2:	c9 2e       	mov	r12, r25
    60c4:	d1 2c       	mov	r13, r1


static void exitToExperimental(void) {
	// Go to basic pose, and then switch to experimental mode
	//BasicPose();
	gNextMode = kExperimentalMode;
    60c6:	01 e0       	ldi	r16, 0x01	; 1
    60c8:	10 e0       	ldi	r17, 0x00	; 0
	gNextMode = kSerialSlaveMode;
}
	

static void handle_serial(int cmd) {
	if ('b' == cmd || 'b' == cmd) gNextMode = kBinMode;
    60ca:	86 e0       	ldi	r24, 0x06	; 6
    60cc:	e8 2e       	mov	r14, r24
    60ce:	f1 2c       	mov	r15, r1
    60d0:	49 c0       	rjmp	.+146    	; 0x6164 <idle_mainloop+0xd0>

	int cmd;

	while (kIdleMode == gNextMode) {

		cmd = uartGetByte();
    60d2:	0e 94 9c 22 	call	0x4538	; 0x4538 <uartGetByte>
    60d6:	ec 01       	movw	r28, r24
		if (cmd >= 0) handle_serial(cmd);
    60d8:	97 fd       	sbrc	r25, 7
    60da:	3a c0       	rjmp	.+116    	; 0x6150 <idle_mainloop+0xbc>
	gNextMode = kSerialSlaveMode;
}
	

static void handle_serial(int cmd) {
	if ('b' == cmd || 'b' == cmd) gNextMode = kBinMode;
    60dc:	82 36       	cpi	r24, 0x62	; 98
    60de:	91 05       	cpc	r25, r1
    60e0:	29 f4       	brne	.+10     	; 0x60ec <idle_mainloop+0x58>
    60e2:	f0 92 80 0b 	sts	0x0B80, r15
    60e6:	e0 92 7f 0b 	sts	0x0B7F, r14
    60ea:	0d c0       	rjmp	.+26     	; 0x6106 <idle_mainloop+0x72>
	if ('p' == cmd || 'P' == cmd) exitToExperimental();
    60ec:	80 37       	cpi	r24, 0x70	; 112
    60ee:	91 05       	cpc	r25, r1
    60f0:	19 f0       	breq	.+6      	; 0x60f8 <idle_mainloop+0x64>
    60f2:	80 35       	cpi	r24, 0x50	; 80
    60f4:	91 05       	cpc	r25, r1
    60f6:	21 f4       	brne	.+8      	; 0x6100 <idle_mainloop+0x6c>


static void exitToExperimental(void) {
	// Go to basic pose, and then switch to experimental mode
	//BasicPose();
	gNextMode = kExperimentalMode;
    60f8:	10 93 80 0b 	sts	0x0B80, r17
    60fc:	00 93 7f 0b 	sts	0x0B7F, r16
	

static void handle_serial(int cmd) {
	if ('b' == cmd || 'b' == cmd) gNextMode = kBinMode;
	if ('p' == cmd || 'P' == cmd) exitToExperimental();
	if ('s' == cmd || 'S' == cmd) exitToSerialSlave();
    6100:	c3 37       	cpi	r28, 0x73	; 115
    6102:	d1 05       	cpc	r29, r1
    6104:	19 f0       	breq	.+6      	; 0x610c <idle_mainloop+0x78>
    6106:	c3 35       	cpi	r28, 0x53	; 83
    6108:	d1 05       	cpc	r29, r1
    610a:	21 f4       	brne	.+8      	; 0x6114 <idle_mainloop+0x80>
	gNextMode = kExperimentalMode;
}

static void exitToSerialSlave(void) {
	// Switch to serial-slave mode
	gNextMode = kSerialSlaveMode;
    610c:	d0 92 80 0b 	sts	0x0B80, r13
    6110:	c0 92 7f 0b 	sts	0x0B7F, r12

static void handle_serial(int cmd) {
	if ('b' == cmd || 'b' == cmd) gNextMode = kBinMode;
	if ('p' == cmd || 'P' == cmd) exitToExperimental();
	if ('s' == cmd || 'S' == cmd) exitToSerialSlave();
	if ('r' == cmd || 'R' == cmd) basic_run(0);
    6114:	c2 37       	cpi	r28, 0x72	; 114
    6116:	d1 05       	cpc	r29, r1
    6118:	19 f0       	breq	.+6      	; 0x6120 <idle_mainloop+0x8c>
    611a:	c2 35       	cpi	r28, 0x52	; 82
    611c:	d1 05       	cpc	r29, r1
    611e:	21 f4       	brne	.+8      	; 0x6128 <idle_mainloop+0x94>
    6120:	80 e0       	ldi	r24, 0x00	; 0
    6122:	90 e0       	ldi	r25, 0x00	; 0
    6124:	0e 94 b0 4e 	call	0x9d60	; 0x9d60 <basic_run>
	if ('c' == cmd || 'C' == cmd) gNextMode = kChargeMode;
    6128:	c3 36       	cpi	r28, 0x63	; 99
    612a:	d1 05       	cpc	r29, r1
    612c:	19 f0       	breq	.+6      	; 0x6134 <idle_mainloop+0xa0>
    612e:	c3 34       	cpi	r28, 0x43	; 67
    6130:	d1 05       	cpc	r29, r1
    6132:	21 f4       	brne	.+8      	; 0x613c <idle_mainloop+0xa8>
    6134:	b0 92 80 0b 	sts	0x0B80, r11
    6138:	a0 92 7f 0b 	sts	0x0B7F, r10
	if ('?' == cmd) {
    613c:	ef 97       	sbiw	r28, 0x3f	; 63
    613e:	41 f4       	brne	.+16     	; 0x6150 <idle_mainloop+0xbc>
		rprintf("\nIdle mode\n");
    6140:	9f 92       	push	r9
    6142:	8f 92       	push	r8
    6144:	7f 92       	push	r7
    6146:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
    614a:	0f 90       	pop	r0
    614c:	0f 90       	pop	r0
    614e:	0f 90       	pop	r0
	while (kIdleMode == gNextMode) {

		cmd = uartGetByte();
		if (cmd >= 0) handle_serial(cmd);

		cmd = irGetByte();
    6150:	0e 94 3a 2e 	call	0x5c74	; 0x5c74 <irGetByte>
		if (cmd >= 0) handle_ir(cmd);
    6154:	97 fd       	sbrc	r25, 7
    6156:	06 c0       	rjmp	.+12     	; 0x6164 <idle_mainloop+0xd0>
		rprintf("\nIdle mode\n");
	}
}

static void handle_ir(int cmd) {
	if (0x07 == cmd) exitToExperimental(); // (square button)
    6158:	07 97       	sbiw	r24, 0x07	; 7
    615a:	21 f4       	brne	.+8      	; 0x6164 <idle_mainloop+0xd0>


static void exitToExperimental(void) {
	// Go to basic pose, and then switch to experimental mode
	//BasicPose();
	gNextMode = kExperimentalMode;
    615c:	10 93 80 0b 	sts	0x0B80, r17
    6160:	00 93 7f 0b 	sts	0x0B7F, r16

void idle_mainloop(void) {

	int cmd;

	while (kIdleMode == gNextMode) {
    6164:	80 91 7f 0b 	lds	r24, 0x0B7F
    6168:	90 91 80 0b 	lds	r25, 0x0B80
    616c:	89 2b       	or	r24, r25
    616e:	09 f4       	brne	.+2      	; 0x6172 <idle_mainloop+0xde>
    6170:	b0 cf       	rjmp	.-160    	; 0x60d2 <idle_mainloop+0x3e>
		
		// Here we should also check hardware buttons -- perhaps one
		// to enter pose mode, and both (held for a while) to enter
		// battery-charging mode.
	}
}
    6172:	df 91       	pop	r29
    6174:	cf 91       	pop	r28
    6176:	1f 91       	pop	r17
    6178:	0f 91       	pop	r16
    617a:	ff 90       	pop	r15
    617c:	ef 90       	pop	r14
    617e:	df 90       	pop	r13
    6180:	cf 90       	pop	r12
    6182:	bf 90       	pop	r11
    6184:	af 90       	pop	r10
    6186:	9f 90       	pop	r9
    6188:	8f 90       	pop	r8
    618a:	7f 90       	pop	r7
    618c:	08 95       	ret

0000618e <check_buttons>:
	}
	return n;
}

void check_buttons(BYTE *action)
{
    618e:	fc 01       	movw	r30, r24
	BYTE tmp;

	tmp = PINA & 0x03;			// buttons are bits 0 and 1 on port A
    6190:	29 b3       	in	r18, 0x19	; 25
    6192:	23 70       	andi	r18, 0x03	; 3
	if((tmp!=0x03))
    6194:	23 30       	cpi	r18, 0x03	; 3
    6196:	81 f0       	breq	.+32     	; 0x61b8 <check_buttons+0x2a>
	{								// low if a button is pressed
		if(++gBtnCnt>100){   		// loop 100 times
    6198:	80 91 83 0b 	lds	r24, 0x0B83
    619c:	90 91 84 0b 	lds	r25, 0x0B84
    61a0:	01 96       	adiw	r24, 0x01	; 1
    61a2:	90 93 84 0b 	sts	0x0B84, r25
    61a6:	80 93 83 0b 	sts	0x0B83, r24
    61aa:	85 36       	cpi	r24, 0x65	; 101
    61ac:	91 05       	cpc	r25, r1
    61ae:	40 f0       	brcs	.+16     	; 0x61c0 <check_buttons+0x32>
			if(tmp==0x02){		// if PF1 only is pressed
    61b0:	22 30       	cpi	r18, 0x02	; 2
    61b2:	31 f4       	brne	.+12     	; 0x61c0 <check_buttons+0x32>
				*action=0x00;
    61b4:	10 82       	st	Z, r1
    61b6:	08 95       	ret
			}
		}
	}
	else{
	    gBtnCnt=0;
    61b8:	10 92 84 0b 	sts	0x0B84, r1
    61bc:	10 92 83 0b 	sts	0x0B83, r1
    61c0:	08 95       	ret

000061c2 <ptime>:
void experimental_binloop();

#define MAX_INP_BUF 32

void ptime()
{
    61c2:	60 91 be 0a 	lds	r22, 0x0ABE
    61c6:	70 91 bf 0a 	lds	r23, 0x0ABF
    61ca:	80 91 ba 0a 	lds	r24, 0x0ABA
    61ce:	20 91 9d 0a 	lds	r18, 0x0A9D
    61d2:	40 91 b5 0a 	lds	r20, 0x0AB5
    61d6:	7f 93       	push	r23
    61d8:	6f 93       	push	r22
    61da:	90 e0       	ldi	r25, 0x00	; 0
    61dc:	9f 93       	push	r25
    61de:	8f 93       	push	r24
    61e0:	30 e0       	ldi	r19, 0x00	; 0
    61e2:	3f 93       	push	r19
    61e4:	2f 93       	push	r18
    61e6:	50 e0       	ldi	r21, 0x00	; 0
    61e8:	5f 93       	push	r21
    61ea:	4f 93       	push	r20
    61ec:	8d ed       	ldi	r24, 0xDD	; 221
    61ee:	9a e3       	ldi	r25, 0x3A	; 58
    61f0:	9f 93       	push	r25
    61f2:	8f 93       	push	r24
    61f4:	81 e0       	ldi	r24, 0x01	; 1
    61f6:	8f 93       	push	r24
    61f8:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
    61fc:	8d b7       	in	r24, 0x3d	; 61
    61fe:	9e b7       	in	r25, 0x3e	; 62
    6200:	0b 96       	adiw	r24, 0x0b	; 11
    6202:	0f b6       	in	r0, 0x3f	; 63
    6204:	f8 94       	cli
    6206:	9e bf       	out	0x3e, r25	; 62
    6208:	0f be       	out	0x3f, r0	; 63
    620a:	8d bf       	out	0x3d, r24	; 61
	rprintf("%d:%d:%d-%d ",gHOUR,gMIN,gSEC,gMSEC);
}
    620c:	08 95       	ret

0000620e <check_IR>:
    }
}


void check_IR(BYTE *action)
{
    620e:	1f 93       	push	r17
    6210:	cf 93       	push	r28
    6212:	df 93       	push	r29
    6214:	ec 01       	movw	r28, r24
	if ( gIRReady) 
    6216:	80 91 9d 0d 	lds	r24, 0x0D9D
    621a:	88 23       	and	r24, r24
    621c:	09 f4       	brne	.+2      	; 0x6220 <check_IR+0x12>
    621e:	79 c0       	rjmp	.+242    	; 0x6312 <check_IR+0x104>
	{
		gIRReady = FALSE;
    6220:	10 92 9d 0d 	sts	0x0D9D, r1

#define MAX_INP_BUF 32

void ptime()
{
	rprintf("%d:%d:%d-%d ",gHOUR,gMIN,gSEC,gMSEC);
    6224:	60 91 be 0a 	lds	r22, 0x0ABE
    6228:	70 91 bf 0a 	lds	r23, 0x0ABF
    622c:	80 91 ba 0a 	lds	r24, 0x0ABA
    6230:	20 91 9d 0a 	lds	r18, 0x0A9D
    6234:	40 91 b5 0a 	lds	r20, 0x0AB5
    6238:	7f 93       	push	r23
    623a:	6f 93       	push	r22
    623c:	90 e0       	ldi	r25, 0x00	; 0
    623e:	9f 93       	push	r25
    6240:	8f 93       	push	r24
    6242:	30 e0       	ldi	r19, 0x00	; 0
    6244:	3f 93       	push	r19
    6246:	2f 93       	push	r18
    6248:	50 e0       	ldi	r21, 0x00	; 0
    624a:	5f 93       	push	r21
    624c:	4f 93       	push	r20
    624e:	8d ed       	ldi	r24, 0xDD	; 221
    6250:	9a e3       	ldi	r25, 0x3A	; 58
    6252:	9f 93       	push	r25
    6254:	8f 93       	push	r24
    6256:	11 e0       	ldi	r17, 0x01	; 1
    6258:	1f 93       	push	r17
    625a:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
{
	if ( gIRReady) 
	{
		gIRReady = FALSE;
		ptime();
		rprintf(" IR Received %x from %x\r\n", gIRData, gIRAddr);
    625e:	80 91 9a 0d 	lds	r24, 0x0D9A
    6262:	20 91 a0 0d 	lds	r18, 0x0DA0
    6266:	90 e0       	ldi	r25, 0x00	; 0
    6268:	9f 93       	push	r25
    626a:	8f 93       	push	r24
    626c:	30 e0       	ldi	r19, 0x00	; 0
    626e:	3f 93       	push	r19
    6270:	2f 93       	push	r18
    6272:	8d eb       	ldi	r24, 0xBD	; 189
    6274:	9a e3       	ldi	r25, 0x3A	; 58
    6276:	9f 93       	push	r25
    6278:	8f 93       	push	r24
    627a:	1f 93       	push	r17
    627c:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
		if (gIRData==0x01) *action=0x00; // A pressed
    6280:	80 91 a0 0d 	lds	r24, 0x0DA0
    6284:	2d b7       	in	r18, 0x3d	; 61
    6286:	3e b7       	in	r19, 0x3e	; 62
    6288:	2e 5e       	subi	r18, 0xEE	; 238
    628a:	3f 4f       	sbci	r19, 0xFF	; 255
    628c:	0f b6       	in	r0, 0x3f	; 63
    628e:	f8 94       	cli
    6290:	3e bf       	out	0x3e, r19	; 62
    6292:	0f be       	out	0x3f, r0	; 63
    6294:	2d bf       	out	0x3d, r18	; 61
    6296:	81 30       	cpi	r24, 0x01	; 1
    6298:	09 f4       	brne	.+2      	; 0x629c <check_IR+0x8e>
    629a:	18 82       	st	Y, r1
		if (gIRData==0x02) *action=0x01; // B pressed
    629c:	80 91 a0 0d 	lds	r24, 0x0DA0
    62a0:	82 30       	cpi	r24, 0x02	; 2
    62a2:	11 f4       	brne	.+4      	; 0x62a8 <check_IR+0x9a>
    62a4:	81 e0       	ldi	r24, 0x01	; 1
    62a6:	88 83       	st	Y, r24
		if (gIRData==0x03) *action=0x04; // Turn left
    62a8:	80 91 a0 0d 	lds	r24, 0x0DA0
    62ac:	83 30       	cpi	r24, 0x03	; 3
    62ae:	11 f4       	brne	.+4      	; 0x62b4 <check_IR+0xa6>
    62b0:	84 e0       	ldi	r24, 0x04	; 4
    62b2:	88 83       	st	Y, r24
		if (gIRData==0x04) *action=0x08; // Forward
    62b4:	80 91 a0 0d 	lds	r24, 0x0DA0
    62b8:	84 30       	cpi	r24, 0x04	; 4
    62ba:	11 f4       	brne	.+4      	; 0x62c0 <check_IR+0xb2>
    62bc:	88 e0       	ldi	r24, 0x08	; 8
    62be:	88 83       	st	Y, r24
		if (gIRData==0x05) *action=0x05; // Turn Right
    62c0:	80 91 a0 0d 	lds	r24, 0x0DA0
    62c4:	85 30       	cpi	r24, 0x05	; 5
    62c6:	09 f4       	brne	.+2      	; 0x62ca <check_IR+0xbc>
    62c8:	88 83       	st	Y, r24
		if (gIRData==0x0A) *action=0x09; // Back
    62ca:	80 91 a0 0d 	lds	r24, 0x0DA0
    62ce:	8a 30       	cpi	r24, 0x0A	; 10
    62d0:	11 f4       	brne	.+4      	; 0x62d6 <check_IR+0xc8>
    62d2:	89 e0       	ldi	r24, 0x09	; 9
    62d4:	88 83       	st	Y, r24
		
		if (gIRData==0x07) *action=0x20; // [] pressed
    62d6:	80 91 a0 0d 	lds	r24, 0x0DA0
    62da:	87 30       	cpi	r24, 0x07	; 7
    62dc:	11 f4       	brne	.+4      	; 0x62e2 <check_IR+0xd4>
    62de:	80 e2       	ldi	r24, 0x20	; 32
    62e0:	88 83       	st	Y, r24
		if (gIRData==0x1c) *action=0x30; // * + [] pressed   (Flash Lights)
    62e2:	80 91 a0 0d 	lds	r24, 0x0DA0
    62e6:	8c 31       	cpi	r24, 0x1C	; 28
    62e8:	11 f4       	brne	.+4      	; 0x62ee <check_IR+0xe0>
    62ea:	80 e3       	ldi	r24, 0x30	; 48
    62ec:	88 83       	st	Y, r24
		if (gIRData==0x3F) *action=0x40; // # + 0 pressed    (Run ADC test)
    62ee:	80 91 a0 0d 	lds	r24, 0x0DA0
    62f2:	8f 33       	cpi	r24, 0x3F	; 63
    62f4:	11 f4       	brne	.+4      	; 0x62fa <check_IR+0xec>
    62f6:	80 e4       	ldi	r24, 0x40	; 64
    62f8:	88 83       	st	Y, r24
		if (gIRData==0x34) *action=0x50; // # + V pressed    (Run tilt test)
    62fa:	80 91 a0 0d 	lds	r24, 0x0DA0
    62fe:	84 33       	cpi	r24, 0x34	; 52
    6300:	11 f4       	brne	.+4      	; 0x6306 <check_IR+0xf8>
    6302:	80 e5       	ldi	r24, 0x50	; 80
    6304:	88 83       	st	Y, r24

		if (gIRData==0x2A) *action=0xC1; // * + 0 pressed    (Run program)
    6306:	80 91 a0 0d 	lds	r24, 0x0DA0
    630a:	8a 32       	cpi	r24, 0x2A	; 42
    630c:	11 f4       	brne	.+4      	; 0x6312 <check_IR+0x104>
    630e:	81 ec       	ldi	r24, 0xC1	; 193
    6310:	88 83       	st	Y, r24
		
	}
}
    6312:	df 91       	pop	r29
    6314:	cf 91       	pop	r28
    6316:	1f 91       	pop	r17
    6318:	08 95       	ret

0000631a <check_balance>:
		
	}
}

void check_balance(BYTE *action)
{
    631a:	cf 92       	push	r12
    631c:	df 92       	push	r13
    631e:	ef 92       	push	r14
    6320:	ff 92       	push	r15
    6322:	1f 93       	push	r17
    6324:	cf 93       	push	r28
    6326:	df 93       	push	r29
    6328:	6c 01       	movw	r12, r24
	if (autobalance)
    632a:	80 91 7c 0b 	lds	r24, 0x0B7C
    632e:	90 91 7d 0b 	lds	r25, 0x0B7D
    6332:	89 2b       	or	r24, r25
    6334:	09 f4       	brne	.+2      	; 0x6338 <check_balance+0x1e>
    6336:	1c c1       	rjmp	.+568    	; 0x6570 <check_balance+0x256>
	{
		int diff;
		tilt_read(0);
    6338:	80 e0       	ldi	r24, 0x00	; 0
    633a:	0e 94 ad 2f 	call	0x5f5a	; 0x5f5a <tilt_read>
		if (abs(gX-x_value)>5)
    633e:	c0 91 c0 0a 	lds	r28, 0x0AC0
    6342:	d0 91 c1 0a 	lds	r29, 0x0AC1
    6346:	80 91 a5 0d 	lds	r24, 0x0DA5
    634a:	90 91 a6 0d 	lds	r25, 0x0DA6
    634e:	9e 01       	movw	r18, r28
    6350:	28 1b       	sub	r18, r24
    6352:	39 0b       	sbc	r19, r25
    6354:	c9 01       	movw	r24, r18
    6356:	37 ff       	sbrs	r19, 7
    6358:	03 c0       	rjmp	.+6      	; 0x6360 <check_balance+0x46>
    635a:	90 95       	com	r25
    635c:	81 95       	neg	r24
    635e:	9f 4f       	sbci	r25, 0xFF	; 255
    6360:	06 97       	sbiw	r24, 0x06	; 6
    6362:	0c f4       	brge	.+2      	; 0x6366 <check_balance+0x4c>
    6364:	47 c0       	rjmp	.+142    	; 0x63f4 <check_balance+0xda>
		{
			diff = gX-x_value;
    6366:	e0 90 a5 0d 	lds	r14, 0x0DA5
    636a:	f0 90 a6 0d 	lds	r15, 0x0DA6

#define MAX_INP_BUF 32

void ptime()
{
	rprintf("%d:%d:%d-%d ",gHOUR,gMIN,gSEC,gMSEC);
    636e:	60 91 be 0a 	lds	r22, 0x0ABE
    6372:	70 91 bf 0a 	lds	r23, 0x0ABF
    6376:	80 91 ba 0a 	lds	r24, 0x0ABA
    637a:	20 91 9d 0a 	lds	r18, 0x0A9D
    637e:	40 91 b5 0a 	lds	r20, 0x0AB5
    6382:	7f 93       	push	r23
    6384:	6f 93       	push	r22
    6386:	90 e0       	ldi	r25, 0x00	; 0
    6388:	9f 93       	push	r25
    638a:	8f 93       	push	r24
    638c:	30 e0       	ldi	r19, 0x00	; 0
    638e:	3f 93       	push	r19
    6390:	2f 93       	push	r18
    6392:	50 e0       	ldi	r21, 0x00	; 0
    6394:	5f 93       	push	r21
    6396:	4f 93       	push	r20
    6398:	8d ed       	ldi	r24, 0xDD	; 221
    639a:	9a e3       	ldi	r25, 0x3A	; 58
    639c:	9f 93       	push	r25
    639e:	8f 93       	push	r24
    63a0:	11 e0       	ldi	r17, 0x01	; 1
    63a2:	1f 93       	push	r17
    63a4:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
		int diff;
		tilt_read(0);
		if (abs(gX-x_value)>5)
		{
			diff = gX-x_value;
			ptime(); rprintf("Tilt event X [%d] (%d,%d,%d)\r\n", diff, x_value, y_value, z_value);	
    63a8:	80 91 af 0d 	lds	r24, 0x0DAF
    63ac:	90 91 b0 0d 	lds	r25, 0x0DB0
    63b0:	20 91 a7 0d 	lds	r18, 0x0DA7
    63b4:	30 91 a8 0d 	lds	r19, 0x0DA8
    63b8:	40 91 a5 0d 	lds	r20, 0x0DA5
    63bc:	50 91 a6 0d 	lds	r21, 0x0DA6
    63c0:	9f 93       	push	r25
    63c2:	8f 93       	push	r24
    63c4:	3f 93       	push	r19
    63c6:	2f 93       	push	r18
    63c8:	5f 93       	push	r21
    63ca:	4f 93       	push	r20
    63cc:	ce 19       	sub	r28, r14
    63ce:	df 09       	sbc	r29, r15
    63d0:	df 93       	push	r29
    63d2:	cf 93       	push	r28
    63d4:	84 ef       	ldi	r24, 0xF4	; 244
    63d6:	99 e3       	ldi	r25, 0x39	; 57
    63d8:	9f 93       	push	r25
    63da:	8f 93       	push	r24
    63dc:	1f 93       	push	r17
    63de:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
    63e2:	4d b7       	in	r20, 0x3d	; 61
    63e4:	5e b7       	in	r21, 0x3e	; 62
    63e6:	4a 5e       	subi	r20, 0xEA	; 234
    63e8:	5f 4f       	sbci	r21, 0xFF	; 255
    63ea:	0f b6       	in	r0, 0x3f	; 63
    63ec:	f8 94       	cli
    63ee:	5e bf       	out	0x3e, r21	; 62
    63f0:	0f be       	out	0x3f, r0	; 63
    63f2:	4d bf       	out	0x3d, r20	; 61
		}
		if (abs(gY-y_value)>5)
    63f4:	c0 91 b2 0a 	lds	r28, 0x0AB2
    63f8:	d0 91 b3 0a 	lds	r29, 0x0AB3
    63fc:	80 91 a7 0d 	lds	r24, 0x0DA7
    6400:	90 91 a8 0d 	lds	r25, 0x0DA8
    6404:	fe 01       	movw	r30, r28
    6406:	e8 1b       	sub	r30, r24
    6408:	f9 0b       	sbc	r31, r25
    640a:	cf 01       	movw	r24, r30
    640c:	f7 ff       	sbrs	r31, 7
    640e:	03 c0       	rjmp	.+6      	; 0x6416 <check_balance+0xfc>
    6410:	90 95       	com	r25
    6412:	81 95       	neg	r24
    6414:	9f 4f       	sbci	r25, 0xFF	; 255
    6416:	06 97       	sbiw	r24, 0x06	; 6
    6418:	0c f4       	brge	.+2      	; 0x641c <check_balance+0x102>
    641a:	47 c0       	rjmp	.+142    	; 0x64aa <check_balance+0x190>
		{
			diff = gY-y_value;
    641c:	e0 90 a7 0d 	lds	r14, 0x0DA7
    6420:	f0 90 a8 0d 	lds	r15, 0x0DA8

#define MAX_INP_BUF 32

void ptime()
{
	rprintf("%d:%d:%d-%d ",gHOUR,gMIN,gSEC,gMSEC);
    6424:	60 91 be 0a 	lds	r22, 0x0ABE
    6428:	70 91 bf 0a 	lds	r23, 0x0ABF
    642c:	80 91 ba 0a 	lds	r24, 0x0ABA
    6430:	20 91 9d 0a 	lds	r18, 0x0A9D
    6434:	40 91 b5 0a 	lds	r20, 0x0AB5
    6438:	7f 93       	push	r23
    643a:	6f 93       	push	r22
    643c:	90 e0       	ldi	r25, 0x00	; 0
    643e:	9f 93       	push	r25
    6440:	8f 93       	push	r24
    6442:	30 e0       	ldi	r19, 0x00	; 0
    6444:	3f 93       	push	r19
    6446:	2f 93       	push	r18
    6448:	50 e0       	ldi	r21, 0x00	; 0
    644a:	5f 93       	push	r21
    644c:	4f 93       	push	r20
    644e:	8d ed       	ldi	r24, 0xDD	; 221
    6450:	9a e3       	ldi	r25, 0x3A	; 58
    6452:	9f 93       	push	r25
    6454:	8f 93       	push	r24
    6456:	11 e0       	ldi	r17, 0x01	; 1
    6458:	1f 93       	push	r17
    645a:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
			ptime(); rprintf("Tilt event X [%d] (%d,%d,%d)\r\n", diff, x_value, y_value, z_value);	
		}
		if (abs(gY-y_value)>5)
		{
			diff = gY-y_value;
			ptime(); rprintf("Tilt event y [%d] (%d,%d,%d)\r\n", diff, x_value, y_value, z_value);	
    645e:	80 91 af 0d 	lds	r24, 0x0DAF
    6462:	90 91 b0 0d 	lds	r25, 0x0DB0
    6466:	20 91 a7 0d 	lds	r18, 0x0DA7
    646a:	30 91 a8 0d 	lds	r19, 0x0DA8
    646e:	40 91 a5 0d 	lds	r20, 0x0DA5
    6472:	50 91 a6 0d 	lds	r21, 0x0DA6
    6476:	9f 93       	push	r25
    6478:	8f 93       	push	r24
    647a:	3f 93       	push	r19
    647c:	2f 93       	push	r18
    647e:	5f 93       	push	r21
    6480:	4f 93       	push	r20
    6482:	ce 19       	sub	r28, r14
    6484:	df 09       	sbc	r29, r15
    6486:	df 93       	push	r29
    6488:	cf 93       	push	r28
    648a:	85 ed       	ldi	r24, 0xD5	; 213
    648c:	99 e3       	ldi	r25, 0x39	; 57
    648e:	9f 93       	push	r25
    6490:	8f 93       	push	r24
    6492:	1f 93       	push	r17
    6494:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
    6498:	2d b7       	in	r18, 0x3d	; 61
    649a:	3e b7       	in	r19, 0x3e	; 62
    649c:	2a 5e       	subi	r18, 0xEA	; 234
    649e:	3f 4f       	sbci	r19, 0xFF	; 255
    64a0:	0f b6       	in	r0, 0x3f	; 63
    64a2:	f8 94       	cli
    64a4:	3e bf       	out	0x3e, r19	; 62
    64a6:	0f be       	out	0x3f, r0	; 63
    64a8:	2d bf       	out	0x3d, r18	; 61
		}		
		if (abs(gZ-z_value)>10)
    64aa:	20 91 b6 0a 	lds	r18, 0x0AB6
    64ae:	30 91 b7 0a 	lds	r19, 0x0AB7
    64b2:	80 91 af 0d 	lds	r24, 0x0DAF
    64b6:	90 91 b0 0d 	lds	r25, 0x0DB0
    64ba:	a9 01       	movw	r20, r18
    64bc:	48 1b       	sub	r20, r24
    64be:	59 0b       	sbc	r21, r25
    64c0:	ca 01       	movw	r24, r20
    64c2:	57 ff       	sbrs	r21, 7
    64c4:	03 c0       	rjmp	.+6      	; 0x64cc <check_balance+0x1b2>
    64c6:	90 95       	com	r25
    64c8:	81 95       	neg	r24
    64ca:	9f 4f       	sbci	r25, 0xFF	; 255
    64cc:	0b 97       	sbiw	r24, 0x0b	; 11
    64ce:	0c f4       	brge	.+2      	; 0x64d2 <check_balance+0x1b8>
    64d0:	4f c0       	rjmp	.+158    	; 0x6570 <check_balance+0x256>
		{
			diff = gZ-z_value;
    64d2:	80 91 af 0d 	lds	r24, 0x0DAF
    64d6:	90 91 b0 0d 	lds	r25, 0x0DB0
    64da:	79 01       	movw	r14, r18
    64dc:	e8 1a       	sub	r14, r24
    64de:	f9 0a       	sbc	r15, r25

#define MAX_INP_BUF 32

void ptime()
{
	rprintf("%d:%d:%d-%d ",gHOUR,gMIN,gSEC,gMSEC);
    64e0:	60 91 be 0a 	lds	r22, 0x0ABE
    64e4:	70 91 bf 0a 	lds	r23, 0x0ABF
    64e8:	80 91 ba 0a 	lds	r24, 0x0ABA
    64ec:	20 91 9d 0a 	lds	r18, 0x0A9D
    64f0:	40 91 b5 0a 	lds	r20, 0x0AB5
    64f4:	7f 93       	push	r23
    64f6:	6f 93       	push	r22
    64f8:	90 e0       	ldi	r25, 0x00	; 0
    64fa:	9f 93       	push	r25
    64fc:	8f 93       	push	r24
    64fe:	30 e0       	ldi	r19, 0x00	; 0
    6500:	3f 93       	push	r19
    6502:	2f 93       	push	r18
    6504:	50 e0       	ldi	r21, 0x00	; 0
    6506:	5f 93       	push	r21
    6508:	4f 93       	push	r20
    650a:	8d ed       	ldi	r24, 0xDD	; 221
    650c:	9a e3       	ldi	r25, 0x3A	; 58
    650e:	9f 93       	push	r25
    6510:	8f 93       	push	r24
    6512:	11 e0       	ldi	r17, 0x01	; 1
    6514:	1f 93       	push	r17
    6516:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
			ptime(); rprintf("Tilt event y [%d] (%d,%d,%d)\r\n", diff, x_value, y_value, z_value);	
		}		
		if (abs(gZ-z_value)>10)
		{
			diff = gZ-z_value;
			ptime(); rprintf("Tilt event z [%d] (%d,%d,%d)\r\n", diff, x_value, y_value, z_value);	
    651a:	80 91 af 0d 	lds	r24, 0x0DAF
    651e:	90 91 b0 0d 	lds	r25, 0x0DB0
    6522:	20 91 a7 0d 	lds	r18, 0x0DA7
    6526:	30 91 a8 0d 	lds	r19, 0x0DA8
    652a:	40 91 a5 0d 	lds	r20, 0x0DA5
    652e:	50 91 a6 0d 	lds	r21, 0x0DA6
    6532:	9f 93       	push	r25
    6534:	8f 93       	push	r24
    6536:	3f 93       	push	r19
    6538:	2f 93       	push	r18
    653a:	5f 93       	push	r21
    653c:	4f 93       	push	r20
    653e:	ff 92       	push	r15
    6540:	ef 92       	push	r14
    6542:	86 eb       	ldi	r24, 0xB6	; 182
    6544:	99 e3       	ldi	r25, 0x39	; 57
    6546:	9f 93       	push	r25
    6548:	8f 93       	push	r24
    654a:	1f 93       	push	r17
    654c:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
			
			if (diff>0) *action=0x71; else *action=0x70;
    6550:	8d b7       	in	r24, 0x3d	; 61
    6552:	9e b7       	in	r25, 0x3e	; 62
    6554:	46 96       	adiw	r24, 0x16	; 22
    6556:	0f b6       	in	r0, 0x3f	; 63
    6558:	f8 94       	cli
    655a:	9e bf       	out	0x3e, r25	; 62
    655c:	0f be       	out	0x3f, r0	; 63
    655e:	8d bf       	out	0x3d, r24	; 61
    6560:	1e 14       	cp	r1, r14
    6562:	1f 04       	cpc	r1, r15
    6564:	14 f4       	brge	.+4      	; 0x656a <check_balance+0x250>
    6566:	81 e7       	ldi	r24, 0x71	; 113
    6568:	01 c0       	rjmp	.+2      	; 0x656c <check_balance+0x252>
    656a:	80 e7       	ldi	r24, 0x70	; 112
    656c:	f6 01       	movw	r30, r12
    656e:	80 83       	st	Z, r24
		}
	}
}
    6570:	df 91       	pop	r29
    6572:	cf 91       	pop	r28
    6574:	1f 91       	pop	r17
    6576:	ff 90       	pop	r15
    6578:	ef 90       	pop	r14
    657a:	df 90       	pop	r13
    657c:	cf 90       	pop	r12
    657e:	08 95       	ret

00006580 <Perform_Action>:
// -------------------------------------------------------------------------------------------------------
// perfom action
// -------------------------------------------------------------------------------------------------------

void Perform_Action (BYTE Action)
{	
    6580:	cf 92       	push	r12
    6582:	df 92       	push	r13
    6584:	ef 92       	push	r14
    6586:	ff 92       	push	r15
    6588:	0f 93       	push	r16
    658a:	1f 93       	push	r17
    658c:	cf 93       	push	r28
    658e:	df 93       	push	r29
    6590:	08 2f       	mov	r16, r24
	WORD	ptmpA, ptmpB;
	
	int i;
	int tlt = 0;		

	if (Action>=0 && Action <=0x12)
    6592:	83 31       	cpi	r24, 0x13	; 19
    6594:	08 f0       	brcs	.+2      	; 0x6598 <Perform_Action+0x18>
    6596:	57 c0       	rjmp	.+174    	; 0x6646 <Perform_Action+0xc6>
		0x0F:  //standupf
		0x10:  //sitdown
		0x11:  //hi
		0x12:  //kick left front turn
	*/
		if (get_type()==HUNO_BASIC)
    6598:	0e 94 3a 42 	call	0x8474	; 0x8474 <get_type>
    659c:	cd ed       	ldi	r28, 0xDD	; 221
    659e:	da e3       	ldi	r29, 0x3A	; 58
    65a0:	88 23       	and	r24, r24
    65a2:	71 f5       	brne	.+92     	; 0x6600 <Perform_Action+0x80>
		{
			SampleMotion(Action);  					// comm.c: perform the sample motion
    65a4:	e0 2e       	mov	r14, r16
    65a6:	ff 24       	eor	r15, r15
    65a8:	c7 01       	movw	r24, r14
    65aa:	0e 94 60 29 	call	0x52c0	; 0x52c0 <SampleMotion>

#define MAX_INP_BUF 32

void ptime()
{
	rprintf("%d:%d:%d-%d ",gHOUR,gMIN,gSEC,gMSEC);
    65ae:	60 91 be 0a 	lds	r22, 0x0ABE
    65b2:	70 91 bf 0a 	lds	r23, 0x0ABF
    65b6:	80 91 ba 0a 	lds	r24, 0x0ABA
    65ba:	20 91 9d 0a 	lds	r18, 0x0A9D
    65be:	40 91 b5 0a 	lds	r20, 0x0AB5
    65c2:	7f 93       	push	r23
    65c4:	6f 93       	push	r22
    65c6:	90 e0       	ldi	r25, 0x00	; 0
    65c8:	9f 93       	push	r25
    65ca:	8f 93       	push	r24
    65cc:	30 e0       	ldi	r19, 0x00	; 0
    65ce:	3f 93       	push	r19
    65d0:	2f 93       	push	r18
    65d2:	50 e0       	ldi	r21, 0x00	; 0
    65d4:	5f 93       	push	r21
    65d6:	4f 93       	push	r20
    65d8:	df 93       	push	r29
    65da:	cf 93       	push	r28
    65dc:	11 e0       	ldi	r17, 0x01	; 1
    65de:	1f 93       	push	r17
    65e0:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
		0x12:  //kick left front turn
	*/
		if (get_type()==HUNO_BASIC)
		{
			SampleMotion(Action);  					// comm.c: perform the sample motion
			ptime(); rprintf("Do Motion %x\r\n", Action);
    65e4:	ff 92       	push	r15
    65e6:	ef 92       	push	r14
    65e8:	87 ea       	ldi	r24, 0xA7	; 167
    65ea:	99 e3       	ldi	r25, 0x39	; 57
    65ec:	9f 93       	push	r25
    65ee:	8f 93       	push	r24
    65f0:	1f 93       	push	r17
    65f2:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
    65f6:	2d b7       	in	r18, 0x3d	; 61
    65f8:	3e b7       	in	r19, 0x3e	; 62
    65fa:	20 5f       	subi	r18, 0xF0	; 240
    65fc:	3f 4f       	sbci	r19, 0xFF	; 255
    65fe:	e7 c1       	rjmp	.+974    	; 0x69ce <Perform_Action+0x44e>

#define MAX_INP_BUF 32

void ptime()
{
	rprintf("%d:%d:%d-%d ",gHOUR,gMIN,gSEC,gMSEC);
    6600:	60 91 be 0a 	lds	r22, 0x0ABE
    6604:	70 91 bf 0a 	lds	r23, 0x0ABF
    6608:	80 91 ba 0a 	lds	r24, 0x0ABA
    660c:	20 91 9d 0a 	lds	r18, 0x0A9D
    6610:	40 91 b5 0a 	lds	r20, 0x0AB5
    6614:	7f 93       	push	r23
    6616:	6f 93       	push	r22
    6618:	90 e0       	ldi	r25, 0x00	; 0
    661a:	9f 93       	push	r25
    661c:	8f 93       	push	r24
    661e:	30 e0       	ldi	r19, 0x00	; 0
    6620:	3f 93       	push	r19
    6622:	2f 93       	push	r18
    6624:	50 e0       	ldi	r21, 0x00	; 0
    6626:	5f 93       	push	r21
    6628:	4f 93       	push	r20
    662a:	df 93       	push	r29
    662c:	cf 93       	push	r28
    662e:	11 e0       	ldi	r17, 0x01	; 1
    6630:	1f 93       	push	r17
    6632:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
			SampleMotion(Action);  					// comm.c: perform the sample motion
			ptime(); rprintf("Do Motion %x\r\n", Action);
		}
		else
		{
			ptime(); rprintf("Only when in HUNO BASIC mode\r\n");
    6636:	88 e8       	ldi	r24, 0x88	; 136
    6638:	99 e3       	ldi	r25, 0x39	; 57
    663a:	9f 93       	push	r25
    663c:	8f 93       	push	r24
    663e:	1f 93       	push	r17
    6640:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
    6644:	62 c1       	rjmp	.+708    	; 0x690a <Perform_Action+0x38a>
		}
	}
	else
	switch (Action)
    6646:	80 3c       	cpi	r24, 0xC0	; 192
    6648:	09 f4       	brne	.+2      	; 0x664c <Perform_Action+0xcc>
    664a:	32 c4       	rjmp	.+2148   	; 0x6eb0 <Perform_Action+0x930>
    664c:	81 3c       	cpi	r24, 0xC1	; 193
    664e:	70 f5       	brcc	.+92     	; 0x66ac <Perform_Action+0x12c>
    6650:	84 37       	cpi	r24, 0x74	; 116
    6652:	c8 f4       	brcc	.+50     	; 0x6686 <Perform_Action+0x106>
    6654:	82 37       	cpi	r24, 0x72	; 114
    6656:	08 f0       	brcs	.+2      	; 0x665a <Perform_Action+0xda>
    6658:	9b c2       	rjmp	.+1334   	; 0x6b90 <Perform_Action+0x610>
    665a:	80 34       	cpi	r24, 0x40	; 64
    665c:	09 f4       	brne	.+2      	; 0x6660 <Perform_Action+0xe0>
    665e:	a8 c0       	rjmp	.+336    	; 0x67b0 <Perform_Action+0x230>
    6660:	81 34       	cpi	r24, 0x41	; 65
    6662:	38 f4       	brcc	.+14     	; 0x6672 <Perform_Action+0xf2>
    6664:	80 32       	cpi	r24, 0x20	; 32
    6666:	09 f4       	brne	.+2      	; 0x666a <Perform_Action+0xea>
    6668:	52 c0       	rjmp	.+164    	; 0x670e <Perform_Action+0x18e>
    666a:	80 33       	cpi	r24, 0x30	; 48
    666c:	09 f0       	breq	.+2      	; 0x6670 <Perform_Action+0xf0>
    666e:	85 c4       	rjmp	.+2314   	; 0x6f7a <Perform_Action+0x9fa>
    6670:	85 c0       	rjmp	.+266    	; 0x677c <Perform_Action+0x1fc>
    6672:	80 35       	cpi	r24, 0x50	; 80
    6674:	09 f4       	brne	.+2      	; 0x6678 <Perform_Action+0xf8>
    6676:	da c0       	rjmp	.+436    	; 0x682c <Perform_Action+0x2ac>
    6678:	80 35       	cpi	r24, 0x50	; 80
    667a:	08 f4       	brcc	.+2      	; 0x667e <Perform_Action+0xfe>
    667c:	7e c4       	rjmp	.+2300   	; 0x6f7a <Perform_Action+0x9fa>
    667e:	80 37       	cpi	r24, 0x70	; 112
    6680:	08 f4       	brcc	.+2      	; 0x6684 <Perform_Action+0x104>
    6682:	7b c4       	rjmp	.+2294   	; 0x6f7a <Perform_Action+0x9fa>
    6684:	eb c1       	rjmp	.+982    	; 0x6a5c <Perform_Action+0x4dc>
    6686:	80 38       	cpi	r24, 0x80	; 128
    6688:	09 f4       	brne	.+2      	; 0x668c <Perform_Action+0x10c>
    668a:	ae c2       	rjmp	.+1372   	; 0x6be8 <Perform_Action+0x668>
    668c:	81 38       	cpi	r24, 0x81	; 129
    668e:	38 f4       	brcc	.+14     	; 0x669e <Perform_Action+0x11e>
    6690:	84 37       	cpi	r24, 0x74	; 116
    6692:	09 f4       	brne	.+2      	; 0x6696 <Perform_Action+0x116>
    6694:	0c c1       	rjmp	.+536    	; 0x68ae <Perform_Action+0x32e>
    6696:	85 37       	cpi	r24, 0x75	; 117
    6698:	09 f0       	breq	.+2      	; 0x669c <Perform_Action+0x11c>
    669a:	6f c4       	rjmp	.+2270   	; 0x6f7a <Perform_Action+0x9fa>
    669c:	9e c1       	rjmp	.+828    	; 0x69da <Perform_Action+0x45a>
    669e:	80 39       	cpi	r24, 0x90	; 144
    66a0:	09 f4       	brne	.+2      	; 0x66a4 <Perform_Action+0x124>
    66a2:	ba c2       	rjmp	.+1396   	; 0x6c18 <Perform_Action+0x698>
    66a4:	81 39       	cpi	r24, 0x91	; 145
    66a6:	09 f0       	breq	.+2      	; 0x66aa <Perform_Action+0x12a>
    66a8:	68 c4       	rjmp	.+2256   	; 0x6f7a <Perform_Action+0x9fa>
    66aa:	5a c3       	rjmp	.+1716   	; 0x6d60 <Perform_Action+0x7e0>
    66ac:	80 3d       	cpi	r24, 0xD0	; 208
    66ae:	09 f4       	brne	.+2      	; 0x66b2 <Perform_Action+0x132>
    66b0:	4f c4       	rjmp	.+2206   	; 0x6f50 <Perform_Action+0x9d0>
    66b2:	81 3d       	cpi	r24, 0xD1	; 209
    66b4:	b0 f4       	brcc	.+44     	; 0x66e2 <Perform_Action+0x162>
    66b6:	83 3c       	cpi	r24, 0xC3	; 195
    66b8:	09 f4       	brne	.+2      	; 0x66bc <Perform_Action+0x13c>
    66ba:	03 c4       	rjmp	.+2054   	; 0x6ec2 <Perform_Action+0x942>
    66bc:	84 3c       	cpi	r24, 0xC4	; 196
    66be:	38 f4       	brcc	.+14     	; 0x66ce <Perform_Action+0x14e>
    66c0:	81 3c       	cpi	r24, 0xC1	; 193
    66c2:	09 f4       	brne	.+2      	; 0x66c6 <Perform_Action+0x146>
    66c4:	f8 c3       	rjmp	.+2032   	; 0x6eb6 <Perform_Action+0x936>
    66c6:	82 3c       	cpi	r24, 0xC2	; 194
    66c8:	09 f0       	breq	.+2      	; 0x66cc <Perform_Action+0x14c>
    66ca:	57 c4       	rjmp	.+2222   	; 0x6f7a <Perform_Action+0x9fa>
    66cc:	f7 c3       	rjmp	.+2030   	; 0x6ebc <Perform_Action+0x93c>
    66ce:	85 3c       	cpi	r24, 0xC5	; 197
    66d0:	09 f4       	brne	.+2      	; 0x66d4 <Perform_Action+0x154>
    66d2:	01 c4       	rjmp	.+2050   	; 0x6ed6 <Perform_Action+0x956>
    66d4:	85 3c       	cpi	r24, 0xC5	; 197
    66d6:	08 f4       	brcc	.+2      	; 0x66da <Perform_Action+0x15a>
    66d8:	f7 c3       	rjmp	.+2030   	; 0x6ec8 <Perform_Action+0x948>
    66da:	87 3c       	cpi	r24, 0xC7	; 199
    66dc:	09 f0       	breq	.+2      	; 0x66e0 <Perform_Action+0x160>
    66de:	4d c4       	rjmp	.+2202   	; 0x6f7a <Perform_Action+0x9fa>
    66e0:	fd c3       	rjmp	.+2042   	; 0x6edc <Perform_Action+0x95c>
    66e2:	8a 3d       	cpi	r24, 0xDA	; 218
    66e4:	09 f4       	brne	.+2      	; 0x66e8 <Perform_Action+0x168>
    66e6:	1e c4       	rjmp	.+2108   	; 0x6f24 <Perform_Action+0x9a4>
    66e8:	8b 3d       	cpi	r24, 0xDB	; 219
    66ea:	38 f4       	brcc	.+14     	; 0x66fa <Perform_Action+0x17a>
    66ec:	88 3d       	cpi	r24, 0xD8	; 216
    66ee:	09 f4       	brne	.+2      	; 0x66f2 <Perform_Action+0x172>
    66f0:	f8 c3       	rjmp	.+2032   	; 0x6ee2 <Perform_Action+0x962>
    66f2:	89 3d       	cpi	r24, 0xD9	; 217
    66f4:	09 f0       	breq	.+2      	; 0x66f8 <Perform_Action+0x178>
    66f6:	41 c4       	rjmp	.+2178   	; 0x6f7a <Perform_Action+0x9fa>
    66f8:	0b c4       	rjmp	.+2070   	; 0x6f10 <Perform_Action+0x990>
    66fa:	88 3e       	cpi	r24, 0xE8	; 232
    66fc:	09 f4       	brne	.+2      	; 0x6700 <Perform_Action+0x180>
    66fe:	2f c4       	rjmp	.+2142   	; 0x6f5e <Perform_Action+0x9de>
    6700:	8e 3e       	cpi	r24, 0xEE	; 238
    6702:	09 f4       	brne	.+2      	; 0x6706 <Perform_Action+0x186>
    6704:	2f c4       	rjmp	.+2142   	; 0x6f64 <Perform_Action+0x9e4>
    6706:	8b 3d       	cpi	r24, 0xDB	; 219
    6708:	09 f0       	breq	.+2      	; 0x670c <Perform_Action+0x18c>
    670a:	37 c4       	rjmp	.+2158   	; 0x6f7a <Perform_Action+0x9fa>
    670c:	15 c4       	rjmp	.+2090   	; 0x6f38 <Perform_Action+0x9b8>

#define MAX_INP_BUF 32

void ptime()
{
	rprintf("%d:%d:%d-%d ",gHOUR,gMIN,gSEC,gMSEC);
    670e:	60 91 be 0a 	lds	r22, 0x0ABE
    6712:	70 91 bf 0a 	lds	r23, 0x0ABF
    6716:	80 91 ba 0a 	lds	r24, 0x0ABA
    671a:	20 91 9d 0a 	lds	r18, 0x0A9D
    671e:	40 91 b5 0a 	lds	r20, 0x0AB5
    6722:	7f 93       	push	r23
    6724:	6f 93       	push	r22
    6726:	90 e0       	ldi	r25, 0x00	; 0
    6728:	9f 93       	push	r25
    672a:	8f 93       	push	r24
    672c:	30 e0       	ldi	r19, 0x00	; 0
    672e:	3f 93       	push	r19
    6730:	2f 93       	push	r18
    6732:	50 e0       	ldi	r21, 0x00	; 0
    6734:	5f 93       	push	r21
    6736:	4f 93       	push	r20
    6738:	8d ed       	ldi	r24, 0xDD	; 221
    673a:	9a e3       	ldi	r25, 0x3A	; 58
    673c:	9f 93       	push	r25
    673e:	8f 93       	push	r24
    6740:	11 e0       	ldi	r17, 0x01	; 1
    6742:	1f 93       	push	r17
    6744:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
	else
	switch (Action)
	{

	case 0x20:
		ptime(); rprintf("Basic Pose\r\n");
    6748:	8b e7       	ldi	r24, 0x7B	; 123
    674a:	99 e3       	ldi	r25, 0x39	; 57
    674c:	9f 93       	push	r25
    674e:	8f 93       	push	r24
    6750:	1f 93       	push	r17
    6752:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
		if (get_type()==HUNO_BASIC)
    6756:	0e 94 3a 42 	call	0x8474	; 0x8474 <get_type>
    675a:	2d b7       	in	r18, 0x3d	; 61
    675c:	3e b7       	in	r19, 0x3e	; 62
    675e:	22 5f       	subi	r18, 0xF2	; 242
    6760:	3f 4f       	sbci	r19, 0xFF	; 255
    6762:	0f b6       	in	r0, 0x3f	; 63
    6764:	f8 94       	cli
    6766:	3e bf       	out	0x3e, r19	; 62
    6768:	0f be       	out	0x3f, r0	; 63
    676a:	2d bf       	out	0x3d, r18	; 61
    676c:	88 23       	and	r24, r24
    676e:	19 f4       	brne	.+6      	; 0x6776 <Perform_Action+0x1f6>
		{
			BasicPose();
    6770:	0e 94 9c 26 	call	0x4d38	; 0x4d38 <BasicPose>
    6774:	02 c4       	rjmp	.+2052   	; 0x6f7a <Perform_Action+0x9fa>
		}
		else
		{
			rprintf("N/A\r\n");
    6776:	85 e7       	ldi	r24, 0x75	; 117
    6778:	99 e3       	ldi	r25, 0x39	; 57
    677a:	96 c3       	rjmp	.+1836   	; 0x6ea8 <Perform_Action+0x928>
    677c:	20 e0       	ldi	r18, 0x00	; 0
    677e:	30 e0       	ldi	r19, 0x00	; 0
    6780:	40 e7       	ldi	r20, 0x70	; 112
    6782:	51 e0       	ldi	r21, 0x01	; 1
		break;
	case 0x30:
		//flash lights
		for (i=0; i<20; i++)
		{
			PF1_LED1_ON;
    6784:	da 98       	cbi	0x1b, 2	; 27
    6786:	84 ec       	ldi	r24, 0xC4	; 196
    6788:	99 e0       	ldi	r25, 0x09	; 9
    678a:	fa 01       	movw	r30, r20
    678c:	31 97       	sbiw	r30, 0x01	; 1
    678e:	f1 f7       	brne	.-4      	; 0x678c <Perform_Action+0x20c>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6790:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6792:	d9 f7       	brne	.-10     	; 0x678a <Perform_Action+0x20a>
			_delay_ms(250);
			PF1_LED1_OFF;
    6794:	da 9a       	sbi	0x1b, 2	; 27
    6796:	84 ec       	ldi	r24, 0xC4	; 196
    6798:	99 e0       	ldi	r25, 0x09	; 9
    679a:	fa 01       	movw	r30, r20
    679c:	31 97       	sbiw	r30, 0x01	; 1
    679e:	f1 f7       	brne	.-4      	; 0x679c <Perform_Action+0x21c>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    67a0:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    67a2:	d9 f7       	brne	.-10     	; 0x679a <Perform_Action+0x21a>
			rprintf("N/A\r\n");
		}		
		break;
	case 0x30:
		//flash lights
		for (i=0; i<20; i++)
    67a4:	2f 5f       	subi	r18, 0xFF	; 255
    67a6:	3f 4f       	sbci	r19, 0xFF	; 255
    67a8:	24 31       	cpi	r18, 0x14	; 20
    67aa:	31 05       	cpc	r19, r1
    67ac:	59 f7       	brne	.-42     	; 0x6784 <Perform_Action+0x204>
    67ae:	e5 c3       	rjmp	.+1994   	; 0x6f7a <Perform_Action+0x9fa>

#define MAX_INP_BUF 32

void ptime()
{
	rprintf("%d:%d:%d-%d ",gHOUR,gMIN,gSEC,gMSEC);
    67b0:	60 91 be 0a 	lds	r22, 0x0ABE
    67b4:	70 91 bf 0a 	lds	r23, 0x0ABF
    67b8:	80 91 ba 0a 	lds	r24, 0x0ABA
    67bc:	20 91 9d 0a 	lds	r18, 0x0A9D
    67c0:	40 91 b5 0a 	lds	r20, 0x0AB5
    67c4:	7f 93       	push	r23
    67c6:	6f 93       	push	r22
    67c8:	90 e0       	ldi	r25, 0x00	; 0
    67ca:	9f 93       	push	r25
    67cc:	8f 93       	push	r24
    67ce:	30 e0       	ldi	r19, 0x00	; 0
    67d0:	3f 93       	push	r19
    67d2:	2f 93       	push	r18
    67d4:	50 e0       	ldi	r21, 0x00	; 0
    67d6:	5f 93       	push	r21
    67d8:	4f 93       	push	r20
    67da:	8d ed       	ldi	r24, 0xDD	; 221
    67dc:	9a e3       	ldi	r25, 0x3A	; 58
    67de:	9f 93       	push	r25
    67e0:	8f 93       	push	r24
    67e2:	11 e0       	ldi	r17, 0x01	; 1
    67e4:	1f 93       	push	r17
    67e6:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
			PF1_LED1_OFF;
			_delay_ms(250);
		}
		break;
	case 0x40:
		ptime(); rprintf("ADC Test - loops until any button on IR pressed\r\n");	
    67ea:	83 e4       	ldi	r24, 0x43	; 67
    67ec:	99 e3       	ldi	r25, 0x39	; 57
    67ee:	9f 93       	push	r25
    67f0:	8f 93       	push	r24
    67f2:	1f 93       	push	r17
    67f4:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
    67f8:	8d b7       	in	r24, 0x3d	; 61
    67fa:	9e b7       	in	r25, 0x3e	; 62
    67fc:	0e 96       	adiw	r24, 0x0e	; 14
    67fe:	0f b6       	in	r0, 0x3f	; 63
    6800:	f8 94       	cli
    6802:	9e bf       	out	0x3e, r25	; 62
    6804:	0f be       	out	0x3f, r0	; 63
    6806:	8d bf       	out	0x3d, r24	; 61
    6808:	c0 e7       	ldi	r28, 0x70	; 112
    680a:	d1 e0       	ldi	r29, 0x01	; 1
    680c:	0a c0       	rjmp	.+20     	; 0x6822 <Perform_Action+0x2a2>
		while(!gIRReady)
		{		
			adc_test(1);  					// ADC test
    680e:	81 e0       	ldi	r24, 0x01	; 1
    6810:	0e 94 12 2d 	call	0x5a24	; 0x5a24 <adc_test>
    6814:	84 ec       	ldi	r24, 0xC4	; 196
    6816:	99 e0       	ldi	r25, 0x09	; 9
    6818:	fe 01       	movw	r30, r28
    681a:	31 97       	sbiw	r30, 0x01	; 1
    681c:	f1 f7       	brne	.-4      	; 0x681a <Perform_Action+0x29a>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    681e:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6820:	d9 f7       	brne	.-10     	; 0x6818 <Perform_Action+0x298>
			_delay_ms(250);
		}
		break;
	case 0x40:
		ptime(); rprintf("ADC Test - loops until any button on IR pressed\r\n");	
		while(!gIRReady)
    6822:	80 91 9d 0d 	lds	r24, 0x0D9D
    6826:	88 23       	and	r24, r24
    6828:	91 f3       	breq	.-28     	; 0x680e <Perform_Action+0x28e>
    682a:	3e c0       	rjmp	.+124    	; 0x68a8 <Perform_Action+0x328>

#define MAX_INP_BUF 32

void ptime()
{
	rprintf("%d:%d:%d-%d ",gHOUR,gMIN,gSEC,gMSEC);
    682c:	60 91 be 0a 	lds	r22, 0x0ABE
    6830:	70 91 bf 0a 	lds	r23, 0x0ABF
    6834:	80 91 ba 0a 	lds	r24, 0x0ABA
    6838:	20 91 9d 0a 	lds	r18, 0x0A9D
    683c:	40 91 b5 0a 	lds	r20, 0x0AB5
    6840:	7f 93       	push	r23
    6842:	6f 93       	push	r22
    6844:	90 e0       	ldi	r25, 0x00	; 0
    6846:	9f 93       	push	r25
    6848:	8f 93       	push	r24
    684a:	30 e0       	ldi	r19, 0x00	; 0
    684c:	3f 93       	push	r19
    684e:	2f 93       	push	r18
    6850:	50 e0       	ldi	r21, 0x00	; 0
    6852:	5f 93       	push	r21
    6854:	4f 93       	push	r20
    6856:	8d ed       	ldi	r24, 0xDD	; 221
    6858:	9a e3       	ldi	r25, 0x3A	; 58
    685a:	9f 93       	push	r25
    685c:	8f 93       	push	r24
    685e:	11 e0       	ldi	r17, 0x01	; 1
    6860:	1f 93       	push	r17
    6862:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
			_delay_ms(250);
		}
		gIRReady = FALSE;
		break;
	case 0x50:
		ptime(); rprintf("Tilt Test - loops until any button on IR pressed\r\n");	
    6866:	80 e1       	ldi	r24, 0x10	; 16
    6868:	99 e3       	ldi	r25, 0x39	; 57
    686a:	9f 93       	push	r25
    686c:	8f 93       	push	r24
    686e:	1f 93       	push	r17
    6870:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
    6874:	2d b7       	in	r18, 0x3d	; 61
    6876:	3e b7       	in	r19, 0x3e	; 62
    6878:	22 5f       	subi	r18, 0xF2	; 242
    687a:	3f 4f       	sbci	r19, 0xFF	; 255
    687c:	0f b6       	in	r0, 0x3f	; 63
    687e:	f8 94       	cli
    6880:	3e bf       	out	0x3e, r19	; 62
    6882:	0f be       	out	0x3f, r0	; 63
    6884:	2d bf       	out	0x3d, r18	; 61
    6886:	c0 e7       	ldi	r28, 0x70	; 112
    6888:	d1 e0       	ldi	r29, 0x01	; 1
    688a:	0a c0       	rjmp	.+20     	; 0x68a0 <Perform_Action+0x320>
		while(!gIRReady)
		{
			tilt_read(1);  					// tilt test (DEBUG MODE)
    688c:	81 e0       	ldi	r24, 0x01	; 1
    688e:	0e 94 ad 2f 	call	0x5f5a	; 0x5f5a <tilt_read>
    6892:	84 ec       	ldi	r24, 0xC4	; 196
    6894:	99 e0       	ldi	r25, 0x09	; 9
    6896:	fe 01       	movw	r30, r28
    6898:	31 97       	sbiw	r30, 0x01	; 1
    689a:	f1 f7       	brne	.-4      	; 0x6898 <Perform_Action+0x318>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    689c:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    689e:	d9 f7       	brne	.-10     	; 0x6896 <Perform_Action+0x316>
		}
		gIRReady = FALSE;
		break;
	case 0x50:
		ptime(); rprintf("Tilt Test - loops until any button on IR pressed\r\n");	
		while(!gIRReady)
    68a0:	80 91 9d 0d 	lds	r24, 0x0D9D
    68a4:	88 23       	and	r24, r24
    68a6:	91 f3       	breq	.-28     	; 0x688c <Perform_Action+0x30c>
		{
			tilt_read(1);  					// tilt test (DEBUG MODE)
			_delay_ms(250);
		}
		gIRReady = FALSE;
    68a8:	10 92 9d 0d 	sts	0x0D9D, r1
    68ac:	66 c3       	rjmp	.+1740   	; 0x6f7a <Perform_Action+0x9fa>
		break;
	case 0x74: //zero (x,y,x)
		if (autobalance)
    68ae:	80 91 7c 0b 	lds	r24, 0x0B7C
    68b2:	90 91 7d 0b 	lds	r25, 0x0B7D
    68b6:	cd ed       	ldi	r28, 0xDD	; 221
    68b8:	da e3       	ldi	r29, 0x3A	; 58
    68ba:	89 2b       	or	r24, r25
    68bc:	79 f1       	breq	.+94     	; 0x691c <Perform_Action+0x39c>

#define MAX_INP_BUF 32

void ptime()
{
	rprintf("%d:%d:%d-%d ",gHOUR,gMIN,gSEC,gMSEC);
    68be:	60 91 be 0a 	lds	r22, 0x0ABE
    68c2:	70 91 bf 0a 	lds	r23, 0x0ABF
    68c6:	80 91 ba 0a 	lds	r24, 0x0ABA
    68ca:	20 91 9d 0a 	lds	r18, 0x0A9D
    68ce:	40 91 b5 0a 	lds	r20, 0x0AB5
    68d2:	7f 93       	push	r23
    68d4:	6f 93       	push	r22
    68d6:	90 e0       	ldi	r25, 0x00	; 0
    68d8:	9f 93       	push	r25
    68da:	8f 93       	push	r24
    68dc:	30 e0       	ldi	r19, 0x00	; 0
    68de:	3f 93       	push	r19
    68e0:	2f 93       	push	r18
    68e2:	50 e0       	ldi	r21, 0x00	; 0
    68e4:	5f 93       	push	r21
    68e6:	4f 93       	push	r20
    68e8:	df 93       	push	r29
    68ea:	cf 93       	push	r28
    68ec:	11 e0       	ldi	r17, 0x01	; 1
    68ee:	1f 93       	push	r17
    68f0:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
		gIRReady = FALSE;
		break;
	case 0x74: //zero (x,y,x)
		if (autobalance)
		{
			ptime(); rprintf("Accel off\r\n");	
    68f4:	84 e0       	ldi	r24, 0x04	; 4
    68f6:	99 e3       	ldi	r25, 0x39	; 57
    68f8:	9f 93       	push	r25
    68fa:	8f 93       	push	r24
    68fc:	1f 93       	push	r17
    68fe:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
			autobalance=0; // off
    6902:	10 92 7d 0b 	sts	0x0B7D, r1
    6906:	10 92 7c 0b 	sts	0x0B7C, r1
    690a:	8d b7       	in	r24, 0x3d	; 61
    690c:	9e b7       	in	r25, 0x3e	; 62
    690e:	0e 96       	adiw	r24, 0x0e	; 14
    6910:	0f b6       	in	r0, 0x3f	; 63
    6912:	f8 94       	cli
    6914:	9e bf       	out	0x3e, r25	; 62
    6916:	0f be       	out	0x3f, r0	; 63
    6918:	8d bf       	out	0x3d, r24	; 61
    691a:	2f c3       	rjmp	.+1630   	; 0x6f7a <Perform_Action+0x9fa>
		}
		else
		{
			tilt_read(0);
    691c:	80 e0       	ldi	r24, 0x00	; 0
    691e:	0e 94 ad 2f 	call	0x5f5a	; 0x5f5a <tilt_read>
			gX=x_value;gY=y_value;gZ=z_value;
    6922:	80 91 a5 0d 	lds	r24, 0x0DA5
    6926:	90 91 a6 0d 	lds	r25, 0x0DA6
    692a:	90 93 c1 0a 	sts	0x0AC1, r25
    692e:	80 93 c0 0a 	sts	0x0AC0, r24
    6932:	80 91 a7 0d 	lds	r24, 0x0DA7
    6936:	90 91 a8 0d 	lds	r25, 0x0DA8
    693a:	90 93 b3 0a 	sts	0x0AB3, r25
    693e:	80 93 b2 0a 	sts	0x0AB2, r24
    6942:	80 91 af 0d 	lds	r24, 0x0DAF
    6946:	90 91 b0 0d 	lds	r25, 0x0DB0
    694a:	90 93 b7 0a 	sts	0x0AB7, r25
    694e:	80 93 b6 0a 	sts	0x0AB6, r24

#define MAX_INP_BUF 32

void ptime()
{
	rprintf("%d:%d:%d-%d ",gHOUR,gMIN,gSEC,gMSEC);
    6952:	60 91 be 0a 	lds	r22, 0x0ABE
    6956:	70 91 bf 0a 	lds	r23, 0x0ABF
    695a:	80 91 ba 0a 	lds	r24, 0x0ABA
    695e:	20 91 9d 0a 	lds	r18, 0x0A9D
    6962:	40 91 b5 0a 	lds	r20, 0x0AB5
    6966:	7f 93       	push	r23
    6968:	6f 93       	push	r22
    696a:	90 e0       	ldi	r25, 0x00	; 0
    696c:	9f 93       	push	r25
    696e:	8f 93       	push	r24
    6970:	30 e0       	ldi	r19, 0x00	; 0
    6972:	3f 93       	push	r19
    6974:	2f 93       	push	r18
    6976:	50 e0       	ldi	r21, 0x00	; 0
    6978:	5f 93       	push	r21
    697a:	4f 93       	push	r20
    697c:	df 93       	push	r29
    697e:	cf 93       	push	r28
    6980:	11 e0       	ldi	r17, 0x01	; 1
    6982:	1f 93       	push	r17
    6984:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
		}
		else
		{
			tilt_read(0);
			gX=x_value;gY=y_value;gZ=z_value;
			ptime(); rprintf("Accel on - Zero(%d,%d,%d)\r\n", gX,gY,gZ);	
    6988:	80 91 b6 0a 	lds	r24, 0x0AB6
    698c:	90 91 b7 0a 	lds	r25, 0x0AB7
    6990:	9f 93       	push	r25
    6992:	8f 93       	push	r24
    6994:	80 91 b2 0a 	lds	r24, 0x0AB2
    6998:	90 91 b3 0a 	lds	r25, 0x0AB3
    699c:	9f 93       	push	r25
    699e:	8f 93       	push	r24
    69a0:	80 91 c0 0a 	lds	r24, 0x0AC0
    69a4:	90 91 c1 0a 	lds	r25, 0x0AC1
    69a8:	9f 93       	push	r25
    69aa:	8f 93       	push	r24
    69ac:	88 ee       	ldi	r24, 0xE8	; 232
    69ae:	98 e3       	ldi	r25, 0x38	; 56
    69b0:	9f 93       	push	r25
    69b2:	8f 93       	push	r24
    69b4:	1f 93       	push	r17
    69b6:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
			autobalance=1; // on
    69ba:	81 e0       	ldi	r24, 0x01	; 1
    69bc:	90 e0       	ldi	r25, 0x00	; 0
    69be:	90 93 7d 0b 	sts	0x0B7D, r25
    69c2:	80 93 7c 0b 	sts	0x0B7C, r24
    69c6:	2d b7       	in	r18, 0x3d	; 61
    69c8:	3e b7       	in	r19, 0x3e	; 62
    69ca:	2c 5e       	subi	r18, 0xEC	; 236
    69cc:	3f 4f       	sbci	r19, 0xFF	; 255
    69ce:	0f b6       	in	r0, 0x3f	; 63
    69d0:	f8 94       	cli
    69d2:	3e bf       	out	0x3e, r19	; 62
    69d4:	0f be       	out	0x3f, r0	; 63
    69d6:	2d bf       	out	0x3d, r18	; 61
    69d8:	d0 c2       	rjmp	.+1440   	; 0x6f7a <Perform_Action+0x9fa>

#define MAX_INP_BUF 32

void ptime()
{
	rprintf("%d:%d:%d-%d ",gHOUR,gMIN,gSEC,gMSEC);
    69da:	60 91 be 0a 	lds	r22, 0x0ABE
    69de:	70 91 bf 0a 	lds	r23, 0x0ABF
    69e2:	80 91 ba 0a 	lds	r24, 0x0ABA
    69e6:	20 91 9d 0a 	lds	r18, 0x0A9D
    69ea:	40 91 b5 0a 	lds	r20, 0x0AB5
    69ee:	7f 93       	push	r23
    69f0:	6f 93       	push	r22
    69f2:	90 e0       	ldi	r25, 0x00	; 0
    69f4:	9f 93       	push	r25
    69f6:	8f 93       	push	r24
    69f8:	30 e0       	ldi	r19, 0x00	; 0
    69fa:	3f 93       	push	r19
    69fc:	2f 93       	push	r18
    69fe:	50 e0       	ldi	r21, 0x00	; 0
    6a00:	5f 93       	push	r21
    6a02:	4f 93       	push	r20
    6a04:	8d ed       	ldi	r24, 0xDD	; 221
    6a06:	9a e3       	ldi	r25, 0x3A	; 58
    6a08:	9f 93       	push	r25
    6a0a:	8f 93       	push	r24
    6a0c:	11 e0       	ldi	r17, 0x01	; 1
    6a0e:	1f 93       	push	r17
    6a10:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
			ptime(); rprintf("Accel on - Zero(%d,%d,%d)\r\n", gX,gY,gZ);	
			autobalance=1; // on
		}
		break;
	case 0x75: //respond on/off
		ptime(); rprintf("Response (%x)\r\n", response);	
    6a14:	80 91 9b 0a 	lds	r24, 0x0A9B
    6a18:	90 91 9c 0a 	lds	r25, 0x0A9C
    6a1c:	9f 93       	push	r25
    6a1e:	8f 93       	push	r24
    6a20:	88 ed       	ldi	r24, 0xD8	; 216
    6a22:	98 e3       	ldi	r25, 0x38	; 56
    6a24:	9f 93       	push	r25
    6a26:	8f 93       	push	r24
    6a28:	1f 93       	push	r17
    6a2a:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
		response = !response;
    6a2e:	20 e0       	ldi	r18, 0x00	; 0
    6a30:	30 e0       	ldi	r19, 0x00	; 0
    6a32:	8d b7       	in	r24, 0x3d	; 61
    6a34:	9e b7       	in	r25, 0x3e	; 62
    6a36:	40 96       	adiw	r24, 0x10	; 16
    6a38:	0f b6       	in	r0, 0x3f	; 63
    6a3a:	f8 94       	cli
    6a3c:	9e bf       	out	0x3e, r25	; 62
    6a3e:	0f be       	out	0x3f, r0	; 63
    6a40:	8d bf       	out	0x3d, r24	; 61
    6a42:	80 91 9b 0a 	lds	r24, 0x0A9B
    6a46:	90 91 9c 0a 	lds	r25, 0x0A9C
    6a4a:	89 2b       	or	r24, r25
    6a4c:	11 f4       	brne	.+4      	; 0x6a52 <Perform_Action+0x4d2>
    6a4e:	21 e0       	ldi	r18, 0x01	; 1
    6a50:	30 e0       	ldi	r19, 0x00	; 0
    6a52:	30 93 9c 0a 	sts	0x0A9C, r19
    6a56:	20 93 9b 0a 	sts	0x0A9B, r18
    6a5a:	8f c2       	rjmp	.+1310   	; 0x6f7a <Perform_Action+0x9fa>

#define MAX_INP_BUF 32

void ptime()
{
	rprintf("%d:%d:%d-%d ",gHOUR,gMIN,gSEC,gMSEC);
    6a5c:	60 91 be 0a 	lds	r22, 0x0ABE
    6a60:	70 91 bf 0a 	lds	r23, 0x0ABF
    6a64:	80 91 ba 0a 	lds	r24, 0x0ABA
    6a68:	20 91 9d 0a 	lds	r18, 0x0A9D
    6a6c:	40 91 b5 0a 	lds	r20, 0x0AB5
    6a70:	7f 93       	push	r23
    6a72:	6f 93       	push	r22
    6a74:	90 e0       	ldi	r25, 0x00	; 0
    6a76:	9f 93       	push	r25
    6a78:	8f 93       	push	r24
    6a7a:	30 e0       	ldi	r19, 0x00	; 0
    6a7c:	3f 93       	push	r19
    6a7e:	2f 93       	push	r18
    6a80:	50 e0       	ldi	r21, 0x00	; 0
    6a82:	5f 93       	push	r21
    6a84:	4f 93       	push	r20
    6a86:	2d ed       	ldi	r18, 0xDD	; 221
    6a88:	e2 2e       	mov	r14, r18
    6a8a:	2a e3       	ldi	r18, 0x3A	; 58
    6a8c:	f2 2e       	mov	r15, r18
    6a8e:	ff 92       	push	r15
    6a90:	ef 92       	push	r14
    6a92:	11 e0       	ldi	r17, 0x01	; 1
    6a94:	1f 93       	push	r17
    6a96:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
		ptime(); rprintf("Response (%x)\r\n", response);	
		response = !response;
		break;
	case 0x70: //lean forward
	case 0x71: //lean back
		ptime(); rprintf("Dynamic Balance Test F/B (%x)\r\n", Action);	
    6a9a:	80 2f       	mov	r24, r16
    6a9c:	90 e0       	ldi	r25, 0x00	; 0
    6a9e:	9f 93       	push	r25
    6aa0:	8f 93       	push	r24
    6aa2:	88 eb       	ldi	r24, 0xB8	; 184
    6aa4:	98 e3       	ldi	r25, 0x38	; 56
    6aa6:	9f 93       	push	r25
    6aa8:	8f 93       	push	r24
    6aaa:	1f 93       	push	r17
    6aac:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
		
		// Knees ID7, ID2
		//UCSR0B &= 0xBF;
		//UCSR0B |= 0x80;   		// UART0 RxInterrupt enable	
	
		ptmpB = wckPosRead(0x02);
    6ab0:	82 e0       	ldi	r24, 0x02	; 2
    6ab2:	0e 94 62 53 	call	0xa6c4	; 0xa6c4 <wckPosRead>
    6ab6:	c8 2e       	mov	r12, r24
    6ab8:	dd 24       	eor	r13, r13
		ptmpA = wckPosRead(0x07);
    6aba:	87 e0       	ldi	r24, 0x07	; 7
    6abc:	0e 94 62 53 	call	0xa6c4	; 0xa6c4 <wckPosRead>
    6ac0:	c8 2f       	mov	r28, r24
    6ac2:	d0 e0       	ldi	r29, 0x00	; 0

#define MAX_INP_BUF 32

void ptime()
{
	rprintf("%d:%d:%d-%d ",gHOUR,gMIN,gSEC,gMSEC);
    6ac4:	60 91 be 0a 	lds	r22, 0x0ABE
    6ac8:	70 91 bf 0a 	lds	r23, 0x0ABF
    6acc:	80 91 ba 0a 	lds	r24, 0x0ABA
    6ad0:	20 91 9d 0a 	lds	r18, 0x0A9D
    6ad4:	40 91 b5 0a 	lds	r20, 0x0AB5
    6ad8:	7f 93       	push	r23
    6ada:	6f 93       	push	r22
    6adc:	90 e0       	ldi	r25, 0x00	; 0
    6ade:	9f 93       	push	r25
    6ae0:	8f 93       	push	r24
    6ae2:	30 e0       	ldi	r19, 0x00	; 0
    6ae4:	3f 93       	push	r19
    6ae6:	2f 93       	push	r18
    6ae8:	50 e0       	ldi	r21, 0x00	; 0
    6aea:	5f 93       	push	r21
    6aec:	4f 93       	push	r20
    6aee:	ff 92       	push	r15
    6af0:	ef 92       	push	r14
    6af2:	1f 93       	push	r17
    6af4:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
		//UCSR0B |= 0x80;   		// UART0 RxInterrupt enable	
	
		ptmpB = wckPosRead(0x02);
		ptmpA = wckPosRead(0x07);
		
		ptime(); rprintf("ReadPos (2)(7) %x - %x, ", ptmpB, ptmpA);	
    6af8:	df 93       	push	r29
    6afa:	cf 93       	push	r28
    6afc:	df 92       	push	r13
    6afe:	cf 92       	push	r12
    6b00:	8f e9       	ldi	r24, 0x9F	; 159
    6b02:	98 e3       	ldi	r25, 0x38	; 56
    6b04:	9f 93       	push	r25
    6b06:	8f 93       	push	r24
    6b08:	1f 93       	push	r17
    6b0a:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
		
		if (Action == 0x70) tlt = params[TLT];
    6b0e:	2d b7       	in	r18, 0x3d	; 61
    6b10:	3e b7       	in	r19, 0x3e	; 62
    6b12:	2e 5d       	subi	r18, 0xDE	; 222
    6b14:	3f 4f       	sbci	r19, 0xFF	; 255
    6b16:	0f b6       	in	r0, 0x3f	; 63
    6b18:	f8 94       	cli
    6b1a:	3e bf       	out	0x3e, r19	; 62
    6b1c:	0f be       	out	0x3f, r0	; 63
    6b1e:	2d bf       	out	0x3d, r18	; 61
    6b20:	00 37       	cpi	r16, 0x70	; 112
    6b22:	29 f4       	brne	.+10     	; 0x6b2e <Perform_Action+0x5ae>
    6b24:	20 91 a0 0a 	lds	r18, 0x0AA0
    6b28:	30 91 a1 0a 	lds	r19, 0x0AA1
    6b2c:	08 c0       	rjmp	.+16     	; 0x6b3e <Perform_Action+0x5be>
		if (Action == 0x71) tlt = -params[TLT];
    6b2e:	80 91 a0 0a 	lds	r24, 0x0AA0
    6b32:	90 91 a1 0a 	lds	r25, 0x0AA1
    6b36:	22 27       	eor	r18, r18
    6b38:	33 27       	eor	r19, r19
    6b3a:	28 1b       	sub	r18, r24
    6b3c:	39 0b       	sbc	r19, r25
		
		ptmpA &= 0xFF;
		ptmpB &= 0xFF;
		
		ptmpA = ((ptmpA+tlt) & 0xFF); // must be 0-254
    6b3e:	79 01       	movw	r14, r18
    6b40:	ec 0e       	add	r14, r28
    6b42:	fd 1e       	adc	r15, r29
    6b44:	8f ef       	ldi	r24, 0xFF	; 255
    6b46:	e8 22       	and	r14, r24
    6b48:	ff 24       	eor	r15, r15
		ptmpB = ((ptmpB-tlt) & 0xFF); // must be 0-254
    6b4a:	86 01       	movw	r16, r12
    6b4c:	02 1b       	sub	r16, r18
    6b4e:	13 0b       	sbc	r17, r19
    6b50:	10 70       	andi	r17, 0x00	; 0
		
		rprintf("MovePos (%d)  %x - %x\r\n", tlt, ptmpB, ptmpA);	
    6b52:	ff 92       	push	r15
    6b54:	ef 92       	push	r14
    6b56:	1f 93       	push	r17
    6b58:	0f 93       	push	r16
    6b5a:	3f 93       	push	r19
    6b5c:	2f 93       	push	r18
    6b5e:	87 e8       	ldi	r24, 0x87	; 135
    6b60:	98 e3       	ldi	r25, 0x38	; 56
    6b62:	9f 93       	push	r25
    6b64:	8f 93       	push	r24
    6b66:	81 e0       	ldi	r24, 0x01	; 1
    6b68:	8f 93       	push	r24
    6b6a:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
		
		wckPosSend(2, params[TORQ], ptmpB);			
    6b6e:	40 2f       	mov	r20, r16
    6b70:	60 91 a2 0a 	lds	r22, 0x0AA2
    6b74:	82 e0       	ldi	r24, 0x02	; 2
    6b76:	0e 94 15 53 	call	0xa62a	; 0xa62a <wckPosSend>
		wckPosSend(7, params[TORQ], ptmpA);
    6b7a:	4e 2d       	mov	r20, r14
    6b7c:	60 91 a2 0a 	lds	r22, 0x0AA2
    6b80:	87 e0       	ldi	r24, 0x07	; 7
    6b82:	0e 94 15 53 	call	0xa62a	; 0xa62a <wckPosSend>
    6b86:	2d b7       	in	r18, 0x3d	; 61
    6b88:	3e b7       	in	r19, 0x3e	; 62
    6b8a:	27 5f       	subi	r18, 0xF7	; 247
    6b8c:	3f 4f       	sbci	r19, 0xFF	; 255
    6b8e:	1f cf       	rjmp	.-450    	; 0x69ce <Perform_Action+0x44e>

#define MAX_INP_BUF 32

void ptime()
{
	rprintf("%d:%d:%d-%d ",gHOUR,gMIN,gSEC,gMSEC);
    6b90:	60 91 be 0a 	lds	r22, 0x0ABE
    6b94:	70 91 bf 0a 	lds	r23, 0x0ABF
    6b98:	80 91 ba 0a 	lds	r24, 0x0ABA
    6b9c:	20 91 9d 0a 	lds	r18, 0x0A9D
    6ba0:	40 91 b5 0a 	lds	r20, 0x0AB5
    6ba4:	7f 93       	push	r23
    6ba6:	6f 93       	push	r22
    6ba8:	90 e0       	ldi	r25, 0x00	; 0
    6baa:	9f 93       	push	r25
    6bac:	8f 93       	push	r24
    6bae:	30 e0       	ldi	r19, 0x00	; 0
    6bb0:	3f 93       	push	r19
    6bb2:	2f 93       	push	r18
    6bb4:	50 e0       	ldi	r21, 0x00	; 0
    6bb6:	5f 93       	push	r21
    6bb8:	4f 93       	push	r20
    6bba:	8d ed       	ldi	r24, 0xDD	; 221
    6bbc:	9a e3       	ldi	r25, 0x3A	; 58
    6bbe:	9f 93       	push	r25
    6bc0:	8f 93       	push	r24
    6bc2:	11 e0       	ldi	r17, 0x01	; 1
    6bc4:	1f 93       	push	r17
    6bc6:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
		wckPosSend(7, params[TORQ], ptmpA);

		break;
	case 0x72:  //lean left
	case 0x73:  //lean right
		ptime(); rprintf("Dynamic Balance Test L/R (%x)\r\n", Action);	
    6bca:	80 2f       	mov	r24, r16
    6bcc:	90 e0       	ldi	r25, 0x00	; 0
    6bce:	9f 93       	push	r25
    6bd0:	8f 93       	push	r24
    6bd2:	87 e6       	ldi	r24, 0x67	; 103
    6bd4:	98 e3       	ldi	r25, 0x38	; 56
    6bd6:	9f 93       	push	r25
    6bd8:	8f 93       	push	r24
    6bda:	1f 93       	push	r17
    6bdc:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
    6be0:	8d b7       	in	r24, 0x3d	; 61
    6be2:	9e b7       	in	r25, 0x3e	; 62
    6be4:	40 96       	adiw	r24, 0x10	; 16
    6be6:	94 ce       	rjmp	.-728    	; 0x6910 <Perform_Action+0x390>
		break;
		
	case 0x80:
		//version
		rprintf("er=");
    6be8:	83 e6       	ldi	r24, 0x63	; 99
    6bea:	98 e3       	ldi	r25, 0x38	; 56
    6bec:	9f 93       	push	r25
    6bee:	8f 93       	push	r24
    6bf0:	11 e0       	ldi	r17, 0x01	; 1
    6bf2:	1f 93       	push	r17
    6bf4:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
		rprintfProgStr(version);
    6bf8:	8a e3       	ldi	r24, 0x3A	; 58
    6bfa:	91 e0       	ldi	r25, 0x01	; 1
    6bfc:	0e 94 36 2a 	call	0x546c	; 0x546c <rprintfProgStr>
		rprintf("Built: " __DATE__ "\r\n");  // Must have CR, else PC code hangs
    6c00:	8e e4       	ldi	r24, 0x4E	; 78
    6c02:	98 e3       	ldi	r25, 0x38	; 56
    6c04:	9f 93       	push	r25
    6c06:	8f 93       	push	r24
    6c08:	1f 93       	push	r17
    6c0a:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
    6c0e:	2d b7       	in	r18, 0x3d	; 61
    6c10:	3e b7       	in	r19, 0x3e	; 62
    6c12:	2a 5f       	subi	r18, 0xFA	; 250
    6c14:	3f 4f       	sbci	r19, 0xFF	; 255
    6c16:	db ce       	rjmp	.-586    	; 0x69ce <Perform_Action+0x44e>
		

	case 0x90:
		//query mode
		{
		int n=get_noservos();
    6c18:	0e 94 43 42 	call	0x8486	; 0x8486 <get_noservos>
    6c1c:	c8 2f       	mov	r28, r24
    6c1e:	d0 e0       	ldi	r29, 0x00	; 0
		rprintf("%x,", n);	
    6c20:	df 93       	push	r29
    6c22:	cf 93       	push	r28
    6c24:	8a e4       	ldi	r24, 0x4A	; 74
    6c26:	98 e3       	ldi	r25, 0x38	; 56
    6c28:	9f 93       	push	r25
    6c2a:	8f 93       	push	r24
    6c2c:	81 e0       	ldi	r24, 0x01	; 1
    6c2e:	8f 93       	push	r24
    6c30:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
    6c34:	10 e0       	ldi	r17, 0x00	; 0
    6c36:	0f 90       	pop	r0
    6c38:	0f 90       	pop	r0
    6c3a:	0f 90       	pop	r0
    6c3c:	0f 90       	pop	r0
    6c3e:	0f 90       	pop	r0
		
		for (BYTE id=0; id<n; id++)
		{
				ptmpA = wckPosAndLoadRead(id);
				rprintf("%x", ptmpA);	
    6c40:	97 e4       	ldi	r25, 0x47	; 71
    6c42:	c9 2e       	mov	r12, r25
    6c44:	98 e3       	ldi	r25, 0x38	; 56
    6c46:	d9 2e       	mov	r13, r25
    6c48:	01 e0       	ldi	r16, 0x01	; 1
    6c4a:	10 c0       	rjmp	.+32     	; 0x6c6c <Perform_Action+0x6ec>
		int n=get_noservos();
		rprintf("%x,", n);	
		
		for (BYTE id=0; id<n; id++)
		{
				ptmpA = wckPosAndLoadRead(id);
    6c4c:	81 2f       	mov	r24, r17
    6c4e:	0e 94 a5 53 	call	0xa74a	; 0xa74a <wckPosAndLoadRead>
				rprintf("%x", ptmpA);	
    6c52:	9f 93       	push	r25
    6c54:	8f 93       	push	r24
    6c56:	df 92       	push	r13
    6c58:	cf 92       	push	r12
    6c5a:	0f 93       	push	r16
    6c5c:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
		//query mode
		{
		int n=get_noservos();
		rprintf("%x,", n);	
		
		for (BYTE id=0; id<n; id++)
    6c60:	1f 5f       	subi	r17, 0xFF	; 255
    6c62:	0f 90       	pop	r0
    6c64:	0f 90       	pop	r0
    6c66:	0f 90       	pop	r0
    6c68:	0f 90       	pop	r0
    6c6a:	0f 90       	pop	r0
    6c6c:	81 2f       	mov	r24, r17
    6c6e:	90 e0       	ldi	r25, 0x00	; 0
    6c70:	8c 17       	cp	r24, r28
    6c72:	9d 07       	cpc	r25, r29
    6c74:	5c f3       	brlt	.-42     	; 0x6c4c <Perform_Action+0x6cc>
		{
				ptmpA = wckPosAndLoadRead(id);
				rprintf("%x", ptmpA);	
		}
		lbtmp=adc_psd();
    6c76:	0e 94 9c 2c 	call	0x5938	; 0x5938 <adc_psd>
		rprintf("%x", lbtmp);	
    6c7a:	90 e0       	ldi	r25, 0x00	; 0
    6c7c:	9f 93       	push	r25
    6c7e:	8f 93       	push	r24
    6c80:	84 e4       	ldi	r24, 0x44	; 68
    6c82:	98 e3       	ldi	r25, 0x38	; 56
    6c84:	9f 93       	push	r25
    6c86:	8f 93       	push	r24
    6c88:	11 e0       	ldi	r17, 0x01	; 1
    6c8a:	1f 93       	push	r17
    6c8c:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
		lbtmp=adc_mic();
    6c90:	0e 94 fb 2c 	call	0x59f6	; 0x59f6 <adc_mic>
		rprintf("%x", lbtmp);	
    6c94:	90 e0       	ldi	r25, 0x00	; 0
    6c96:	9f 93       	push	r25
    6c98:	8f 93       	push	r24
    6c9a:	81 e4       	ldi	r24, 0x41	; 65
    6c9c:	98 e3       	ldi	r25, 0x38	; 56
    6c9e:	9f 93       	push	r25
    6ca0:	8f 93       	push	r24
    6ca2:	1f 93       	push	r17
    6ca4:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
		ptmpA=adc_volt();
    6ca8:	0e 94 d1 2b 	call	0x57a2	; 0x57a2 <adc_volt>
		rprintf("%x", ptmpA);
    6cac:	9f 93       	push	r25
    6cae:	8f 93       	push	r24
    6cb0:	8e e3       	ldi	r24, 0x3E	; 62
    6cb2:	98 e3       	ldi	r25, 0x38	; 56
    6cb4:	9f 93       	push	r25
    6cb6:	8f 93       	push	r24
    6cb8:	1f 93       	push	r17
    6cba:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
		tilt_read(0);
    6cbe:	80 e0       	ldi	r24, 0x00	; 0
    6cc0:	0e 94 ad 2f 	call	0x5f5a	; 0x5f5a <tilt_read>
		rprintf("%x", x_value);
    6cc4:	80 91 a5 0d 	lds	r24, 0x0DA5
    6cc8:	90 91 a6 0d 	lds	r25, 0x0DA6
    6ccc:	9f 93       	push	r25
    6cce:	8f 93       	push	r24
    6cd0:	8b e3       	ldi	r24, 0x3B	; 59
    6cd2:	98 e3       	ldi	r25, 0x38	; 56
    6cd4:	9f 93       	push	r25
    6cd6:	8f 93       	push	r24
    6cd8:	1f 93       	push	r17
    6cda:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
		rprintf("%x", y_value);
    6cde:	80 91 a7 0d 	lds	r24, 0x0DA7
    6ce2:	90 91 a8 0d 	lds	r25, 0x0DA8
    6ce6:	9f 93       	push	r25
    6ce8:	8f 93       	push	r24
    6cea:	88 e3       	ldi	r24, 0x38	; 56
    6cec:	98 e3       	ldi	r25, 0x38	; 56
    6cee:	9f 93       	push	r25
    6cf0:	8f 93       	push	r24
    6cf2:	1f 93       	push	r17
    6cf4:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
		rprintf("%x  ", z_value);
    6cf8:	80 91 af 0d 	lds	r24, 0x0DAF
    6cfc:	90 91 b0 0d 	lds	r25, 0x0DB0
    6d00:	9f 93       	push	r25
    6d02:	8f 93       	push	r24
    6d04:	83 e3       	ldi	r24, 0x33	; 51
    6d06:	98 e3       	ldi	r25, 0x38	; 56
    6d08:	9f 93       	push	r25
    6d0a:	8f 93       	push	r24
    6d0c:	1f 93       	push	r17
    6d0e:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>

#define MAX_INP_BUF 32

void ptime()
{
	rprintf("%d:%d:%d-%d ",gHOUR,gMIN,gSEC,gMSEC);
    6d12:	60 91 be 0a 	lds	r22, 0x0ABE
    6d16:	70 91 bf 0a 	lds	r23, 0x0ABF
    6d1a:	80 91 ba 0a 	lds	r24, 0x0ABA
    6d1e:	20 91 9d 0a 	lds	r18, 0x0A9D
    6d22:	40 91 b5 0a 	lds	r20, 0x0AB5
    6d26:	7f 93       	push	r23
    6d28:	6f 93       	push	r22
    6d2a:	90 e0       	ldi	r25, 0x00	; 0
    6d2c:	9f 93       	push	r25
    6d2e:	8f 93       	push	r24
    6d30:	30 e0       	ldi	r19, 0x00	; 0
    6d32:	3f 93       	push	r19
    6d34:	2f 93       	push	r18
    6d36:	50 e0       	ldi	r21, 0x00	; 0
    6d38:	5f 93       	push	r21
    6d3a:	4f 93       	push	r20
    6d3c:	8d ed       	ldi	r24, 0xDD	; 221
    6d3e:	9a e3       	ldi	r25, 0x3A	; 58
    6d40:	9f 93       	push	r25
    6d42:	8f 93       	push	r24
    6d44:	1f 93       	push	r17
    6d46:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
		tilt_read(0);
		rprintf("%x", x_value);
		rprintf("%x", y_value);
		rprintf("%x  ", z_value);
		ptime(); 
		rprintf("\r\n");	
    6d4a:	8d b7       	in	r24, 0x3d	; 61
    6d4c:	9e b7       	in	r25, 0x3e	; 62
    6d4e:	89 96       	adiw	r24, 0x29	; 41
    6d50:	0f b6       	in	r0, 0x3f	; 63
    6d52:	f8 94       	cli
    6d54:	9e bf       	out	0x3e, r25	; 62
    6d56:	0f be       	out	0x3f, r0	; 63
    6d58:	8d bf       	out	0x3d, r24	; 61
    6d5a:	80 e3       	ldi	r24, 0x30	; 48
    6d5c:	98 e3       	ldi	r25, 0x38	; 56
    6d5e:	a4 c0       	rjmp	.+328    	; 0x6ea8 <Perform_Action+0x928>
		}
		break;
	case 0x91:
		//query decimal mode
		{
		int n=get_noservos();
    6d60:	0e 94 43 42 	call	0x8486	; 0x8486 <get_noservos>
    6d64:	c8 2f       	mov	r28, r24
    6d66:	d0 e0       	ldi	r29, 0x00	; 0
		rprintf("%d,", n);	
    6d68:	df 93       	push	r29
    6d6a:	cf 93       	push	r28
    6d6c:	8c e2       	ldi	r24, 0x2C	; 44
    6d6e:	98 e3       	ldi	r25, 0x38	; 56
    6d70:	9f 93       	push	r25
    6d72:	8f 93       	push	r24
    6d74:	81 e0       	ldi	r24, 0x01	; 1
    6d76:	8f 93       	push	r24
    6d78:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
    6d7c:	10 e0       	ldi	r17, 0x00	; 0
    6d7e:	0f 90       	pop	r0
    6d80:	0f 90       	pop	r0
    6d82:	0f 90       	pop	r0
    6d84:	0f 90       	pop	r0
    6d86:	0f 90       	pop	r0

		for (BYTE id=0; id<n; id++)
		{
				ptmpA = wckPosAndLoadRead(id);
				rprintf("%d,", ptmpA);	
    6d88:	88 e2       	ldi	r24, 0x28	; 40
    6d8a:	c8 2e       	mov	r12, r24
    6d8c:	88 e3       	ldi	r24, 0x38	; 56
    6d8e:	d8 2e       	mov	r13, r24
    6d90:	01 e0       	ldi	r16, 0x01	; 1
    6d92:	10 c0       	rjmp	.+32     	; 0x6db4 <Perform_Action+0x834>
		int n=get_noservos();
		rprintf("%d,", n);	

		for (BYTE id=0; id<n; id++)
		{
				ptmpA = wckPosAndLoadRead(id);
    6d94:	81 2f       	mov	r24, r17
    6d96:	0e 94 a5 53 	call	0xa74a	; 0xa74a <wckPosAndLoadRead>
				rprintf("%d,", ptmpA);	
    6d9a:	9f 93       	push	r25
    6d9c:	8f 93       	push	r24
    6d9e:	df 92       	push	r13
    6da0:	cf 92       	push	r12
    6da2:	0f 93       	push	r16
    6da4:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
		//query decimal mode
		{
		int n=get_noservos();
		rprintf("%d,", n);	

		for (BYTE id=0; id<n; id++)
    6da8:	1f 5f       	subi	r17, 0xFF	; 255
    6daa:	0f 90       	pop	r0
    6dac:	0f 90       	pop	r0
    6dae:	0f 90       	pop	r0
    6db0:	0f 90       	pop	r0
    6db2:	0f 90       	pop	r0
    6db4:	81 2f       	mov	r24, r17
    6db6:	90 e0       	ldi	r25, 0x00	; 0
    6db8:	8c 17       	cp	r24, r28
    6dba:	9d 07       	cpc	r25, r29
    6dbc:	5c f3       	brlt	.-42     	; 0x6d94 <Perform_Action+0x814>
		{
				ptmpA = wckPosAndLoadRead(id);
				rprintf("%d,", ptmpA);	
		}
		lbtmp=adc_psd();
    6dbe:	0e 94 9c 2c 	call	0x5938	; 0x5938 <adc_psd>
		rprintf("%d,", lbtmp);	
    6dc2:	90 e0       	ldi	r25, 0x00	; 0
    6dc4:	9f 93       	push	r25
    6dc6:	8f 93       	push	r24
    6dc8:	84 e2       	ldi	r24, 0x24	; 36
    6dca:	98 e3       	ldi	r25, 0x38	; 56
    6dcc:	9f 93       	push	r25
    6dce:	8f 93       	push	r24
    6dd0:	11 e0       	ldi	r17, 0x01	; 1
    6dd2:	1f 93       	push	r17
    6dd4:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
		lbtmp=adc_mic();
    6dd8:	0e 94 fb 2c 	call	0x59f6	; 0x59f6 <adc_mic>
		rprintf("%d,", lbtmp);	
    6ddc:	90 e0       	ldi	r25, 0x00	; 0
    6dde:	9f 93       	push	r25
    6de0:	8f 93       	push	r24
    6de2:	80 e2       	ldi	r24, 0x20	; 32
    6de4:	98 e3       	ldi	r25, 0x38	; 56
    6de6:	9f 93       	push	r25
    6de8:	8f 93       	push	r24
    6dea:	1f 93       	push	r17
    6dec:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
		ptmpA=adc_volt();
    6df0:	0e 94 d1 2b 	call	0x57a2	; 0x57a2 <adc_volt>
		rprintf("%d,", ptmpA);
    6df4:	9f 93       	push	r25
    6df6:	8f 93       	push	r24
    6df8:	8c e1       	ldi	r24, 0x1C	; 28
    6dfa:	98 e3       	ldi	r25, 0x38	; 56
    6dfc:	9f 93       	push	r25
    6dfe:	8f 93       	push	r24
    6e00:	1f 93       	push	r17
    6e02:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
		tilt_read(0);
    6e06:	80 e0       	ldi	r24, 0x00	; 0
    6e08:	0e 94 ad 2f 	call	0x5f5a	; 0x5f5a <tilt_read>
		rprintf("%d,", (int)x_value);
    6e0c:	80 91 a5 0d 	lds	r24, 0x0DA5
    6e10:	90 91 a6 0d 	lds	r25, 0x0DA6
    6e14:	9f 93       	push	r25
    6e16:	8f 93       	push	r24
    6e18:	88 e1       	ldi	r24, 0x18	; 24
    6e1a:	98 e3       	ldi	r25, 0x38	; 56
    6e1c:	9f 93       	push	r25
    6e1e:	8f 93       	push	r24
    6e20:	1f 93       	push	r17
    6e22:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
		rprintf("%d,", (int)y_value);
    6e26:	80 91 a7 0d 	lds	r24, 0x0DA7
    6e2a:	90 91 a8 0d 	lds	r25, 0x0DA8
    6e2e:	9f 93       	push	r25
    6e30:	8f 93       	push	r24
    6e32:	84 e1       	ldi	r24, 0x14	; 20
    6e34:	98 e3       	ldi	r25, 0x38	; 56
    6e36:	9f 93       	push	r25
    6e38:	8f 93       	push	r24
    6e3a:	1f 93       	push	r17
    6e3c:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
		rprintf("%d  ", (int)z_value);
    6e40:	80 91 af 0d 	lds	r24, 0x0DAF
    6e44:	90 91 b0 0d 	lds	r25, 0x0DB0
    6e48:	9f 93       	push	r25
    6e4a:	8f 93       	push	r24
    6e4c:	8f e0       	ldi	r24, 0x0F	; 15
    6e4e:	98 e3       	ldi	r25, 0x38	; 56
    6e50:	9f 93       	push	r25
    6e52:	8f 93       	push	r24
    6e54:	1f 93       	push	r17
    6e56:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>

#define MAX_INP_BUF 32

void ptime()
{
	rprintf("%d:%d:%d-%d ",gHOUR,gMIN,gSEC,gMSEC);
    6e5a:	60 91 be 0a 	lds	r22, 0x0ABE
    6e5e:	70 91 bf 0a 	lds	r23, 0x0ABF
    6e62:	80 91 ba 0a 	lds	r24, 0x0ABA
    6e66:	20 91 9d 0a 	lds	r18, 0x0A9D
    6e6a:	40 91 b5 0a 	lds	r20, 0x0AB5
    6e6e:	7f 93       	push	r23
    6e70:	6f 93       	push	r22
    6e72:	90 e0       	ldi	r25, 0x00	; 0
    6e74:	9f 93       	push	r25
    6e76:	8f 93       	push	r24
    6e78:	30 e0       	ldi	r19, 0x00	; 0
    6e7a:	3f 93       	push	r19
    6e7c:	2f 93       	push	r18
    6e7e:	50 e0       	ldi	r21, 0x00	; 0
    6e80:	5f 93       	push	r21
    6e82:	4f 93       	push	r20
    6e84:	8d ed       	ldi	r24, 0xDD	; 221
    6e86:	9a e3       	ldi	r25, 0x3A	; 58
    6e88:	9f 93       	push	r25
    6e8a:	8f 93       	push	r24
    6e8c:	1f 93       	push	r17
    6e8e:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
		tilt_read(0);
		rprintf("%d,", (int)x_value);
		rprintf("%d,", (int)y_value);
		rprintf("%d  ", (int)z_value);
		ptime(); 
		rprintf("\r\n");	
    6e92:	2d b7       	in	r18, 0x3d	; 61
    6e94:	3e b7       	in	r19, 0x3e	; 62
    6e96:	27 5d       	subi	r18, 0xD7	; 215
    6e98:	3f 4f       	sbci	r19, 0xFF	; 255
    6e9a:	0f b6       	in	r0, 0x3f	; 63
    6e9c:	f8 94       	cli
    6e9e:	3e bf       	out	0x3e, r19	; 62
    6ea0:	0f be       	out	0x3f, r0	; 63
    6ea2:	2d bf       	out	0x3d, r18	; 61
    6ea4:	8c e0       	ldi	r24, 0x0C	; 12
    6ea6:	98 e3       	ldi	r25, 0x38	; 56
    6ea8:	9f 93       	push	r25
    6eaa:	8f 93       	push	r24
    6eac:	1f 93       	push	r17
    6eae:	60 c0       	rjmp	.+192    	; 0x6f70 <Perform_Action+0x9f0>
		
	// very experimental - BASIC
	// Short term aim - simple eprograms controlling motions
	// long term aim  - to be compatible with Robonova basic
	case 0xC0:
		basic_load();
    6eb0:	0e 94 be 4a 	call	0x957c	; 0x957c <basic_load>
    6eb4:	62 c0       	rjmp	.+196    	; 0x6f7a <Perform_Action+0x9fa>
		break;
	case 0xC1:
		basic_run(0);
    6eb6:	80 e0       	ldi	r24, 0x00	; 0
    6eb8:	90 e0       	ldi	r25, 0x00	; 0
    6eba:	0a c0       	rjmp	.+20     	; 0x6ed0 <Perform_Action+0x950>
		break;		
	case 0xC2:
		basic_clear();
    6ebc:	0e 94 b8 44 	call	0x8970	; 0x8970 <basic_clear>
    6ec0:	5c c0       	rjmp	.+184    	; 0x6f7a <Perform_Action+0x9fa>
		break;	
	case 0xC3:
		basic_list();
    6ec2:	0e 94 ba 45 	call	0x8b74	; 0x8b74 <basic_list>
    6ec6:	59 c0       	rjmp	.+178    	; 0x6f7a <Perform_Action+0x9fa>
		break;
	case 0xC4:
		basic_list();
    6ec8:	0e 94 ba 45 	call	0x8b74	; 0x8b74 <basic_list>
		basic_run(1);
    6ecc:	81 e0       	ldi	r24, 0x01	; 1
    6ece:	90 e0       	ldi	r25, 0x00	; 0
    6ed0:	0e 94 b0 4e 	call	0x9d60	; 0x9d60 <basic_run>
    6ed4:	52 c0       	rjmp	.+164    	; 0x6f7a <Perform_Action+0x9fa>
		break;				
	case 0xC5:
		dump_firmware();
    6ed6:	0e 94 93 43 	call	0x8726	; 0x8726 <dump_firmware>
    6eda:	4f c0       	rjmp	.+158    	; 0x6f7a <Perform_Action+0x9fa>
		break;	
	//case 0xC6:
	//	basic_download();
	//	break;	
	case 0xC7:
		dump();
    6edc:	0e 94 25 44 	call	0x884a	; 0x884a <dump>
    6ee0:	4c c0       	rjmp	.+152    	; 0x6f7a <Perform_Action+0x9fa>
		break;	
		
		//Robot type - prep for 20 dof	
	case 0xD8:
		switch(get_type())
    6ee2:	0e 94 3a 42 	call	0x8474	; 0x8474 <get_type>
    6ee6:	28 2f       	mov	r18, r24
    6ee8:	81 30       	cpi	r24, 0x01	; 1
    6eea:	49 f0       	breq	.+18     	; 0x6efe <Perform_Action+0x97e>
    6eec:	81 30       	cpi	r24, 0x01	; 1
    6eee:	20 f0       	brcs	.+8      	; 0x6ef8 <Perform_Action+0x978>
    6ef0:	82 30       	cpi	r24, 0x02	; 2
    6ef2:	09 f0       	breq	.+2      	; 0x6ef6 <Perform_Action+0x976>
    6ef4:	42 c0       	rjmp	.+132    	; 0x6f7a <Perform_Action+0x9fa>
    6ef6:	09 c0       	rjmp	.+18     	; 0x6f0a <Perform_Action+0x98a>
		{
		case HUNO_BASIC:
			rprintf("Robot type - BASIC\r\n"); break;
    6ef8:	87 ef       	ldi	r24, 0xF7	; 247
    6efa:	97 e3       	ldi	r25, 0x37	; 55
    6efc:	35 c0       	rjmp	.+106    	; 0x6f68 <Perform_Action+0x9e8>
		case HUNO_ADVANCED:
			rprintf("Robot type - ADANCED\r\n"); break;
    6efe:	80 ee       	ldi	r24, 0xE0	; 224
    6f00:	97 e3       	ldi	r25, 0x37	; 55
    6f02:	9f 93       	push	r25
    6f04:	8f 93       	push	r24
    6f06:	2f 93       	push	r18
    6f08:	33 c0       	rjmp	.+102    	; 0x6f70 <Perform_Action+0x9f0>
		case HUNO_OTHER:
			rprintf("Robot type - OTHER\r\n"); break;
    6f0a:	8b ec       	ldi	r24, 0xCB	; 203
    6f0c:	97 e3       	ldi	r25, 0x37	; 55
    6f0e:	2c c0       	rjmp	.+88     	; 0x6f68 <Perform_Action+0x9e8>
		}
		break;	
	case 0xD9:
		rprintf("set Robot type Huno\r\n");
    6f10:	85 eb       	ldi	r24, 0xB5	; 181
    6f12:	97 e3       	ldi	r25, 0x37	; 55
    6f14:	9f 93       	push	r25
    6f16:	8f 93       	push	r24
    6f18:	81 e0       	ldi	r24, 0x01	; 1
    6f1a:	8f 93       	push	r24
    6f1c:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
		set_type(HUNO_BASIC);
    6f20:	80 e0       	ldi	r24, 0x00	; 0
    6f22:	13 c0       	rjmp	.+38     	; 0x6f4a <Perform_Action+0x9ca>
		break;	
	case 0xDA:
		rprintf("set Robot type Adv\r\n");
    6f24:	80 ea       	ldi	r24, 0xA0	; 160
    6f26:	97 e3       	ldi	r25, 0x37	; 55
    6f28:	9f 93       	push	r25
    6f2a:	8f 93       	push	r24
    6f2c:	81 e0       	ldi	r24, 0x01	; 1
    6f2e:	8f 93       	push	r24
    6f30:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
		set_type(HUNO_ADVANCED);
    6f34:	81 e0       	ldi	r24, 0x01	; 1
    6f36:	09 c0       	rjmp	.+18     	; 0x6f4a <Perform_Action+0x9ca>
		break;		
	case 0xDB:
		rprintf("set Robot type Other\r\n");
    6f38:	89 e8       	ldi	r24, 0x89	; 137
    6f3a:	97 e3       	ldi	r25, 0x37	; 55
    6f3c:	9f 93       	push	r25
    6f3e:	8f 93       	push	r24
    6f40:	81 e0       	ldi	r24, 0x01	; 1
    6f42:	8f 93       	push	r24
    6f44:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
		set_type(HUNO_OTHER);
    6f48:	82 e0       	ldi	r24, 0x02	; 2
    6f4a:	0e 94 2c 42 	call	0x8458	; 0x8458 <set_type>
    6f4e:	12 c0       	rjmp	.+36     	; 0x6f74 <Perform_Action+0x9f4>
		break;	
		
	case 0xD0:
		//experimental
		gNextMode = kChargeMode;
    6f50:	82 e0       	ldi	r24, 0x02	; 2
    6f52:	90 e0       	ldi	r25, 0x00	; 0
    6f54:	90 93 80 0b 	sts	0x0B80, r25
    6f58:	80 93 7f 0b 	sts	0x0B7F, r24
    6f5c:	0e c0       	rjmp	.+28     	; 0x6f7a <Perform_Action+0x9fa>
		break;	
		
	case 0xE8:
		//binary mode
		experimental_binloop();
    6f5e:	0e 94 bd 5b 	call	0xb77a	; 0xb77a <experimental_binloop>
    6f62:	0b c0       	rjmp	.+22     	; 0x6f7a <Perform_Action+0x9fa>
		break;	

	case 0xEE:
		//help
		
		rprintf(
    6f64:	85 ee       	ldi	r24, 0xE5	; 229
    6f66:	94 e3       	ldi	r25, 0x34	; 52
    6f68:	9f 93       	push	r25
    6f6a:	8f 93       	push	r24
    6f6c:	81 e0       	ldi	r24, 0x01	; 1
    6f6e:	8f 93       	push	r24
    6f70:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
    6f74:	0f 90       	pop	r0
    6f76:	0f 90       	pop	r0
    6f78:	0f 90       	pop	r0

		"#  binary mode\r\n"
		);	
		break;	
	}
} 
    6f7a:	df 91       	pop	r29
    6f7c:	cf 91       	pop	r28
    6f7e:	1f 91       	pop	r17
    6f80:	0f 91       	pop	r16
    6f82:	ff 90       	pop	r15
    6f84:	ef 90       	pop	r14
    6f86:	df 90       	pop	r13
    6f88:	cf 90       	pop	r12
    6f8a:	08 95       	ret

00006f8c <getHex>:
	}
	return n;
}

int getHex(int d)
{
    6f8c:	9f 92       	push	r9
    6f8e:	af 92       	push	r10
    6f90:	bf 92       	push	r11
    6f92:	cf 92       	push	r12
    6f94:	df 92       	push	r13
    6f96:	ef 92       	push	r14
    6f98:	ff 92       	push	r15
    6f9a:	0f 93       	push	r16
    6f9c:	1f 93       	push	r17
    6f9e:	cf 93       	push	r28
    6fa0:	df 93       	push	r29
    6fa2:	6c 01       	movw	r12, r24
    6fa4:	c0 e0       	ldi	r28, 0x00	; 0
    6fa6:	d0 e0       	ldi	r29, 0x00	; 0
    6fa8:	ee 24       	eor	r14, r14
    6faa:	ff 24       	eor	r15, r15
	int ch;
	
	for (int i=0; i<d; i++)
	{
			while ((ch = uartGetByte())<0) ;
			rprintf("%c", ch);	
    6fac:	57 ed       	ldi	r21, 0xD7	; 215
    6fae:	a5 2e       	mov	r10, r21
    6fb0:	5a e3       	ldi	r21, 0x3A	; 58
    6fb2:	b5 2e       	mov	r11, r21
    6fb4:	99 24       	eor	r9, r9
    6fb6:	93 94       	inc	r9
    6fb8:	2f c0       	rjmp	.+94     	; 0x7018 <getHex+0x8c>
	int n=0;
	int ch;
	
	for (int i=0; i<d; i++)
	{
			while ((ch = uartGetByte())<0) ;
    6fba:	0e 94 9c 22 	call	0x4538	; 0x4538 <uartGetByte>
    6fbe:	8c 01       	movw	r16, r24
    6fc0:	97 fd       	sbrc	r25, 7
    6fc2:	fb cf       	rjmp	.-10     	; 0x6fba <getHex+0x2e>
			rprintf("%c", ch);	
    6fc4:	9f 93       	push	r25
    6fc6:	8f 93       	push	r24
    6fc8:	bf 92       	push	r11
    6fca:	af 92       	push	r10
    6fcc:	9f 92       	push	r9
    6fce:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
			if ((ch>=0x30) && (ch<=0x39)) { n = n*16 + (ch-0x30); }
    6fd2:	c8 01       	movw	r24, r16
    6fd4:	c0 97       	sbiw	r24, 0x30	; 48
    6fd6:	0f 90       	pop	r0
    6fd8:	0f 90       	pop	r0
    6fda:	0f 90       	pop	r0
    6fdc:	0f 90       	pop	r0
    6fde:	0f 90       	pop	r0
    6fe0:	0a 97       	sbiw	r24, 0x0a	; 10
    6fe2:	40 f4       	brcc	.+16     	; 0x6ff4 <getHex+0x68>
    6fe4:	44 e0       	ldi	r20, 0x04	; 4
    6fe6:	cc 0f       	add	r28, r28
    6fe8:	dd 1f       	adc	r29, r29
    6fea:	4a 95       	dec	r20
    6fec:	e1 f7       	brne	.-8      	; 0x6fe6 <getHex+0x5a>
    6fee:	e0 97       	sbiw	r28, 0x30	; 48
    6ff0:	c0 0f       	add	r28, r16
    6ff2:	d1 1f       	adc	r29, r17
			if ((ch>=0x41) && (ch<=0x46)) { n = n*16 + (ch-0x41+10); }
    6ff4:	c8 01       	movw	r24, r16
    6ff6:	81 54       	subi	r24, 0x41	; 65
    6ff8:	90 40       	sbci	r25, 0x00	; 0
    6ffa:	06 97       	sbiw	r24, 0x06	; 6
    6ffc:	50 f4       	brcc	.+20     	; 0x7012 <getHex+0x86>
    6ffe:	ce 01       	movw	r24, r28
    7000:	34 e0       	ldi	r19, 0x04	; 4
    7002:	88 0f       	add	r24, r24
    7004:	99 1f       	adc	r25, r25
    7006:	3a 95       	dec	r19
    7008:	e1 f7       	brne	.-8      	; 0x7002 <getHex+0x76>
    700a:	e8 01       	movw	r28, r16
    700c:	e7 97       	sbiw	r28, 0x37	; 55
    700e:	c8 0f       	add	r28, r24
    7010:	d9 1f       	adc	r29, r25
int getHex(int d)
{
	int n=0;
	int ch;
	
	for (int i=0; i<d; i++)
    7012:	08 94       	sec
    7014:	e1 1c       	adc	r14, r1
    7016:	f1 1c       	adc	r15, r1
    7018:	ec 14       	cp	r14, r12
    701a:	fd 04       	cpc	r15, r13
    701c:	74 f2       	brlt	.-100    	; 0x6fba <getHex+0x2e>
			rprintf("%c", ch);	
			if ((ch>=0x30) && (ch<=0x39)) { n = n*16 + (ch-0x30); }
			if ((ch>=0x41) && (ch<=0x46)) { n = n*16 + (ch-0x41+10); }
	}
	return n;
}
    701e:	ce 01       	movw	r24, r28
    7020:	df 91       	pop	r29
    7022:	cf 91       	pop	r28
    7024:	1f 91       	pop	r17
    7026:	0f 91       	pop	r16
    7028:	ff 90       	pop	r15
    702a:	ef 90       	pop	r14
    702c:	df 90       	pop	r13
    702e:	cf 90       	pop	r12
    7030:	bf 90       	pop	r11
    7032:	af 90       	pop	r10
    7034:	9f 90       	pop	r9
    7036:	08 95       	ret

00007038 <getDec>:
{
	rprintf("%d:%d:%d-%d ",gHOUR,gMIN,gSEC,gMSEC);
}

int getDec(int d)
{
    7038:	9f 92       	push	r9
    703a:	af 92       	push	r10
    703c:	bf 92       	push	r11
    703e:	cf 92       	push	r12
    7040:	df 92       	push	r13
    7042:	ef 92       	push	r14
    7044:	ff 92       	push	r15
    7046:	0f 93       	push	r16
    7048:	1f 93       	push	r17
    704a:	cf 93       	push	r28
    704c:	df 93       	push	r29
    704e:	6c 01       	movw	r12, r24
    7050:	c0 e0       	ldi	r28, 0x00	; 0
    7052:	d0 e0       	ldi	r29, 0x00	; 0
    7054:	ee 24       	eor	r14, r14
    7056:	ff 24       	eor	r15, r15
	int ch;
	
	for (int i=0; i<d; i++)
	{
			while ((ch = uartGetByte())<0) ;
			rprintf("%c", ch);	
    7058:	ea ed       	ldi	r30, 0xDA	; 218
    705a:	ae 2e       	mov	r10, r30
    705c:	ea e3       	ldi	r30, 0x3A	; 58
    705e:	be 2e       	mov	r11, r30
    7060:	99 24       	eor	r9, r9
    7062:	93 94       	inc	r9
    7064:	25 c0       	rjmp	.+74     	; 0x70b0 <getDec+0x78>
	int n=0;
	int ch;
	
	for (int i=0; i<d; i++)
	{
			while ((ch = uartGetByte())<0) ;
    7066:	0e 94 9c 22 	call	0x4538	; 0x4538 <uartGetByte>
    706a:	8c 01       	movw	r16, r24
    706c:	97 fd       	sbrc	r25, 7
    706e:	fb cf       	rjmp	.-10     	; 0x7066 <getDec+0x2e>
			rprintf("%c", ch);	
    7070:	9f 93       	push	r25
    7072:	8f 93       	push	r24
    7074:	bf 92       	push	r11
    7076:	af 92       	push	r10
    7078:	9f 92       	push	r9
    707a:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
			if ((ch>=0x30) && (ch<=0x39)) { n = n*10 + (ch-0x30); }
    707e:	c8 01       	movw	r24, r16
    7080:	c0 97       	sbiw	r24, 0x30	; 48
    7082:	0f 90       	pop	r0
    7084:	0f 90       	pop	r0
    7086:	0f 90       	pop	r0
    7088:	0f 90       	pop	r0
    708a:	0f 90       	pop	r0
    708c:	0a 97       	sbiw	r24, 0x0a	; 10
    708e:	68 f4       	brcc	.+26     	; 0x70aa <getDec+0x72>
    7090:	ce 01       	movw	r24, r28
    7092:	73 e0       	ldi	r23, 0x03	; 3
    7094:	88 0f       	add	r24, r24
    7096:	99 1f       	adc	r25, r25
    7098:	7a 95       	dec	r23
    709a:	e1 f7       	brne	.-8      	; 0x7094 <getDec+0x5c>
    709c:	cc 0f       	add	r28, r28
    709e:	dd 1f       	adc	r29, r29
    70a0:	c8 0f       	add	r28, r24
    70a2:	d9 1f       	adc	r29, r25
    70a4:	e0 97       	sbiw	r28, 0x30	; 48
    70a6:	c0 0f       	add	r28, r16
    70a8:	d1 1f       	adc	r29, r17
int getDec(int d)
{
	int n=0;
	int ch;
	
	for (int i=0; i<d; i++)
    70aa:	08 94       	sec
    70ac:	e1 1c       	adc	r14, r1
    70ae:	f1 1c       	adc	r15, r1
    70b0:	ec 14       	cp	r14, r12
    70b2:	fd 04       	cpc	r15, r13
    70b4:	c4 f2       	brlt	.-80     	; 0x7066 <getDec+0x2e>
			while ((ch = uartGetByte())<0) ;
			rprintf("%c", ch);	
			if ((ch>=0x30) && (ch<=0x39)) { n = n*10 + (ch-0x30); }
	}
	return n;
}
    70b6:	ce 01       	movw	r24, r28
    70b8:	df 91       	pop	r29
    70ba:	cf 91       	pop	r28
    70bc:	1f 91       	pop	r17
    70be:	0f 91       	pop	r16
    70c0:	ff 90       	pop	r15
    70c2:	ef 90       	pop	r14
    70c4:	df 90       	pop	r13
    70c6:	cf 90       	pop	r12
    70c8:	bf 90       	pop	r11
    70ca:	af 90       	pop	r10
    70cc:	9f 90       	pop	r9
    70ce:	08 95       	ret

000070d0 <check_serial>:
		}
	}
}

void check_serial(BYTE *action)
{
    70d0:	4f 92       	push	r4
    70d2:	5f 92       	push	r5
    70d4:	6f 92       	push	r6
    70d6:	7f 92       	push	r7
    70d8:	8f 92       	push	r8
    70da:	9f 92       	push	r9
    70dc:	af 92       	push	r10
    70de:	bf 92       	push	r11
    70e0:	cf 92       	push	r12
    70e2:	df 92       	push	r13
    70e4:	ef 92       	push	r14
    70e6:	ff 92       	push	r15
    70e8:	0f 93       	push	r16
    70ea:	1f 93       	push	r17
    70ec:	df 93       	push	r29
    70ee:	cf 93       	push	r28
    70f0:	cd b7       	in	r28, 0x3d	; 61
    70f2:	de b7       	in	r29, 0x3e	; 62
    70f4:	a0 97       	sbiw	r28, 0x20	; 32
    70f6:	0f b6       	in	r0, 0x3f	; 63
    70f8:	f8 94       	cli
    70fa:	de bf       	out	0x3e, r29	; 62
    70fc:	0f be       	out	0x3f, r0	; 63
    70fe:	cd bf       	out	0x3d, r28	; 61
    7100:	6c 01       	movw	r12, r24
	int c,l;
	BYTE buff[MAX_INP_BUF];
	
	int ch = uartGetByte();
    7102:	0e 94 9c 22 	call	0x4538	; 0x4538 <uartGetByte>
    7106:	7c 01       	movw	r14, r24
	if (ch >= 0)
    7108:	97 fd       	sbrc	r25, 7
    710a:	a5 c2       	rjmp	.+1354   	; 0x7656 <check_serial+0x586>
	{
		rprintf("%c", ch);	
    710c:	9f 93       	push	r25
    710e:	8f 93       	push	r24
    7110:	8b ea       	ldi	r24, 0xAB	; 171
    7112:	9a e3       	ldi	r25, 0x3A	; 58
    7114:	9f 93       	push	r25
    7116:	8f 93       	push	r24
    7118:	81 e0       	ldi	r24, 0x01	; 1
    711a:	8f 93       	push	r24
    711c:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
		
		if (ch==0x4C) *action=0x02;  	  //'L' pressed
    7120:	0f 90       	pop	r0
    7122:	0f 90       	pop	r0
    7124:	0f 90       	pop	r0
    7126:	0f 90       	pop	r0
    7128:	0f 90       	pop	r0
    712a:	8c e4       	ldi	r24, 0x4C	; 76
    712c:	e8 16       	cp	r14, r24
    712e:	f1 04       	cpc	r15, r1
    7130:	21 f4       	brne	.+8      	; 0x713a <check_serial+0x6a>
    7132:	82 e0       	ldi	r24, 0x02	; 2
    7134:	f6 01       	movw	r30, r12
    7136:	80 83       	st	Z, r24
    7138:	18 c0       	rjmp	.+48     	; 0x716a <check_serial+0x9a>
		if (ch==0x52) *action=0x03;       //'R' pressed
    713a:	f2 e5       	ldi	r31, 0x52	; 82
    713c:	ef 16       	cp	r14, r31
    713e:	f1 04       	cpc	r15, r1
    7140:	21 f4       	brne	.+8      	; 0x714a <check_serial+0x7a>
    7142:	83 e0       	ldi	r24, 0x03	; 3
    7144:	f6 01       	movw	r30, r12
    7146:	80 83       	st	Z, r24
    7148:	18 c0       	rjmp	.+48     	; 0x717a <check_serial+0xaa>
		if (ch==0x46) *action=0x08;       //'F' pressed
    714a:	f6 e4       	ldi	r31, 0x46	; 70
    714c:	ef 16       	cp	r14, r31
    714e:	f1 04       	cpc	r15, r1
    7150:	21 f4       	brne	.+8      	; 0x715a <check_serial+0x8a>
    7152:	88 e0       	ldi	r24, 0x08	; 8
    7154:	f6 01       	movw	r30, r12
    7156:	80 83       	st	Z, r24
    7158:	18 c0       	rjmp	.+48     	; 0x718a <check_serial+0xba>
		if (ch==0x42) *action=0x09;       //'B' pressed
    715a:	f2 e4       	ldi	r31, 0x42	; 66
    715c:	ef 16       	cp	r14, r31
    715e:	f1 04       	cpc	r15, r1
    7160:	21 f4       	brne	.+8      	; 0x716a <check_serial+0x9a>
    7162:	89 e0       	ldi	r24, 0x09	; 9
    7164:	f6 01       	movw	r30, r12
    7166:	80 83       	st	Z, r24
    7168:	18 c0       	rjmp	.+48     	; 0x719a <check_serial+0xca>


		if (ch==0x7a) *action=0x74;       //'z' pressed
    716a:	fa e7       	ldi	r31, 0x7A	; 122
    716c:	ef 16       	cp	r14, r31
    716e:	f1 04       	cpc	r15, r1
    7170:	21 f4       	brne	.+8      	; 0x717a <check_serial+0xaa>
    7172:	84 e7       	ldi	r24, 0x74	; 116
    7174:	f6 01       	movw	r30, r12
    7176:	80 83       	st	Z, r24
    7178:	18 c0       	rjmp	.+48     	; 0x71aa <check_serial+0xda>
		if (ch==0x77) *action=0x70;       //'w' pressed
    717a:	f7 e7       	ldi	r31, 0x77	; 119
    717c:	ef 16       	cp	r14, r31
    717e:	f1 04       	cpc	r15, r1
    7180:	21 f4       	brne	.+8      	; 0x718a <check_serial+0xba>
    7182:	80 e7       	ldi	r24, 0x70	; 112
    7184:	f6 01       	movw	r30, r12
    7186:	80 83       	st	Z, r24
    7188:	18 c0       	rjmp	.+48     	; 0x71ba <check_serial+0xea>
		if (ch==0x73) *action=0x71;       //'s' pressed
    718a:	f3 e7       	ldi	r31, 0x73	; 115
    718c:	ef 16       	cp	r14, r31
    718e:	f1 04       	cpc	r15, r1
    7190:	21 f4       	brne	.+8      	; 0x719a <check_serial+0xca>
    7192:	81 e7       	ldi	r24, 0x71	; 113
    7194:	f6 01       	movw	r30, r12
    7196:	80 83       	st	Z, r24
    7198:	18 c0       	rjmp	.+48     	; 0x71ca <check_serial+0xfa>
		if (ch==0x61) *action=0x72;       //'a' pressed
    719a:	f1 e6       	ldi	r31, 0x61	; 97
    719c:	ef 16       	cp	r14, r31
    719e:	f1 04       	cpc	r15, r1
    71a0:	21 f4       	brne	.+8      	; 0x71aa <check_serial+0xda>
    71a2:	82 e7       	ldi	r24, 0x72	; 114
    71a4:	f6 01       	movw	r30, r12
    71a6:	80 83       	st	Z, r24
    71a8:	18 c0       	rjmp	.+48     	; 0x71da <check_serial+0x10a>
		if (ch==0x64) *action=0x73;       //'d' pressed
    71aa:	f4 e6       	ldi	r31, 0x64	; 100
    71ac:	ef 16       	cp	r14, r31
    71ae:	f1 04       	cpc	r15, r1
    71b0:	21 f4       	brne	.+8      	; 0x71ba <check_serial+0xea>
    71b2:	83 e7       	ldi	r24, 0x73	; 115
    71b4:	f6 01       	movw	r30, r12
    71b6:	80 83       	st	Z, r24
    71b8:	18 c0       	rjmp	.+48     	; 0x71ea <check_serial+0x11a>
		
		if (ch==0x72) *action=0x75;       //'r' pressed
    71ba:	f2 e7       	ldi	r31, 0x72	; 114
    71bc:	ef 16       	cp	r14, r31
    71be:	f1 04       	cpc	r15, r1
    71c0:	21 f4       	brne	.+8      	; 0x71ca <check_serial+0xfa>
    71c2:	85 e7       	ldi	r24, 0x75	; 117
    71c4:	f6 01       	movw	r30, r12
    71c6:	80 83       	st	Z, r24
    71c8:	18 c0       	rjmp	.+48     	; 0x71fa <check_serial+0x12a>

		if (ch==0x70) *action=0x20;       //'p' pressed
    71ca:	f0 e7       	ldi	r31, 0x70	; 112
    71cc:	ef 16       	cp	r14, r31
    71ce:	f1 04       	cpc	r15, r1
    71d0:	21 f4       	brne	.+8      	; 0x71da <check_serial+0x10a>
    71d2:	80 e2       	ldi	r24, 0x20	; 32
    71d4:	f6 01       	movw	r30, r12
    71d6:	80 83       	st	Z, r24
    71d8:	18 c0       	rjmp	.+48     	; 0x720a <check_serial+0x13a>
		if (ch==0x6c) *action=0x30;       //'l' pressed			
    71da:	fc e6       	ldi	r31, 0x6C	; 108
    71dc:	ef 16       	cp	r14, r31
    71de:	f1 04       	cpc	r15, r1
    71e0:	21 f4       	brne	.+8      	; 0x71ea <check_serial+0x11a>
    71e2:	80 e3       	ldi	r24, 0x30	; 48
    71e4:	f6 01       	movw	r30, r12
    71e6:	80 83       	st	Z, r24
    71e8:	18 c0       	rjmp	.+48     	; 0x721a <check_serial+0x14a>
		if (ch==0x69) *action=0x40;       //'i' pressed		
    71ea:	f9 e6       	ldi	r31, 0x69	; 105
    71ec:	ef 16       	cp	r14, r31
    71ee:	f1 04       	cpc	r15, r1
    71f0:	21 f4       	brne	.+8      	; 0x71fa <check_serial+0x12a>
    71f2:	80 e4       	ldi	r24, 0x40	; 64
    71f4:	f6 01       	movw	r30, r12
    71f6:	80 83       	st	Z, r24
    71f8:	16 c0       	rjmp	.+44     	; 0x7226 <check_serial+0x156>
		
		
		if (ch==0x74) *action=0x50;       //'query mode
    71fa:	f4 e7       	ldi	r31, 0x74	; 116
    71fc:	ef 16       	cp	r14, r31
    71fe:	f1 04       	cpc	r15, r1
    7200:	21 f4       	brne	.+8      	; 0x720a <check_serial+0x13a>
    7202:	80 e5       	ldi	r24, 0x50	; 80
    7204:	f6 01       	movw	r30, r12
    7206:	80 83       	st	Z, r24
    7208:	16 c0       	rjmp	.+44     	; 0x7236 <check_serial+0x166>


		if (ch=='!') *action=0xC1;       //'program run mode
    720a:	f1 e2       	ldi	r31, 0x21	; 33
    720c:	ef 16       	cp	r14, r31
    720e:	f1 04       	cpc	r15, r1
    7210:	21 f4       	brne	.+8      	; 0x721a <check_serial+0x14a>
    7212:	81 ec       	ldi	r24, 0xC1	; 193
    7214:	f6 01       	movw	r30, r12
    7216:	80 83       	st	Z, r24
    7218:	12 c0       	rjmp	.+36     	; 0x723e <check_serial+0x16e>
		if (ch=='&') *action=0xC0;       //'program entry mode
    721a:	f6 e2       	ldi	r31, 0x26	; 38
    721c:	ef 16       	cp	r14, r31
    721e:	f1 04       	cpc	r15, r1
    7220:	11 f4       	brne	.+4      	; 0x7226 <check_serial+0x156>
    7222:	80 ec       	ldi	r24, 0xC0	; 192
    7224:	11 c0       	rjmp	.+34     	; 0x7248 <check_serial+0x178>
		if (ch=='#') *action=0xE8; 		// binary mode
    7226:	f3 e2       	ldi	r31, 0x23	; 35
    7228:	ef 16       	cp	r14, r31
    722a:	f1 04       	cpc	r15, r1
    722c:	21 f4       	brne	.+8      	; 0x7236 <check_serial+0x166>
    722e:	88 ee       	ldi	r24, 0xE8	; 232
    7230:	f6 01       	movw	r30, r12
    7232:	80 83       	st	Z, r24
    7234:	13 c0       	rjmp	.+38     	; 0x725c <check_serial+0x18c>
		
		
		if (ch=='q' || ch == 'Q' ) 
    7236:	f1 e7       	ldi	r31, 0x71	; 113
    7238:	ef 16       	cp	r14, r31
    723a:	f1 04       	cpc	r15, r1
    723c:	21 f0       	breq	.+8      	; 0x7246 <check_serial+0x176>
    723e:	81 e5       	ldi	r24, 0x51	; 81
    7240:	e8 16       	cp	r14, r24
    7242:	f1 04       	cpc	r15, r1
    7244:	19 f4       	brne	.+6      	; 0x724c <check_serial+0x17c>
			*action=0x90;       
    7246:	80 e9       	ldi	r24, 0x90	; 144
    7248:	f6 01       	movw	r30, r12
    724a:	80 83       	st	Z, r24
		

		if (ch==0x76) *action=0x80;       //'v' pressed
    724c:	f6 e7       	ldi	r31, 0x76	; 118
    724e:	ef 16       	cp	r14, r31
    7250:	f1 04       	cpc	r15, r1
    7252:	21 f4       	brne	.+8      	; 0x725c <check_serial+0x18c>
    7254:	80 e8       	ldi	r24, 0x80	; 128
    7256:	f6 01       	movw	r30, r12
    7258:	80 83       	st	Z, r24
    725a:	1f c0       	rjmp	.+62     	; 0x729a <check_serial+0x1ca>
		
		if (ch==27 || ch == 'P') 		// exit to idleMode
    725c:	fb e1       	ldi	r31, 0x1B	; 27
    725e:	ef 16       	cp	r14, r31
    7260:	f1 04       	cpc	r15, r1
    7262:	21 f0       	breq	.+8      	; 0x726c <check_serial+0x19c>
    7264:	80 e5       	ldi	r24, 0x50	; 80
    7266:	e8 16       	cp	r14, r24
    7268:	f1 04       	cpc	r15, r1
    726a:	39 f4       	brne	.+14     	; 0x727a <check_serial+0x1aa>
		{
			*action=0xFF;       			
    726c:	8f ef       	ldi	r24, 0xFF	; 255
    726e:	f6 01       	movw	r30, r12
    7270:	80 83       	st	Z, r24
			gNextMode = kIdleMode;		
    7272:	10 92 80 0b 	sts	0x0B80, r1
    7276:	10 92 7f 0b 	sts	0x0B7F, r1
		}
		
		if ('?' == ch) {
    727a:	ff e3       	ldi	r31, 0x3F	; 63
    727c:	ef 16       	cp	r14, r31
    727e:	f1 04       	cpc	r15, r1
    7280:	61 f4       	brne	.+24     	; 0x729a <check_serial+0x1ca>
			rprintf("Experimental Mode ('h' for help)\r\n");
    7282:	88 e8       	ldi	r24, 0x88	; 136
    7284:	9a e3       	ldi	r25, 0x3A	; 58
    7286:	9f 93       	push	r25
    7288:	8f 93       	push	r24
    728a:	81 e0       	ldi	r24, 0x01	; 1
    728c:	8f 93       	push	r24
    728e:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
    7292:	0f 90       	pop	r0
    7294:	0f 90       	pop	r0
    7296:	0f 90       	pop	r0
    7298:	dd c0       	rjmp	.+442    	; 0x7454 <check_serial+0x384>
		}
		
		if (ch==0x78 || ch==0x58)        //'x' or 'X' pressed
    729a:	88 e7       	ldi	r24, 0x78	; 120
    729c:	e8 16       	cp	r14, r24
    729e:	f1 04       	cpc	r15, r1
    72a0:	29 f0       	breq	.+10     	; 0x72ac <check_serial+0x1dc>
    72a2:	98 e5       	ldi	r25, 0x58	; 88
    72a4:	e9 16       	cp	r14, r25
    72a6:	f1 04       	cpc	r15, r1
    72a8:	09 f0       	breq	.+2      	; 0x72ac <check_serial+0x1dc>
    72aa:	60 c0       	rjmp	.+192    	; 0x736c <check_serial+0x29c>
		{
			// PC control mode
			// 2 hex digits = length
			
			l=getHex(2);
    72ac:	82 e0       	ldi	r24, 0x02	; 2
    72ae:	90 e0       	ldi	r25, 0x00	; 0
    72b0:	0e 94 c6 37 	call	0x6f8c	; 0x6f8c <getHex>
    72b4:	5c 01       	movw	r10, r24
    72b6:	00 e0       	ldi	r16, 0x00	; 0
    72b8:	10 e0       	ldi	r17, 0x00	; 0

			// foreach byte
			for (c=0; (c<l && c<MAX_INP_BUF); c++)
			{			
			//  read each hex digit into buffer
				buff[c]=getHex(2);
    72ba:	4e 01       	movw	r8, r28
    72bc:	08 94       	sec
    72be:	81 1c       	adc	r8, r1
    72c0:	91 1c       	adc	r9, r1
    72c2:	0a c0       	rjmp	.+20     	; 0x72d8 <check_serial+0x208>
    72c4:	82 e0       	ldi	r24, 0x02	; 2
    72c6:	90 e0       	ldi	r25, 0x00	; 0
    72c8:	0e 94 c6 37 	call	0x6f8c	; 0x6f8c <getHex>
    72cc:	f4 01       	movw	r30, r8
    72ce:	e0 0f       	add	r30, r16
    72d0:	f1 1f       	adc	r31, r17
    72d2:	80 83       	st	Z, r24
			// 2 hex digits = length
			
			l=getHex(2);

			// foreach byte
			for (c=0; (c<l && c<MAX_INP_BUF); c++)
    72d4:	0f 5f       	subi	r16, 0xFF	; 255
    72d6:	1f 4f       	sbci	r17, 0xFF	; 255
    72d8:	0a 15       	cp	r16, r10
    72da:	1b 05       	cpc	r17, r11
    72dc:	6c f4       	brge	.+26     	; 0x72f8 <check_serial+0x228>
    72de:	00 32       	cpi	r16, 0x20	; 32
    72e0:	11 05       	cpc	r17, r1
    72e2:	81 f7       	brne	.-32     	; 0x72c4 <check_serial+0x1f4>
    72e4:	09 c0       	rjmp	.+18     	; 0x72f8 <check_serial+0x228>
			}
						
			// transmit  buffer
			for (c=0; (c<l && c<MAX_INP_BUF); c++)
			{	
				sciTx0Data(buff[c]&0xFF);
    72e6:	f4 01       	movw	r30, r8
    72e8:	e0 0f       	add	r30, r16
    72ea:	f1 1f       	adc	r31, r17
    72ec:	80 81       	ld	r24, Z
    72ee:	0e 94 9f 23 	call	0x473e	; 0x473e <sciTx0Data>
			//  read each hex digit into buffer
				buff[c]=getHex(2);
			}
						
			// transmit  buffer
			for (c=0; (c<l && c<MAX_INP_BUF); c++)
    72f2:	0f 5f       	subi	r16, 0xFF	; 255
    72f4:	1f 4f       	sbci	r17, 0xFF	; 255
    72f6:	06 c0       	rjmp	.+12     	; 0x7304 <check_serial+0x234>
    72f8:	00 e0       	ldi	r16, 0x00	; 0
    72fa:	10 e0       	ldi	r17, 0x00	; 0
			{	
				sciTx0Data(buff[c]&0xFF);
    72fc:	4e 01       	movw	r8, r28
    72fe:	08 94       	sec
    7300:	81 1c       	adc	r8, r1
    7302:	91 1c       	adc	r9, r1
			//  read each hex digit into buffer
				buff[c]=getHex(2);
			}
						
			// transmit  buffer
			for (c=0; (c<l && c<MAX_INP_BUF); c++)
    7304:	0a 15       	cp	r16, r10
    7306:	1b 05       	cpc	r17, r11
    7308:	1c f4       	brge	.+6      	; 0x7310 <check_serial+0x240>
    730a:	00 32       	cpi	r16, 0x20	; 32
    730c:	11 05       	cpc	r17, r1
    730e:	59 f7       	brne	.-42     	; 0x72e6 <check_serial+0x216>
			{	
				sciTx0Data(buff[c]&0xFF);
			}

			if (ch==0x78)
    7310:	e8 e7       	ldi	r30, 0x78	; 120
    7312:	ee 16       	cp	r14, r30
    7314:	f1 04       	cpc	r15, r1
    7316:	e1 f4       	brne	.+56     	; 0x7350 <check_serial+0x280>
			{
				// get response (or timeout)					
				BYTE b1 = sciRx0Ready();
    7318:	0e 94 a3 23 	call	0x4746	; 0x4746 <sciRx0Ready>
    731c:	08 2f       	mov	r16, r24
				BYTE b2 = sciRx0Ready();
    731e:	0e 94 a3 23 	call	0x4746	; 0x4746 <sciRx0Ready>
				// echo response
				rprintf ("=%x%x\r\n", b1,b2);
    7322:	90 e0       	ldi	r25, 0x00	; 0
    7324:	9f 93       	push	r25
    7326:	8f 93       	push	r24
    7328:	10 e0       	ldi	r17, 0x00	; 0
    732a:	1f 93       	push	r17
    732c:	0f 93       	push	r16
    732e:	80 e8       	ldi	r24, 0x80	; 128
    7330:	9a e3       	ldi	r25, 0x3A	; 58
    7332:	9f 93       	push	r25
    7334:	8f 93       	push	r24
    7336:	81 e0       	ldi	r24, 0x01	; 1
    7338:	8f 93       	push	r24
    733a:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
    733e:	8d b7       	in	r24, 0x3d	; 61
    7340:	9e b7       	in	r25, 0x3e	; 62
    7342:	07 96       	adiw	r24, 0x07	; 7
    7344:	0f b6       	in	r0, 0x3f	; 63
    7346:	f8 94       	cli
    7348:	9e bf       	out	0x3e, r25	; 62
    734a:	0f be       	out	0x3f, r0	; 63
    734c:	8d bf       	out	0x3d, r24	; 61
    734e:	0b c0       	rjmp	.+22     	; 0x7366 <check_serial+0x296>
			}
			else
			{
				rprintf (" ok\r\n");
    7350:	8a e7       	ldi	r24, 0x7A	; 122
    7352:	9a e3       	ldi	r25, 0x3A	; 58
    7354:	9f 93       	push	r25
    7356:	8f 93       	push	r24
    7358:	81 e0       	ldi	r24, 0x01	; 1
    735a:	8f 93       	push	r24
    735c:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
    7360:	0f 90       	pop	r0
    7362:	0f 90       	pop	r0
    7364:	0f 90       	pop	r0
			}
		
			*action=0xFF;       
    7366:	8f ef       	ldi	r24, 0xFF	; 255
    7368:	f6 01       	movw	r30, r12
    736a:	80 83       	st	Z, r24
		}
		
		if (ch=='u' )        //like X but at 9600 baud
    736c:	f5 e7       	ldi	r31, 0x75	; 117
    736e:	ef 16       	cp	r14, r31
    7370:	f1 04       	cpc	r15, r1
    7372:	09 f0       	breq	.+2      	; 0x7376 <check_serial+0x2a6>
    7374:	6f c0       	rjmp	.+222    	; 0x7454 <check_serial+0x384>
		{		
			int f=1;
					
			UBRR0H=0x00;
    7376:	10 92 90 00 	sts	0x0090, r1
			UBRR0L=BR9600; //motion.h	
    737a:	8f e5       	ldi	r24, 0x5F	; 95
    737c:	89 b9       	out	0x09, r24	; 9
			
			while(f)
			{
				rprintf("wcK interactive (at 9600) : ");	
    737e:	3d e5       	ldi	r19, 0x5D	; 93
    7380:	43 2e       	mov	r4, r19
    7382:	3a e3       	ldi	r19, 0x3A	; 58
    7384:	53 2e       	mov	r5, r19
    7386:	11 e0       	ldi	r17, 0x01	; 1
				while ((ch = uartGetByte())<0) ;
				rprintf("%c", ch);	
    7388:	2a e5       	ldi	r18, 0x5A	; 90
    738a:	62 2e       	mov	r6, r18
    738c:	2a e3       	ldi	r18, 0x3A	; 58
    738e:	72 2e       	mov	r7, r18
    7390:	90 e7       	ldi	r25, 0x70	; 112
    7392:	89 2e       	mov	r8, r25
    7394:	91 e0       	ldi	r25, 0x01	; 1
    7396:	99 2e       	mov	r9, r25
						if (b != 0) wckSendByte(b);			
					}
					
					_delay_ms(50);
					ch = wckGetByte(1000);
					rprintf ("%d\r\n", ch);
    7398:	85 e5       	ldi	r24, 0x55	; 85
    739a:	a8 2e       	mov	r10, r24
    739c:	8a e3       	ldi	r24, 0x3A	; 58
    739e:	b8 2e       	mov	r11, r24
    73a0:	4c c0       	rjmp	.+152    	; 0x743a <check_serial+0x36a>
			UBRR0L=BR9600; //motion.h	
			
			while(f)
			{
				rprintf("wcK interactive (at 9600) : ");	
				while ((ch = uartGetByte())<0) ;
    73a2:	0e 94 9c 22 	call	0x4538	; 0x4538 <uartGetByte>
    73a6:	7c 01       	movw	r14, r24
    73a8:	97 fd       	sbrc	r25, 7
    73aa:	fb cf       	rjmp	.-10     	; 0x73a2 <check_serial+0x2d2>
				rprintf("%c", ch);	
    73ac:	9f 93       	push	r25
    73ae:	8f 93       	push	r24
    73b0:	7f 92       	push	r7
    73b2:	6f 92       	push	r6
    73b4:	1f 93       	push	r17
    73b6:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
				
				if (ch != '.')
    73ba:	0f 90       	pop	r0
    73bc:	0f 90       	pop	r0
    73be:	0f 90       	pop	r0
    73c0:	0f 90       	pop	r0
    73c2:	0f 90       	pop	r0
    73c4:	8e e2       	ldi	r24, 0x2E	; 46
    73c6:	e8 16       	cp	r14, r24
    73c8:	f1 04       	cpc	r15, r1
    73ca:	09 f4       	brne	.+2      	; 0x73ce <check_serial+0x2fe>
    73cc:	3f c0       	rjmp	.+126    	; 0x744c <check_serial+0x37c>
				{
					wckSendByte('S');
    73ce:	83 e5       	ldi	r24, 0x53	; 83
    73d0:	0e 94 c6 52 	call	0xa58c	; 0xa58c <wckSendByte>
					wckSendByte(ch&0xFF);
    73d4:	8e 2d       	mov	r24, r14
    73d6:	0e 94 c6 52 	call	0xa58c	; 0xa58c <wckSendByte>
					
					if (ch=='p' || ch=='t')
    73da:	90 e7       	ldi	r25, 0x70	; 112
    73dc:	e9 16       	cp	r14, r25
    73de:	f1 04       	cpc	r15, r1
    73e0:	21 f0       	breq	.+8      	; 0x73ea <check_serial+0x31a>
    73e2:	e4 e7       	ldi	r30, 0x74	; 116
    73e4:	ee 16       	cp	r14, r30
    73e6:	f1 04       	cpc	r15, r1
    73e8:	81 f4       	brne	.+32     	; 0x740a <check_serial+0x33a>
					{
						unsigned char b;
						b = getHex(2);		
    73ea:	82 e0       	ldi	r24, 0x02	; 2
    73ec:	90 e0       	ldi	r25, 0x00	; 0
    73ee:	0e 94 c6 37 	call	0x6f8c	; 0x6f8c <getHex>
						if (b != 0) wckSendByte(b);
    73f2:	88 23       	and	r24, r24
    73f4:	11 f0       	breq	.+4      	; 0x73fa <check_serial+0x32a>
    73f6:	0e 94 c6 52 	call	0xa58c	; 0xa58c <wckSendByte>
						b = getHex(2);		
    73fa:	82 e0       	ldi	r24, 0x02	; 2
    73fc:	90 e0       	ldi	r25, 0x00	; 0
    73fe:	0e 94 c6 37 	call	0x6f8c	; 0x6f8c <getHex>
						if (b != 0) wckSendByte(b);			
    7402:	88 23       	and	r24, r24
    7404:	11 f0       	breq	.+4      	; 0x740a <check_serial+0x33a>
    7406:	0e 94 c6 52 	call	0xa58c	; 0xa58c <wckSendByte>
    740a:	84 ef       	ldi	r24, 0xF4	; 244
    740c:	91 e0       	ldi	r25, 0x01	; 1
    740e:	f4 01       	movw	r30, r8
    7410:	31 97       	sbiw	r30, 0x01	; 1
    7412:	f1 f7       	brne	.-4      	; 0x7410 <check_serial+0x340>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7414:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7416:	d9 f7       	brne	.-10     	; 0x740e <check_serial+0x33e>
					}
					
					_delay_ms(50);
					ch = wckGetByte(1000);
    7418:	88 ee       	ldi	r24, 0xE8	; 232
    741a:	93 e0       	ldi	r25, 0x03	; 3
    741c:	0e 94 ca 52 	call	0xa594	; 0xa594 <wckGetByte>
					rprintf ("%d\r\n", ch);
    7420:	90 e0       	ldi	r25, 0x00	; 0
    7422:	9f 93       	push	r25
    7424:	8f 93       	push	r24
    7426:	bf 92       	push	r11
    7428:	af 92       	push	r10
    742a:	1f 93       	push	r17
    742c:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
    7430:	0f 90       	pop	r0
    7432:	0f 90       	pop	r0
    7434:	0f 90       	pop	r0
    7436:	0f 90       	pop	r0
    7438:	0f 90       	pop	r0
			UBRR0H=0x00;
			UBRR0L=BR9600; //motion.h	
			
			while(f)
			{
				rprintf("wcK interactive (at 9600) : ");	
    743a:	5f 92       	push	r5
    743c:	4f 92       	push	r4
    743e:	1f 93       	push	r17
    7440:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
    7444:	0f 90       	pop	r0
    7446:	0f 90       	pop	r0
    7448:	0f 90       	pop	r0
    744a:	ab cf       	rjmp	.-170    	; 0x73a2 <check_serial+0x2d2>
				else
				{
					f=0;
				}
			}
			UBRR0H=0x00;
    744c:	10 92 90 00 	sts	0x0090, r1
			UBRR0L=BR115200;
    7450:	87 e0       	ldi	r24, 0x07	; 7
    7452:	89 b9       	out	0x09, r24	; 9
		}
		

		if (ch==0x68 || ch==0x48) 				//'h' pressed
    7454:	f8 e6       	ldi	r31, 0x68	; 104
    7456:	ef 16       	cp	r14, r31
    7458:	f1 04       	cpc	r15, r1
    745a:	21 f0       	breq	.+8      	; 0x7464 <check_serial+0x394>
    745c:	88 e4       	ldi	r24, 0x48	; 72
    745e:	e8 16       	cp	r14, r24
    7460:	f1 04       	cpc	r15, r1
    7462:	19 f4       	brne	.+6      	; 0x746a <check_serial+0x39a>
			*action=0xEE; 
    7464:	8e ee       	ldi	r24, 0xEE	; 238
    7466:	f6 01       	movw	r30, r12
    7468:	80 83       	st	Z, r24
		
		if (ch==0x65) 	  						//'e' pressed 
    746a:	f5 e6       	ldi	r31, 0x65	; 101
    746c:	ef 16       	cp	r14, r31
    746e:	f1 04       	cpc	r15, r1
    7470:	b9 f4       	brne	.+46     	; 0x74a0 <check_serial+0x3d0>
		{			
			*action=getHex(2);      				//Action code
    7472:	82 e0       	ldi	r24, 0x02	; 2
    7474:	90 e0       	ldi	r25, 0x00	; 0
    7476:	0e 94 c6 37 	call	0x6f8c	; 0x6f8c <getHex>
    747a:	f6 01       	movw	r30, r12
    747c:	80 83       	st	Z, r24
			rprintf(" Special event [%x]\r\n", *action);	
    747e:	90 e0       	ldi	r25, 0x00	; 0
    7480:	9f 93       	push	r25
    7482:	8f 93       	push	r24
    7484:	8f e3       	ldi	r24, 0x3F	; 63
    7486:	9a e3       	ldi	r25, 0x3A	; 58
    7488:	9f 93       	push	r25
    748a:	8f 93       	push	r24
    748c:	81 e0       	ldi	r24, 0x01	; 1
    748e:	8f 93       	push	r24
    7490:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
    7494:	0f 90       	pop	r0
    7496:	0f 90       	pop	r0
    7498:	0f 90       	pop	r0
    749a:	0f 90       	pop	r0
    749c:	0f 90       	pop	r0
    749e:	db c0       	rjmp	.+438    	; 0x7656 <check_serial+0x586>
		}

		if (ch==0x4D) 							// 'M' pressed
    74a0:	fd e4       	ldi	r31, 0x4D	; 77
    74a2:	ef 16       	cp	r14, r31
    74a4:	f1 04       	cpc	r15, r1
    74a6:	09 f0       	breq	.+2      	; 0x74aa <check_serial+0x3da>
    74a8:	6d c0       	rjmp	.+218    	; 0x7584 <check_serial+0x4b4>
		{
			//modify param command (for tuning only)
			int op;
			int pv=0;
			int pn=getDec(1);
    74aa:	81 e0       	ldi	r24, 0x01	; 1
    74ac:	90 e0       	ldi	r25, 0x00	; 0
    74ae:	0e 94 1c 38 	call	0x7038	; 0x7038 <getDec>
    74b2:	7c 01       	movw	r14, r24

			while ((op = uartGetByte())<0) ;
    74b4:	0e 94 9c 22 	call	0x4538	; 0x4538 <uartGetByte>
    74b8:	8c 01       	movw	r16, r24
    74ba:	97 fd       	sbrc	r25, 7
    74bc:	fb cf       	rjmp	.-10     	; 0x74b4 <check_serial+0x3e4>
			rprintf("%c", ch);	
    74be:	8d e4       	ldi	r24, 0x4D	; 77
    74c0:	90 e0       	ldi	r25, 0x00	; 0
    74c2:	9f 93       	push	r25
    74c4:	8f 93       	push	r24
    74c6:	8c e3       	ldi	r24, 0x3C	; 60
    74c8:	9a e3       	ldi	r25, 0x3A	; 58
    74ca:	9f 93       	push	r25
    74cc:	8f 93       	push	r24
    74ce:	81 e0       	ldi	r24, 0x01	; 1
    74d0:	8f 93       	push	r24
    74d2:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
			if (op != '?')
    74d6:	0f 90       	pop	r0
    74d8:	0f 90       	pop	r0
    74da:	0f 90       	pop	r0
    74dc:	0f 90       	pop	r0
    74de:	0f 90       	pop	r0
    74e0:	0f 33       	cpi	r16, 0x3F	; 63
    74e2:	11 05       	cpc	r17, r1
    74e4:	19 f4       	brne	.+6      	; 0x74ec <check_serial+0x41c>
    74e6:	20 e0       	ldi	r18, 0x00	; 0
    74e8:	30 e0       	ldi	r19, 0x00	; 0
    74ea:	05 c0       	rjmp	.+10     	; 0x74f6 <check_serial+0x426>
			{
				pv = getHex(2);
    74ec:	82 e0       	ldi	r24, 0x02	; 2
    74ee:	90 e0       	ldi	r25, 0x00	; 0
    74f0:	0e 94 c6 37 	call	0x6f8c	; 0x6f8c <getHex>
    74f4:	9c 01       	movw	r18, r24
			}
			
			if ( (pn>=0) && (pn<10))
    74f6:	8a e0       	ldi	r24, 0x0A	; 10
    74f8:	e8 16       	cp	r14, r24
    74fa:	f1 04       	cpc	r15, r1
    74fc:	08 f0       	brcs	.+2      	; 0x7500 <check_serial+0x430>
    74fe:	ab c0       	rjmp	.+342    	; 0x7656 <check_serial+0x586>
			{
				if (op=='+') params[pn] += pv;
    7500:	0b 32       	cpi	r16, 0x2B	; 43
    7502:	11 05       	cpc	r17, r1
    7504:	51 f4       	brne	.+20     	; 0x751a <check_serial+0x44a>
    7506:	f7 01       	movw	r30, r14
    7508:	ee 0f       	add	r30, r30
    750a:	ff 1f       	adc	r31, r31
    750c:	e2 56       	subi	r30, 0x62	; 98
    750e:	f5 4f       	sbci	r31, 0xF5	; 245
    7510:	80 81       	ld	r24, Z
    7512:	91 81       	ldd	r25, Z+1	; 0x01
    7514:	82 0f       	add	r24, r18
    7516:	93 1f       	adc	r25, r19
    7518:	0c c0       	rjmp	.+24     	; 0x7532 <check_serial+0x462>
				if (op=='-') params[pn] -= pv;
    751a:	0d 32       	cpi	r16, 0x2D	; 45
    751c:	11 05       	cpc	r17, r1
    751e:	61 f4       	brne	.+24     	; 0x7538 <check_serial+0x468>
    7520:	f7 01       	movw	r30, r14
    7522:	ee 0f       	add	r30, r30
    7524:	ff 1f       	adc	r31, r31
    7526:	e2 56       	subi	r30, 0x62	; 98
    7528:	f5 4f       	sbci	r31, 0xF5	; 245
    752a:	80 81       	ld	r24, Z
    752c:	91 81       	ldd	r25, Z+1	; 0x01
    752e:	82 1b       	sub	r24, r18
    7530:	93 0b       	sbc	r25, r19
    7532:	91 83       	std	Z+1, r25	; 0x01
    7534:	80 83       	st	Z, r24
    7536:	0a c0       	rjmp	.+20     	; 0x754c <check_serial+0x47c>
				if (op=='=') params[pn] = pv;
    7538:	0d 33       	cpi	r16, 0x3D	; 61
    753a:	11 05       	cpc	r17, r1
    753c:	39 f4       	brne	.+14     	; 0x754c <check_serial+0x47c>
    753e:	f7 01       	movw	r30, r14
    7540:	ee 0f       	add	r30, r30
    7542:	ff 1f       	adc	r31, r31
    7544:	e2 56       	subi	r30, 0x62	; 98
    7546:	f5 4f       	sbci	r31, 0xF5	; 245
    7548:	31 83       	std	Z+1, r19	; 0x01
    754a:	20 83       	st	Z, r18
				rprintf(" P[%d]=%x\r\n", pn, params[pn]);
    754c:	f7 01       	movw	r30, r14
    754e:	ee 0f       	add	r30, r30
    7550:	ff 1f       	adc	r31, r31
    7552:	e2 56       	subi	r30, 0x62	; 98
    7554:	f5 4f       	sbci	r31, 0xF5	; 245
    7556:	80 81       	ld	r24, Z
    7558:	91 81       	ldd	r25, Z+1	; 0x01
    755a:	9f 93       	push	r25
    755c:	8f 93       	push	r24
    755e:	ff 92       	push	r15
    7560:	ef 92       	push	r14
    7562:	80 e3       	ldi	r24, 0x30	; 48
    7564:	9a e3       	ldi	r25, 0x3A	; 58
    7566:	9f 93       	push	r25
    7568:	8f 93       	push	r24
    756a:	81 e0       	ldi	r24, 0x01	; 1
    756c:	8f 93       	push	r24
    756e:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
    7572:	ed b7       	in	r30, 0x3d	; 61
    7574:	fe b7       	in	r31, 0x3e	; 62
    7576:	37 96       	adiw	r30, 0x07	; 7
    7578:	0f b6       	in	r0, 0x3f	; 63
    757a:	f8 94       	cli
    757c:	fe bf       	out	0x3e, r31	; 62
    757e:	0f be       	out	0x3f, r0	; 63
    7580:	ed bf       	out	0x3d, r30	; 61
    7582:	69 c0       	rjmp	.+210    	; 0x7656 <check_serial+0x586>
			}
		}
		
	
		if (ch==0x6D) 							// 'm' pressed
    7584:	fd e6       	ldi	r31, 0x6D	; 109
    7586:	ef 16       	cp	r14, r31
    7588:	f1 04       	cpc	r15, r1
    758a:	09 f0       	breq	.+2      	; 0x758e <check_serial+0x4be>
    758c:	64 c0       	rjmp	.+200    	; 0x7656 <check_serial+0x586>
		{
			int nb=0;
			int b0;
			int b1;
			
			while ((b0=uartGetByte())<0);
    758e:	0e 94 9c 22 	call	0x4538	; 0x4538 <uartGetByte>
    7592:	7c 01       	movw	r14, r24
    7594:	97 fd       	sbrc	r25, 7
    7596:	fb cf       	rjmp	.-10     	; 0x758e <check_serial+0x4be>
			while ((b1=uartGetByte())<0);
    7598:	0e 94 9c 22 	call	0x4538	; 0x4538 <uartGetByte>
    759c:	97 fd       	sbrc	r25, 7
    759e:	fc cf       	rjmp	.-8      	; 0x7598 <check_serial+0x4c8>
			int bytes = ((int)b1 << 8) | b0;
    75a0:	18 2f       	mov	r17, r24
    75a2:	00 27       	eor	r16, r16
    75a4:	0e 29       	or	r16, r14
    75a6:	1f 29       	or	r17, r15

			motionBuf = GetNextMotionBuffer();
    75a8:	0e 94 8d 23 	call	0x471a	; 0x471a <GetNextMotionBuffer>
    75ac:	90 93 83 0a 	sts	0x0A83, r25
    75b0:	80 93 82 0a 	sts	0x0A82, r24
			
			rprintf("^");
    75b4:	8e e2       	ldi	r24, 0x2E	; 46
    75b6:	9a e3       	ldi	r25, 0x3A	; 58
    75b8:	9f 93       	push	r25
    75ba:	8f 93       	push	r24
    75bc:	81 e0       	ldi	r24, 0x01	; 1
    75be:	8f 93       	push	r24
    75c0:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
    75c4:	ee 24       	eor	r14, r14
    75c6:	ff 24       	eor	r15, r15
    75c8:	0f 90       	pop	r0
    75ca:	0f 90       	pop	r0
    75cc:	0f 90       	pop	r0
    75ce:	0e c0       	rjmp	.+28     	; 0x75ec <check_serial+0x51c>
	
			while (nb<bytes)
			{				
				while ((b0=uartGetByte())<0);
    75d0:	0e 94 9c 22 	call	0x4538	; 0x4538 <uartGetByte>
    75d4:	97 fd       	sbrc	r25, 7
    75d6:	fc cf       	rjmp	.-8      	; 0x75d0 <check_serial+0x500>
				motionBuf[nb++] = b0;
    75d8:	e0 91 82 0a 	lds	r30, 0x0A82
    75dc:	f0 91 83 0a 	lds	r31, 0x0A83
    75e0:	ee 0d       	add	r30, r14
    75e2:	ff 1d       	adc	r31, r15
    75e4:	80 83       	st	Z, r24
    75e6:	08 94       	sec
    75e8:	e1 1c       	adc	r14, r1
    75ea:	f1 1c       	adc	r15, r1

			motionBuf = GetNextMotionBuffer();
			
			rprintf("^");
	
			while (nb<bytes)
    75ec:	e0 16       	cp	r14, r16
    75ee:	f1 06       	cpc	r15, r17
    75f0:	7c f3       	brlt	.-34     	; 0x75d0 <check_serial+0x500>
			{				
				while ((b0=uartGetByte())<0);
				motionBuf[nb++] = b0;
			}
			rprintf("Received %d bytes\r\n", nb);
    75f2:	ff 92       	push	r15
    75f4:	ef 92       	push	r14
    75f6:	8a e1       	ldi	r24, 0x1A	; 26
    75f8:	9a e3       	ldi	r25, 0x3A	; 58
    75fa:	9f 93       	push	r25
    75fc:	8f 93       	push	r24
    75fe:	11 e0       	ldi	r17, 0x01	; 1
    7600:	1f 93       	push	r17
    7602:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>

			print_motionBuf(nb);
    7606:	c7 01       	movw	r24, r14
    7608:	0e 94 2f 3e 	call	0x7c5e	; 0x7c5e <print_motionBuf>
			LoadMotionFromBuffer(motionBuf);			
    760c:	80 91 82 0a 	lds	r24, 0x0A82
    7610:	90 91 83 0a 	lds	r25, 0x0A83
    7614:	0e 94 76 27 	call	0x4eec	; 0x4eec <LoadMotionFromBuffer>
			PlaySceneFromBuffer(motionBuf, 0);
    7618:	60 e0       	ldi	r22, 0x00	; 0
    761a:	70 e0       	ldi	r23, 0x00	; 0
    761c:	80 91 82 0a 	lds	r24, 0x0A82
    7620:	90 91 83 0a 	lds	r25, 0x0A83
    7624:	0e 94 81 25 	call	0x4b02	; 0x4b02 <PlaySceneFromBuffer>
			complete_motion(motionBuf);
    7628:	80 91 82 0a 	lds	r24, 0x0A82
    762c:	90 91 83 0a 	lds	r25, 0x0A83
    7630:	0e 94 71 26 	call	0x4ce2	; 0x4ce2 <complete_motion>
			
			rprintf("Done\r\n", nb);
    7634:	ff 92       	push	r15
    7636:	ef 92       	push	r14
    7638:	83 e1       	ldi	r24, 0x13	; 19
    763a:	9a e3       	ldi	r25, 0x3A	; 58
    763c:	9f 93       	push	r25
    763e:	8f 93       	push	r24
    7640:	1f 93       	push	r17
    7642:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
    7646:	8d b7       	in	r24, 0x3d	; 61
    7648:	9e b7       	in	r25, 0x3e	; 62
    764a:	0a 96       	adiw	r24, 0x0a	; 10
    764c:	0f b6       	in	r0, 0x3f	; 63
    764e:	f8 94       	cli
    7650:	9e bf       	out	0x3e, r25	; 62
    7652:	0f be       	out	0x3f, r0	; 63
    7654:	8d bf       	out	0x3d, r24	; 61

		}
		
	}
}
    7656:	a0 96       	adiw	r28, 0x20	; 32
    7658:	0f b6       	in	r0, 0x3f	; 63
    765a:	f8 94       	cli
    765c:	de bf       	out	0x3e, r29	; 62
    765e:	0f be       	out	0x3f, r0	; 63
    7660:	cd bf       	out	0x3d, r28	; 61
    7662:	cf 91       	pop	r28
    7664:	df 91       	pop	r29
    7666:	1f 91       	pop	r17
    7668:	0f 91       	pop	r16
    766a:	ff 90       	pop	r15
    766c:	ef 90       	pop	r14
    766e:	df 90       	pop	r13
    7670:	cf 90       	pop	r12
    7672:	bf 90       	pop	r11
    7674:	af 90       	pop	r10
    7676:	9f 90       	pop	r9
    7678:	8f 90       	pop	r8
    767a:	7f 90       	pop	r7
    767c:	6f 90       	pop	r6
    767e:	5f 90       	pop	r5
    7680:	4f 90       	pop	r4
    7682:	08 95       	ret

00007684 <check_behaviour>:
		
	}
}

void check_behaviour(BYTE *action)
{
    7684:	1f 93       	push	r17
    7686:	cf 93       	push	r28
    7688:	df 93       	push	r29
    768a:	ec 01       	movw	r28, r24
		}
	}
	
#endif
		
	if (adc_mic()>params[MICL])  //if mic semsor levl reached
    768c:	0e 94 fb 2c 	call	0x59f6	; 0x59f6 <adc_mic>
    7690:	90 e0       	ldi	r25, 0x00	; 0
    7692:	20 91 aa 0a 	lds	r18, 0x0AAA
    7696:	30 91 ab 0a 	lds	r19, 0x0AAB
    769a:	28 17       	cp	r18, r24
    769c:	39 07       	cpc	r19, r25
    769e:	0c f0       	brlt	.+2      	; 0x76a2 <check_behaviour+0x1e>
    76a0:	48 c0       	rjmp	.+144    	; 0x7732 <check_behaviour+0xae>
	{
		if (response) 
    76a2:	80 91 9b 0a 	lds	r24, 0x0A9B
    76a6:	90 91 9c 0a 	lds	r25, 0x0A9C
    76aa:	89 2b       	or	r24, r25
    76ac:	09 f4       	brne	.+2      	; 0x76b0 <check_behaviour+0x2c>
    76ae:	41 c0       	rjmp	.+130    	; 0x7732 <check_behaviour+0xae>

#define MAX_INP_BUF 32

void ptime()
{
	rprintf("%d:%d:%d-%d ",gHOUR,gMIN,gSEC,gMSEC);
    76b0:	60 91 be 0a 	lds	r22, 0x0ABE
    76b4:	70 91 bf 0a 	lds	r23, 0x0ABF
    76b8:	80 91 ba 0a 	lds	r24, 0x0ABA
    76bc:	20 91 9d 0a 	lds	r18, 0x0A9D
    76c0:	40 91 b5 0a 	lds	r20, 0x0AB5
    76c4:	7f 93       	push	r23
    76c6:	6f 93       	push	r22
    76c8:	90 e0       	ldi	r25, 0x00	; 0
    76ca:	9f 93       	push	r25
    76cc:	8f 93       	push	r24
    76ce:	30 e0       	ldi	r19, 0x00	; 0
    76d0:	3f 93       	push	r19
    76d2:	2f 93       	push	r18
    76d4:	50 e0       	ldi	r21, 0x00	; 0
    76d6:	5f 93       	push	r21
    76d8:	4f 93       	push	r20
    76da:	8d ed       	ldi	r24, 0xDD	; 221
    76dc:	9a e3       	ldi	r25, 0x3A	; 58
    76de:	9f 93       	push	r25
    76e0:	8f 93       	push	r24
    76e2:	11 e0       	ldi	r17, 0x01	; 1
    76e4:	1f 93       	push	r17
    76e6:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
		
	if (adc_mic()>params[MICL])  //if mic semsor levl reached
	{
		if (response) 
		{
			ptime(); rprintf("MIC event %x\r\n", gSoundLevel);	
    76ea:	80 91 98 0d 	lds	r24, 0x0D98
    76ee:	90 e0       	ldi	r25, 0x00	; 0
    76f0:	9f 93       	push	r25
    76f2:	8f 93       	push	r24
    76f4:	8e ea       	ldi	r24, 0xAE	; 174
    76f6:	9a e3       	ldi	r25, 0x3A	; 58
    76f8:	9f 93       	push	r25
    76fa:	8f 93       	push	r24
    76fc:	1f 93       	push	r17
    76fe:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>

			//depending on mood :)
			int mood = rand()%2;
    7702:	0e 94 69 6d 	call	0xdad2	; 0xdad2 <rand>
			switch(mood)
    7706:	2d b7       	in	r18, 0x3d	; 61
    7708:	3e b7       	in	r19, 0x3e	; 62
    770a:	20 5f       	subi	r18, 0xF0	; 240
    770c:	3f 4f       	sbci	r19, 0xFF	; 255
    770e:	0f b6       	in	r0, 0x3f	; 63
    7710:	f8 94       	cli
    7712:	3e bf       	out	0x3e, r19	; 62
    7714:	0f be       	out	0x3f, r0	; 63
    7716:	2d bf       	out	0x3d, r18	; 61
    7718:	62 e0       	ldi	r22, 0x02	; 2
    771a:	70 e0       	ldi	r23, 0x00	; 0
    771c:	0e 94 31 6e 	call	0xdc62	; 0xdc62 <__divmodhi4>
    7720:	00 97       	sbiw	r24, 0x00	; 0
    7722:	19 f0       	breq	.+6      	; 0x772a <check_behaviour+0xa6>
    7724:	01 97       	sbiw	r24, 0x01	; 1
    7726:	29 f4       	brne	.+10     	; 0x7732 <check_behaviour+0xae>
    7728:	02 c0       	rjmp	.+4      	; 0x772e <check_behaviour+0xaa>
			{
			case 0:
				*action=0x10; //sit down
    772a:	80 e1       	ldi	r24, 0x10	; 16
    772c:	01 c0       	rjmp	.+2      	; 0x7730 <check_behaviour+0xac>
				break;
			case 1:
				*action=0x11; //wave hi
    772e:	81 e1       	ldi	r24, 0x11	; 17
    7730:	88 83       	st	Y, r24
				break;
			}	
		}
	}
}
    7732:	df 91       	pop	r29
    7734:	cf 91       	pop	r28
    7736:	1f 91       	pop	r17
    7738:	08 95       	ret

0000773a <Read_Events>:
//------------------------------------------------------------------------------
// Check if an event has occured that causes an Action
//------------------------------------------------------------------------------

BYTE Read_Events(void)
{
    773a:	0f 93       	push	r16
    773c:	1f 93       	push	r17
    773e:	df 93       	push	r29
    7740:	cf 93       	push	r28
    7742:	0f 92       	push	r0
    7744:	cd b7       	in	r28, 0x3d	; 61
    7746:	de b7       	in	r29, 0x3e	; 62
	BYTE Action=0xFF;				//No action
    7748:	8f ef       	ldi	r24, 0xFF	; 255
    774a:	89 83       	std	Y+1, r24	; 0x01

void check_buttons(BYTE *action)
{
	BYTE tmp;

	tmp = PINA & 0x03;			// buttons are bits 0 and 1 on port A
    774c:	29 b3       	in	r18, 0x19	; 25
    774e:	23 70       	andi	r18, 0x03	; 3
	if((tmp!=0x03))
    7750:	23 30       	cpi	r18, 0x03	; 3
    7752:	81 f0       	breq	.+32     	; 0x7774 <Read_Events+0x3a>
	{								// low if a button is pressed
		if(++gBtnCnt>100){   		// loop 100 times
    7754:	80 91 83 0b 	lds	r24, 0x0B83
    7758:	90 91 84 0b 	lds	r25, 0x0B84
    775c:	01 96       	adiw	r24, 0x01	; 1
    775e:	90 93 84 0b 	sts	0x0B84, r25
    7762:	80 93 83 0b 	sts	0x0B83, r24
    7766:	85 36       	cpi	r24, 0x65	; 101
    7768:	91 05       	cpc	r25, r1
    776a:	40 f0       	brcs	.+16     	; 0x777c <Read_Events+0x42>
			if(tmp==0x02){		// if PF1 only is pressed
    776c:	22 30       	cpi	r18, 0x02	; 2
    776e:	31 f4       	brne	.+12     	; 0x777c <Read_Events+0x42>
				*action=0x00;
    7770:	19 82       	std	Y+1, r1	; 0x01
    7772:	04 c0       	rjmp	.+8      	; 0x777c <Read_Events+0x42>
			}
		}
	}
	else{
	    gBtnCnt=0;
    7774:	10 92 84 0b 	sts	0x0B84, r1
    7778:	10 92 83 0b 	sts	0x0B83, r1
		
	// -------------------------------------------------------------------------------------------------------
	// Check for IR event and set Action state
	// -------------------------------------------------------------------------------------------------------
	
	check_IR(&Action);
    777c:	8e 01       	movw	r16, r28
    777e:	0f 5f       	subi	r16, 0xFF	; 255
    7780:	1f 4f       	sbci	r17, 0xFF	; 255
    7782:	c8 01       	movw	r24, r16
    7784:	0e 94 07 31 	call	0x620e	; 0x620e <check_IR>
	
	// -------------------------------------------------------------------------------------------------------
	// Simple behaviour
	// -------------------------------------------------------------------------------------------------------
	
	check_behaviour(&Action);	
    7788:	c8 01       	movw	r24, r16
    778a:	0e 94 42 3b 	call	0x7684	; 0x7684 <check_behaviour>
	
	// -------------------------------------------------------------------------------------------------------
	// terminal input get input and  set Action state
	// -------------------------------------------------------------------------------------------------------

	check_serial(&Action);
    778e:	c8 01       	movw	r24, r16
    7790:	0e 94 68 38 	call	0x70d0	; 0x70d0 <check_serial>
	
	// -------------------------------------------------------------------------------------------------------
	//tilt events (change in X,y,Z by certain limit)
	// -------------------------------------------------------------------------------------------------------
	
	check_balance(&Action);
    7794:	c8 01       	movw	r24, r16
    7796:	0e 94 8d 31 	call	0x631a	; 0x631a <check_balance>

	return Action;
}
    779a:	89 81       	ldd	r24, Y+1	; 0x01
    779c:	0f 90       	pop	r0
    779e:	cf 91       	pop	r28
    77a0:	df 91       	pop	r29
    77a2:	1f 91       	pop	r17
    77a4:	0f 91       	pop	r16
    77a6:	08 95       	ret

000077a8 <experimental_mainloop>:
	}
} 


void experimental_mainloop()
{
    77a8:	cf 93       	push	r28
    77aa:	df 93       	push	r29
	WORD lMSEC;
	rprintf ("Experimental mode\r\n");
    77ac:	81 ed       	ldi	r24, 0xD1	; 209
    77ae:	94 e3       	ldi	r25, 0x34	; 52
    77b0:	9f 93       	push	r25
    77b2:	8f 93       	push	r24
    77b4:	81 e0       	ldi	r24, 0x01	; 1
    77b6:	8f 93       	push	r24
    77b8:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
    77bc:	0f 90       	pop	r0
    77be:	0f 90       	pop	r0
    77c0:	0f 90       	pop	r0
    77c2:	11 c0       	rjmp	.+34     	; 0x77e6 <experimental_mainloop+0x3e>
	while (kExperimentalMode == gNextMode) {
		lMSEC = gMSEC;
    77c4:	c0 91 be 0a 	lds	r28, 0x0ABE
    77c8:	d0 91 bf 0a 	lds	r29, 0x0ABF
		
		BYTE act = Read_Events();
    77cc:	0e 94 9d 3b 	call	0x773a	; 0x773a <Read_Events>
		
		if (act != 0xFF) Perform_Action(act);
    77d0:	8f 3f       	cpi	r24, 0xFF	; 255
    77d2:	11 f0       	breq	.+4      	; 0x77d8 <experimental_mainloop+0x30>
    77d4:	0e 94 c0 32 	call	0x6580	; 0x6580 <Perform_Action>
		
		while(lMSEC==gMSEC);
    77d8:	80 91 be 0a 	lds	r24, 0x0ABE
    77dc:	90 91 bf 0a 	lds	r25, 0x0ABF
    77e0:	c8 17       	cp	r28, r24
    77e2:	d9 07       	cpc	r29, r25
    77e4:	c9 f3       	breq	.-14     	; 0x77d8 <experimental_mainloop+0x30>

void experimental_mainloop()
{
	WORD lMSEC;
	rprintf ("Experimental mode\r\n");
	while (kExperimentalMode == gNextMode) {
    77e6:	80 91 7f 0b 	lds	r24, 0x0B7F
    77ea:	90 91 80 0b 	lds	r25, 0x0B80
    77ee:	01 97       	sbiw	r24, 0x01	; 1
    77f0:	49 f3       	breq	.-46     	; 0x77c4 <experimental_mainloop+0x1c>
		
		if (act != 0xFF) Perform_Action(act);
		
		while(lMSEC==gMSEC);
	}
}
    77f2:	df 91       	pop	r29
    77f4:	cf 91       	pop	r28
    77f6:	08 95       	ret

000077f8 <DetectPower>:

//------------------------------------------------------------------------------
//  
//------------------------------------------------------------------------------
void DetectPower(void)
{
    77f8:	80 91 81 0a 	lds	r24, 0x0A81
    77fc:	88 23       	and	r24, r24
    77fe:	09 f0       	breq	.+2      	; 0x7802 <DetectPower+0xa>
    7800:	4c c0       	rjmp	.+152    	; 0x789a <DetectPower+0xa2>
	if(F_DOWNLOAD) return;
	if(F_PS_PLUGGED){
    7802:	80 91 b1 0d 	lds	r24, 0x0DB1
    7806:	88 23       	and	r24, r24
    7808:	11 f1       	breq	.+68     	; 0x784e <DetectPower+0x56>
		if(gVOLTAGE >= U_T_OF_POWER)
    780a:	80 91 92 0d 	lds	r24, 0x0D92
    780e:	90 91 93 0d 	lds	r25, 0x0D93
    7812:	8c 51       	subi	r24, 0x1C	; 28
    7814:	95 42       	sbci	r25, 0x25	; 37
    7816:	28 f0       	brcs	.+10     	; 0x7822 <DetectPower+0x2a>
			gPSunplugCount = 0;
    7818:	10 92 ba 0d 	sts	0x0DBA, r1
    781c:	10 92 b9 0d 	sts	0x0DB9, r1
    7820:	09 c0       	rjmp	.+18     	; 0x7834 <DetectPower+0x3c>
		else
			gPSunplugCount++;
    7822:	80 91 b9 0d 	lds	r24, 0x0DB9
    7826:	90 91 ba 0d 	lds	r25, 0x0DBA
    782a:	01 96       	adiw	r24, 0x01	; 1
    782c:	90 93 ba 0d 	sts	0x0DBA, r25
    7830:	80 93 b9 0d 	sts	0x0DB9, r24
		if(gPSunplugCount > 6){
    7834:	80 91 b9 0d 	lds	r24, 0x0DB9
    7838:	90 91 ba 0d 	lds	r25, 0x0DBA
    783c:	07 97       	sbiw	r24, 0x07	; 7
    783e:	68 f1       	brcs	.+90     	; 0x789a <DetectPower+0xa2>
			F_PS_PLUGGED = 0;
    7840:	10 92 b1 0d 	sts	0x0DB1, r1
			gPSunplugCount = 0;
    7844:	10 92 ba 0d 	sts	0x0DBA, r1
    7848:	10 92 b9 0d 	sts	0x0DB9, r1
    784c:	08 95       	ret
		}
	}
	else{
		if(gVOLTAGE >= U_T_OF_POWER){
    784e:	80 91 92 0d 	lds	r24, 0x0D92
    7852:	90 91 93 0d 	lds	r25, 0x0D93
    7856:	8c 51       	subi	r24, 0x1C	; 28
    7858:	95 42       	sbci	r25, 0x25	; 37
    785a:	70 f0       	brcs	.+28     	; 0x7878 <DetectPower+0x80>
			gPSunplugCount = 0;
    785c:	10 92 ba 0d 	sts	0x0DBA, r1
    7860:	10 92 b9 0d 	sts	0x0DB9, r1
			gPSplugCount++;
    7864:	80 91 b5 0d 	lds	r24, 0x0DB5
    7868:	90 91 b6 0d 	lds	r25, 0x0DB6
    786c:	01 96       	adiw	r24, 0x01	; 1
    786e:	90 93 b6 0d 	sts	0x0DB6, r25
    7872:	80 93 b5 0d 	sts	0x0DB5, r24
    7876:	04 c0       	rjmp	.+8      	; 0x7880 <DetectPower+0x88>
		}
		else{
			gPSplugCount = 0;
    7878:	10 92 b6 0d 	sts	0x0DB6, r1
    787c:	10 92 b5 0d 	sts	0x0DB5, r1
		}

		if(gPSplugCount>2){
    7880:	80 91 b5 0d 	lds	r24, 0x0DB5
    7884:	90 91 b6 0d 	lds	r25, 0x0DB6
    7888:	03 97       	sbiw	r24, 0x03	; 3
    788a:	38 f0       	brcs	.+14     	; 0x789a <DetectPower+0xa2>
			F_PS_PLUGGED = 1;
    788c:	81 e0       	ldi	r24, 0x01	; 1
    788e:	80 93 b1 0d 	sts	0x0DB1, r24
			gPSplugCount = 0;
    7892:	10 92 b6 0d 	sts	0x0DB6, r1
    7896:	10 92 b5 0d 	sts	0x0DB5, r1
    789a:	08 95       	ret

0000789c <ChargeNiMH>:

//-----------------------------------------------------------------------------
// NiMH  
//-----------------------------------------------------------------------------
void ChargeNiMH(void)
{
    789c:	1f 93       	push	r17
    789e:	cf 93       	push	r28
    78a0:	df 93       	push	r29
	rprintf("Battery charging\r\n");
    78a2:	85 e7       	ldi	r24, 0x75	; 117
    78a4:	9b e3       	ldi	r25, 0x3B	; 59
    78a6:	9f 93       	push	r25
    78a8:	8f 93       	push	r24
    78aa:	11 e0       	ldi	r17, 0x01	; 1
    78ac:	1f 93       	push	r17
    78ae:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>

	F_CHARGING = 1;
    78b2:	10 93 b4 0d 	sts	0x0DB4, r17
	gMIN_DCOUNT = 5;
    78b6:	85 e0       	ldi	r24, 0x05	; 5
    78b8:	90 e0       	ldi	r25, 0x00	; 0
    78ba:	90 93 82 0b 	sts	0x0B82, r25
    78be:	80 93 81 0b 	sts	0x0B81, r24
    78c2:	0f 90       	pop	r0
    78c4:	0f 90       	pop	r0
    78c6:	0f 90       	pop	r0
    78c8:	c0 e7       	ldi	r28, 0x70	; 112
    78ca:	d1 e0       	ldi	r29, 0x01	; 1
    78cc:	32 c0       	rjmp	.+100    	; 0x7932 <ChargeNiMH+0x96>
	while(gMIN_DCOUNT){
		PWR_LED2_OFF;
    78ce:	af 9a       	sbi	0x15, 7	; 21
		PWR_LED1_ON;
    78d0:	80 91 65 00 	lds	r24, 0x0065
    78d4:	8b 7f       	andi	r24, 0xFB	; 251
    78d6:	80 93 65 00 	sts	0x0065, r24
		Get_VOLTAGE();	DetectPower();
    78da:	0e 94 00 2d 	call	0x5a00	; 0x5a00 <Get_VOLTAGE>
    78de:	0e 94 fc 3b 	call	0x77f8	; 0x77f8 <DetectPower>
		if(F_PS_PLUGGED == 0) break;
    78e2:	80 91 b1 0d 	lds	r24, 0x0DB1
    78e6:	88 23       	and	r24, r24
    78e8:	59 f1       	breq	.+86     	; 0x7940 <ChargeNiMH+0xa4>
		CHARGE_ENABLE;
    78ea:	c4 9a       	sbi	0x18, 4	; 24
    78ec:	80 e9       	ldi	r24, 0x90	; 144
    78ee:	91 e0       	ldi	r25, 0x01	; 1
    78f0:	fe 01       	movw	r30, r28
    78f2:	31 97       	sbiw	r30, 0x01	; 1
    78f4:	f1 f7       	brne	.-4      	; 0x78f2 <ChargeNiMH+0x56>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    78f6:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    78f8:	d9 f7       	brne	.-10     	; 0x78f0 <ChargeNiMH+0x54>
		_delay_ms(40);
		CHARGE_DISABLE;
    78fa:	c4 98       	cbi	0x18, 4	; 24
    78fc:	88 ef       	ldi	r24, 0xF8	; 248
    78fe:	91 e1       	ldi	r25, 0x11	; 17
    7900:	fe 01       	movw	r30, r28
    7902:	31 97       	sbiw	r30, 0x01	; 1
    7904:	f1 f7       	brne	.-4      	; 0x7902 <ChargeNiMH+0x66>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7906:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7908:	d9 f7       	brne	.-10     	; 0x7900 <ChargeNiMH+0x64>
		_delay_ms(500-40);
		PWR_LED1_OFF;
    790a:	80 91 65 00 	lds	r24, 0x0065
    790e:	84 60       	ori	r24, 0x04	; 4
    7910:	80 93 65 00 	sts	0x0065, r24
		Get_VOLTAGE();	DetectPower();
    7914:	0e 94 00 2d 	call	0x5a00	; 0x5a00 <Get_VOLTAGE>
    7918:	0e 94 fc 3b 	call	0x77f8	; 0x77f8 <DetectPower>
		if(F_PS_PLUGGED == 0) break;
    791c:	80 91 b1 0d 	lds	r24, 0x0DB1
    7920:	88 23       	and	r24, r24
    7922:	71 f0       	breq	.+28     	; 0x7940 <ChargeNiMH+0xa4>
    7924:	88 e8       	ldi	r24, 0x88	; 136
    7926:	93 e1       	ldi	r25, 0x13	; 19
    7928:	fe 01       	movw	r30, r28
    792a:	31 97       	sbiw	r30, 0x01	; 1
    792c:	f1 f7       	brne	.-4      	; 0x792a <ChargeNiMH+0x8e>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    792e:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7930:	d9 f7       	brne	.-10     	; 0x7928 <ChargeNiMH+0x8c>
{
	rprintf("Battery charging\r\n");

	F_CHARGING = 1;
	gMIN_DCOUNT = 5;
	while(gMIN_DCOUNT){
    7932:	80 91 81 0b 	lds	r24, 0x0B81
    7936:	90 91 82 0b 	lds	r25, 0x0B82
    793a:	89 2b       	or	r24, r25
    793c:	09 f0       	breq	.+2      	; 0x7940 <ChargeNiMH+0xa4>
    793e:	c7 cf       	rjmp	.-114    	; 0x78ce <ChargeNiMH+0x32>
		PWR_LED1_OFF;
		Get_VOLTAGE();	DetectPower();
		if(F_PS_PLUGGED == 0) break;
		_delay_ms(500);
	}
	gMIN_DCOUNT = 85;
    7940:	85 e5       	ldi	r24, 0x55	; 85
    7942:	90 e0       	ldi	r25, 0x00	; 0
    7944:	90 93 82 0b 	sts	0x0B82, r25
    7948:	80 93 81 0b 	sts	0x0B81, r24
    794c:	27 c0       	rjmp	.+78     	; 0x799c <ChargeNiMH+0x100>
	while(gMIN_DCOUNT){
		PWR_LED2_OFF;
    794e:	af 9a       	sbi	0x15, 7	; 21
		if(gMSEC > 500)	PWR_LED1_ON;
    7950:	80 91 be 0a 	lds	r24, 0x0ABE
    7954:	90 91 bf 0a 	lds	r25, 0x0ABF
    7958:	85 5f       	subi	r24, 0xF5	; 245
    795a:	91 40       	sbci	r25, 0x01	; 1
    795c:	20 f0       	brcs	.+8      	; 0x7966 <ChargeNiMH+0xca>
    795e:	80 91 65 00 	lds	r24, 0x0065
    7962:	8b 7f       	andi	r24, 0xFB	; 251
    7964:	03 c0       	rjmp	.+6      	; 0x796c <ChargeNiMH+0xd0>
		else			PWR_LED1_OFF;
    7966:	80 91 65 00 	lds	r24, 0x0065
    796a:	84 60       	ori	r24, 0x04	; 4
    796c:	80 93 65 00 	sts	0x0065, r24
		if(gMSEC == 0 || gMSEC == 500){
    7970:	80 91 be 0a 	lds	r24, 0x0ABE
    7974:	90 91 bf 0a 	lds	r25, 0x0ABF
    7978:	89 2b       	or	r24, r25
    797a:	39 f0       	breq	.+14     	; 0x798a <ChargeNiMH+0xee>
    797c:	80 91 be 0a 	lds	r24, 0x0ABE
    7980:	90 91 bf 0a 	lds	r25, 0x0ABF
    7984:	84 5f       	subi	r24, 0xF4	; 244
    7986:	91 40       	sbci	r25, 0x01	; 1
    7988:	21 f4       	brne	.+8      	; 0x7992 <ChargeNiMH+0xf6>
			Get_VOLTAGE();
    798a:	0e 94 00 2d 	call	0x5a00	; 0x5a00 <Get_VOLTAGE>
			DetectPower();
    798e:	0e 94 fc 3b 	call	0x77f8	; 0x77f8 <DetectPower>
		}
		if(F_PS_PLUGGED == 0) break;
    7992:	80 91 b1 0d 	lds	r24, 0x0DB1
    7996:	88 23       	and	r24, r24
    7998:	39 f0       	breq	.+14     	; 0x79a8 <ChargeNiMH+0x10c>
		CHARGE_ENABLE;
    799a:	c4 9a       	sbi	0x18, 4	; 24
		Get_VOLTAGE();	DetectPower();
		if(F_PS_PLUGGED == 0) break;
		_delay_ms(500);
	}
	gMIN_DCOUNT = 85;
	while(gMIN_DCOUNT){
    799c:	80 91 81 0b 	lds	r24, 0x0B81
    79a0:	90 91 82 0b 	lds	r25, 0x0B82
    79a4:	89 2b       	or	r24, r25
    79a6:	99 f6       	brne	.-90     	; 0x794e <ChargeNiMH+0xb2>
			DetectPower();
		}
		if(F_PS_PLUGGED == 0) break;
		CHARGE_ENABLE;
	}
	CHARGE_DISABLE;
    79a8:	c4 98       	cbi	0x18, 4	; 24
	F_CHARGING = 0;
    79aa:	10 92 b4 0d 	sts	0x0DB4, r1
	rprintf("Charging complete - %dmV\r\n", gVOLTAGE);
    79ae:	80 91 92 0d 	lds	r24, 0x0D92
    79b2:	90 91 93 0d 	lds	r25, 0x0D93
    79b6:	9f 93       	push	r25
    79b8:	8f 93       	push	r24
    79ba:	8a e5       	ldi	r24, 0x5A	; 90
    79bc:	9b e3       	ldi	r25, 0x3B	; 59
    79be:	9f 93       	push	r25
    79c0:	8f 93       	push	r24
    79c2:	81 e0       	ldi	r24, 0x01	; 1
    79c4:	8f 93       	push	r24
    79c6:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
    79ca:	0f 90       	pop	r0
    79cc:	0f 90       	pop	r0
    79ce:	0f 90       	pop	r0
    79d0:	0f 90       	pop	r0
    79d2:	0f 90       	pop	r0
}
    79d4:	df 91       	pop	r29
    79d6:	cf 91       	pop	r28
    79d8:	1f 91       	pop	r17
    79da:	08 95       	ret

000079dc <charge_mainloop>:
		break;
	}
}

void charge_mainloop(void) 
{
    79dc:	4f 92       	push	r4
    79de:	5f 92       	push	r5
    79e0:	6f 92       	push	r6
    79e2:	7f 92       	push	r7
    79e4:	8f 92       	push	r8
    79e6:	9f 92       	push	r9
    79e8:	af 92       	push	r10
    79ea:	bf 92       	push	r11
    79ec:	cf 92       	push	r12
    79ee:	df 92       	push	r13
    79f0:	ff 92       	push	r15
    79f2:	0f 93       	push	r16
    79f4:	1f 93       	push	r17
    79f6:	cf 93       	push	r28
    79f8:	df 93       	push	r29
	WORD    lMSEC=0;
	int 	cmd;

	rprintf("Charge mode\n");
    79fa:	8d ef       	ldi	r24, 0xFD	; 253
    79fc:	9a e3       	ldi	r25, 0x3A	; 58
    79fe:	9f 93       	push	r25
    7a00:	8f 93       	push	r24
    7a02:	81 e0       	ldi	r24, 0x01	; 1
    7a04:	8f 93       	push	r24
    7a06:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
    7a0a:	00 e0       	ldi	r16, 0x00	; 0
    7a0c:	10 e0       	ldi	r17, 0x00	; 0
    7a0e:	0f 90       	pop	r0
    7a10:	0f 90       	pop	r0
    7a12:	0f 90       	pop	r0


static void handle_serial(int cmd) {
	switch (cmd) {
	case '?':
		rprintf("Charge mode\n");
    7a14:	4d e4       	ldi	r20, 0x4D	; 77
    7a16:	44 2e       	mov	r4, r20
    7a18:	4b e3       	ldi	r20, 0x3B	; 59
    7a1a:	54 2e       	mov	r5, r20
    7a1c:	ff 24       	eor	r15, r15
    7a1e:	f3 94       	inc	r15
		Get_VOLTAGE();
		DetectPower();
		rprintf("Voltage = %dmv (%d)\n", gVOLTAGE, F_PS_PLUGGED);	
		break;
	case 'c':
		rprintf("Initiating charge cycle\n");
    7a20:	3f e1       	ldi	r19, 0x1F	; 31
    7a22:	63 2e       	mov	r6, r19
    7a24:	3b e3       	ldi	r19, 0x3B	; 59
    7a26:	73 2e       	mov	r7, r19
		rprintf("Charge mode\n");
		break;
	case 'v':
		Get_VOLTAGE();
		DetectPower();
		rprintf("Voltage = %dmv (%d)\n", gVOLTAGE, F_PS_PLUGGED);	
    7a28:	28 e3       	ldi	r18, 0x38	; 56
    7a2a:	82 2e       	mov	r8, r18
    7a2c:	2b e3       	ldi	r18, 0x3B	; 59
    7a2e:	92 2e       	mov	r9, r18
	case 'c':
		rprintf("Initiating charge cycle\n");
		ChargeNiMH();
		break;
	case 27:
		rprintf("Exiting charge mode\n");
    7a30:	9a e0       	ldi	r25, 0x0A	; 10
    7a32:	a9 2e       	mov	r10, r25
    7a34:	9b e3       	ldi	r25, 0x3B	; 59
    7a36:	b9 2e       	mov	r11, r25
		if(gMSEC == 0 || gMSEC == 50){
			if(gMSEC != lMSEC){
				lMSEC = gMSEC;
				Get_VOLTAGE();
				DetectPower();
				rprintf("Voltage = %d (%d)\n", gVOLTAGE, F_PS_PLUGGED);	
    7a38:	8a ee       	ldi	r24, 0xEA	; 234
    7a3a:	c8 2e       	mov	r12, r24
    7a3c:	8a e3       	ldi	r24, 0x3A	; 58
    7a3e:	d8 2e       	mov	r13, r24
    7a40:	82 c0       	rjmp	.+260    	; 0x7b46 <charge_mainloop+0x16a>

	rprintf("Charge mode\n");
	
	while (kChargeMode == gNextMode) {

		cmd = uartGetByte();
    7a42:	0e 94 9c 22 	call	0x4538	; 0x4538 <uartGetByte>
		if (cmd >= 0) handle_serial(cmd);
    7a46:	97 fd       	sbrc	r25, 7
    7a48:	48 c0       	rjmp	.+144    	; 0x7ada <charge_mainloop+0xfe>

/********************************************************************************************/


static void handle_serial(int cmd) {
	switch (cmd) {
    7a4a:	8f 33       	cpi	r24, 0x3F	; 63
    7a4c:	91 05       	cpc	r25, r1
    7a4e:	71 f0       	breq	.+28     	; 0x7a6c <charge_mainloop+0x90>
    7a50:	80 34       	cpi	r24, 0x40	; 64
    7a52:	91 05       	cpc	r25, r1
    7a54:	24 f4       	brge	.+8      	; 0x7a5e <charge_mainloop+0x82>
    7a56:	4b 97       	sbiw	r24, 0x1b	; 27
    7a58:	09 f0       	breq	.+2      	; 0x7a5c <charge_mainloop+0x80>
    7a5a:	3f c0       	rjmp	.+126    	; 0x7ada <charge_mainloop+0xfe>
    7a5c:	32 c0       	rjmp	.+100    	; 0x7ac2 <charge_mainloop+0xe6>
    7a5e:	83 36       	cpi	r24, 0x63	; 99
    7a60:	91 05       	cpc	r25, r1
    7a62:	39 f1       	breq	.+78     	; 0x7ab2 <charge_mainloop+0xd6>
    7a64:	86 37       	cpi	r24, 0x76	; 118
    7a66:	91 05       	cpc	r25, r1
    7a68:	c1 f5       	brne	.+112    	; 0x7ada <charge_mainloop+0xfe>
    7a6a:	06 c0       	rjmp	.+12     	; 0x7a78 <charge_mainloop+0x9c>
	case '?':
		rprintf("Charge mode\n");
    7a6c:	5f 92       	push	r5
    7a6e:	4f 92       	push	r4
    7a70:	ff 92       	push	r15
    7a72:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
    7a76:	2e c0       	rjmp	.+92     	; 0x7ad4 <charge_mainloop+0xf8>
		break;
	case 'v':
		Get_VOLTAGE();
    7a78:	0e 94 00 2d 	call	0x5a00	; 0x5a00 <Get_VOLTAGE>
		DetectPower();
    7a7c:	0e 94 fc 3b 	call	0x77f8	; 0x77f8 <DetectPower>
		rprintf("Voltage = %dmv (%d)\n", gVOLTAGE, F_PS_PLUGGED);	
    7a80:	20 91 92 0d 	lds	r18, 0x0D92
    7a84:	30 91 93 0d 	lds	r19, 0x0D93
    7a88:	80 91 b1 0d 	lds	r24, 0x0DB1
    7a8c:	90 e0       	ldi	r25, 0x00	; 0
    7a8e:	9f 93       	push	r25
    7a90:	8f 93       	push	r24
    7a92:	3f 93       	push	r19
    7a94:	2f 93       	push	r18
    7a96:	9f 92       	push	r9
    7a98:	8f 92       	push	r8
    7a9a:	ff 92       	push	r15
    7a9c:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
    7aa0:	8d b7       	in	r24, 0x3d	; 61
    7aa2:	9e b7       	in	r25, 0x3e	; 62
    7aa4:	07 96       	adiw	r24, 0x07	; 7
    7aa6:	0f b6       	in	r0, 0x3f	; 63
    7aa8:	f8 94       	cli
    7aaa:	9e bf       	out	0x3e, r25	; 62
    7aac:	0f be       	out	0x3f, r0	; 63
    7aae:	8d bf       	out	0x3d, r24	; 61
    7ab0:	14 c0       	rjmp	.+40     	; 0x7ada <charge_mainloop+0xfe>
		break;
	case 'c':
		rprintf("Initiating charge cycle\n");
    7ab2:	7f 92       	push	r7
    7ab4:	6f 92       	push	r6
    7ab6:	ff 92       	push	r15
    7ab8:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
		ChargeNiMH();
    7abc:	0e 94 4e 3c 	call	0x789c	; 0x789c <ChargeNiMH>
    7ac0:	09 c0       	rjmp	.+18     	; 0x7ad4 <charge_mainloop+0xf8>
		break;
	case 27:
		rprintf("Exiting charge mode\n");
    7ac2:	bf 92       	push	r11
    7ac4:	af 92       	push	r10
    7ac6:	ff 92       	push	r15
    7ac8:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
		gNextMode = kIdleMode;
    7acc:	10 92 80 0b 	sts	0x0B80, r1
    7ad0:	10 92 7f 0b 	sts	0x0B7F, r1
    7ad4:	0f 90       	pop	r0
    7ad6:	0f 90       	pop	r0
    7ad8:	0f 90       	pop	r0
	while (kChargeMode == gNextMode) {

		cmd = uartGetByte();
		if (cmd >= 0) handle_serial(cmd);
		
		if(gMSEC == 0 || gMSEC == 50){
    7ada:	80 91 be 0a 	lds	r24, 0x0ABE
    7ade:	90 91 bf 0a 	lds	r25, 0x0ABF
    7ae2:	89 2b       	or	r24, r25
    7ae4:	41 f0       	breq	.+16     	; 0x7af6 <charge_mainloop+0x11a>
    7ae6:	80 91 be 0a 	lds	r24, 0x0ABE
    7aea:	90 91 bf 0a 	lds	r25, 0x0ABF
    7aee:	c2 97       	sbiw	r24, 0x32	; 50
    7af0:	11 f0       	breq	.+4      	; 0x7af6 <charge_mainloop+0x11a>
    7af2:	e8 01       	movw	r28, r16
    7af4:	27 c0       	rjmp	.+78     	; 0x7b44 <charge_mainloop+0x168>
			if(gMSEC != lMSEC){
    7af6:	c0 91 be 0a 	lds	r28, 0x0ABE
    7afa:	d0 91 bf 0a 	lds	r29, 0x0ABF
    7afe:	c0 17       	cp	r28, r16
    7b00:	d1 07       	cpc	r29, r17
    7b02:	01 f1       	breq	.+64     	; 0x7b44 <charge_mainloop+0x168>
				lMSEC = gMSEC;
    7b04:	c0 91 be 0a 	lds	r28, 0x0ABE
    7b08:	d0 91 bf 0a 	lds	r29, 0x0ABF
				Get_VOLTAGE();
    7b0c:	0e 94 00 2d 	call	0x5a00	; 0x5a00 <Get_VOLTAGE>
				DetectPower();
    7b10:	0e 94 fc 3b 	call	0x77f8	; 0x77f8 <DetectPower>
				rprintf("Voltage = %d (%d)\n", gVOLTAGE, F_PS_PLUGGED);	
    7b14:	20 91 92 0d 	lds	r18, 0x0D92
    7b18:	30 91 93 0d 	lds	r19, 0x0D93
    7b1c:	80 91 b1 0d 	lds	r24, 0x0DB1
    7b20:	90 e0       	ldi	r25, 0x00	; 0
    7b22:	9f 93       	push	r25
    7b24:	8f 93       	push	r24
    7b26:	3f 93       	push	r19
    7b28:	2f 93       	push	r18
    7b2a:	df 92       	push	r13
    7b2c:	cf 92       	push	r12
    7b2e:	ff 92       	push	r15
    7b30:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
    7b34:	8d b7       	in	r24, 0x3d	; 61
    7b36:	9e b7       	in	r25, 0x3e	; 62
    7b38:	07 96       	adiw	r24, 0x07	; 7
    7b3a:	0f b6       	in	r0, 0x3f	; 63
    7b3c:	f8 94       	cli
    7b3e:	9e bf       	out	0x3e, r25	; 62
    7b40:	0f be       	out	0x3f, r0	; 63
    7b42:	8d bf       	out	0x3d, r24	; 61
    7b44:	8e 01       	movw	r16, r28
	WORD    lMSEC=0;
	int 	cmd;

	rprintf("Charge mode\n");
	
	while (kChargeMode == gNextMode) {
    7b46:	80 91 7f 0b 	lds	r24, 0x0B7F
    7b4a:	90 91 80 0b 	lds	r25, 0x0B80
    7b4e:	02 97       	sbiw	r24, 0x02	; 2
    7b50:	09 f4       	brne	.+2      	; 0x7b54 <charge_mainloop+0x178>
    7b52:	77 cf       	rjmp	.-274    	; 0x7a42 <charge_mainloop+0x66>
		}

		// Meanwhile... continue charging the battery?
		// Not entirely sure how to integrate this with the above.
	}
}
    7b54:	df 91       	pop	r29
    7b56:	cf 91       	pop	r28
    7b58:	1f 91       	pop	r17
    7b5a:	0f 91       	pop	r16
    7b5c:	ff 90       	pop	r15
    7b5e:	df 90       	pop	r13
    7b60:	cf 90       	pop	r12
    7b62:	bf 90       	pop	r11
    7b64:	af 90       	pop	r10
    7b66:	9f 90       	pop	r9
    7b68:	8f 90       	pop	r8
    7b6a:	7f 90       	pop	r7
    7b6c:	6f 90       	pop	r6
    7b6e:	5f 90       	pop	r5
    7b70:	4f 90       	pop	r4
    7b72:	08 95       	ret

00007b74 <ReceiveIntoMotionBuf>:

//------------------------------------------------------------------------------
// ReceiveIntoMotionBuf: uart Rx routine that stuffs data into nextMotionBuf.
//------------------------------------------------------------------------------
void ReceiveIntoMotionBuf(unsigned char c)
{
    7b74:	20 91 8a 0a 	lds	r18, 0x0A8A
    7b78:	30 91 8b 0a 	lds	r19, 0x0A8B
    7b7c:	e0 91 86 0a 	lds	r30, 0x0A86
    7b80:	f0 91 87 0a 	lds	r31, 0x0A87
    7b84:	e2 0f       	add	r30, r18
    7b86:	f3 1f       	adc	r31, r19
    7b88:	80 83       	st	Z, r24
    7b8a:	2f 5f       	subi	r18, 0xFF	; 255
    7b8c:	3f 4f       	sbci	r19, 0xFF	; 255
    7b8e:	30 93 8b 0a 	sts	0x0A8B, r19
    7b92:	20 93 8a 0a 	sts	0x0A8A, r18
	nextMotionBuf[nextRxIndex++] = c;
}
    7b96:	08 95       	ret

00007b98 <SkipMsgData>:

//------------------------------------------------------------------------------
// Skip the rest of the current message, by reading from the uart until we get
// a null byte not escaped by a backslash.
static void SkipMsgData()
{
    7b98:	0f 93       	push	r16
    7b9a:	1f 93       	push	r17
    7b9c:	df 93       	push	r29
    7b9e:	cf 93       	push	r28
    7ba0:	0f 92       	push	r0
    7ba2:	cd b7       	in	r28, 0x3d	; 61
    7ba4:	de b7       	in	r29, 0x3e	; 62
	// To-do: add a timeout mechanism here.
	u08 ch;
	while (1) {
		while (!uartReceiveByte(&ch)) ;
    7ba6:	8e 01       	movw	r16, r28
    7ba8:	0f 5f       	subi	r16, 0xFF	; 255
    7baa:	1f 4f       	sbci	r17, 0xFF	; 255
    7bac:	c8 01       	movw	r24, r16
    7bae:	0e 94 82 22 	call	0x4504	; 0x4504 <uartReceiveByte>
    7bb2:	88 23       	and	r24, r24
    7bb4:	d9 f3       	breq	.-10     	; 0x7bac <SkipMsgData+0x14>
		if ('\\' == ch) {
    7bb6:	89 81       	ldd	r24, Y+1	; 0x01
    7bb8:	8c 35       	cpi	r24, 0x5C	; 92
    7bba:	31 f4       	brne	.+12     	; 0x7bc8 <SkipMsgData+0x30>
			// backslash found; skip the next byte and continue
			while (!uartReceiveByte(&ch)) ;
    7bbc:	c8 01       	movw	r24, r16
    7bbe:	0e 94 82 22 	call	0x4504	; 0x4504 <uartReceiveByte>
    7bc2:	88 23       	and	r24, r24
    7bc4:	d9 f3       	breq	.-10     	; 0x7bbc <SkipMsgData+0x24>
    7bc6:	f2 cf       	rjmp	.-28     	; 0x7bac <SkipMsgData+0x14>
			continue;
		}
		if (!ch) return;	// null found; end of message
    7bc8:	88 23       	and	r24, r24
    7bca:	81 f7       	brne	.-32     	; 0x7bac <SkipMsgData+0x14>
	}
}
    7bcc:	0f 90       	pop	r0
    7bce:	cf 91       	pop	r28
    7bd0:	df 91       	pop	r29
    7bd2:	1f 91       	pop	r17
    7bd4:	0f 91       	pop	r16
    7bd6:	08 95       	ret

00007bd8 <GetMsgByte>:
}

//------------------------------------------------------------------------------
// Get a byte of data from the message in the uart (unescaping as necessary).
static u08 GetMsgByte(void)
{
    7bd8:	0f 93       	push	r16
    7bda:	1f 93       	push	r17
    7bdc:	df 93       	push	r29
    7bde:	cf 93       	push	r28
    7be0:	0f 92       	push	r0
    7be2:	cd b7       	in	r28, 0x3d	; 61
    7be4:	de b7       	in	r29, 0x3e	; 62
	u08 ch;
	while (!uartReceiveByte(&ch));		// To-Do: add a timeout here
    7be6:	8e 01       	movw	r16, r28
    7be8:	0f 5f       	subi	r16, 0xFF	; 255
    7bea:	1f 4f       	sbci	r17, 0xFF	; 255
    7bec:	c8 01       	movw	r24, r16
    7bee:	0e 94 82 22 	call	0x4504	; 0x4504 <uartReceiveByte>
    7bf2:	88 23       	and	r24, r24
    7bf4:	d9 f3       	breq	.-10     	; 0x7bec <GetMsgByte+0x14>
	if ('\\' == ch) {
    7bf6:	89 81       	ldd	r24, Y+1	; 0x01
    7bf8:	8c 35       	cpi	r24, 0x5C	; 92
    7bfa:	41 f4       	brne	.+16     	; 0x7c0c <GetMsgByte+0x34>
		while (!uartReceiveByte(&ch));		// To-Do: and here
    7bfc:	8e 01       	movw	r16, r28
    7bfe:	0f 5f       	subi	r16, 0xFF	; 255
    7c00:	1f 4f       	sbci	r17, 0xFF	; 255
    7c02:	c8 01       	movw	r24, r16
    7c04:	0e 94 82 22 	call	0x4504	; 0x4504 <uartReceiveByte>
    7c08:	88 23       	and	r24, r24
    7c0a:	d9 f3       	breq	.-10     	; 0x7c02 <GetMsgByte+0x2a>
	}
	return ch;
}
    7c0c:	89 81       	ldd	r24, Y+1	; 0x01
    7c0e:	0f 90       	pop	r0
    7c10:	cf 91       	pop	r28
    7c12:	df 91       	pop	r29
    7c14:	1f 91       	pop	r17
    7c16:	0f 91       	pop	r16
    7c18:	08 95       	ret

00007c1a <StartMsg>:
}

//------------------------------------------------------------------------------
// Send a message header for the given message type.
static void StartMsg(u08 msgType)
{
    7c1a:	1f 93       	push	r17
    7c1c:	18 2f       	mov	r17, r24
	uartSendByte(0xBE);
    7c1e:	8e eb       	ldi	r24, 0xBE	; 190
    7c20:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
	uartSendByte(0xAD);
    7c24:	8d ea       	ldi	r24, 0xAD	; 173
    7c26:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
	uartSendByte(msgType);
    7c2a:	81 2f       	mov	r24, r17
    7c2c:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
}
    7c30:	1f 91       	pop	r17
    7c32:	08 95       	ret

00007c34 <AddMsgByte>:
}

//------------------------------------------------------------------------------
// Add a byte of data to the message (properly escaped as necessary).
static void AddMsgByte(u08 b)
{
    7c34:	1f 93       	push	r17
    7c36:	18 2f       	mov	r17, r24
	if (!b) uartSendByte('\\');
    7c38:	88 23       	and	r24, r24
    7c3a:	19 f4       	brne	.+6      	; 0x7c42 <AddMsgByte+0xe>
    7c3c:	8c e5       	ldi	r24, 0x5C	; 92
    7c3e:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
	uartSendByte(b);
    7c42:	81 2f       	mov	r24, r17
    7c44:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
}
    7c48:	1f 91       	pop	r17
    7c4a:	08 95       	ret

00007c4c <AddMsgWord>:

//------------------------------------------------------------------------------
// Add a word of data to the message (in Little-Endian format).
static void AddMsgWord(WORD w)
{
    7c4c:	1f 93       	push	r17
    7c4e:	19 2f       	mov	r17, r25
	AddMsgByte(w & 0xFF);
    7c50:	0e 94 1a 3e 	call	0x7c34	; 0x7c34 <AddMsgByte>
	AddMsgByte(w >> 8);
    7c54:	81 2f       	mov	r24, r17
    7c56:	0e 94 1a 3e 	call	0x7c34	; 0x7c34 <AddMsgByte>
}
    7c5a:	1f 91       	pop	r17
    7c5c:	08 95       	ret

00007c5e <print_motionBuf>:

//------------------------------------------------------------------------------
// print_motionBuf: debugging routine to dump motionBuf to the uart.
//------------------------------------------------------------------------------
void print_motionBuf(unsigned char *buf, int bytes)
{
    7c5e:	cf 92       	push	r12
    7c60:	df 92       	push	r13
    7c62:	ef 92       	push	r14
    7c64:	ff 92       	push	r15
    7c66:	1f 93       	push	r17
    7c68:	cf 93       	push	r28
    7c6a:	df 93       	push	r29
    7c6c:	6c 01       	movw	r12, r24
    7c6e:	7b 01       	movw	r14, r22
	// Print the bytes, for debugging purposes.
	rprintf("motionBuf: ");
    7c70:	8f eb       	ldi	r24, 0xBF	; 191
    7c72:	9c e3       	ldi	r25, 0x3C	; 60
    7c74:	9f 93       	push	r25
    7c76:	8f 93       	push	r24
    7c78:	81 e0       	ldi	r24, 0x01	; 1
    7c7a:	8f 93       	push	r24
    7c7c:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
    7c80:	c0 e0       	ldi	r28, 0x00	; 0
    7c82:	d0 e0       	ldi	r29, 0x00	; 0
    7c84:	0f 90       	pop	r0
    7c86:	0f 90       	pop	r0
    7c88:	0f 90       	pop	r0
    7c8a:	1a c0       	rjmp	.+52     	; 0x7cc0 <print_motionBuf+0x62>
	const unsigned char *hexDigits = "0123456789ABCDEF";
	for (int i = 0; i < bytes; i++) {
		unsigned char b = buf[i];
    7c8c:	f6 01       	movw	r30, r12
    7c8e:	ec 0f       	add	r30, r28
    7c90:	fd 1f       	adc	r31, r29
    7c92:	10 81       	ld	r17, Z
		uartSendByte( hexDigits[ b >> 4 ] );
    7c94:	e1 2f       	mov	r30, r17
    7c96:	e2 95       	swap	r30
    7c98:	ef 70       	andi	r30, 0x0F	; 15
    7c9a:	f0 e0       	ldi	r31, 0x00	; 0
    7c9c:	ec 56       	subi	r30, 0x6C	; 108
    7c9e:	fd 4f       	sbci	r31, 0xFD	; 253
    7ca0:	80 81       	ld	r24, Z
    7ca2:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
		uartSendByte( hexDigits[ b & 0x0F ] );
    7ca6:	e1 2f       	mov	r30, r17
    7ca8:	f0 e0       	ldi	r31, 0x00	; 0
    7caa:	ef 70       	andi	r30, 0x0F	; 15
    7cac:	f0 70       	andi	r31, 0x00	; 0
    7cae:	ec 56       	subi	r30, 0x6C	; 108
    7cb0:	fd 4f       	sbci	r31, 0xFD	; 253
    7cb2:	80 81       	ld	r24, Z
    7cb4:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
		uartSendByte( ' ' );
    7cb8:	80 e2       	ldi	r24, 0x20	; 32
    7cba:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
void print_motionBuf(unsigned char *buf, int bytes)
{
	// Print the bytes, for debugging purposes.
	rprintf("motionBuf: ");
	const unsigned char *hexDigits = "0123456789ABCDEF";
	for (int i = 0; i < bytes; i++) {
    7cbe:	21 96       	adiw	r28, 0x01	; 1
    7cc0:	ce 15       	cp	r28, r14
    7cc2:	df 05       	cpc	r29, r15
    7cc4:	1c f3       	brlt	.-58     	; 0x7c8c <print_motionBuf+0x2e>
		unsigned char b = buf[i];
		uartSendByte( hexDigits[ b >> 4 ] );
		uartSendByte( hexDigits[ b & 0x0F ] );
		uartSendByte( ' ' );
	}
}
    7cc6:	df 91       	pop	r29
    7cc8:	cf 91       	pop	r28
    7cca:	1f 91       	pop	r17
    7ccc:	ff 90       	pop	r15
    7cce:	ef 90       	pop	r14
    7cd0:	df 90       	pop	r13
    7cd2:	cf 90       	pop	r12
    7cd4:	08 95       	ret

00007cd6 <handle_get_status>:
}

//------------------------------------------------------------------------------
// Report all the servo positions and other status info.
void handle_get_status(void)
{
    7cd6:	0f 93       	push	r16
    7cd8:	1f 93       	push	r17
	// Currently this command takes no parameters...
	// in the future, we may want to send a mask indicating which sort
	// of data we're interested in receiving.
	SkipMsgData();
    7cda:	0e 94 cc 3d 	call	0x7b98	; 0x7b98 <SkipMsgData>

	StartMsg('q');
    7cde:	81 e7       	ldi	r24, 0x71	; 113
    7ce0:	0e 94 0d 3e 	call	0x7c1a	; 0x7c1a <StartMsg>
    7ce4:	00 e0       	ldi	r16, 0x00	; 0

	// Start with servo positions.
	for (BYTE id=0; id<16; id++) {
		AddMsgByte( wckPosRead(id) );
    7ce6:	80 2f       	mov	r24, r16
    7ce8:	0e 94 62 53 	call	0xa6c4	; 0xa6c4 <wckPosRead>
    7cec:	0e 94 1a 3e 	call	0x7c34	; 0x7c34 <AddMsgByte>
	SkipMsgData();

	StartMsg('q');

	// Start with servo positions.
	for (BYTE id=0; id<16; id++) {
    7cf0:	0f 5f       	subi	r16, 0xFF	; 255
    7cf2:	00 31       	cpi	r16, 0x10	; 16
    7cf4:	c1 f7       	brne	.-16     	; 0x7ce6 <handle_get_status+0x10>
		AddMsgByte( wckPosRead(id) );
	}

	// PSD (distance) sensor value
	AddMsgWord( adc_psd() );
    7cf6:	0e 94 9c 2c 	call	0x5938	; 0x5938 <adc_psd>
    7cfa:	90 e0       	ldi	r25, 0x00	; 0
    7cfc:	0e 94 26 3e 	call	0x7c4c	; 0x7c4c <AddMsgWord>
	
	// Microphone value
	AddMsgWord( adc_mic() );
    7d00:	0e 94 fb 2c 	call	0x59f6	; 0x59f6 <adc_mic>
    7d04:	90 e0       	ldi	r25, 0x00	; 0
    7d06:	0e 94 26 3e 	call	0x7c4c	; 0x7c4c <AddMsgWord>
	
	// Battery voltage
	WORD v = adc_volt();
    7d0a:	0e 94 d1 2b 	call	0x57a2	; 0x57a2 <adc_volt>
    7d0e:	8c 01       	movw	r16, r24
	AddMsgWord( v );
    7d10:	0e 94 26 3e 	call	0x7c4c	; 0x7c4c <AddMsgWord>
	
	// accelerometer
	tilt_read(0);
    7d14:	80 e0       	ldi	r24, 0x00	; 0
    7d16:	0e 94 ad 2f 	call	0x5f5a	; 0x5f5a <tilt_read>
	AddMsgWord( x_value );
    7d1a:	80 91 a5 0d 	lds	r24, 0x0DA5
    7d1e:	90 91 a6 0d 	lds	r25, 0x0DA6
    7d22:	0e 94 26 3e 	call	0x7c4c	; 0x7c4c <AddMsgWord>
	AddMsgWord( y_value );
    7d26:	80 91 a7 0d 	lds	r24, 0x0DA7
    7d2a:	90 91 a8 0d 	lds	r25, 0x0DA8
    7d2e:	0e 94 26 3e 	call	0x7c4c	; 0x7c4c <AddMsgWord>
	AddMsgWord( z_value );
    7d32:	80 91 af 0d 	lds	r24, 0x0DAF
    7d36:	90 91 b0 0d 	lds	r25, 0x0DB0
    7d3a:	0e 94 26 3e 	call	0x7c4c	; 0x7c4c <AddMsgWord>
	
	// clock
	AddMsgByte( gHOUR );
    7d3e:	80 91 b5 0a 	lds	r24, 0x0AB5
    7d42:	0e 94 1a 3e 	call	0x7c34	; 0x7c34 <AddMsgByte>
	AddMsgByte( gMIN );
    7d46:	80 91 9d 0a 	lds	r24, 0x0A9D
    7d4a:	0e 94 1a 3e 	call	0x7c34	; 0x7c34 <AddMsgByte>
	AddMsgByte( gSEC );
    7d4e:	80 91 ba 0a 	lds	r24, 0x0ABA
    7d52:	0e 94 1a 3e 	call	0x7c34	; 0x7c34 <AddMsgByte>
	AddMsgWord( gMSEC );
    7d56:	80 91 be 0a 	lds	r24, 0x0ABE
    7d5a:	90 91 bf 0a 	lds	r25, 0x0ABF
    7d5e:	0e 94 26 3e 	call	0x7c4c	; 0x7c4c <AddMsgWord>
	AddMsgWord( gTicks );
    7d62:	80 91 82 05 	lds	r24, 0x0582
    7d66:	90 91 83 05 	lds	r25, 0x0583
    7d6a:	0e 94 26 3e 	call	0x7c4c	; 0x7c4c <AddMsgWord>

//------------------------------------------------------------------------------
// Send the message ending delimiter.
static void EndMsg(void)
{
	uartSendByte(0);
    7d6e:	80 e0       	ldi	r24, 0x00	; 0
    7d70:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
	AddMsgWord( gMSEC );
	AddMsgWord( gTicks );

	EndMsg();

	rprintf("Battery voltage: %d mV\n", v);
    7d74:	1f 93       	push	r17
    7d76:	0f 93       	push	r16
    7d78:	84 ea       	ldi	r24, 0xA4	; 164
    7d7a:	9b e3       	ldi	r25, 0x3B	; 59
    7d7c:	9f 93       	push	r25
    7d7e:	8f 93       	push	r24
    7d80:	81 e0       	ldi	r24, 0x01	; 1
    7d82:	8f 93       	push	r24
    7d84:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
    7d88:	0f 90       	pop	r0
    7d8a:	0f 90       	pop	r0
    7d8c:	0f 90       	pop	r0
    7d8e:	0f 90       	pop	r0
    7d90:	0f 90       	pop	r0

}
    7d92:	1f 91       	pop	r17
    7d94:	0f 91       	pop	r16
    7d96:	08 95       	ret

00007d98 <handle_goto_position>:
	}
}

//------------------------------------------------------------------------------
void handle_goto_position(void)
{
    7d98:	ff 92       	push	r15
    7d9a:	0f 93       	push	r16
    7d9c:	1f 93       	push	r17
	// three binary parameters, one byte each:
	// Servo ID, torque (max. 0, min. 4), position (0-255)
	// Note: send 0xFF for torque to set the servo to passive mode
	
	u08 servoID = GetMsgByte();
    7d9e:	0e 94 ec 3d 	call	0x7bd8	; 0x7bd8 <GetMsgByte>
    7da2:	f8 2e       	mov	r15, r24
	u08 torque = GetMsgByte();
    7da4:	0e 94 ec 3d 	call	0x7bd8	; 0x7bd8 <GetMsgByte>
    7da8:	08 2f       	mov	r16, r24
	u08 position = GetMsgByte();
    7daa:	0e 94 ec 3d 	call	0x7bd8	; 0x7bd8 <GetMsgByte>
    7dae:	18 2f       	mov	r17, r24
	SkipMsgData();	// skip rest of message (if any)
    7db0:	0e 94 cc 3d 	call	0x7b98	; 0x7b98 <SkipMsgData>
	
	if (torque <= 4) {
    7db4:	05 30       	cpi	r16, 0x05	; 5
    7db6:	30 f4       	brcc	.+12     	; 0x7dc4 <handle_goto_position+0x2c>
		wckPosSend(servoID, torque, position);
    7db8:	41 2f       	mov	r20, r17
    7dba:	60 2f       	mov	r22, r16
    7dbc:	8f 2d       	mov	r24, r15
    7dbe:	0e 94 15 53 	call	0xa62a	; 0xa62a <wckPosSend>
    7dc2:	03 c0       	rjmp	.+6      	; 0x7dca <handle_goto_position+0x32>
	} else {
		wckSetPassive(servoID);
    7dc4:	8f 2d       	mov	r24, r15
    7dc6:	0e 94 ee 53 	call	0xa7dc	; 0xa7dc <wckSetPassive>
//------------------------------------------------------------------------------
// Send an acknowledgement that we received and handled the last
// message of the given type.
static void SendAck(u08 msgType) 
{
	rprintf("\xBE\xAD%c%c%c", 'k', msgType, 0);
    7dca:	1f 92       	push	r1
    7dcc:	1f 92       	push	r1
    7dce:	87 e6       	ldi	r24, 0x67	; 103
    7dd0:	90 e0       	ldi	r25, 0x00	; 0
    7dd2:	9f 93       	push	r25
    7dd4:	8f 93       	push	r24
    7dd6:	8b e6       	ldi	r24, 0x6B	; 107
    7dd8:	90 e0       	ldi	r25, 0x00	; 0
    7dda:	9f 93       	push	r25
    7ddc:	8f 93       	push	r24
    7dde:	8b e9       	ldi	r24, 0x9B	; 155
    7de0:	9b e3       	ldi	r25, 0x3B	; 59
    7de2:	9f 93       	push	r25
    7de4:	8f 93       	push	r24
    7de6:	81 e0       	ldi	r24, 0x01	; 1
    7de8:	8f 93       	push	r24
    7dea:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
    7dee:	8d b7       	in	r24, 0x3d	; 61
    7df0:	9e b7       	in	r25, 0x3e	; 62
    7df2:	09 96       	adiw	r24, 0x09	; 9
    7df4:	0f b6       	in	r0, 0x3f	; 63
    7df6:	f8 94       	cli
    7df8:	9e bf       	out	0x3e, r25	; 62
    7dfa:	0f be       	out	0x3f, r0	; 63
    7dfc:	8d bf       	out	0x3d, r24	; 61
	} else {
		wckSetPassive(servoID);
	}
	
	SendAck('g');
}
    7dfe:	1f 91       	pop	r17
    7e00:	0f 91       	pop	r16
    7e02:	ff 90       	pop	r15
    7e04:	08 95       	ret

00007e06 <handle_direct_ctl>:
	PlaySceneFromBuffer(curMotionBuf, gSceneIndex+1);
}

//------------------------------------------------------------------------------
void handle_direct_ctl(BOOL showResponse)
{
    7e06:	9f 92       	push	r9
    7e08:	af 92       	push	r10
    7e0a:	bf 92       	push	r11
    7e0c:	cf 92       	push	r12
    7e0e:	df 92       	push	r13
    7e10:	ef 92       	push	r14
    7e12:	ff 92       	push	r15
    7e14:	0f 93       	push	r16
    7e16:	1f 93       	push	r17
    7e18:	df 93       	push	r29
    7e1a:	cf 93       	push	r28
    7e1c:	cd b7       	in	r28, 0x3d	; 61
    7e1e:	de b7       	in	r29, 0x3e	; 62
    7e20:	c0 54       	subi	r28, 0x40	; 64
    7e22:	d0 40       	sbci	r29, 0x00	; 0
    7e24:	0f b6       	in	r0, 0x3f	; 63
    7e26:	f8 94       	cli
    7e28:	de bf       	out	0x3e, r29	; 62
    7e2a:	0f be       	out	0x3f, r0	; 63
    7e2c:	cd bf       	out	0x3d, r28	; 61
    7e2e:	98 2e       	mov	r9, r24
	// 2 hex digits = length
	
	#define MAX_INP_BUF 32

	int c;
	int l=getHex(2);
    7e30:	82 e0       	ldi	r24, 0x02	; 2
    7e32:	90 e0       	ldi	r25, 0x00	; 0
    7e34:	0e 94 c6 37 	call	0x6f8c	; 0x6f8c <getHex>
    7e38:	5c 01       	movw	r10, r24
    7e3a:	7e 01       	movw	r14, r28
    7e3c:	08 94       	sec
    7e3e:	e1 1c       	adc	r14, r1
    7e40:	f1 1c       	adc	r15, r1
    7e42:	67 01       	movw	r12, r14
    7e44:	00 e0       	ldi	r16, 0x00	; 0
    7e46:	10 e0       	ldi	r17, 0x00	; 0
    7e48:	0a c0       	rjmp	.+20     	; 0x7e5e <handle_direct_ctl+0x58>
	int buff[MAX_INP_BUF];
	// foreach byte
	for (c=0; (c<l && c<MAX_INP_BUF); c++) {			
		// read each hex digit into buffer
		buff[c]=getHex(2);
    7e4a:	82 e0       	ldi	r24, 0x02	; 2
    7e4c:	90 e0       	ldi	r25, 0x00	; 0
    7e4e:	0e 94 c6 37 	call	0x6f8c	; 0x6f8c <getHex>
    7e52:	f6 01       	movw	r30, r12
    7e54:	81 93       	st	Z+, r24
    7e56:	91 93       	st	Z+, r25
    7e58:	6f 01       	movw	r12, r30

	int c;
	int l=getHex(2);
	int buff[MAX_INP_BUF];
	// foreach byte
	for (c=0; (c<l && c<MAX_INP_BUF); c++) {			
    7e5a:	0f 5f       	subi	r16, 0xFF	; 255
    7e5c:	1f 4f       	sbci	r17, 0xFF	; 255
    7e5e:	0a 15       	cp	r16, r10
    7e60:	1b 05       	cpc	r17, r11
    7e62:	7c f4       	brge	.+30     	; 0x7e82 <handle_direct_ctl+0x7c>
    7e64:	00 32       	cpi	r16, 0x20	; 32
    7e66:	11 05       	cpc	r17, r1
    7e68:	81 f7       	brne	.-32     	; 0x7e4a <handle_direct_ctl+0x44>
    7e6a:	0b c0       	rjmp	.+22     	; 0x7e82 <handle_direct_ctl+0x7c>
		buff[c]=getHex(2);
	}
				
	// transmit  buffer
	for (c=0; (c<l && c<MAX_INP_BUF); c++) {	
		sciTx0Data(buff[c]&0xFF);
    7e6c:	f7 01       	movw	r30, r14
    7e6e:	80 81       	ld	r24, Z
    7e70:	0e 94 9f 23 	call	0x473e	; 0x473e <sciTx0Data>
		// read each hex digit into buffer
		buff[c]=getHex(2);
	}
				
	// transmit  buffer
	for (c=0; (c<l && c<MAX_INP_BUF); c++) {	
    7e74:	0f 5f       	subi	r16, 0xFF	; 255
    7e76:	1f 4f       	sbci	r17, 0xFF	; 255
    7e78:	82 e0       	ldi	r24, 0x02	; 2
    7e7a:	90 e0       	ldi	r25, 0x00	; 0
    7e7c:	e8 0e       	add	r14, r24
    7e7e:	f9 1e       	adc	r15, r25
    7e80:	02 c0       	rjmp	.+4      	; 0x7e86 <handle_direct_ctl+0x80>
    7e82:	00 e0       	ldi	r16, 0x00	; 0
    7e84:	10 e0       	ldi	r17, 0x00	; 0
    7e86:	0a 15       	cp	r16, r10
    7e88:	1b 05       	cpc	r17, r11
    7e8a:	1c f4       	brge	.+6      	; 0x7e92 <handle_direct_ctl+0x8c>
    7e8c:	00 32       	cpi	r16, 0x20	; 32
    7e8e:	11 05       	cpc	r17, r1
    7e90:	69 f7       	brne	.-38     	; 0x7e6c <handle_direct_ctl+0x66>
		sciTx0Data(buff[c]&0xFF);
	}

	if (showResponse) {
    7e92:	99 20       	and	r9, r9
    7e94:	e1 f0       	breq	.+56     	; 0x7ece <handle_direct_ctl+0xc8>
		// get response (or timeout)					
		BYTE b1 = sciRx0Ready();
    7e96:	0e 94 a3 23 	call	0x4746	; 0x4746 <sciRx0Ready>
    7e9a:	08 2f       	mov	r16, r24
		BYTE b2 = sciRx0Ready();
    7e9c:	0e 94 a3 23 	call	0x4746	; 0x4746 <sciRx0Ready>
		// echo response
		rprintf ("=%x%x\n", b1,b2);
    7ea0:	90 e0       	ldi	r25, 0x00	; 0
    7ea2:	9f 93       	push	r25
    7ea4:	8f 93       	push	r24
    7ea6:	10 e0       	ldi	r17, 0x00	; 0
    7ea8:	1f 93       	push	r17
    7eaa:	0f 93       	push	r16
    7eac:	81 ec       	ldi	r24, 0xC1	; 193
    7eae:	9b e3       	ldi	r25, 0x3B	; 59
    7eb0:	9f 93       	push	r25
    7eb2:	8f 93       	push	r24
    7eb4:	81 e0       	ldi	r24, 0x01	; 1
    7eb6:	8f 93       	push	r24
    7eb8:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
    7ebc:	ed b7       	in	r30, 0x3d	; 61
    7ebe:	fe b7       	in	r31, 0x3e	; 62
    7ec0:	37 96       	adiw	r30, 0x07	; 7
    7ec2:	0f b6       	in	r0, 0x3f	; 63
    7ec4:	f8 94       	cli
    7ec6:	fe bf       	out	0x3e, r31	; 62
    7ec8:	0f be       	out	0x3f, r0	; 63
    7eca:	ed bf       	out	0x3d, r30	; 61
    7ecc:	0b c0       	rjmp	.+22     	; 0x7ee4 <handle_direct_ctl+0xde>
	} else {
		rprintf (" ok\n");
    7ece:	8c eb       	ldi	r24, 0xBC	; 188
    7ed0:	9b e3       	ldi	r25, 0x3B	; 59
    7ed2:	9f 93       	push	r25
    7ed4:	8f 93       	push	r24
    7ed6:	81 e0       	ldi	r24, 0x01	; 1
    7ed8:	8f 93       	push	r24
    7eda:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
    7ede:	0f 90       	pop	r0
    7ee0:	0f 90       	pop	r0
    7ee2:	0f 90       	pop	r0
	}
}
    7ee4:	c0 5c       	subi	r28, 0xC0	; 192
    7ee6:	df 4f       	sbci	r29, 0xFF	; 255
    7ee8:	0f b6       	in	r0, 0x3f	; 63
    7eea:	f8 94       	cli
    7eec:	de bf       	out	0x3e, r29	; 62
    7eee:	0f be       	out	0x3f, r0	; 63
    7ef0:	cd bf       	out	0x3d, r28	; 61
    7ef2:	cf 91       	pop	r28
    7ef4:	df 91       	pop	r29
    7ef6:	1f 91       	pop	r17
    7ef8:	0f 91       	pop	r16
    7efa:	ff 90       	pop	r15
    7efc:	ef 90       	pop	r14
    7efe:	df 90       	pop	r13
    7f00:	cf 90       	pop	r12
    7f02:	bf 90       	pop	r11
    7f04:	af 90       	pop	r10
    7f06:	9f 90       	pop	r9
    7f08:	08 95       	ret

00007f0a <continue_motions>:
//------------------------------------------------------------------------------
// continue_motions: keep our motion going by noticing when the current scene
// is done playing, and starting the next one (if any).
//------------------------------------------------------------------------------
void continue_motions()
{
    7f0a:	80 91 85 0a 	lds	r24, 0x0A85
    7f0e:	88 23       	and	r24, r24
    7f10:	09 f4       	brne	.+2      	; 0x7f14 <continue_motions+0xa>
    7f12:	b2 c0       	rjmp	.+356    	; 0x8078 <continue_motions+0x16e>
	if (!inMotion) return;		// not playing a motion
	if (F_PLAYING) return;		// in the middle of a scene
    7f14:	80 91 85 0b 	lds	r24, 0x0B85
    7f18:	88 23       	and	r24, r24
    7f1a:	09 f0       	breq	.+2      	; 0x7f1e <continue_motions+0x14>
    7f1c:	ad c0       	rjmp	.+346    	; 0x8078 <continue_motions+0x16e>
	
	if (gSceneIndex+1 >= curMotionBuf[0]) {
    7f1e:	20 91 00 01 	lds	r18, 0x0100
    7f22:	30 91 01 01 	lds	r19, 0x0101
    7f26:	2f 5f       	subi	r18, 0xFF	; 255
    7f28:	3f 4f       	sbci	r19, 0xFF	; 255
    7f2a:	e0 91 88 0a 	lds	r30, 0x0A88
    7f2e:	f0 91 89 0a 	lds	r31, 0x0A89
    7f32:	80 81       	ld	r24, Z
    7f34:	90 e0       	ldi	r25, 0x00	; 0
    7f36:	28 17       	cp	r18, r24
    7f38:	39 07       	cpc	r19, r25
    7f3a:	08 f4       	brcc	.+2      	; 0x7f3e <continue_motions+0x34>
    7f3c:	7d c0       	rjmp	.+250    	; 0x8038 <continue_motions+0x12e>
		// all done with the motion!
		// Send a notification that we're done with this motion...
		// currently, the data is the number of scenes; we might want
		// to change this to some other unique identifier that was
		// sent when the motion was loaded.
		StartMsg('d');
    7f3e:	84 e6       	ldi	r24, 0x64	; 100
    7f40:	0e 94 0d 3e 	call	0x7c1a	; 0x7c1a <StartMsg>
		AddMsgByte(curMotionBuf[0]);  // number of scenes
    7f44:	e0 91 88 0a 	lds	r30, 0x0A88
    7f48:	f0 91 89 0a 	lds	r31, 0x0A89
    7f4c:	80 81       	ld	r24, Z
    7f4e:	0e 94 1a 3e 	call	0x7c34	; 0x7c34 <AddMsgByte>

//------------------------------------------------------------------------------
// Send the message ending delimiter.
static void EndMsg(void)
{
	uartSendByte(0);
    7f52:	80 e0       	ldi	r24, 0x00	; 0
    7f54:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
		// sent when the motion was loaded.
		StartMsg('d');
		AddMsgByte(curMotionBuf[0]);  // number of scenes
		EndMsg();
		
		gSceneIndex = -1;
    7f58:	8f ef       	ldi	r24, 0xFF	; 255
    7f5a:	9f ef       	ldi	r25, 0xFF	; 255
    7f5c:	90 93 01 01 	sts	0x0101, r25
    7f60:	80 93 00 01 	sts	0x0100, r24

		if (nextMotionBuf == curMotionBuf || nextRxIndex < nextBytesExpected) {
    7f64:	40 91 86 0a 	lds	r20, 0x0A86
    7f68:	50 91 87 0a 	lds	r21, 0x0A87
    7f6c:	80 91 88 0a 	lds	r24, 0x0A88
    7f70:	90 91 89 0a 	lds	r25, 0x0A89
    7f74:	48 17       	cp	r20, r24
    7f76:	59 07       	cpc	r21, r25
    7f78:	61 f0       	breq	.+24     	; 0x7f92 <continue_motions+0x88>
    7f7a:	20 91 8a 0a 	lds	r18, 0x0A8A
    7f7e:	30 91 8b 0a 	lds	r19, 0x0A8B
    7f82:	80 91 8c 0a 	lds	r24, 0x0A8C
    7f86:	90 91 8d 0a 	lds	r25, 0x0A8D
    7f8a:	28 17       	cp	r18, r24
    7f8c:	39 07       	cpc	r19, r25
    7f8e:	ac f0       	brlt	.+42     	; 0x7fba <continue_motions+0xb0>
    7f90:	3a c0       	rjmp	.+116    	; 0x8006 <continue_motions+0xfc>
			// No next motion has been received (or not received completely),
			// so we're done here.
			if (nextMotionBuf == curMotionBuf) rprintf("No next motion; %d == %d\n", nextMotionBuf, curMotionBuf);
    7f92:	5f 93       	push	r21
    7f94:	4f 93       	push	r20
    7f96:	5f 93       	push	r21
    7f98:	4f 93       	push	r20
    7f9a:	80 e0       	ldi	r24, 0x00	; 0
    7f9c:	9c e3       	ldi	r25, 0x3C	; 60
    7f9e:	9f 93       	push	r25
    7fa0:	8f 93       	push	r24
    7fa2:	81 e0       	ldi	r24, 0x01	; 1
    7fa4:	8f 93       	push	r24
    7fa6:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
    7faa:	8d b7       	in	r24, 0x3d	; 61
    7fac:	9e b7       	in	r25, 0x3e	; 62
    7fae:	07 96       	adiw	r24, 0x07	; 7
    7fb0:	0f b6       	in	r0, 0x3f	; 63
    7fb2:	f8 94       	cli
    7fb4:	9e bf       	out	0x3e, r25	; 62
    7fb6:	0f be       	out	0x3f, r0	; 63
    7fb8:	8d bf       	out	0x3d, r24	; 61
			if (nextRxIndex < nextBytesExpected) rprintf("Next motion incomplete: %d < %d\n", nextRxIndex, nextBytesExpected);
    7fba:	80 91 8a 0a 	lds	r24, 0x0A8A
    7fbe:	90 91 8b 0a 	lds	r25, 0x0A8B
    7fc2:	20 91 8c 0a 	lds	r18, 0x0A8C
    7fc6:	30 91 8d 0a 	lds	r19, 0x0A8D
    7fca:	82 17       	cp	r24, r18
    7fcc:	93 07       	cpc	r25, r19
    7fce:	c4 f4       	brge	.+48     	; 0x8000 <continue_motions+0xf6>
    7fd0:	80 91 8a 0a 	lds	r24, 0x0A8A
    7fd4:	90 91 8b 0a 	lds	r25, 0x0A8B
    7fd8:	3f 93       	push	r19
    7fda:	2f 93       	push	r18
    7fdc:	9f 93       	push	r25
    7fde:	8f 93       	push	r24
    7fe0:	8f ed       	ldi	r24, 0xDF	; 223
    7fe2:	9b e3       	ldi	r25, 0x3B	; 59
    7fe4:	9f 93       	push	r25
    7fe6:	8f 93       	push	r24
    7fe8:	81 e0       	ldi	r24, 0x01	; 1
    7fea:	8f 93       	push	r24
    7fec:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
    7ff0:	8d b7       	in	r24, 0x3d	; 61
    7ff2:	9e b7       	in	r25, 0x3e	; 62
    7ff4:	07 96       	adiw	r24, 0x07	; 7
    7ff6:	0f b6       	in	r0, 0x3f	; 63
    7ff8:	f8 94       	cli
    7ffa:	9e bf       	out	0x3e, r25	; 62
    7ffc:	0f be       	out	0x3f, r0	; 63
    7ffe:	8d bf       	out	0x3d, r24	; 61
			inMotion = FALSE;
    8000:	10 92 85 0a 	sts	0x0A85, r1
    8004:	08 95       	ret
			return;
		}
		
		// Start the next motion.
		curMotionBuf = nextMotionBuf;
    8006:	50 93 89 0a 	sts	0x0A89, r21
    800a:	40 93 88 0a 	sts	0x0A88, r20
		rprintf("Loading motion buf %d\n", curMotionBuf );
    800e:	5f 93       	push	r21
    8010:	4f 93       	push	r20
    8012:	88 ec       	ldi	r24, 0xC8	; 200
    8014:	9b e3       	ldi	r25, 0x3B	; 59
    8016:	9f 93       	push	r25
    8018:	8f 93       	push	r24
    801a:	81 e0       	ldi	r24, 0x01	; 1
    801c:	8f 93       	push	r24
    801e:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
		LoadMotionFromBuffer( curMotionBuf );
    8022:	80 91 88 0a 	lds	r24, 0x0A88
    8026:	90 91 89 0a 	lds	r25, 0x0A89
    802a:	0e 94 76 27 	call	0x4eec	; 0x4eec <LoadMotionFromBuffer>
    802e:	0f 90       	pop	r0
    8030:	0f 90       	pop	r0
    8032:	0f 90       	pop	r0
    8034:	0f 90       	pop	r0
    8036:	0f 90       	pop	r0
	}

	// Notify host that we're beginning a new scene.
	StartMsg('b');
    8038:	82 e6       	ldi	r24, 0x62	; 98
    803a:	0e 94 0d 3e 	call	0x7c1a	; 0x7c1a <StartMsg>
	AddMsgByte(gSceneIndex+1);		// scene number we're starting
    803e:	80 91 00 01 	lds	r24, 0x0100
    8042:	90 91 01 01 	lds	r25, 0x0101
    8046:	8f 5f       	subi	r24, 0xFF	; 255
    8048:	0e 94 1a 3e 	call	0x7c34	; 0x7c34 <AddMsgByte>
	AddMsgByte(curMotionBuf[0]);		// number of scenes
    804c:	e0 91 88 0a 	lds	r30, 0x0A88
    8050:	f0 91 89 0a 	lds	r31, 0x0A89
    8054:	80 81       	ld	r24, Z
    8056:	0e 94 1a 3e 	call	0x7c34	; 0x7c34 <AddMsgByte>

//------------------------------------------------------------------------------
// Send the message ending delimiter.
static void EndMsg(void)
{
	uartSendByte(0);
    805a:	80 e0       	ldi	r24, 0x00	; 0
    805c:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
	AddMsgByte(gSceneIndex+1);		// scene number we're starting
	AddMsgByte(curMotionBuf[0]);		// number of scenes
	EndMsg();

	// And actually start it.
	PlaySceneFromBuffer(curMotionBuf, gSceneIndex+1);
    8060:	60 91 00 01 	lds	r22, 0x0100
    8064:	70 91 01 01 	lds	r23, 0x0101
    8068:	6f 5f       	subi	r22, 0xFF	; 255
    806a:	7f 4f       	sbci	r23, 0xFF	; 255
    806c:	80 91 88 0a 	lds	r24, 0x0A88
    8070:	90 91 89 0a 	lds	r25, 0x0A89
    8074:	0e 94 81 25 	call	0x4b02	; 0x4b02 <PlaySceneFromBuffer>
    8078:	08 95       	ret

0000807a <handle_load_motion>:
// desire to send a motion block; the robot will prepare the buffer and uart,
// respond that it is ready, and then receive the entire motion block at once,
// directly into the motion buffer.
//------------------------------------------------------------------------------
void handle_load_motion()
{
    807a:	0f 93       	push	r16
    807c:	1f 93       	push	r17
    807e:	cf 93       	push	r28
    8080:	df 93       	push	r29

//------------------------------------------------------------------------------
// Get a WORD of data from the message in the uart (unescaping as necessary).
static WORD GetMsgWord(void)
{
	u08 b0 = GetMsgByte();
    8082:	0e 94 ec 3d 	call	0x7bd8	; 0x7bd8 <GetMsgByte>
    8086:	08 2f       	mov	r16, r24
	u08 b1 = GetMsgByte();
    8088:	0e 94 ec 3d 	call	0x7bd8	; 0x7bd8 <GetMsgByte>
{
	WORD startTicks;
	WORD profileTicks1, profileTicks2, profileTicks3;
	
	// Let's start by getting the data size to expect.	
	nextBytesExpected = GetMsgWord();
    808c:	38 2f       	mov	r19, r24
    808e:	20 e0       	ldi	r18, 0x00	; 0
    8090:	10 e0       	ldi	r17, 0x00	; 0
    8092:	02 2b       	or	r16, r18
    8094:	13 2b       	or	r17, r19
    8096:	10 93 8d 0a 	sts	0x0A8D, r17
    809a:	00 93 8c 0a 	sts	0x0A8C, r16
	
	if (nextBytesExpected > kMaxMotionBufSize) {
    809e:	0b 53       	subi	r16, 0x3B	; 59
    80a0:	12 40       	sbci	r17, 0x02	; 2
    80a2:	cc f0       	brlt	.+50     	; 0x80d6 <handle_load_motion+0x5c>
		StartMsg('E');
    80a4:	85 e4       	ldi	r24, 0x45	; 69
    80a6:	0e 94 0d 3e 	call	0x7c1a	; 0x7c1a <StartMsg>
		rprintf("Error: requested buffer size (%d) exceeds max (%d)\n", 
    80aa:	8a e3       	ldi	r24, 0x3A	; 58
    80ac:	92 e0       	ldi	r25, 0x02	; 2
    80ae:	9f 93       	push	r25
    80b0:	8f 93       	push	r24
    80b2:	80 91 8c 0a 	lds	r24, 0x0A8C
    80b6:	90 91 8d 0a 	lds	r25, 0x0A8D
    80ba:	9f 93       	push	r25
    80bc:	8f 93       	push	r24
    80be:	8b e8       	ldi	r24, 0x8B	; 139
    80c0:	9c e3       	ldi	r25, 0x3C	; 60
    80c2:	9f 93       	push	r25
    80c4:	8f 93       	push	r24
    80c6:	81 e0       	ldi	r24, 0x01	; 1
    80c8:	8f 93       	push	r24
    80ca:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>

//------------------------------------------------------------------------------
// Send the message ending delimiter.
static void EndMsg(void)
{
	uartSendByte(0);
    80ce:	80 e0       	ldi	r24, 0x00	; 0
    80d0:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
    80d4:	4a c0       	rjmp	.+148    	; 0x816a <handle_load_motion+0xf0>
		EndMsg();
		return;
	}
	
	// Initialize our buffer.
	nextMotionBuf = GetNextMotionBuffer();
    80d6:	0e 94 8d 23 	call	0x471a	; 0x471a <GetNextMotionBuffer>
    80da:	90 93 87 0a 	sts	0x0A87, r25
    80de:	80 93 86 0a 	sts	0x0A86, r24
    80e2:	20 e0       	ldi	r18, 0x00	; 0
    80e4:	30 e0       	ldi	r19, 0x00	; 0
//	rprintf("Loading into buf %d\n", nextMotionBuf);
	for (int i=0; i < kMaxMotionBufSize; i++) nextMotionBuf[i] = 0xFF;
    80e6:	4f ef       	ldi	r20, 0xFF	; 255
    80e8:	fc 01       	movw	r30, r24
    80ea:	e2 0f       	add	r30, r18
    80ec:	f3 1f       	adc	r31, r19
    80ee:	40 83       	st	Z, r20
    80f0:	2f 5f       	subi	r18, 0xFF	; 255
    80f2:	3f 4f       	sbci	r19, 0xFF	; 255
    80f4:	52 e0       	ldi	r21, 0x02	; 2
    80f6:	2a 33       	cpi	r18, 0x3A	; 58
    80f8:	35 07       	cpc	r19, r21
    80fa:	b1 f7       	brne	.-20     	; 0x80e8 <handle_load_motion+0x6e>
	nextRxIndex = 0;
    80fc:	10 92 8b 0a 	sts	0x0A8B, r1
    8100:	10 92 8a 0a 	sts	0x0A8A, r1
	
	// Point the uart at our custom receive function.
	uartSetRxHandler( ReceiveIntoMotionBuf );	// receive directly into motionBuf
    8104:	8a eb       	ldi	r24, 0xBA	; 186
    8106:	9d e3       	ldi	r25, 0x3D	; 61
    8108:	0e 94 aa 21 	call	0x4354	; 0x4354 <uartSetRxHandler>
	
	// Let the host know we're ready.
	StartMsg('^');
    810c:	8e e5       	ldi	r24, 0x5E	; 94
    810e:	0e 94 0d 3e 	call	0x7c1a	; 0x7c1a <StartMsg>

//------------------------------------------------------------------------------
// Send the message ending delimiter.
static void EndMsg(void)
{
	uartSendByte(0);
    8112:	80 e0       	ldi	r24, 0x00	; 0
    8114:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
	
	// Now, we should be receiving data directly into motion buf via
	// the interrupt handler.  So all we have to do is sit here and
	// watch nextRxIndex, until we've gotten all the data we need, or
	// we appear to have timed out.
	startTicks = gTicks;
    8118:	c0 91 82 05 	lds	r28, 0x0582
    811c:	d0 91 83 05 	lds	r29, 0x0583
    8120:	2d c0       	rjmp	.+90     	; 0x817c <handle_load_motion+0x102>
	while (nextRxIndex < nextBytesExpected) {
		process_frames();			// ...but be sure to keep the robot moving
    8122:	0e 94 56 26 	call	0x4cac	; 0x4cac <process_frames>
		continue_motions();			// while we're waiting on the serial port!
    8126:	0e 94 85 3f 	call	0x7f0a	; 0x7f0a <continue_motions>
		if (gTicks - startTicks > 50) {
    812a:	80 91 82 05 	lds	r24, 0x0582
    812e:	90 91 83 05 	lds	r25, 0x0583
    8132:	8c 1b       	sub	r24, r28
    8134:	9d 0b       	sbc	r25, r29
    8136:	c3 97       	sbiw	r24, 0x33	; 51
    8138:	08 f1       	brcs	.+66     	; 0x817c <handle_load_motion+0x102>
			// Timed out
			uartSetRxHandler( NULL );
    813a:	80 e0       	ldi	r24, 0x00	; 0
    813c:	90 e0       	ldi	r25, 0x00	; 0
    813e:	0e 94 aa 21 	call	0x4354	; 0x4354 <uartSetRxHandler>
			rprintf("Timed out after receiving %d/%d bytes\n", nextRxIndex, nextBytesExpected );
    8142:	20 91 8a 0a 	lds	r18, 0x0A8A
    8146:	30 91 8b 0a 	lds	r19, 0x0A8B
    814a:	80 91 8c 0a 	lds	r24, 0x0A8C
    814e:	90 91 8d 0a 	lds	r25, 0x0A8D
    8152:	9f 93       	push	r25
    8154:	8f 93       	push	r24
    8156:	3f 93       	push	r19
    8158:	2f 93       	push	r18
    815a:	84 e6       	ldi	r24, 0x64	; 100
    815c:	9c e3       	ldi	r25, 0x3C	; 60
    815e:	9f 93       	push	r25
    8160:	8f 93       	push	r24
    8162:	81 e0       	ldi	r24, 0x01	; 1
    8164:	8f 93       	push	r24
    8166:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
    816a:	8d b7       	in	r24, 0x3d	; 61
    816c:	9e b7       	in	r25, 0x3e	; 62
    816e:	07 96       	adiw	r24, 0x07	; 7
    8170:	0f b6       	in	r0, 0x3f	; 63
    8172:	f8 94       	cli
    8174:	9e bf       	out	0x3e, r25	; 62
    8176:	0f be       	out	0x3f, r0	; 63
    8178:	8d bf       	out	0x3d, r24	; 61
    817a:	84 c0       	rjmp	.+264    	; 0x8284 <handle_load_motion+0x20a>
	// Now, we should be receiving data directly into motion buf via
	// the interrupt handler.  So all we have to do is sit here and
	// watch nextRxIndex, until we've gotten all the data we need, or
	// we appear to have timed out.
	startTicks = gTicks;
	while (nextRxIndex < nextBytesExpected) {
    817c:	20 91 8a 0a 	lds	r18, 0x0A8A
    8180:	30 91 8b 0a 	lds	r19, 0x0A8B
    8184:	80 91 8c 0a 	lds	r24, 0x0A8C
    8188:	90 91 8d 0a 	lds	r25, 0x0A8D
    818c:	28 17       	cp	r18, r24
    818e:	39 07       	cpc	r19, r25
    8190:	44 f2       	brlt	.-112    	; 0x8122 <handle_load_motion+0xa8>
			uartSetRxHandler( NULL );
			rprintf("Timed out after receiving %d/%d bytes\n", nextRxIndex, nextBytesExpected );
			return;
		}
	}
	profileTicks1 = gTicks - startTicks;
    8192:	80 91 82 05 	lds	r24, 0x0582
    8196:	90 91 83 05 	lds	r25, 0x0583
	
	// Reset the UART Rx handler, and acknowledge that we got the data.
	uartSetRxHandler( NULL );
    819a:	80 e0       	ldi	r24, 0x00	; 0
    819c:	90 e0       	ldi	r25, 0x00	; 0
    819e:	0e 94 aa 21 	call	0x4354	; 0x4354 <uartSetRxHandler>
//------------------------------------------------------------------------------
// Send an acknowledgement that we received and handled the last
// message of the given type.
static void SendAck(u08 msgType) 
{
	rprintf("\xBE\xAD%c%c%c", 'k', msgType, 0);
    81a2:	1f 92       	push	r1
    81a4:	1f 92       	push	r1
    81a6:	8e e5       	ldi	r24, 0x5E	; 94
    81a8:	90 e0       	ldi	r25, 0x00	; 0
    81aa:	9f 93       	push	r25
    81ac:	8f 93       	push	r24
    81ae:	8b e6       	ldi	r24, 0x6B	; 107
    81b0:	90 e0       	ldi	r25, 0x00	; 0
    81b2:	9f 93       	push	r25
    81b4:	8f 93       	push	r24
    81b6:	8b e9       	ldi	r24, 0x9B	; 155
    81b8:	9b e3       	ldi	r25, 0x3B	; 59
    81ba:	9f 93       	push	r25
    81bc:	8f 93       	push	r24
    81be:	01 e0       	ldi	r16, 0x01	; 1
    81c0:	0f 93       	push	r16
    81c2:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
	uartSetRxHandler( NULL );
	SendAck('^');
//	rprintf("Received %d bytes in %d ticks\n", nextRxIndex, profileTicks1 );

	// If no motion in progress, then start the new motion.
	if (!inMotion) {
    81c6:	8d b7       	in	r24, 0x3d	; 61
    81c8:	9e b7       	in	r25, 0x3e	; 62
    81ca:	09 96       	adiw	r24, 0x09	; 9
    81cc:	0f b6       	in	r0, 0x3f	; 63
    81ce:	f8 94       	cli
    81d0:	9e bf       	out	0x3e, r25	; 62
    81d2:	0f be       	out	0x3f, r0	; 63
    81d4:	8d bf       	out	0x3d, r24	; 61
    81d6:	80 91 85 0a 	lds	r24, 0x0A85
    81da:	88 23       	and	r24, r24
    81dc:	09 f0       	breq	.+2      	; 0x81e0 <handle_load_motion+0x166>
    81de:	48 c0       	rjmp	.+144    	; 0x8270 <handle_load_motion+0x1f6>
		curMotionBuf = nextMotionBuf;
    81e0:	80 91 86 0a 	lds	r24, 0x0A86
    81e4:	90 91 87 0a 	lds	r25, 0x0A87
    81e8:	90 93 89 0a 	sts	0x0A89, r25
    81ec:	80 93 88 0a 	sts	0x0A88, r24
		startTicks = gTicks;
    81f0:	20 91 82 05 	lds	r18, 0x0582
    81f4:	30 91 83 05 	lds	r19, 0x0583
		rprintf("Loading motion buf %d\n", curMotionBuf );
    81f8:	9f 93       	push	r25
    81fa:	8f 93       	push	r24
    81fc:	8d e4       	ldi	r24, 0x4D	; 77
    81fe:	9c e3       	ldi	r25, 0x3C	; 60
    8200:	9f 93       	push	r25
    8202:	8f 93       	push	r24
    8204:	0f 93       	push	r16
    8206:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
		LoadMotionFromBuffer( curMotionBuf );
    820a:	80 91 88 0a 	lds	r24, 0x0A88
    820e:	90 91 89 0a 	lds	r25, 0x0A89
    8212:	0e 94 76 27 	call	0x4eec	; 0x4eec <LoadMotionFromBuffer>

		StartMsg('b');		// Notify host that we're beginning a new scene.
    8216:	82 e6       	ldi	r24, 0x62	; 98
    8218:	0e 94 0d 3e 	call	0x7c1a	; 0x7c1a <StartMsg>
		AddMsgByte(0);		// scene number we're starting
    821c:	80 e0       	ldi	r24, 0x00	; 0
    821e:	0e 94 1a 3e 	call	0x7c34	; 0x7c34 <AddMsgByte>
		AddMsgByte(curMotionBuf[0]);		// number of scenes
    8222:	e0 91 88 0a 	lds	r30, 0x0A88
    8226:	f0 91 89 0a 	lds	r31, 0x0A89
    822a:	80 81       	ld	r24, Z
    822c:	0e 94 1a 3e 	call	0x7c34	; 0x7c34 <AddMsgByte>

//------------------------------------------------------------------------------
// Send the message ending delimiter.
static void EndMsg(void)
{
	uartSendByte(0);
    8230:	80 e0       	ldi	r24, 0x00	; 0
    8232:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
		StartMsg('b');		// Notify host that we're beginning a new scene.
		AddMsgByte(0);		// scene number we're starting
		AddMsgByte(curMotionBuf[0]);		// number of scenes
		EndMsg();
	
		profileTicks2 = gTicks - startTicks;
    8236:	80 91 82 05 	lds	r24, 0x0582
    823a:	90 91 83 05 	lds	r25, 0x0583
		inMotion = TRUE;
    823e:	8f ef       	ldi	r24, 0xFF	; 255
    8240:	80 93 85 0a 	sts	0x0A85, r24
		startTicks = gTicks;
    8244:	80 91 82 05 	lds	r24, 0x0582
    8248:	90 91 83 05 	lds	r25, 0x0583
		PlaySceneFromBuffer( curMotionBuf, 0 );
    824c:	60 e0       	ldi	r22, 0x00	; 0
    824e:	70 e0       	ldi	r23, 0x00	; 0
    8250:	80 91 88 0a 	lds	r24, 0x0A88
    8254:	90 91 89 0a 	lds	r25, 0x0A89
    8258:	0e 94 81 25 	call	0x4b02	; 0x4b02 <PlaySceneFromBuffer>
		profileTicks3 = gTicks - startTicks;
    825c:	80 91 82 05 	lds	r24, 0x0582
    8260:	90 91 83 05 	lds	r25, 0x0583
    8264:	0f 90       	pop	r0
    8266:	0f 90       	pop	r0
    8268:	0f 90       	pop	r0
    826a:	0f 90       	pop	r0
    826c:	0f 90       	pop	r0
    826e:	0a c0       	rjmp	.+20     	; 0x8284 <handle_load_motion+0x20a>
		
	//	rprintf("Loaded in %d ticks; started in %d\n", profileTicks2, profileTicks3);
	} else {
		rprintf("Not loading motion because we're already in motion");
    8270:	8a e1       	ldi	r24, 0x1A	; 26
    8272:	9c e3       	ldi	r25, 0x3C	; 60
    8274:	9f 93       	push	r25
    8276:	8f 93       	push	r24
    8278:	0f 93       	push	r16
    827a:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
    827e:	0f 90       	pop	r0
    8280:	0f 90       	pop	r0
    8282:	0f 90       	pop	r0
	}
}
    8284:	df 91       	pop	r29
    8286:	cf 91       	pop	r28
    8288:	1f 91       	pop	r17
    828a:	0f 91       	pop	r16
    828c:	08 95       	ret

0000828e <Do_Serial>:
// Do_Serial
//
//	Handle one command (if there is any) in serial slave mode.
//------------------------------------------------------------------------------
void Do_Serial(void)
{
    828e:	0f 93       	push	r16
    8290:	1f 93       	push	r17
    8292:	df 93       	push	r29
    8294:	cf 93       	push	r28
    8296:	00 d0       	rcall	.+0      	; 0x8298 <Do_Serial+0xa>
    8298:	cd b7       	in	r28, 0x3d	; 61
    829a:	de b7       	in	r29, 0x3e	; 62
//	BYTE	lbtmp;
//	WORD	ptmpA;
	
	u08 ch;
	if (!uartReceiveByte(&ch)) return;
    829c:	ce 01       	movw	r24, r28
    829e:	01 96       	adiw	r24, 0x01	; 1
    82a0:	0e 94 82 22 	call	0x4504	; 0x4504 <uartReceiveByte>
    82a4:	88 23       	and	r24, r24
    82a6:	09 f4       	brne	.+2      	; 0x82aa <Do_Serial+0x1c>
    82a8:	a3 c0       	rjmp	.+326    	; 0x83f0 <Do_Serial+0x162>

	static u08 lastCh = 0;	
	if (lastCh == 0xBE && ch == 0xAD) {
    82aa:	80 91 84 0a 	lds	r24, 0x0A84
    82ae:	8e 3b       	cpi	r24, 0xBE	; 190
    82b0:	09 f0       	breq	.+2      	; 0x82b4 <Do_Serial+0x26>
    82b2:	9b c0       	rjmp	.+310    	; 0x83ea <Do_Serial+0x15c>
    82b4:	89 81       	ldd	r24, Y+1	; 0x01
    82b6:	8d 3a       	cpi	r24, 0xAD	; 173
    82b8:	09 f0       	breq	.+2      	; 0x82bc <Do_Serial+0x2e>
    82ba:	97 c0       	rjmp	.+302    	; 0x83ea <Do_Serial+0x15c>
		// Got magic word that indicates the start of a message.
		// Assume the rest of the message is coming very quickly now.
		// First we get the type code...
		u08 msgType;
		while (!uartReceiveByte(&msgType)) ;  // To-do: add a timeout here
    82bc:	8e 01       	movw	r16, r28
    82be:	0e 5f       	subi	r16, 0xFE	; 254
    82c0:	1f 4f       	sbci	r17, 0xFF	; 255
    82c2:	c8 01       	movw	r24, r16
    82c4:	0e 94 82 22 	call	0x4504	; 0x4504 <uartReceiveByte>
    82c8:	88 23       	and	r24, r24
    82ca:	d9 f3       	breq	.-10     	; 0x82c2 <Do_Serial+0x34>

		// Now, dispatch to a handler based on the type
		// (except for any trivial ones we can handle here).
		switch (msgType) {
    82cc:	8a 81       	ldd	r24, Y+2	; 0x02
    82ce:	87 36       	cpi	r24, 0x67	; 103
    82d0:	89 f1       	breq	.+98     	; 0x8334 <Do_Serial+0xa6>
    82d2:	88 36       	cpi	r24, 0x68	; 104
    82d4:	48 f4       	brcc	.+18     	; 0x82e8 <Do_Serial+0x5a>
    82d6:	8e 32       	cpi	r24, 0x2E	; 46
    82d8:	09 f4       	brne	.+2      	; 0x82dc <Do_Serial+0x4e>
    82da:	4e c0       	rjmp	.+156    	; 0x8378 <Do_Serial+0xea>
    82dc:	8f 33       	cpi	r24, 0x3F	; 63
    82de:	91 f0       	breq	.+36     	; 0x8304 <Do_Serial+0x76>
    82e0:	8b 31       	cpi	r24, 0x1B	; 27
    82e2:	09 f0       	breq	.+2      	; 0x82e6 <Do_Serial+0x58>
    82e4:	76 c0       	rjmp	.+236    	; 0x83d2 <Do_Serial+0x144>
    82e6:	5c c0       	rjmp	.+184    	; 0x83a0 <Do_Serial+0x112>
    82e8:	80 37       	cpi	r24, 0x70	; 112
    82ea:	39 f1       	breq	.+78     	; 0x833a <Do_Serial+0xac>
    82ec:	81 37       	cpi	r24, 0x71	; 113
    82ee:	20 f4       	brcc	.+8      	; 0x82f8 <Do_Serial+0x6a>
    82f0:	8d 36       	cpi	r24, 0x6D	; 109
    82f2:	09 f0       	breq	.+2      	; 0x82f6 <Do_Serial+0x68>
    82f4:	6e c0       	rjmp	.+220    	; 0x83d2 <Do_Serial+0x144>
    82f6:	51 c0       	rjmp	.+162    	; 0x839a <Do_Serial+0x10c>
    82f8:	81 37       	cpi	r24, 0x71	; 113
    82fa:	c9 f0       	breq	.+50     	; 0x832e <Do_Serial+0xa0>
    82fc:	88 37       	cpi	r24, 0x78	; 120
    82fe:	09 f0       	breq	.+2      	; 0x8302 <Do_Serial+0x74>
    8300:	68 c0       	rjmp	.+208    	; 0x83d2 <Do_Serial+0x144>
    8302:	47 c0       	rjmp	.+142    	; 0x8392 <Do_Serial+0x104>
//------------------------------------------------------------------------------
// Send an acknowledgement that we received and handled the last
// message of the given type.
static void SendAck(u08 msgType) 
{
	rprintf("\xBE\xAD%c%c%c", 'k', msgType, 0);
    8304:	1f 92       	push	r1
    8306:	1f 92       	push	r1
    8308:	8f e3       	ldi	r24, 0x3F	; 63
    830a:	90 e0       	ldi	r25, 0x00	; 0
    830c:	9f 93       	push	r25
    830e:	8f 93       	push	r24
    8310:	8b e6       	ldi	r24, 0x6B	; 107
    8312:	90 e0       	ldi	r25, 0x00	; 0
    8314:	9f 93       	push	r25
    8316:	8f 93       	push	r24
    8318:	8b e9       	ldi	r24, 0x9B	; 155
    831a:	9b e3       	ldi	r25, 0x3B	; 59
    831c:	9f 93       	push	r25
    831e:	8f 93       	push	r24
    8320:	81 e0       	ldi	r24, 0x01	; 1
    8322:	8f 93       	push	r24
    8324:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
		// (except for any trivial ones we can handle here).
		switch (msgType) {

		case '?':		// Are-you-there?
			SendAck('?');
			SkipMsgData();
    8328:	0e 94 cc 3d 	call	0x7b98	; 0x7b98 <SkipMsgData>
    832c:	1c c0       	rjmp	.+56     	; 0x8366 <Do_Serial+0xd8>
			break;

		case 'q':		// Query status
			handle_get_status();
    832e:	0e 94 6b 3e 	call	0x7cd6	; 0x7cd6 <handle_get_status>
    8332:	5b c0       	rjmp	.+182    	; 0x83ea <Do_Serial+0x15c>
			break;

		case 'g':		// servo Go to position
			handle_goto_position();
    8334:	0e 94 cc 3e 	call	0x7d98	; 0x7d98 <handle_goto_position>
    8338:	58 c0       	rjmp	.+176    	; 0x83ea <Do_Serial+0x15c>
//------------------------------------------------------------------------------
// Send an acknowledgement that we received and handled the last
// message of the given type.
static void SendAck(u08 msgType) 
{
	rprintf("\xBE\xAD%c%c%c", 'k', msgType, 0);
    833a:	1f 92       	push	r1
    833c:	1f 92       	push	r1
    833e:	80 e7       	ldi	r24, 0x70	; 112
    8340:	90 e0       	ldi	r25, 0x00	; 0
    8342:	9f 93       	push	r25
    8344:	8f 93       	push	r24
    8346:	8b e6       	ldi	r24, 0x6B	; 107
    8348:	90 e0       	ldi	r25, 0x00	; 0
    834a:	9f 93       	push	r25
    834c:	8f 93       	push	r24
    834e:	8b e9       	ldi	r24, 0x9B	; 155
    8350:	9b e3       	ldi	r25, 0x3B	; 59
    8352:	9f 93       	push	r25
    8354:	8f 93       	push	r24
    8356:	81 e0       	ldi	r24, 0x01	; 1
    8358:	8f 93       	push	r24
    835a:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
			handle_goto_position();
			break;
		
		case 'p':		// assume the basic Pose
			SendAck('p');
			SkipMsgData();
    835e:	0e 94 cc 3d 	call	0x7b98	; 0x7b98 <SkipMsgData>
			BasicPose();
    8362:	0e 94 9c 26 	call	0x4d38	; 0x4d38 <BasicPose>
    8366:	8d b7       	in	r24, 0x3d	; 61
    8368:	9e b7       	in	r25, 0x3e	; 62
    836a:	09 96       	adiw	r24, 0x09	; 9
    836c:	0f b6       	in	r0, 0x3f	; 63
    836e:	f8 94       	cli
    8370:	9e bf       	out	0x3e, r25	; 62
    8372:	0f be       	out	0x3f, r0	; 63
    8374:	8d bf       	out	0x3d, r24	; 61
    8376:	39 c0       	rjmp	.+114    	; 0x83ea <Do_Serial+0x15c>
			break;
		
		case '.':		// read a byte from the wCK bus (just a debugging hack really)
			SkipMsgData();
    8378:	0e 94 cc 3d 	call	0x7b98	; 0x7b98 <SkipMsgData>
			StartMsg('.');
    837c:	8e e2       	ldi	r24, 0x2E	; 46
    837e:	0e 94 0d 3e 	call	0x7c1a	; 0x7c1a <StartMsg>
			AddMsgByte(sciRx0Ready());
    8382:	0e 94 a3 23 	call	0x4746	; 0x4746 <sciRx0Ready>
    8386:	0e 94 1a 3e 	call	0x7c34	; 0x7c34 <AddMsgByte>

//------------------------------------------------------------------------------
// Send the message ending delimiter.
static void EndMsg(void)
{
	uartSendByte(0);
    838a:	80 e0       	ldi	r24, 0x00	; 0
    838c:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
    8390:	2c c0       	rjmp	.+88     	; 0x83ea <Do_Serial+0x15c>
			AddMsgByte(sciRx0Ready());
			EndMsg();
			break;
		
		case 'x':		// send data directly to the wCK bus
			handle_direct_ctl(TRUE);
    8392:	8f ef       	ldi	r24, 0xFF	; 255
    8394:	0e 94 03 3f 	call	0x7e06	; 0x7e06 <handle_direct_ctl>
    8398:	28 c0       	rjmp	.+80     	; 0x83ea <Do_Serial+0x15c>
			break;

		case 'm':		// request to load Motion
			handle_load_motion();
    839a:	0e 94 3d 40 	call	0x807a	; 0x807a <handle_load_motion>
    839e:	25 c0       	rjmp	.+74     	; 0x83ea <Do_Serial+0x15c>
//------------------------------------------------------------------------------
// Send an acknowledgement that we received and handled the last
// message of the given type.
static void SendAck(u08 msgType) 
{
	rprintf("\xBE\xAD%c%c%c", 'k', msgType, 0);
    83a0:	1f 92       	push	r1
    83a2:	1f 92       	push	r1
    83a4:	8b e1       	ldi	r24, 0x1B	; 27
    83a6:	90 e0       	ldi	r25, 0x00	; 0
    83a8:	9f 93       	push	r25
    83aa:	8f 93       	push	r24
    83ac:	8b e6       	ldi	r24, 0x6B	; 107
    83ae:	90 e0       	ldi	r25, 0x00	; 0
    83b0:	9f 93       	push	r25
    83b2:	8f 93       	push	r24
    83b4:	8b e9       	ldi	r24, 0x9B	; 155
    83b6:	9b e3       	ldi	r25, 0x3B	; 59
    83b8:	9f 93       	push	r25
    83ba:	8f 93       	push	r24
    83bc:	81 e0       	ldi	r24, 0x01	; 1
    83be:	8f 93       	push	r24
    83c0:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
			handle_load_motion();
			break;
			
		case 27:		// Escape (exit serial slave mode)
			SendAck(27);
			SkipMsgData();
    83c4:	0e 94 cc 3d 	call	0x7b98	; 0x7b98 <SkipMsgData>
			gNextMode = kIdleMode;
    83c8:	10 92 80 0b 	sts	0x0B80, r1
    83cc:	10 92 7f 0b 	sts	0x0B7F, r1
    83d0:	ca cf       	rjmp	.-108    	; 0x8366 <Do_Serial+0xd8>

//------------------------------------------------------------------------------
// Send an error message.
static void SendErr(const char *errMsg) 
{
	StartMsg('E');
    83d2:	85 e4       	ldi	r24, 0x45	; 69
    83d4:	0e 94 0d 3e 	call	0x7c1a	; 0x7c1a <StartMsg>
	rprintfStr((char*)errMsg);
    83d8:	85 ea       	ldi	r24, 0xA5	; 165
    83da:	92 e0       	ldi	r25, 0x02	; 2
    83dc:	0e 94 f9 29 	call	0x53f2	; 0x53f2 <rprintfStr>

//------------------------------------------------------------------------------
// Send the message ending delimiter.
static void EndMsg(void)
{
	uartSendByte(0);
    83e0:	80 e0       	ldi	r24, 0x00	; 0
    83e2:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
			gNextMode = kIdleMode;
			break;

		default:
			SendErr("Unknown message type");
			SkipMsgData();
    83e6:	0e 94 cc 3d 	call	0x7b98	; 0x7b98 <SkipMsgData>
		}
	}
	lastCh = ch;
    83ea:	89 81       	ldd	r24, Y+1	; 0x01
    83ec:	80 93 84 0a 	sts	0x0A84, r24
} 
    83f0:	0f 90       	pop	r0
    83f2:	0f 90       	pop	r0
    83f4:	cf 91       	pop	r28
    83f6:	df 91       	pop	r29
    83f8:	1f 91       	pop	r17
    83fa:	0f 91       	pop	r16
    83fc:	08 95       	ret

000083fe <serialslave_mainloop>:


//------------------------------------------------------------------------------
void serialslave_mainloop()
{
    83fe:	88 e8       	ldi	r24, 0x88	; 136
    8400:	9b e3       	ldi	r25, 0x3B	; 59
    8402:	9f 93       	push	r25
    8404:	8f 93       	push	r24
    8406:	81 e0       	ldi	r24, 0x01	; 1
    8408:	8f 93       	push	r24
    840a:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
    840e:	0f 90       	pop	r0
    8410:	0f 90       	pop	r0
    8412:	0f 90       	pop	r0
    8414:	06 c0       	rjmp	.+12     	; 0x8422 <serialslave_mainloop+0x24>
	rprintf ("Serial Slave mode\n");
	while (kSerialSlaveMode == gNextMode) {
		Do_Serial();
    8416:	0e 94 47 41 	call	0x828e	; 0x828e <Do_Serial>

		process_frames();
    841a:	0e 94 56 26 	call	0x4cac	; 0x4cac <process_frames>
		continue_motions();
    841e:	0e 94 85 3f 	call	0x7f0a	; 0x7f0a <continue_motions>

//------------------------------------------------------------------------------
void serialslave_mainloop()
{
	rprintf ("Serial Slave mode\n");
	while (kSerialSlaveMode == gNextMode) {
    8422:	80 91 7f 0b 	lds	r24, 0x0B7F
    8426:	90 91 80 0b 	lds	r25, 0x0B80
    842a:	04 97       	sbiw	r24, 0x04	; 4
    842c:	a1 f3       	breq	.-24     	; 0x8416 <serialslave_mainloop+0x18>
		Do_Serial();

		process_frames();
		continue_motions();
	}
}
    842e:	08 95       	ret

00008430 <eeprom_read_byte>:

/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    8430:	9c 01       	movw	r18, r24
    do {} while (!eeprom_is_ready ());
    8432:	e1 99       	sbic	0x1c, 1	; 28
    8434:	fe cf       	rjmp	.-4      	; 0x8432 <eeprom_read_byte+0x2>
#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    8436:	3f bb       	out	0x1f, r19	; 31
    8438:	2e bb       	out	0x1e, r18	; 30
#endif
    EECR |= (1 << EERE);
    843a:	e0 9a       	sbi	0x1c, 0	; 28
    return EEDR;
    843c:	8d b3       	in	r24, 0x1d	; 29
}
    843e:	08 95       	ret

00008440 <eeprom_write_byte>:

/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    8440:	9c 01       	movw	r18, r24
    do {} while (!eeprom_is_ready ());
    8442:	e1 99       	sbic	0x1c, 1	; 28
    8444:	fe cf       	rjmp	.-4      	; 0x8442 <eeprom_write_byte+0x2>
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    8446:	3f bb       	out	0x1f, r19	; 31
    8448:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
    844a:	6d bb       	out	0x1d, r22	; 29

    __asm__ __volatile__ (
    844c:	0f b6       	in	r0, 0x3f	; 63
    844e:	f8 94       	cli
    8450:	e2 9a       	sbi	0x1c, 2	; 28
    8452:	e1 9a       	sbi	0x1c, 1	; 28
    8454:	0f be       	out	0x3f, r0	; 63
          [__sreg]  "i" (_SFR_IO_ADDR(SREG)),
          [__eemwe] "i" (EEMWE),
          [__eewe]  "i" (EEWE)
        : "r0"
    );
}
    8456:	08 95       	ret

00008458 <set_type>:
	char *text; // rest of line - unproceesed
};


void set_type(uint8_t c)
{
    8458:	28 2f       	mov	r18, r24
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    845a:	e1 99       	sbic	0x1c, 1	; 28
    845c:	fe cf       	rjmp	.-4      	; 0x845a <set_type+0x2>
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    845e:	80 e4       	ldi	r24, 0x40	; 64
    8460:	90 e0       	ldi	r25, 0x00	; 0
    8462:	9f bb       	out	0x1f, r25	; 31
    8464:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    8466:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
    8468:	0f b6       	in	r0, 0x3f	; 63
    846a:	f8 94       	cli
    846c:	e2 9a       	sbi	0x1c, 2	; 28
    846e:	e1 9a       	sbi	0x1c, 1	; 28
    8470:	0f be       	out	0x3f, r0	; 63
	eeprom_write_byte(HUNO_TYPE, c);	
}
    8472:	08 95       	ret

00008474 <get_type>:

uint8_t get_type()
{
    8474:	e1 99       	sbic	0x1c, 1	; 28
    8476:	fe cf       	rjmp	.-4      	; 0x8474 <get_type>
{
    do {} while (!eeprom_is_ready ());
#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    8478:	80 e4       	ldi	r24, 0x40	; 64
    847a:	90 e0       	ldi	r25, 0x00	; 0
    847c:	9f bb       	out	0x1f, r25	; 31
    847e:	8e bb       	out	0x1e, r24	; 30
#endif
    EECR |= (1 << EERE);
    8480:	e0 9a       	sbi	0x1c, 0	; 28
    return EEDR;
    8482:	8d b3       	in	r24, 0x1d	; 29
	return eeprom_read_byte(HUNO_TYPE);
}
    8484:	08 95       	ret

00008486 <get_noservos>:
		wckFlush(); // flush the buffer
}


uint8_t get_noservos()
{
    8486:	e1 99       	sbic	0x1c, 1	; 28
    8488:	fe cf       	rjmp	.-4      	; 0x8486 <get_noservos>
{
    do {} while (!eeprom_is_ready ());
#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    848a:	80 e4       	ldi	r24, 0x40	; 64
    848c:	90 e0       	ldi	r25, 0x00	; 0
    848e:	9f bb       	out	0x1f, r25	; 31
    8490:	8e bb       	out	0x1e, r24	; 30
#endif
    EECR |= (1 << EERE);
    8492:	e0 9a       	sbi	0x1c, 0	; 28
    return EEDR;
    8494:	8d b3       	in	r24, 0x1d	; 29
	int noservos=0;
	switch (get_type())
    8496:	81 30       	cpi	r24, 0x01	; 1
    8498:	59 f0       	breq	.+22     	; 0x84b0 <get_noservos+0x2a>
    849a:	81 30       	cpi	r24, 0x01	; 1
    849c:	18 f0       	brcs	.+6      	; 0x84a4 <get_noservos+0x1e>
    849e:	82 30       	cpi	r24, 0x02	; 2
    84a0:	21 f4       	brne	.+8      	; 0x84aa <get_noservos+0x24>
    84a2:	09 c0       	rjmp	.+18     	; 0x84b6 <get_noservos+0x30>
    84a4:	80 e1       	ldi	r24, 0x10	; 16
    84a6:	90 e0       	ldi	r25, 0x00	; 0
    84a8:	08 95       	ret
    84aa:	80 e0       	ldi	r24, 0x00	; 0
    84ac:	90 e0       	ldi	r25, 0x00	; 0
    84ae:	08 95       	ret
    84b0:	83 e1       	ldi	r24, 0x13	; 19
    84b2:	90 e0       	ldi	r25, 0x00	; 0
    84b4:	08 95       	ret
	case HUNO_BASIC: 
	    noservos=16;
		break;
	case HUNO_ADVANCED: 
	    noservos=19;
		break;
    84b6:	82 e1       	ldi	r24, 0x12	; 18
    84b8:	90 e0       	ldi	r25, 0x00	; 0
	case HUNO_OTHER: 
	    noservos=18;
		break;	
	}
	return noservos;
}
    84ba:	08 95       	ret

000084bc <getNext>:

int errno;

//next no space char
char getNext(char **p_line) 
{
    84bc:	dc 01       	movw	r26, r24
	char c1=**p_line;
    84be:	ed 91       	ld	r30, X+
    84c0:	fc 91       	ld	r31, X
    84c2:	11 97       	sbiw	r26, 0x01	; 1
    84c4:	e0 81       	ld	r30, Z
    84c6:	09 c0       	rjmp	.+18     	; 0x84da <getNext+0x1e>
	
	while (c1 == ' ' )
	{
		(*p_line)++;
    84c8:	ed 91       	ld	r30, X+
    84ca:	fc 91       	ld	r31, X
    84cc:	11 97       	sbiw	r26, 0x01	; 1
    84ce:	31 96       	adiw	r30, 0x01	; 1
    84d0:	11 96       	adiw	r26, 0x01	; 1
    84d2:	fc 93       	st	X, r31
    84d4:	ee 93       	st	-X, r30
    84d6:	31 97       	sbiw	r30, 0x01	; 1
		c1=**p_line;
    84d8:	e1 81       	ldd	r30, Z+1	; 0x01
//next no space char
char getNext(char **p_line) 
{
	char c1=**p_line;
	
	while (c1 == ' ' )
    84da:	e0 32       	cpi	r30, 0x20	; 32
    84dc:	a9 f3       	breq	.-22     	; 0x84c8 <getNext+0xc>
	{
		(*p_line)++;
		c1=**p_line;
	}
	if (c1 != '\0') (*p_line)++;
    84de:	ee 23       	and	r30, r30
    84e0:	31 f0       	breq	.+12     	; 0x84ee <getNext+0x32>
    84e2:	8d 91       	ld	r24, X+
    84e4:	9c 91       	ld	r25, X
    84e6:	11 97       	sbiw	r26, 0x01	; 1
    84e8:	01 96       	adiw	r24, 0x01	; 1
    84ea:	8d 93       	st	X+, r24
    84ec:	9c 93       	st	X, r25

	return c1;
}
    84ee:	8e 2f       	mov	r24, r30
    84f0:	08 95       	ret

000084f2 <getVar>:

// Read variable - 
// Simple def - must be A-Z
// More complex later
int getVar(char **p_line) 
{
    84f2:	dc 01       	movw	r26, r24
int errno;

//next no space char
char getNext(char **p_line) 
{
	char c1=**p_line;
    84f4:	ed 91       	ld	r30, X+
    84f6:	fc 91       	ld	r31, X
    84f8:	11 97       	sbiw	r26, 0x01	; 1
    84fa:	e0 81       	ld	r30, Z
    84fc:	09 c0       	rjmp	.+18     	; 0x8510 <getVar+0x1e>
	
	while (c1 == ' ' )
	{
		(*p_line)++;
    84fe:	ed 91       	ld	r30, X+
    8500:	fc 91       	ld	r31, X
    8502:	11 97       	sbiw	r26, 0x01	; 1
    8504:	31 96       	adiw	r30, 0x01	; 1
    8506:	11 96       	adiw	r26, 0x01	; 1
    8508:	fc 93       	st	X, r31
    850a:	ee 93       	st	-X, r30
    850c:	31 97       	sbiw	r30, 0x01	; 1
		c1=**p_line;
    850e:	e1 81       	ldd	r30, Z+1	; 0x01
//next no space char
char getNext(char **p_line) 
{
	char c1=**p_line;
	
	while (c1 == ' ' )
    8510:	e0 32       	cpi	r30, 0x20	; 32
    8512:	a9 f3       	breq	.-22     	; 0x84fe <getVar+0xc>
	{
		(*p_line)++;
		c1=**p_line;
	}
	if (c1 != '\0') (*p_line)++;
    8514:	ee 23       	and	r30, r30
    8516:	31 f0       	breq	.+12     	; 0x8524 <getVar+0x32>
    8518:	8d 91       	ld	r24, X+
    851a:	9c 91       	ld	r25, X
    851c:	11 97       	sbiw	r26, 0x01	; 1
    851e:	01 96       	adiw	r24, 0x01	; 1
    8520:	8d 93       	st	X+, r24
    8522:	9c 93       	st	X, r25
// More complex later
int getVar(char **p_line) 
{
	char c1=getNext(p_line);
	
	if (c1>='A' && c1<= 'Z' )
    8524:	8e 2f       	mov	r24, r30
    8526:	81 54       	subi	r24, 0x41	; 65
    8528:	8a 31       	cpi	r24, 0x1A	; 26
    852a:	18 f0       	brcs	.+6      	; 0x8532 <getVar+0x40>
    852c:	ef ef       	ldi	r30, 0xFF	; 255
    852e:	ff ef       	ldi	r31, 0xFF	; 255
    8530:	03 c0       	rjmp	.+6      	; 0x8538 <getVar+0x46>
	{
		return c1-'A';
    8532:	f0 e0       	ldi	r31, 0x00	; 0
    8534:	e1 54       	subi	r30, 0x41	; 65
    8536:	f0 40       	sbci	r31, 0x00	; 0
	}
	else
	return -1;
}
    8538:	cf 01       	movw	r24, r30
    853a:	08 95       	ret

0000853c <getNum>:

// Read number  - 
// Simple def - must be 0-9
// More complex later (%/& etc)
int getNum(char **p_line) 
{
    853c:	dc 01       	movw	r26, r24
int errno;

//next no space char
char getNext(char **p_line) 
{
	char c1=**p_line;
    853e:	ed 91       	ld	r30, X+
    8540:	fc 91       	ld	r31, X
    8542:	11 97       	sbiw	r26, 0x01	; 1
    8544:	40 81       	ld	r20, Z
    8546:	09 c0       	rjmp	.+18     	; 0x855a <getNum+0x1e>
	
	while (c1 == ' ' )
	{
		(*p_line)++;
    8548:	ed 91       	ld	r30, X+
    854a:	fc 91       	ld	r31, X
    854c:	11 97       	sbiw	r26, 0x01	; 1
    854e:	31 96       	adiw	r30, 0x01	; 1
    8550:	11 96       	adiw	r26, 0x01	; 1
    8552:	fc 93       	st	X, r31
    8554:	ee 93       	st	-X, r30
    8556:	31 97       	sbiw	r30, 0x01	; 1
		c1=**p_line;
    8558:	41 81       	ldd	r20, Z+1	; 0x01
//next no space char
char getNext(char **p_line) 
{
	char c1=**p_line;
	
	while (c1 == ' ' )
    855a:	40 32       	cpi	r20, 0x20	; 32
    855c:	a9 f3       	breq	.-22     	; 0x8548 <getNum+0xc>
	{
		(*p_line)++;
		c1=**p_line;
	}
	if (c1 != '\0') (*p_line)++;
    855e:	44 23       	and	r20, r20
    8560:	39 f0       	breq	.+14     	; 0x8570 <getNum+0x34>
    8562:	8d 91       	ld	r24, X+
    8564:	9c 91       	ld	r25, X
    8566:	11 97       	sbiw	r26, 0x01	; 1
    8568:	01 96       	adiw	r24, 0x01	; 1
    856a:	11 96       	adiw	r26, 0x01	; 1
    856c:	9c 93       	st	X, r25
    856e:	8e 93       	st	-X, r24
    8570:	20 e0       	ldi	r18, 0x00	; 0
    8572:	30 e0       	ldi	r19, 0x00	; 0
    8574:	12 c0       	rjmp	.+36     	; 0x859a <getNum+0x5e>
	int num=0;
	char c1=getNext(p_line);
	
	while (c1>='0' && c1<= '9' )
	{
		num = num*10 + c1-'0';
    8576:	c9 01       	movw	r24, r18
    8578:	63 e0       	ldi	r22, 0x03	; 3
    857a:	88 0f       	add	r24, r24
    857c:	99 1f       	adc	r25, r25
    857e:	6a 95       	dec	r22
    8580:	e1 f7       	brne	.-8      	; 0x857a <getNum+0x3e>
    8582:	22 0f       	add	r18, r18
    8584:	33 1f       	adc	r19, r19
    8586:	28 0f       	add	r18, r24
    8588:	39 1f       	adc	r19, r25
    858a:	24 0f       	add	r18, r20
    858c:	31 1d       	adc	r19, r1
    858e:	20 53       	subi	r18, 0x30	; 48
    8590:	30 40       	sbci	r19, 0x00	; 0
		c1=**p_line;
    8592:	41 91       	ld	r20, Z+
		(*p_line)++;	
    8594:	11 96       	adiw	r26, 0x01	; 1
    8596:	fc 93       	st	X, r31
    8598:	ee 93       	st	-X, r30
int getNum(char **p_line) 
{
	int num=0;
	char c1=getNext(p_line);
	
	while (c1>='0' && c1<= '9' )
    859a:	84 2f       	mov	r24, r20
    859c:	80 53       	subi	r24, 0x30	; 48
    859e:	ed 91       	ld	r30, X+
    85a0:	fc 91       	ld	r31, X
    85a2:	11 97       	sbiw	r26, 0x01	; 1
    85a4:	8a 30       	cpi	r24, 0x0A	; 10
    85a6:	38 f3       	brcs	.-50     	; 0x8576 <getNum+0x3a>
	{
		num = num*10 + c1-'0';
		c1=**p_line;
		(*p_line)++;	
	}
	(*p_line)--;	
    85a8:	31 97       	sbiw	r30, 0x01	; 1
    85aa:	ed 93       	st	X+, r30
    85ac:	fc 93       	st	X, r31
	return num;
}
    85ae:	c9 01       	movw	r24, r18
    85b0:	08 95       	ret

000085b2 <getToken>:
//i points to next char after toek
//returns token ID or -1 if not found
//

int getToken(char *str, char *tok)
{
    85b2:	fc 01       	movw	r30, r24
    85b4:	db 01       	movw	r26, r22
    85b6:	20 e0       	ldi	r18, 0x00	; 0
    85b8:	30 e0       	ldi	r19, 0x00	; 0
    85ba:	08 c0       	rjmp	.+16     	; 0x85cc <getToken+0x1a>
	int n=0;
	char c;
	while ((c=*str))
	{
		str++;
		if (!(c>= 'A' && c <='Z') )  //must be alpha
    85bc:	89 2f       	mov	r24, r25
    85be:	81 54       	subi	r24, 0x41	; 65
    85c0:	8a 31       	cpi	r24, 0x1A	; 26
    85c2:	38 f4       	brcc	.+14     	; 0x85d2 <getToken+0x20>
{
	int n=0;
	char c;
	while ((c=*str))
	{
		str++;
    85c4:	31 96       	adiw	r30, 0x01	; 1
		if (!(c>= 'A' && c <='Z') )  //must be alpha
			break;
		*tok++=c; //copy in dest buff
    85c6:	9d 93       	st	X+, r25
		n++;
    85c8:	2f 5f       	subi	r18, 0xFF	; 255
    85ca:	3f 4f       	sbci	r19, 0xFF	; 255

int getToken(char *str, char *tok)
{
	int n=0;
	char c;
	while ((c=*str))
    85cc:	90 81       	ld	r25, Z
    85ce:	99 23       	and	r25, r25
    85d0:	a9 f7       	brne	.-22     	; 0x85bc <getToken+0xa>
		if (!(c>= 'A' && c <='Z') )  //must be alpha
			break;
		*tok++=c; //copy in dest buff
		n++;
	}	
	*tok='\0';
    85d2:	1c 92       	st	X, r1
	return n;
}
    85d4:	c9 01       	movw	r24, r18
    85d6:	08 95       	ret

000085d8 <get_bit>:
*************************************************************************************************************/

int variable[26]; // only A-Z at moment

int get_bit(int pn, int bn)
{
    85d8:	83 30       	cpi	r24, 0x03	; 3
    85da:	91 05       	cpc	r25, r1
    85dc:	e9 f0       	breq	.+58     	; 0x8618 <get_bit+0x40>
    85de:	84 30       	cpi	r24, 0x04	; 4
    85e0:	91 05       	cpc	r25, r1
    85e2:	4c f4       	brge	.+18     	; 0x85f6 <get_bit+0x1e>
    85e4:	81 30       	cpi	r24, 0x01	; 1
    85e6:	91 05       	cpc	r25, r1
    85e8:	99 f0       	breq	.+38     	; 0x8610 <get_bit+0x38>
    85ea:	82 30       	cpi	r24, 0x02	; 2
    85ec:	91 05       	cpc	r25, r1
    85ee:	94 f4       	brge	.+36     	; 0x8614 <get_bit+0x3c>
    85f0:	89 2b       	or	r24, r25
    85f2:	61 f0       	breq	.+24     	; 0x860c <get_bit+0x34>
    85f4:	08 c0       	rjmp	.+16     	; 0x8606 <get_bit+0x2e>
    85f6:	85 30       	cpi	r24, 0x05	; 5
    85f8:	91 05       	cpc	r25, r1
    85fa:	91 f0       	breq	.+36     	; 0x8620 <get_bit+0x48>
    85fc:	85 30       	cpi	r24, 0x05	; 5
    85fe:	91 05       	cpc	r25, r1
    8600:	6c f0       	brlt	.+26     	; 0x861c <get_bit+0x44>
    8602:	06 97       	sbiw	r24, 0x06	; 6
    8604:	79 f0       	breq	.+30     	; 0x8624 <get_bit+0x4c>
    8606:	20 e0       	ldi	r18, 0x00	; 0
    8608:	30 e0       	ldi	r19, 0x00	; 0
    860a:	1c c0       	rjmp	.+56     	; 0x8644 <get_bit+0x6c>
	int n;
	switch(pn)
	{
	case 0:
		n = PINA;
    860c:	89 b3       	in	r24, 0x19	; 25
    860e:	0c c0       	rjmp	.+24     	; 0x8628 <get_bit+0x50>
		break;
	case 1:
		n = PINB;
    8610:	86 b3       	in	r24, 0x16	; 22
    8612:	0a c0       	rjmp	.+20     	; 0x8628 <get_bit+0x50>
		break;
	case 2:
		n = PINC;
    8614:	83 b3       	in	r24, 0x13	; 19
    8616:	08 c0       	rjmp	.+16     	; 0x8628 <get_bit+0x50>
		break;
	case 3:
		n = PIND;
    8618:	80 b3       	in	r24, 0x10	; 16
    861a:	06 c0       	rjmp	.+12     	; 0x8628 <get_bit+0x50>
		break;
	case 4:
		n = PINE;
    861c:	81 b1       	in	r24, 0x01	; 1
    861e:	04 c0       	rjmp	.+8      	; 0x8628 <get_bit+0x50>
		break;
	case 5:
		n = PINF;
    8620:	80 b1       	in	r24, 0x00	; 0
    8622:	02 c0       	rjmp	.+4      	; 0x8628 <get_bit+0x50>
		break;
	case 6:
		n = PING;
    8624:	80 91 63 00 	lds	r24, 0x0063
    8628:	28 2f       	mov	r18, r24
    862a:	30 e0       	ldi	r19, 0x00	; 0
		break;
	default:
		return 0;
	}
	
	if (bn<8)
    862c:	68 30       	cpi	r22, 0x08	; 8
    862e:	71 05       	cpc	r23, r1
    8630:	4c f4       	brge	.+18     	; 0x8644 <get_bit+0x6c>
	{
		// mask result with bit
		int mask = 1<< bn;
		n &= mask;
    8632:	81 e0       	ldi	r24, 0x01	; 1
    8634:	90 e0       	ldi	r25, 0x00	; 0
    8636:	02 c0       	rjmp	.+4      	; 0x863c <get_bit+0x64>
    8638:	88 0f       	add	r24, r24
    863a:	99 1f       	adc	r25, r25
    863c:	6a 95       	dec	r22
    863e:	e2 f7       	brpl	.-8      	; 0x8638 <get_bit+0x60>
    8640:	28 23       	and	r18, r24
    8642:	39 23       	and	r19, r25
	}
	return n;
}
    8644:	c9 01       	movw	r24, r18
    8646:	08 95       	ret

00008648 <math>:
}

enum {STRING, NUMBER, ERROR, CONDITION } ;

int math(int n1, int n2, char op)
{
    8648:	9c 01       	movw	r18, r24
	switch (op) {
    864a:	4d 33       	cpi	r20, 0x3D	; 61
    864c:	09 f4       	brne	.+2      	; 0x8650 <math+0x8>
    864e:	56 c0       	rjmp	.+172    	; 0x86fc <math+0xb4>
    8650:	4e 33       	cpi	r20, 0x3E	; 62
    8652:	90 f4       	brcc	.+36     	; 0x8678 <math+0x30>
    8654:	4b 32       	cpi	r20, 0x2B	; 43
    8656:	e9 f0       	breq	.+58     	; 0x8692 <math+0x4a>
    8658:	4c 32       	cpi	r20, 0x2C	; 44
    865a:	30 f4       	brcc	.+12     	; 0x8668 <math+0x20>
    865c:	45 32       	cpi	r20, 0x25	; 37
    865e:	59 f1       	breq	.+86     	; 0x86b6 <math+0x6e>
    8660:	4a 32       	cpi	r20, 0x2A	; 42
    8662:	09 f0       	breq	.+2      	; 0x8666 <math+0x1e>
    8664:	53 c0       	rjmp	.+166    	; 0x870c <math+0xc4>
    8666:	1b c0       	rjmp	.+54     	; 0x869e <math+0x56>
    8668:	4f 32       	cpi	r20, 0x2F	; 47
    866a:	09 f1       	breq	.+66     	; 0x86ae <math+0x66>
    866c:	4c 33       	cpi	r20, 0x3C	; 60
    866e:	71 f1       	breq	.+92     	; 0x86cc <math+0x84>
    8670:	4d 32       	cpi	r20, 0x2D	; 45
    8672:	09 f0       	breq	.+2      	; 0x8676 <math+0x2e>
    8674:	4b c0       	rjmp	.+150    	; 0x870c <math+0xc4>
    8676:	10 c0       	rjmp	.+32     	; 0x8698 <math+0x50>
    8678:	4c 36       	cpi	r20, 0x6C	; 108
    867a:	71 f1       	breq	.+92     	; 0x86d8 <math+0x90>
    867c:	4d 36       	cpi	r20, 0x6D	; 109
    867e:	30 f4       	brcc	.+12     	; 0x868c <math+0x44>
    8680:	4e 33       	cpi	r20, 0x3E	; 62
    8682:	f1 f0       	breq	.+60     	; 0x86c0 <math+0x78>
    8684:	47 36       	cpi	r20, 0x67	; 103
    8686:	09 f0       	breq	.+2      	; 0x868a <math+0x42>
    8688:	41 c0       	rjmp	.+130    	; 0x870c <math+0xc4>
    868a:	2c c0       	rjmp	.+88     	; 0x86e4 <math+0x9c>
    868c:	4e 36       	cpi	r20, 0x6E	; 110
    868e:	f1 f5       	brne	.+124    	; 0x870c <math+0xc4>
    8690:	2f c0       	rjmp	.+94     	; 0x86f0 <math+0xa8>
	case '+': 
		n1=n1+n2; break;
    8692:	26 0f       	add	r18, r22
    8694:	37 1f       	adc	r19, r23
    8696:	3a c0       	rjmp	.+116    	; 0x870c <math+0xc4>
	case '-':
		n1=n1-n2; break;
    8698:	26 1b       	sub	r18, r22
    869a:	37 0b       	sbc	r19, r23
    869c:	37 c0       	rjmp	.+110    	; 0x870c <math+0xc4>
	case '*':
		n1=n2*n1; break;
    869e:	86 9f       	mul	r24, r22
    86a0:	90 01       	movw	r18, r0
    86a2:	87 9f       	mul	r24, r23
    86a4:	30 0d       	add	r19, r0
    86a6:	96 9f       	mul	r25, r22
    86a8:	30 0d       	add	r19, r0
    86aa:	11 24       	eor	r1, r1
    86ac:	2f c0       	rjmp	.+94     	; 0x870c <math+0xc4>
	case '/':
		n1=n1/n2; break;
    86ae:	0e 94 31 6e 	call	0xdc62	; 0xdc62 <__divmodhi4>
    86b2:	9b 01       	movw	r18, r22
    86b4:	03 c0       	rjmp	.+6      	; 0x86bc <math+0x74>
	case '%':
		n1=n1%n2; break;
    86b6:	0e 94 31 6e 	call	0xdc62	; 0xdc62 <__divmodhi4>
    86ba:	9c 01       	movw	r18, r24
    86bc:	c9 01       	movw	r24, r18
    86be:	25 c0       	rjmp	.+74     	; 0x870a <math+0xc2>
	case '>':
		n1=(n1>n2)?1:0; break;		
    86c0:	80 e0       	ldi	r24, 0x00	; 0
    86c2:	90 e0       	ldi	r25, 0x00	; 0
    86c4:	62 17       	cp	r22, r18
    86c6:	73 07       	cpc	r23, r19
    86c8:	04 f5       	brge	.+64     	; 0x870a <math+0xc2>
    86ca:	1d c0       	rjmp	.+58     	; 0x8706 <math+0xbe>
	case '<':
		n1=(n1<n2)?1:0; break;	
    86cc:	80 e0       	ldi	r24, 0x00	; 0
    86ce:	90 e0       	ldi	r25, 0x00	; 0
    86d0:	26 17       	cp	r18, r22
    86d2:	37 07       	cpc	r19, r23
    86d4:	d4 f4       	brge	.+52     	; 0x870a <math+0xc2>
    86d6:	17 c0       	rjmp	.+46     	; 0x8706 <math+0xbe>
	case 'l':
		n1=(n1<=n2)?1:0; break;	
    86d8:	80 e0       	ldi	r24, 0x00	; 0
    86da:	90 e0       	ldi	r25, 0x00	; 0
    86dc:	62 17       	cp	r22, r18
    86de:	73 07       	cpc	r23, r19
    86e0:	a4 f0       	brlt	.+40     	; 0x870a <math+0xc2>
    86e2:	11 c0       	rjmp	.+34     	; 0x8706 <math+0xbe>
	case 'g':
		n1=(n1>=n2)?1:0; break;	
    86e4:	80 e0       	ldi	r24, 0x00	; 0
    86e6:	90 e0       	ldi	r25, 0x00	; 0
    86e8:	26 17       	cp	r18, r22
    86ea:	37 07       	cpc	r19, r23
    86ec:	74 f0       	brlt	.+28     	; 0x870a <math+0xc2>
    86ee:	0b c0       	rjmp	.+22     	; 0x8706 <math+0xbe>
	case 'n':
		n1=(n1!=n2)?1:0; break;	
    86f0:	80 e0       	ldi	r24, 0x00	; 0
    86f2:	90 e0       	ldi	r25, 0x00	; 0
    86f4:	26 17       	cp	r18, r22
    86f6:	37 07       	cpc	r19, r23
    86f8:	31 f4       	brne	.+12     	; 0x8706 <math+0xbe>
    86fa:	07 c0       	rjmp	.+14     	; 0x870a <math+0xc2>
	case '=':
		n1=(n2==n1)?1:0; break;		
    86fc:	80 e0       	ldi	r24, 0x00	; 0
    86fe:	90 e0       	ldi	r25, 0x00	; 0
    8700:	62 17       	cp	r22, r18
    8702:	73 07       	cpc	r23, r19
    8704:	11 f4       	brne	.+4      	; 0x870a <math+0xc2>
    8706:	81 e0       	ldi	r24, 0x01	; 1
    8708:	90 e0       	ldi	r25, 0x00	; 0
    870a:	9c 01       	movw	r18, r24
	}
	return n1;
}
    870c:	c9 01       	movw	r24, r18
    870e:	08 95       	ret

00008710 <str_expr>:

int str_expr(char *str)
{
    8710:	9c 01       	movw	r18, r24
    8712:	fc 01       	movw	r30, r24
    8714:	01 c0       	rjmp	.+2      	; 0x8718 <str_expr+0x8>
	char *p=str;
	while (*str != '"') str++;
    8716:	31 96       	adiw	r30, 0x01	; 1
    8718:	80 81       	ld	r24, Z
    871a:	82 32       	cpi	r24, 0x22	; 34
    871c:	e1 f7       	brne	.-8      	; 0x8716 <str_expr+0x6>
    871e:	cf 01       	movw	r24, r30
    8720:	82 1b       	sub	r24, r18
    8722:	93 0b       	sbc	r25, r19
	return str-p;
}
    8724:	08 95       	ret

00008726 <dump_firmware>:
		rprintfStr ("\r\n");	
	}
}

void dump_firmware()
{
    8726:	2f 92       	push	r2
    8728:	3f 92       	push	r3
    872a:	4f 92       	push	r4
    872c:	5f 92       	push	r5
    872e:	6f 92       	push	r6
    8730:	7f 92       	push	r7
    8732:	8f 92       	push	r8
    8734:	9f 92       	push	r9
    8736:	af 92       	push	r10
    8738:	bf 92       	push	r11
    873a:	cf 92       	push	r12
    873c:	df 92       	push	r13
    873e:	ef 92       	push	r14
    8740:	ff 92       	push	r15
    8742:	0f 93       	push	r16
    8744:	1f 93       	push	r17
    8746:	df 93       	push	r29
    8748:	cf 93       	push	r28
    874a:	cd b7       	in	r28, 0x3d	; 61
    874c:	de b7       	in	r29, 0x3e	; 62
    874e:	29 97       	sbiw	r28, 0x09	; 9
    8750:	0f b6       	in	r0, 0x3f	; 63
    8752:	f8 94       	cli
    8754:	de bf       	out	0x3e, r29	; 62
    8756:	0f be       	out	0x3f, r0	; 63
    8758:	cd bf       	out	0x3d, r28	; 61
    875a:	aa 24       	eor	r10, r10
    875c:	bb 24       	eor	r11, r11
	
	for (i=0; i<64; i+=8) 	
	{
		int j;
		char asciis[9];
		rprintf ("%x ", i);
    875e:	a8 ef       	ldi	r26, 0xF8	; 248
    8760:	2a 2e       	mov	r2, r26
    8762:	ac e3       	ldi	r26, 0x3C	; 60
    8764:	3a 2e       	mov	r3, r26
    8766:	ee 24       	eor	r14, r14
    8768:	e3 94       	inc	r14
    876a:	4e 01       	movw	r8, r28
    876c:	08 94       	sec
    876e:	81 1c       	adc	r8, r1
    8770:	91 1c       	adc	r9, r1
		for (j=0; j<8;  j++)
		{
			uint8_t data = eeprom_read_byte((uint8_t*)(FIRMWARE+i+j));
			rprintf ("%x ", data);
    8772:	f4 ef       	ldi	r31, 0xF4	; 244
    8774:	4f 2e       	mov	r4, r31
    8776:	fc e3       	ldi	r31, 0x3C	; 60
    8778:	5f 2e       	mov	r5, r31
	for (i=0; i<64; i+=8) 	
	{
		int j;
		char asciis[9];
		rprintf ("%x ", i);
		for (j=0; j<8;  j++)
    877a:	e9 e0       	ldi	r30, 0x09	; 9
    877c:	6e 2e       	mov	r6, r30
    877e:	71 2c       	mov	r7, r1
    8780:	6c 0e       	add	r6, r28
    8782:	7d 1e       	adc	r7, r29
	
	for (i=0; i<64; i+=8) 	
	{
		int j;
		char asciis[9];
		rprintf ("%x ", i);
    8784:	bf 92       	push	r11
    8786:	af 92       	push	r10
    8788:	3f 92       	push	r3
    878a:	2f 92       	push	r2
    878c:	ef 92       	push	r14
    878e:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
    8792:	84 01       	movw	r16, r8
    8794:	70 e0       	ldi	r23, 0x00	; 0
    8796:	c7 2e       	mov	r12, r23
    8798:	70 e0       	ldi	r23, 0x00	; 0
    879a:	d7 2e       	mov	r13, r23
    879c:	ca 0c       	add	r12, r10
    879e:	db 1c       	adc	r13, r11
    87a0:	0f 90       	pop	r0
    87a2:	0f 90       	pop	r0
    87a4:	0f 90       	pop	r0
    87a6:	0f 90       	pop	r0
    87a8:	0f 90       	pop	r0
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    87aa:	e1 99       	sbic	0x1c, 1	; 28
    87ac:	fe cf       	rjmp	.-4      	; 0x87aa <dump_firmware+0x84>
#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    87ae:	df ba       	out	0x1f, r13	; 31
    87b0:	ce ba       	out	0x1e, r12	; 30
#endif
    EECR |= (1 << EERE);
    87b2:	e0 9a       	sbi	0x1c, 0	; 28
    return EEDR;
    87b4:	fd b2       	in	r15, 0x1d	; 29
		for (j=0; j<8;  j++)
		{
			uint8_t data = eeprom_read_byte((uint8_t*)(FIRMWARE+i+j));
			rprintf ("%x ", data);
    87b6:	8f 2d       	mov	r24, r15
    87b8:	90 e0       	ldi	r25, 0x00	; 0
    87ba:	9f 93       	push	r25
    87bc:	8f 93       	push	r24
    87be:	5f 92       	push	r5
    87c0:	4f 92       	push	r4
    87c2:	ef 92       	push	r14
    87c4:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
			if (data>27 && data<127) asciis[j]=data; else asciis[j]='.';
    87c8:	8f 2d       	mov	r24, r15
    87ca:	8c 51       	subi	r24, 0x1C	; 28
    87cc:	0f 90       	pop	r0
    87ce:	0f 90       	pop	r0
    87d0:	0f 90       	pop	r0
    87d2:	0f 90       	pop	r0
    87d4:	0f 90       	pop	r0
    87d6:	83 36       	cpi	r24, 0x63	; 99
    87d8:	18 f4       	brcc	.+6      	; 0x87e0 <dump_firmware+0xba>
    87da:	f8 01       	movw	r30, r16
    87dc:	f0 82       	st	Z, r15
    87de:	03 c0       	rjmp	.+6      	; 0x87e6 <dump_firmware+0xc0>
    87e0:	8e e2       	ldi	r24, 0x2E	; 46
    87e2:	f8 01       	movw	r30, r16
    87e4:	80 83       	st	Z, r24
    87e6:	0f 5f       	subi	r16, 0xFF	; 255
    87e8:	1f 4f       	sbci	r17, 0xFF	; 255
    87ea:	08 94       	sec
    87ec:	c1 1c       	adc	r12, r1
    87ee:	d1 1c       	adc	r13, r1
	for (i=0; i<64; i+=8) 	
	{
		int j;
		char asciis[9];
		rprintf ("%x ", i);
		for (j=0; j<8;  j++)
    87f0:	06 15       	cp	r16, r6
    87f2:	17 05       	cpc	r17, r7
    87f4:	d1 f6       	brne	.-76     	; 0x87aa <dump_firmware+0x84>
		{
			uint8_t data = eeprom_read_byte((uint8_t*)(FIRMWARE+i+j));
			rprintf ("%x ", data);
			if (data>27 && data<127) asciis[j]=data; else asciis[j]='.';
		}
		asciis[8]='\0';
    87f6:	19 86       	std	Y+9, r1	; 0x09
		rprintfStr (asciis);
    87f8:	c4 01       	movw	r24, r8
    87fa:	0e 94 f9 29 	call	0x53f2	; 0x53f2 <rprintfStr>
		rprintfStr ("\r\n");	
    87fe:	8a eb       	ldi	r24, 0xBA	; 186
    8800:	92 e0       	ldi	r25, 0x02	; 2
    8802:	0e 94 f9 29 	call	0x53f2	; 0x53f2 <rprintfStr>

void dump_firmware()
{
	int i;
	
	for (i=0; i<64; i+=8) 	
    8806:	e8 e0       	ldi	r30, 0x08	; 8
    8808:	f0 e0       	ldi	r31, 0x00	; 0
    880a:	ae 0e       	add	r10, r30
    880c:	bf 1e       	adc	r11, r31
    880e:	f0 e4       	ldi	r31, 0x40	; 64
    8810:	af 16       	cp	r10, r31
    8812:	b1 04       	cpc	r11, r1
    8814:	09 f0       	breq	.+2      	; 0x8818 <dump_firmware+0xf2>
    8816:	b6 cf       	rjmp	.-148    	; 0x8784 <dump_firmware+0x5e>
		}
		asciis[8]='\0';
		rprintfStr (asciis);
		rprintfStr ("\r\n");	
	}
}
    8818:	29 96       	adiw	r28, 0x09	; 9
    881a:	0f b6       	in	r0, 0x3f	; 63
    881c:	f8 94       	cli
    881e:	de bf       	out	0x3e, r29	; 62
    8820:	0f be       	out	0x3f, r0	; 63
    8822:	cd bf       	out	0x3d, r28	; 61
    8824:	cf 91       	pop	r28
    8826:	df 91       	pop	r29
    8828:	1f 91       	pop	r17
    882a:	0f 91       	pop	r16
    882c:	ff 90       	pop	r15
    882e:	ef 90       	pop	r14
    8830:	df 90       	pop	r13
    8832:	cf 90       	pop	r12
    8834:	bf 90       	pop	r11
    8836:	af 90       	pop	r10
    8838:	9f 90       	pop	r9
    883a:	8f 90       	pop	r8
    883c:	7f 90       	pop	r7
    883e:	6f 90       	pop	r6
    8840:	5f 90       	pop	r5
    8842:	4f 90       	pop	r4
    8844:	3f 90       	pop	r3
    8846:	2f 90       	pop	r2
    8848:	08 95       	ret

0000884a <dump>:

}


void dump()
{
    884a:	2f 92       	push	r2
    884c:	3f 92       	push	r3
    884e:	4f 92       	push	r4
    8850:	5f 92       	push	r5
    8852:	6f 92       	push	r6
    8854:	7f 92       	push	r7
    8856:	8f 92       	push	r8
    8858:	9f 92       	push	r9
    885a:	af 92       	push	r10
    885c:	bf 92       	push	r11
    885e:	cf 92       	push	r12
    8860:	df 92       	push	r13
    8862:	ef 92       	push	r14
    8864:	ff 92       	push	r15
    8866:	0f 93       	push	r16
    8868:	1f 93       	push	r17
    886a:	df 93       	push	r29
    886c:	cf 93       	push	r28
    886e:	cd b7       	in	r28, 0x3d	; 61
    8870:	de b7       	in	r29, 0x3e	; 62
    8872:	29 97       	sbiw	r28, 0x09	; 9
    8874:	0f b6       	in	r0, 0x3f	; 63
    8876:	f8 94       	cli
    8878:	de bf       	out	0x3e, r29	; 62
    887a:	0f be       	out	0x3f, r0	; 63
    887c:	cd bf       	out	0x3d, r28	; 61
    887e:	aa 24       	eor	r10, r10
    8880:	bb 24       	eor	r11, r11
	
	for (i=0; i<EEPROM_MEM_SZ; i+=8) 	
	{
		int j;
		char asciis[9];
		rprintf ("%x ", i);
    8882:	80 e0       	ldi	r24, 0x00	; 0
    8884:	28 2e       	mov	r2, r24
    8886:	8d e3       	ldi	r24, 0x3D	; 61
    8888:	38 2e       	mov	r3, r24
    888a:	ee 24       	eor	r14, r14
    888c:	e3 94       	inc	r14
    888e:	4e 01       	movw	r8, r28
    8890:	08 94       	sec
    8892:	81 1c       	adc	r8, r1
    8894:	91 1c       	adc	r9, r1
		for (j=0; j<8;  j++)
		{
			uint8_t data = eeprom_read_byte((uint8_t*)(BASIC_PROG_SPACE+i+j));
			rprintf ("%x ", data);
    8896:	0c ef       	ldi	r16, 0xFC	; 252
    8898:	40 2e       	mov	r4, r16
    889a:	0c e3       	ldi	r16, 0x3C	; 60
    889c:	50 2e       	mov	r5, r16
	for (i=0; i<EEPROM_MEM_SZ; i+=8) 	
	{
		int j;
		char asciis[9];
		rprintf ("%x ", i);
		for (j=0; j<8;  j++)
    889e:	19 e0       	ldi	r17, 0x09	; 9
    88a0:	61 2e       	mov	r6, r17
    88a2:	71 2c       	mov	r7, r1
    88a4:	6c 0e       	add	r6, r28
    88a6:	7d 1e       	adc	r7, r29
	
	for (i=0; i<EEPROM_MEM_SZ; i+=8) 	
	{
		int j;
		char asciis[9];
		rprintf ("%x ", i);
    88a8:	bf 92       	push	r11
    88aa:	af 92       	push	r10
    88ac:	3f 92       	push	r3
    88ae:	2f 92       	push	r2
    88b0:	ef 92       	push	r14
    88b2:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
    88b6:	84 01       	movw	r16, r8
    88b8:	b1 e4       	ldi	r27, 0x41	; 65
    88ba:	cb 2e       	mov	r12, r27
    88bc:	b0 e0       	ldi	r27, 0x00	; 0
    88be:	db 2e       	mov	r13, r27
    88c0:	ca 0c       	add	r12, r10
    88c2:	db 1c       	adc	r13, r11
    88c4:	0f 90       	pop	r0
    88c6:	0f 90       	pop	r0
    88c8:	0f 90       	pop	r0
    88ca:	0f 90       	pop	r0
    88cc:	0f 90       	pop	r0
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    88ce:	e1 99       	sbic	0x1c, 1	; 28
    88d0:	fe cf       	rjmp	.-4      	; 0x88ce <dump+0x84>
#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    88d2:	df ba       	out	0x1f, r13	; 31
    88d4:	ce ba       	out	0x1e, r12	; 30
#endif
    EECR |= (1 << EERE);
    88d6:	e0 9a       	sbi	0x1c, 0	; 28
    return EEDR;
    88d8:	fd b2       	in	r15, 0x1d	; 29
		for (j=0; j<8;  j++)
		{
			uint8_t data = eeprom_read_byte((uint8_t*)(BASIC_PROG_SPACE+i+j));
			rprintf ("%x ", data);
    88da:	8f 2d       	mov	r24, r15
    88dc:	90 e0       	ldi	r25, 0x00	; 0
    88de:	9f 93       	push	r25
    88e0:	8f 93       	push	r24
    88e2:	5f 92       	push	r5
    88e4:	4f 92       	push	r4
    88e6:	ef 92       	push	r14
    88e8:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
			if (data>27 && data<127) asciis[j]=data; else asciis[j]='.';
    88ec:	8f 2d       	mov	r24, r15
    88ee:	8c 51       	subi	r24, 0x1C	; 28
    88f0:	0f 90       	pop	r0
    88f2:	0f 90       	pop	r0
    88f4:	0f 90       	pop	r0
    88f6:	0f 90       	pop	r0
    88f8:	0f 90       	pop	r0
    88fa:	83 36       	cpi	r24, 0x63	; 99
    88fc:	18 f4       	brcc	.+6      	; 0x8904 <dump+0xba>
    88fe:	f8 01       	movw	r30, r16
    8900:	f0 82       	st	Z, r15
    8902:	03 c0       	rjmp	.+6      	; 0x890a <dump+0xc0>
    8904:	8e e2       	ldi	r24, 0x2E	; 46
    8906:	f8 01       	movw	r30, r16
    8908:	80 83       	st	Z, r24
    890a:	0f 5f       	subi	r16, 0xFF	; 255
    890c:	1f 4f       	sbci	r17, 0xFF	; 255
    890e:	08 94       	sec
    8910:	c1 1c       	adc	r12, r1
    8912:	d1 1c       	adc	r13, r1
	for (i=0; i<EEPROM_MEM_SZ; i+=8) 	
	{
		int j;
		char asciis[9];
		rprintf ("%x ", i);
		for (j=0; j<8;  j++)
    8914:	06 15       	cp	r16, r6
    8916:	17 05       	cpc	r17, r7
    8918:	d1 f6       	brne	.-76     	; 0x88ce <dump+0x84>
		{
			uint8_t data = eeprom_read_byte((uint8_t*)(BASIC_PROG_SPACE+i+j));
			rprintf ("%x ", data);
			if (data>27 && data<127) asciis[j]=data; else asciis[j]='.';
		}
		asciis[8]='\0';
    891a:	19 86       	std	Y+9, r1	; 0x09
		rprintfStr (asciis);
    891c:	c4 01       	movw	r24, r8
    891e:	0e 94 f9 29 	call	0x53f2	; 0x53f2 <rprintfStr>
		rprintfStr ("\r\n");	
    8922:	8a eb       	ldi	r24, 0xBA	; 186
    8924:	92 e0       	ldi	r25, 0x02	; 2
    8926:	0e 94 f9 29 	call	0x53f2	; 0x53f2 <rprintfStr>

void dump()
{
	int i;
	
	for (i=0; i<EEPROM_MEM_SZ; i+=8) 	
    892a:	e8 e0       	ldi	r30, 0x08	; 8
    892c:	f0 e0       	ldi	r31, 0x00	; 0
    892e:	ae 0e       	add	r10, r30
    8930:	bf 1e       	adc	r11, r31
    8932:	f0 e0       	ldi	r31, 0x00	; 0
    8934:	af 16       	cp	r10, r31
    8936:	f4 e0       	ldi	r31, 0x04	; 4
    8938:	bf 06       	cpc	r11, r31
    893a:	09 f0       	breq	.+2      	; 0x893e <dump+0xf4>
    893c:	b5 cf       	rjmp	.-150    	; 0x88a8 <dump+0x5e>
		}
		asciis[8]='\0';
		rprintfStr (asciis);
		rprintfStr ("\r\n");	
	}
}
    893e:	29 96       	adiw	r28, 0x09	; 9
    8940:	0f b6       	in	r0, 0x3f	; 63
    8942:	f8 94       	cli
    8944:	de bf       	out	0x3e, r29	; 62
    8946:	0f be       	out	0x3f, r0	; 63
    8948:	cd bf       	out	0x3d, r28	; 61
    894a:	cf 91       	pop	r28
    894c:	df 91       	pop	r29
    894e:	1f 91       	pop	r17
    8950:	0f 91       	pop	r16
    8952:	ff 90       	pop	r15
    8954:	ef 90       	pop	r14
    8956:	df 90       	pop	r13
    8958:	cf 90       	pop	r12
    895a:	bf 90       	pop	r11
    895c:	af 90       	pop	r10
    895e:	9f 90       	pop	r9
    8960:	8f 90       	pop	r8
    8962:	7f 90       	pop	r7
    8964:	6f 90       	pop	r6
    8966:	5f 90       	pop	r5
    8968:	4f 90       	pop	r4
    896a:	3f 90       	pop	r3
    896c:	2f 90       	pop	r2
    896e:	08 95       	ret

00008970 <basic_clear>:
	}
	
}

void basic_clear()
{
    8970:	8d eb       	ldi	r24, 0xBD	; 189
    8972:	92 e0       	ldi	r25, 0x02	; 2
    8974:	0e 94 f9 29 	call	0x53f2	; 0x53f2 <rprintfStr>
    8978:	81 e4       	ldi	r24, 0x41	; 65
    897a:	90 e0       	ldi	r25, 0x00	; 0
#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
#endif
    EEDR = __value;
    897c:	2f ef       	ldi	r18, 0xFF	; 255
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    897e:	e1 99       	sbic	0x1c, 1	; 28
    8980:	fe cf       	rjmp	.-4      	; 0x897e <basic_clear+0xe>
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    8982:	9f bb       	out	0x1f, r25	; 31
    8984:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    8986:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
    8988:	0f b6       	in	r0, 0x3f	; 63
    898a:	f8 94       	cli
    898c:	e2 9a       	sbi	0x1c, 2	; 28
    898e:	e1 9a       	sbi	0x1c, 1	; 28
    8990:	0f be       	out	0x3f, r0	; 63
    8992:	01 96       	adiw	r24, 0x01	; 1
	// Set Init pointer to Zero
	int i;	
	rprintfStr("Clear Program \r\n");
			
	uint8_t data= 0xFF; 				// start of program byte		
	for (i=0; i<EEPROM_MEM_SZ; i++) 	
    8994:	34 e0       	ldi	r19, 0x04	; 4
    8996:	81 34       	cpi	r24, 0x41	; 65
    8998:	93 07       	cpc	r25, r19
    899a:	89 f7       	brne	.-30     	; 0x897e <basic_clear+0xe>
	{
		eeprom_write_byte(BASIC_PROG_SPACE+i, data);
	}
	
	rprintf("Cleared %d bytes \r\n", EEPROM_MEM_SZ);
    899c:	80 e0       	ldi	r24, 0x00	; 0
    899e:	94 e0       	ldi	r25, 0x04	; 4
    89a0:	9f 93       	push	r25
    89a2:	8f 93       	push	r24
    89a4:	84 e0       	ldi	r24, 0x04	; 4
    89a6:	9d e3       	ldi	r25, 0x3D	; 61
    89a8:	9f 93       	push	r25
    89aa:	8f 93       	push	r24
    89ac:	81 e0       	ldi	r24, 0x01	; 1
    89ae:	8f 93       	push	r24
    89b0:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
    89b4:	0f 90       	pop	r0
    89b6:	0f 90       	pop	r0
    89b8:	0f 90       	pop	r0
    89ba:	0f 90       	pop	r0
    89bc:	0f 90       	pop	r0

}
    89be:	08 95       	ret

000089c0 <gotoln>:
	return NUMBER;
}


int gotoln(int gl)
{
    89c0:	fc 01       	movw	r30, r24
    89c2:	21 e0       	ldi	r18, 0x01	; 1
    89c4:	30 e0       	ldi	r19, 0x00	; 0
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    89c6:	e1 99       	sbic	0x1c, 1	; 28
    89c8:	fe cf       	rjmp	.-4      	; 0x89c6 <gotoln+0x6>
#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    89ca:	c9 01       	movw	r24, r18
    89cc:	8f 5b       	subi	r24, 0xBF	; 191
    89ce:	9f 4f       	sbci	r25, 0xFF	; 255
    89d0:	9f bb       	out	0x1f, r25	; 31
    89d2:	8e bb       	out	0x1e, r24	; 30
#endif
    EECR |= (1 << EERE);
    89d4:	e0 9a       	sbi	0x1c, 0	; 28
    return EEDR;
    89d6:	8d b3       	in	r24, 0x1d	; 29
	while (lno != 0)
	{
		//rprintf("debug: %d,%d ??\r\n", lno, nl);
		//DPAUSE

		lno=eeprom_read_byte(BASIC_PROG_SPACE+nl);					
    89d8:	68 2f       	mov	r22, r24
    89da:	70 e0       	ldi	r23, 0x00	; 0
		if (lno == 0xCC)
    89dc:	6c 3c       	cpi	r22, 0xCC	; 204
    89de:	71 05       	cpc	r23, r1
    89e0:	71 f4       	brne	.+28     	; 0x89fe <gotoln+0x3e>
		{
			rprintf("Goto line missing ??\r\n");
    89e2:	8a e6       	ldi	r24, 0x6A	; 106
    89e4:	9d e3       	ldi	r25, 0x3D	; 61
    89e6:	9f 93       	push	r25
    89e8:	8f 93       	push	r24
    89ea:	81 e0       	ldi	r24, 0x01	; 1
    89ec:	8f 93       	push	r24
    89ee:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
    89f2:	2f ef       	ldi	r18, 0xFF	; 255
    89f4:	3f ef       	ldi	r19, 0xFF	; 255
    89f6:	0f 90       	pop	r0
    89f8:	0f 90       	pop	r0
    89fa:	0f 90       	pop	r0
    89fc:	24 c0       	rjmp	.+72     	; 0x8a46 <gotoln+0x86>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    89fe:	e1 99       	sbic	0x1c, 1	; 28
    8a00:	fe cf       	rjmp	.-4      	; 0x89fe <gotoln+0x3e>
#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    8a02:	c9 01       	movw	r24, r18
    8a04:	8e 5b       	subi	r24, 0xBE	; 190
    8a06:	9f 4f       	sbci	r25, 0xFF	; 255
    8a08:	9f bb       	out	0x1f, r25	; 31
    8a0a:	8e bb       	out	0x1e, r24	; 30
#endif
    EECR |= (1 << EERE);
    8a0c:	e0 9a       	sbi	0x1c, 0	; 28
    return EEDR;
    8a0e:	8d b3       	in	r24, 0x1d	; 29
			return -1;
		}	
		lno += (eeprom_read_byte(BASIC_PROG_SPACE+nl+1)<<8);	
    8a10:	58 2f       	mov	r21, r24
    8a12:	40 e0       	ldi	r20, 0x00	; 0
    8a14:	64 0f       	add	r22, r20
    8a16:	75 1f       	adc	r23, r21
		
		if (lno == gl)
    8a18:	6e 17       	cp	r22, r30
    8a1a:	7f 07       	cpc	r23, r31
    8a1c:	81 f0       	breq	.+32     	; 0x8a3e <gotoln+0x7e>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    8a1e:	e1 99       	sbic	0x1c, 1	; 28
    8a20:	fe cf       	rjmp	.-4      	; 0x8a1e <gotoln+0x5e>
#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    8a22:	c9 01       	movw	r24, r18
    8a24:	89 5b       	subi	r24, 0xB9	; 185
    8a26:	9f 4f       	sbci	r25, 0xFF	; 255
    8a28:	9f bb       	out	0x1f, r25	; 31
    8a2a:	8e bb       	out	0x1e, r24	; 30
#endif
    EECR |= (1 << EERE);
    8a2c:	e0 9a       	sbi	0x1c, 0	; 28
    return EEDR;
    8a2e:	8d b3       	in	r24, 0x1d	; 29
int gotoln(int gl)
{
	int nl=1;
	int lno=1;

	while (lno != 0)
    8a30:	67 2b       	or	r22, r23
    8a32:	39 f0       	breq	.+14     	; 0x8a42 <gotoln+0x82>
		lno += (eeprom_read_byte(BASIC_PROG_SPACE+nl+1)<<8);	
		
		if (lno == gl)
			break;				
		uint8_t b=eeprom_read_byte(BASIC_PROG_SPACE+nl+6);	
		nl = nl + 6+ b +1;
    8a34:	90 e0       	ldi	r25, 0x00	; 0
    8a36:	07 96       	adiw	r24, 0x07	; 7
    8a38:	28 0f       	add	r18, r24
    8a3a:	39 1f       	adc	r19, r25
    8a3c:	c4 cf       	rjmp	.-120    	; 0x89c6 <gotoln+0x6>
	}
	if (lno!=0) 
    8a3e:	ef 2b       	or	r30, r31
    8a40:	11 f4       	brne	.+4      	; 0x8a46 <gotoln+0x86>
    8a42:	2f ef       	ldi	r18, 0xFF	; 255
    8a44:	3f ef       	ldi	r19, 0xFF	; 255
	{
		return nl;
	}
	return -1;
}
    8a46:	c9 01       	movw	r24, r18
    8a48:	08 95       	ret

00008a4a <set_bit>:
	}
	return n;
}

void set_bit(int p, int b, int n)
{
    8a4a:	69 30       	cpi	r22, 0x09	; 9
    8a4c:	71 05       	cpc	r23, r1
    8a4e:	08 f0       	brcs	.+2      	; 0x8a52 <set_bit+0x8>
    8a50:	50 c0       	rjmp	.+160    	; 0x8af2 <set_bit+0xa8>
	volatile uint8_t *port;
	uint8_t mask;
	
	if (b<0 || b>8) return;
		
	switch(p)
    8a52:	83 30       	cpi	r24, 0x03	; 3
    8a54:	91 05       	cpc	r25, r1
    8a56:	d9 f0       	breq	.+54     	; 0x8a8e <set_bit+0x44>
    8a58:	84 30       	cpi	r24, 0x04	; 4
    8a5a:	91 05       	cpc	r25, r1
    8a5c:	4c f4       	brge	.+18     	; 0x8a70 <set_bit+0x26>
    8a5e:	81 30       	cpi	r24, 0x01	; 1
    8a60:	91 05       	cpc	r25, r1
    8a62:	79 f0       	breq	.+30     	; 0x8a82 <set_bit+0x38>
    8a64:	82 30       	cpi	r24, 0x02	; 2
    8a66:	91 05       	cpc	r25, r1
    8a68:	7c f4       	brge	.+30     	; 0x8a88 <set_bit+0x3e>
    8a6a:	89 2b       	or	r24, r25
    8a6c:	41 f1       	breq	.+80     	; 0x8abe <set_bit+0x74>
    8a6e:	1b c0       	rjmp	.+54     	; 0x8aa6 <set_bit+0x5c>
    8a70:	85 30       	cpi	r24, 0x05	; 5
    8a72:	91 05       	cpc	r25, r1
    8a74:	91 f0       	breq	.+36     	; 0x8a9a <set_bit+0x50>
    8a76:	85 30       	cpi	r24, 0x05	; 5
    8a78:	91 05       	cpc	r25, r1
    8a7a:	64 f0       	brlt	.+24     	; 0x8a94 <set_bit+0x4a>
    8a7c:	06 97       	sbiw	r24, 0x06	; 6
    8a7e:	99 f4       	brne	.+38     	; 0x8aa6 <set_bit+0x5c>
    8a80:	0f c0       	rjmp	.+30     	; 0x8aa0 <set_bit+0x56>
    8a82:	e8 e3       	ldi	r30, 0x38	; 56
    8a84:	f0 e0       	ldi	r31, 0x00	; 0
    8a86:	1d c0       	rjmp	.+58     	; 0x8ac2 <set_bit+0x78>
    8a88:	e5 e3       	ldi	r30, 0x35	; 53
    8a8a:	f0 e0       	ldi	r31, 0x00	; 0
    8a8c:	1a c0       	rjmp	.+52     	; 0x8ac2 <set_bit+0x78>
	case 1:
		port=&PORTB;
		break;
	case 2:
		port=&PORTC;
		break;
    8a8e:	e2 e3       	ldi	r30, 0x32	; 50
    8a90:	f0 e0       	ldi	r31, 0x00	; 0
    8a92:	17 c0       	rjmp	.+46     	; 0x8ac2 <set_bit+0x78>
	case 3:
		port=&PORTD;
		break;
    8a94:	e3 e2       	ldi	r30, 0x23	; 35
    8a96:	f0 e0       	ldi	r31, 0x00	; 0
    8a98:	14 c0       	rjmp	.+40     	; 0x8ac2 <set_bit+0x78>
	case 4:
		port=&PORTE;
		break;
    8a9a:	e2 e6       	ldi	r30, 0x62	; 98
    8a9c:	f0 e0       	ldi	r31, 0x00	; 0
    8a9e:	11 c0       	rjmp	.+34     	; 0x8ac2 <set_bit+0x78>
	case 5:
		port=&PORTF;
		break;
    8aa0:	e5 e6       	ldi	r30, 0x65	; 101
    8aa2:	f0 e0       	ldi	r31, 0x00	; 0
    8aa4:	0e c0       	rjmp	.+28     	; 0x8ac2 <set_bit+0x78>
	case 6:
		port=&PORTG;
		break;
	default:
		rprintf ("panic error\r\n");
    8aa6:	85 e9       	ldi	r24, 0x95	; 149
    8aa8:	9d e3       	ldi	r25, 0x3D	; 61
    8aaa:	9f 93       	push	r25
    8aac:	8f 93       	push	r24
    8aae:	81 e0       	ldi	r24, 0x01	; 1
    8ab0:	8f 93       	push	r24
    8ab2:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
    8ab6:	0f 90       	pop	r0
    8ab8:	0f 90       	pop	r0
    8aba:	0f 90       	pop	r0
    8abc:	08 95       	ret
		return;
    8abe:	eb e3       	ldi	r30, 0x3B	; 59
    8ac0:	f0 e0       	ldi	r31, 0x00	; 0
	}
	
	if (b==8) // set DDR
    8ac2:	68 30       	cpi	r22, 0x08	; 8
    8ac4:	71 05       	cpc	r23, r1
    8ac6:	19 f4       	brne	.+6      	; 0x8ace <set_bit+0x84>
	{
		port -= 1; // now points to DDR
    8ac8:	31 97       	sbiw	r30, 0x01	; 1
		*port = n;
    8aca:	40 83       	st	Z, r20
    8acc:	08 95       	ret
		return;
	}
	
	mask = (1<<b);
    8ace:	81 e0       	ldi	r24, 0x01	; 1
    8ad0:	90 e0       	ldi	r25, 0x00	; 0
    8ad2:	02 c0       	rjmp	.+4      	; 0x8ad8 <set_bit+0x8e>
    8ad4:	88 0f       	add	r24, r24
    8ad6:	99 1f       	adc	r25, r25
    8ad8:	6a 95       	dec	r22
    8ada:	e2 f7       	brpl	.-8      	; 0x8ad4 <set_bit+0x8a>
    8adc:	98 2f       	mov	r25, r24
	
	if (n==0)	
    8ade:	45 2b       	or	r20, r21
    8ae0:	29 f4       	brne	.+10     	; 0x8aec <set_bit+0xa2>
	{	
		*port &= ~mask; //clear bit
    8ae2:	80 81       	ld	r24, Z
    8ae4:	90 95       	com	r25
    8ae6:	89 23       	and	r24, r25
    8ae8:	80 83       	st	Z, r24
    8aea:	08 95       	ret
	}
	else
	{
		*port |= mask;  //set bit
    8aec:	80 81       	ld	r24, Z
    8aee:	89 2b       	or	r24, r25
    8af0:	80 83       	st	Z, r24
    8af2:	08 95       	ret

00008af4 <put_special>:
	return -1;
}


int put_special(int var, int n)
{
    8af4:	cf 93       	push	r28
    8af6:	df 93       	push	r29
    8af8:	fc 01       	movw	r30, r24
    8afa:	eb 01       	movw	r28, r22
	if (var>= 30)
    8afc:	8e 31       	cpi	r24, 0x1E	; 30
    8afe:	91 05       	cpc	r25, r1
    8b00:	8c f0       	brlt	.+34     	; 0x8b24 <put_special+0x30>
	{
		char a,b;
		a='A' + (var-30)/10;
		b='0' + (var % 10);
		set_bit((var-30)/10, (var % 10), n);
    8b02:	6a e0       	ldi	r22, 0x0A	; 10
    8b04:	70 e0       	ldi	r23, 0x00	; 0
    8b06:	0e 94 31 6e 	call	0xdc62	; 0xdc62 <__divmodhi4>
    8b0a:	9c 01       	movw	r18, r24
    8b0c:	cf 01       	movw	r24, r30
    8b0e:	4e 97       	sbiw	r24, 0x1e	; 30
    8b10:	6a e0       	ldi	r22, 0x0A	; 10
    8b12:	70 e0       	ldi	r23, 0x00	; 0
    8b14:	0e 94 31 6e 	call	0xdc62	; 0xdc62 <__divmodhi4>
    8b18:	cb 01       	movw	r24, r22
    8b1a:	ae 01       	movw	r20, r28
    8b1c:	b9 01       	movw	r22, r18
    8b1e:	0e 94 25 45 	call	0x8a4a	; 0x8a4a <set_bit>
    8b22:	23 c0       	rjmp	.+70     	; 0x8b6a <put_special+0x76>
	}
	else
		switch(var) {
    8b24:	00 97       	sbiw	r24, 0x00	; 0
    8b26:	21 f0       	breq	.+8      	; 0x8b30 <put_special+0x3c>
    8b28:	85 30       	cpi	r24, 0x05	; 5
    8b2a:	91 05       	cpc	r25, r1
    8b2c:	79 f4       	brne	.+30     	; 0x8b4c <put_special+0x58>
    8b2e:	07 c0       	rjmp	.+14     	; 0x8b3e <put_special+0x4a>
		case sPF1:
			if (n) PF1_LED1_ON; else PF1_LED1_OFF;
    8b30:	61 15       	cp	r22, r1
    8b32:	71 05       	cpc	r23, r1
    8b34:	11 f0       	breq	.+4      	; 0x8b3a <put_special+0x46>
    8b36:	da 98       	cbi	0x1b, 2	; 27
    8b38:	18 c0       	rjmp	.+48     	; 0x8b6a <put_special+0x76>
    8b3a:	da 9a       	sbi	0x1b, 2	; 27
    8b3c:	16 c0       	rjmp	.+44     	; 0x8b6a <put_special+0x76>
			break;
		case sPSD:
			if (n) PSD_ON; else PSD_OFF;
    8b3e:	61 15       	cp	r22, r1
    8b40:	71 05       	cpc	r23, r1
    8b42:	11 f0       	breq	.+4      	; 0x8b48 <put_special+0x54>
    8b44:	c5 9a       	sbi	0x18, 5	; 24
    8b46:	11 c0       	rjmp	.+34     	; 0x8b6a <put_special+0x76>
    8b48:	c5 98       	cbi	0x18, 5	; 24
    8b4a:	0f c0       	rjmp	.+30     	; 0x8b6a <put_special+0x76>
			break;
		default:
			rprintf ("? special %d is read only\r\n", var);
    8b4c:	9f 93       	push	r25
    8b4e:	8f 93       	push	r24
    8b50:	8e e4       	ldi	r24, 0x4E	; 78
    8b52:	9d e3       	ldi	r25, 0x3D	; 61
    8b54:	9f 93       	push	r25
    8b56:	8f 93       	push	r24
    8b58:	81 e0       	ldi	r24, 0x01	; 1
    8b5a:	8f 93       	push	r24
    8b5c:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
    8b60:	0f 90       	pop	r0
    8b62:	0f 90       	pop	r0
    8b64:	0f 90       	pop	r0
    8b66:	0f 90       	pop	r0
    8b68:	0f 90       	pop	r0
			break;
		}
	return 0;
}
    8b6a:	80 e0       	ldi	r24, 0x00	; 0
    8b6c:	90 e0       	ldi	r25, 0x00	; 0
    8b6e:	df 91       	pop	r29
    8b70:	cf 91       	pop	r28
    8b72:	08 95       	ret

00008b74 <basic_list>:
	}
}


void basic_list()
{
    8b74:	2f 92       	push	r2
    8b76:	3f 92       	push	r3
    8b78:	4f 92       	push	r4
    8b7a:	5f 92       	push	r5
    8b7c:	6f 92       	push	r6
    8b7e:	7f 92       	push	r7
    8b80:	9f 92       	push	r9
    8b82:	af 92       	push	r10
    8b84:	bf 92       	push	r11
    8b86:	cf 92       	push	r12
    8b88:	df 92       	push	r13
    8b8a:	ef 92       	push	r14
    8b8c:	ff 92       	push	r15
    8b8e:	0f 93       	push	r16
    8b90:	1f 93       	push	r17
    8b92:	df 93       	push	r29
    8b94:	cf 93       	push	r28
    8b96:	cd b7       	in	r28, 0x3d	; 61
    8b98:	de b7       	in	r29, 0x3e	; 62
    8b9a:	c0 54       	subi	r28, 0x40	; 64
    8b9c:	d0 40       	sbci	r29, 0x00	; 0
    8b9e:	0f b6       	in	r0, 0x3f	; 63
    8ba0:	f8 94       	cli
    8ba2:	de bf       	out	0x3e, r29	; 62
    8ba4:	0f be       	out	0x3f, r0	; 63
    8ba6:	cd bf       	out	0x3d, r28	; 61
	// TBD -  Dump EEprom for the Moment
	rprintfStr("List Program \r\n");
    8ba8:	8e ec       	ldi	r24, 0xCE	; 206
    8baa:	92 e0       	ldi	r25, 0x02	; 2
    8bac:	0e 94 f9 29 	call	0x53f2	; 0x53f2 <rprintfStr>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    8bb0:	e1 99       	sbic	0x1c, 1	; 28
    8bb2:	fe cf       	rjmp	.-4      	; 0x8bb0 <basic_list+0x3c>
#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    8bb4:	81 e4       	ldi	r24, 0x41	; 65
    8bb6:	90 e0       	ldi	r25, 0x00	; 0
    8bb8:	9f bb       	out	0x1f, r25	; 31
    8bba:	8e bb       	out	0x1e, r24	; 30
#endif
    EECR |= (1 << EERE);
    8bbc:	e0 9a       	sbi	0x1c, 0	; 28
    return EEDR;
    8bbe:	8d b3       	in	r24, 0x1d	; 29

	if (eeprom_read_byte((uint8_t*)(BASIC_PROG_SPACE)) != 0xAA ) {
    8bc0:	8a 3a       	cpi	r24, 0xAA	; 170
    8bc2:	29 f0       	breq	.+10     	; 0x8bce <basic_list+0x5a>
		rprintfStr("No program loaded\r\n");
    8bc4:	8e ed       	ldi	r24, 0xDE	; 222
    8bc6:	92 e0       	ldi	r25, 0x02	; 2
    8bc8:	0e 94 f9 29 	call	0x53f2	; 0x53f2 <rprintfStr>
    8bcc:	28 c1       	rjmp	.+592    	; 0x8e1e <basic_list+0x2aa>
		dump();
		return;
    8bce:	01 e0       	ldi	r16, 0x01	; 1
    8bd0:	10 e0       	ldi	r17, 0x00	; 0
    \a __dst.
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    8bd2:	2e 01       	movw	r4, r28
    8bd4:	08 94       	sec
    8bd6:	41 1c       	adc	r4, r1
    8bd8:	51 1c       	adc	r5, r1
		
		tmp = eeprom_read_byte(BASIC_PROG_SPACE+ptr);	// terminator character ?

		/* list code */
	
		rprintf ("%d ", line.lineno); 
    8bda:	99 24       	eor	r9, r9
    8bdc:	93 94       	inc	r9
		else
		if (line.token==GOTO || line.token==WAIT ) 
			rprintf ("%d", line.value);
		else
			rprintfStr (line.text);
		rprintf ("\r\n");
    8bde:	4b ec       	ldi	r20, 0xCB	; 203
    8be0:	24 2e       	mov	r2, r20
    8be2:	4c e3       	ldi	r20, 0x3C	; 60
    8be4:	34 2e       	mov	r3, r20
/** \ingroup avr_eeprom
    Read one 16-bit word (little endian) from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint16_t eeprom_read_word (const uint16_t *__p)
{
    return __eerd_word (__p, eeprom_read_byte);
    8be6:	68 e1       	ldi	r22, 0x18	; 24
    8be8:	72 e4       	ldi	r23, 0x42	; 66
    8bea:	c8 01       	movw	r24, r16
    8bec:	8f 5b       	subi	r24, 0xBF	; 191
    8bee:	9f 4f       	sbci	r25, 0xFF	; 255
    8bf0:	0e 94 ca 6d 	call	0xdb94	; 0xdb94 <__eerd_word>
    8bf4:	5c 01       	movw	r10, r24
	
	line.text=buf;
	while (tmp != 0xCC && ptr < EEPROM_MEM_SZ )
	{
		line.lineno=(int)eeprom_read_word((uint16_t *)(BASIC_PROG_SPACE+ptr));	
		ptr+=2;
    8bf6:	0e 5f       	subi	r16, 0xFE	; 254
    8bf8:	1f 4f       	sbci	r17, 0xFF	; 255
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    8bfa:	e1 99       	sbic	0x1c, 1	; 28
    8bfc:	fe cf       	rjmp	.-4      	; 0x8bfa <basic_list+0x86>
#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    8bfe:	c8 01       	movw	r24, r16
    8c00:	8f 5b       	subi	r24, 0xBF	; 191
    8c02:	9f 4f       	sbci	r25, 0xFF	; 255
    8c04:	9f bb       	out	0x1f, r25	; 31
    8c06:	8e bb       	out	0x1e, r24	; 30
#endif
    EECR |= (1 << EERE);
    8c08:	e0 9a       	sbi	0x1c, 0	; 28
    return EEDR;
    8c0a:	dd b2       	in	r13, 0x1d	; 29
		line.token=eeprom_read_byte(BASIC_PROG_SPACE+ptr);	
		ptr++;		
    8c0c:	0f 5f       	subi	r16, 0xFF	; 255
    8c0e:	1f 4f       	sbci	r17, 0xFF	; 255
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    8c10:	e1 99       	sbic	0x1c, 1	; 28
    8c12:	fe cf       	rjmp	.-4      	; 0x8c10 <basic_list+0x9c>
#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    8c14:	c8 01       	movw	r24, r16
    8c16:	8f 5b       	subi	r24, 0xBF	; 191
    8c18:	9f 4f       	sbci	r25, 0xFF	; 255
    8c1a:	9f bb       	out	0x1f, r25	; 31
    8c1c:	8e bb       	out	0x1e, r24	; 30
#endif
    EECR |= (1 << EERE);
    8c1e:	e0 9a       	sbi	0x1c, 0	; 28
    return EEDR;
    8c20:	cd b2       	in	r12, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one 16-bit word (little endian) from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint16_t eeprom_read_word (const uint16_t *__p)
{
    return __eerd_word (__p, eeprom_read_byte);
    8c22:	68 e1       	ldi	r22, 0x18	; 24
    8c24:	72 e4       	ldi	r23, 0x42	; 66
    8c26:	c8 01       	movw	r24, r16
    8c28:	8e 5b       	subi	r24, 0xBE	; 190
    8c2a:	9f 4f       	sbci	r25, 0xFF	; 255
    8c2c:	0e 94 ca 6d 	call	0xdb94	; 0xdb94 <__eerd_word>
    8c30:	3c 01       	movw	r6, r24
		line.var=eeprom_read_byte(BASIC_PROG_SPACE+ptr);	
		ptr++;	
		line.value=eeprom_read_word((uint16_t *)(BASIC_PROG_SPACE+ptr));	
		ptr+=2;
    8c32:	33 e0       	ldi	r19, 0x03	; 3
    8c34:	e3 2e       	mov	r14, r19
    8c36:	f1 2c       	mov	r15, r1
    8c38:	e0 0e       	add	r14, r16
    8c3a:	f1 1e       	adc	r15, r17
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    8c3c:	e1 99       	sbic	0x1c, 1	; 28
    8c3e:	fe cf       	rjmp	.-4      	; 0x8c3c <basic_list+0xc8>
#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    8c40:	c7 01       	movw	r24, r14
    8c42:	8f 5b       	subi	r24, 0xBF	; 191
    8c44:	9f 4f       	sbci	r25, 0xFF	; 255
    8c46:	9f bb       	out	0x1f, r25	; 31
    8c48:	8e bb       	out	0x1e, r24	; 30
#endif
    EECR |= (1 << EERE);
    8c4a:	e0 9a       	sbi	0x1c, 0	; 28
    return EEDR;
    8c4c:	0d b3       	in	r16, 0x1d	; 29
		
		uint8_t l=eeprom_read_byte(BASIC_PROG_SPACE+ptr);	

		eeprom_read_block(line.text, BASIC_PROG_SPACE+ptr+1, l);	
    8c4e:	10 e0       	ldi	r17, 0x00	; 0
    \a __dst.
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    8c50:	b7 01       	movw	r22, r14
    8c52:	6e 5b       	subi	r22, 0xBE	; 190
    8c54:	7f 4f       	sbci	r23, 0xFF	; 255
    8c56:	28 e1       	ldi	r18, 0x18	; 24
    8c58:	32 e4       	ldi	r19, 0x42	; 66
    8c5a:	a8 01       	movw	r20, r16
    8c5c:	c2 01       	movw	r24, r4
    8c5e:	0e 94 ae 6d 	call	0xdb5c	; 0xdb5c <__eerd_block>
		line.text[l]='\0';
    8c62:	f2 01       	movw	r30, r4
    8c64:	e0 0f       	add	r30, r16
    8c66:	f1 1f       	adc	r31, r17
    8c68:	10 82       	st	Z, r1
		
		ptr += (l+1);
    8c6a:	0f 5f       	subi	r16, 0xFF	; 255
    8c6c:	1f 4f       	sbci	r17, 0xFF	; 255
    8c6e:	0e 0d       	add	r16, r14
    8c70:	1f 1d       	adc	r17, r15
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    8c72:	e1 99       	sbic	0x1c, 1	; 28
    8c74:	fe cf       	rjmp	.-4      	; 0x8c72 <basic_list+0xfe>
#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    8c76:	c8 01       	movw	r24, r16
    8c78:	8f 5b       	subi	r24, 0xBF	; 191
    8c7a:	9f 4f       	sbci	r25, 0xFF	; 255
    8c7c:	9f bb       	out	0x1f, r25	; 31
    8c7e:	8e bb       	out	0x1e, r24	; 30
#endif
    EECR |= (1 << EERE);
    8c80:	e0 9a       	sbi	0x1c, 0	; 28
    return EEDR;
    8c82:	fd b2       	in	r15, 0x1d	; 29
		
		tmp = eeprom_read_byte(BASIC_PROG_SPACE+ptr);	// terminator character ?

		/* list code */
	
		rprintf ("%d ", line.lineno); 
    8c84:	bf 92       	push	r11
    8c86:	af 92       	push	r10
    8c88:	80 ef       	ldi	r24, 0xF0	; 240
    8c8a:	9c e3       	ldi	r25, 0x3C	; 60
    8c8c:	9f 93       	push	r25
    8c8e:	8f 93       	push	r24
    8c90:	9f 92       	push	r9
    8c92:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
		rprintfStr (tokens[line.token]);
    8c96:	ed 2d       	mov	r30, r13
    8c98:	f0 e0       	ldi	r31, 0x00	; 0
    8c9a:	ee 0f       	add	r30, r30
    8c9c:	ff 1f       	adc	r31, r31
    8c9e:	e3 50       	subi	r30, 0x03	; 3
    8ca0:	fc 4f       	sbci	r31, 0xFC	; 252
    8ca2:	80 81       	ld	r24, Z
    8ca4:	91 81       	ldd	r25, Z+1	; 0x01
    8ca6:	0e 94 f9 29 	call	0x53f2	; 0x53f2 <rprintfStr>
		rprintf (" "); 
    8caa:	8e ee       	ldi	r24, 0xEE	; 238
    8cac:	9c e3       	ldi	r25, 0x3C	; 60
    8cae:	9f 93       	push	r25
    8cb0:	8f 93       	push	r24
    8cb2:	9f 92       	push	r9
    8cb4:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
		
		if (line.token==LET || line.token==GET || line.token==FOR)
    8cb8:	8d b7       	in	r24, 0x3d	; 61
    8cba:	9e b7       	in	r25, 0x3e	; 62
    8cbc:	08 96       	adiw	r24, 0x08	; 8
    8cbe:	0f b6       	in	r0, 0x3f	; 63
    8cc0:	f8 94       	cli
    8cc2:	9e bf       	out	0x3e, r25	; 62
    8cc4:	0f be       	out	0x3f, r0	; 63
    8cc6:	8d bf       	out	0x3d, r24	; 61
    8cc8:	dd 20       	and	r13, r13
    8cca:	31 f0       	breq	.+12     	; 0x8cd8 <basic_list+0x164>
    8ccc:	97 e0       	ldi	r25, 0x07	; 7
    8cce:	d9 16       	cp	r13, r25
    8cd0:	19 f0       	breq	.+6      	; 0x8cd8 <basic_list+0x164>
    8cd2:	81 e0       	ldi	r24, 0x01	; 1
    8cd4:	d8 16       	cp	r13, r24
    8cd6:	91 f4       	brne	.+36     	; 0x8cfc <basic_list+0x188>
			rprintf ("%c = ", line.var+'A');
    8cd8:	8c 2d       	mov	r24, r12
    8cda:	90 e0       	ldi	r25, 0x00	; 0
    8cdc:	8f 5b       	subi	r24, 0xBF	; 191
    8cde:	9f 4f       	sbci	r25, 0xFF	; 255
    8ce0:	9f 93       	push	r25
    8ce2:	8f 93       	push	r24
    8ce4:	88 ee       	ldi	r24, 0xE8	; 232
    8ce6:	9c e3       	ldi	r25, 0x3C	; 60
    8ce8:	9f 93       	push	r25
    8cea:	8f 93       	push	r24
    8cec:	9f 92       	push	r9
    8cee:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
    8cf2:	0f 90       	pop	r0
    8cf4:	0f 90       	pop	r0
    8cf6:	0f 90       	pop	r0
    8cf8:	0f 90       	pop	r0
    8cfa:	0f 90       	pop	r0
			
		if (line.token==PUT)
    8cfc:	98 e0       	ldi	r25, 0x08	; 8
    8cfe:	d9 16       	cp	r13, r25
    8d00:	a9 f5       	brne	.+106    	; 0x8d6c <basic_list+0x1f8>
    8d02:	ec 2d       	mov	r30, r12
    8d04:	f0 e0       	ldi	r31, 0x00	; 0
		{
			if (line.var <30)
    8d06:	8d e1       	ldi	r24, 0x1D	; 29
    8d08:	8c 15       	cp	r24, r12
    8d0a:	48 f0       	brcs	.+18     	; 0x8d1e <basic_list+0x1aa>
			{
				rprintfStr (specials[line.var]); 
    8d0c:	ee 0f       	add	r30, r30
    8d0e:	ff 1f       	adc	r31, r31
    8d10:	e9 5a       	subi	r30, 0xA9	; 169
    8d12:	fb 4f       	sbci	r31, 0xFB	; 251
    8d14:	80 81       	ld	r24, Z
    8d16:	91 81       	ldd	r25, Z+1	; 0x01
    8d18:	0e 94 f9 29 	call	0x53f2	; 0x53f2 <rprintfStr>
    8d1c:	22 c0       	rjmp	.+68     	; 0x8d62 <basic_list+0x1ee>
			else
			{
				char a, b;
				a='A' + ( (line.var - 30) /10) ;
				b='0' + (line.var % 10) ;
				rprintf ("PORT:%c:%c", a, b);			
    8d1e:	8c 2d       	mov	r24, r12
    8d20:	6a e0       	ldi	r22, 0x0A	; 10
    8d22:	0e 94 11 6e 	call	0xdc22	; 0xdc22 <__udivmodqi4>
    8d26:	89 2f       	mov	r24, r25
    8d28:	80 5d       	subi	r24, 0xD0	; 208
    8d2a:	90 e0       	ldi	r25, 0x00	; 0
    8d2c:	9f 93       	push	r25
    8d2e:	8f 93       	push	r24
    8d30:	cf 01       	movw	r24, r30
    8d32:	4e 97       	sbiw	r24, 0x1e	; 30
    8d34:	6a e0       	ldi	r22, 0x0A	; 10
    8d36:	70 e0       	ldi	r23, 0x00	; 0
    8d38:	0e 94 31 6e 	call	0xdc62	; 0xdc62 <__divmodhi4>
    8d3c:	6f 5b       	subi	r22, 0xBF	; 191
    8d3e:	70 e0       	ldi	r23, 0x00	; 0
    8d40:	7f 93       	push	r23
    8d42:	6f 93       	push	r22
    8d44:	8d ed       	ldi	r24, 0xDD	; 221
    8d46:	9c e3       	ldi	r25, 0x3C	; 60
    8d48:	9f 93       	push	r25
    8d4a:	8f 93       	push	r24
    8d4c:	9f 92       	push	r9
    8d4e:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
    8d52:	8d b7       	in	r24, 0x3d	; 61
    8d54:	9e b7       	in	r25, 0x3e	; 62
    8d56:	07 96       	adiw	r24, 0x07	; 7
    8d58:	0f b6       	in	r0, 0x3f	; 63
    8d5a:	f8 94       	cli
    8d5c:	9e bf       	out	0x3e, r25	; 62
    8d5e:	0f be       	out	0x3f, r0	; 63
    8d60:	8d bf       	out	0x3d, r24	; 61
			}
			rprintfStr (" = ");
    8d62:	82 ef       	ldi	r24, 0xF2	; 242
    8d64:	92 e0       	ldi	r25, 0x02	; 2
    8d66:	0e 94 f9 29 	call	0x53f2	; 0x53f2 <rprintfStr>
    8d6a:	46 c0       	rjmp	.+140    	; 0x8df8 <basic_list+0x284>
		}

		if (line.token==SERVO)
    8d6c:	9e e0       	ldi	r25, 0x0E	; 14
    8d6e:	d9 16       	cp	r13, r25
    8d70:	89 f4       	brne	.+34     	; 0x8d94 <basic_list+0x220>
			rprintf ("%d = ", line.var);
    8d72:	8c 2d       	mov	r24, r12
    8d74:	90 e0       	ldi	r25, 0x00	; 0
    8d76:	9f 93       	push	r25
    8d78:	8f 93       	push	r24
    8d7a:	87 ed       	ldi	r24, 0xD7	; 215
    8d7c:	9c e3       	ldi	r25, 0x3C	; 60
    8d7e:	9f 93       	push	r25
    8d80:	8f 93       	push	r24
    8d82:	9f 92       	push	r9
    8d84:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
    8d88:	0f 90       	pop	r0
    8d8a:	0f 90       	pop	r0
    8d8c:	0f 90       	pop	r0
    8d8e:	0f 90       	pop	r0
    8d90:	0f 90       	pop	r0
    8d92:	32 c0       	rjmp	.+100    	; 0x8df8 <basic_list+0x284>
			
		if (line.token==PRINT && line.var==1)
    8d94:	96 e0       	ldi	r25, 0x06	; 6
    8d96:	d9 16       	cp	r13, r25
    8d98:	71 f4       	brne	.+28     	; 0x8db6 <basic_list+0x242>
    8d9a:	81 e0       	ldi	r24, 0x01	; 1
    8d9c:	c8 16       	cp	r12, r24
    8d9e:	61 f5       	brne	.+88     	; 0x8df8 <basic_list+0x284>
			rprintf ("# ");
    8da0:	84 ed       	ldi	r24, 0xD4	; 212
    8da2:	9c e3       	ldi	r25, 0x3C	; 60
    8da4:	9f 93       	push	r25
    8da6:	8f 93       	push	r24
    8da8:	cf 92       	push	r12
    8daa:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
    8dae:	0f 90       	pop	r0
    8db0:	0f 90       	pop	r0
    8db2:	0f 90       	pop	r0
    8db4:	21 c0       	rjmp	.+66     	; 0x8df8 <basic_list+0x284>
			
		if (line.token==NEXT) 
    8db6:	9d e0       	ldi	r25, 0x0D	; 13
    8db8:	d9 16       	cp	r13, r25
    8dba:	49 f4       	brne	.+18     	; 0x8dce <basic_list+0x25a>
			rprintf ("%c", line.var+'A');
    8dbc:	8c 2d       	mov	r24, r12
    8dbe:	90 e0       	ldi	r25, 0x00	; 0
    8dc0:	8f 5b       	subi	r24, 0xBF	; 191
    8dc2:	9f 4f       	sbci	r25, 0xFF	; 255
    8dc4:	9f 93       	push	r25
    8dc6:	8f 93       	push	r24
    8dc8:	81 ed       	ldi	r24, 0xD1	; 209
    8dca:	9c e3       	ldi	r25, 0x3C	; 60
    8dcc:	0a c0       	rjmp	.+20     	; 0x8de2 <basic_list+0x26e>
		else
		if (line.token==GOTO || line.token==WAIT ) 
    8dce:	95 e0       	ldi	r25, 0x05	; 5
    8dd0:	d9 16       	cp	r13, r25
    8dd2:	19 f0       	breq	.+6      	; 0x8dda <basic_list+0x266>
    8dd4:	8c e0       	ldi	r24, 0x0C	; 12
    8dd6:	d8 16       	cp	r13, r24
    8dd8:	79 f4       	brne	.+30     	; 0x8df8 <basic_list+0x284>
			rprintf ("%d", line.value);
    8dda:	7f 92       	push	r7
    8ddc:	6f 92       	push	r6
    8dde:	8e ec       	ldi	r24, 0xCE	; 206
    8de0:	9c e3       	ldi	r25, 0x3C	; 60
    8de2:	9f 93       	push	r25
    8de4:	8f 93       	push	r24
    8de6:	9f 92       	push	r9
    8de8:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
    8dec:	0f 90       	pop	r0
    8dee:	0f 90       	pop	r0
    8df0:	0f 90       	pop	r0
    8df2:	0f 90       	pop	r0
    8df4:	0f 90       	pop	r0
    8df6:	03 c0       	rjmp	.+6      	; 0x8dfe <basic_list+0x28a>
		else
			rprintfStr (line.text);
    8df8:	c2 01       	movw	r24, r4
    8dfa:	0e 94 f9 29 	call	0x53f2	; 0x53f2 <rprintfStr>
		rprintf ("\r\n");
    8dfe:	3f 92       	push	r3
    8e00:	2f 92       	push	r2
    8e02:	9f 92       	push	r9
    8e04:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
	
	struct basic_line line;
	char buf[64];
	
	line.text=buf;
	while (tmp != 0xCC && ptr < EEPROM_MEM_SZ )
    8e08:	0f 90       	pop	r0
    8e0a:	0f 90       	pop	r0
    8e0c:	0f 90       	pop	r0
    8e0e:	9c ec       	ldi	r25, 0xCC	; 204
    8e10:	f9 16       	cp	r15, r25
    8e12:	29 f0       	breq	.+10     	; 0x8e1e <basic_list+0x2aa>
    8e14:	84 e0       	ldi	r24, 0x04	; 4
    8e16:	00 30       	cpi	r16, 0x00	; 0
    8e18:	18 07       	cpc	r17, r24
    8e1a:	0c f4       	brge	.+2      	; 0x8e1e <basic_list+0x2aa>
    8e1c:	e4 ce       	rjmp	.-568    	; 0x8be6 <basic_list+0x72>
		else
			rprintfStr (line.text);
		rprintf ("\r\n");
	}
	
	dump(); //debug
    8e1e:	0e 94 25 44 	call	0x884a	; 0x884a <dump>

}
    8e22:	c0 5c       	subi	r28, 0xC0	; 192
    8e24:	df 4f       	sbci	r29, 0xFF	; 255
    8e26:	0f b6       	in	r0, 0x3f	; 63
    8e28:	f8 94       	cli
    8e2a:	de bf       	out	0x3e, r29	; 62
    8e2c:	0f be       	out	0x3f, r0	; 63
    8e2e:	cd bf       	out	0x3d, r28	; 61
    8e30:	cf 91       	pop	r28
    8e32:	df 91       	pop	r29
    8e34:	1f 91       	pop	r17
    8e36:	0f 91       	pop	r16
    8e38:	ff 90       	pop	r15
    8e3a:	ef 90       	pop	r14
    8e3c:	df 90       	pop	r13
    8e3e:	cf 90       	pop	r12
    8e40:	bf 90       	pop	r11
    8e42:	af 90       	pop	r10
    8e44:	9f 90       	pop	r9
    8e46:	7f 90       	pop	r7
    8e48:	6f 90       	pop	r6
    8e4a:	5f 90       	pop	r5
    8e4c:	4f 90       	pop	r4
    8e4e:	3f 90       	pop	r3
    8e50:	2f 90       	pop	r2
    8e52:	08 95       	ret

00008e54 <readLine>:
		return t;
	} 
}

int readLine(char *line)
{
    8e54:	cf 92       	push	r12
    8e56:	df 92       	push	r13
    8e58:	ef 92       	push	r14
    8e5a:	ff 92       	push	r15
    8e5c:	0f 93       	push	r16
    8e5e:	1f 93       	push	r17
    8e60:	cf 93       	push	r28
    8e62:	df 93       	push	r29
    8e64:	7c 01       	movw	r14, r24
	int ch;
	int qf=1;
	char *start=line;
	
	rprintfStr ("> ");
    8e66:	86 ef       	ldi	r24, 0xF6	; 246
    8e68:	92 e0       	ldi	r25, 0x02	; 2
    8e6a:	0e 94 f9 29 	call	0x53f2	; 0x53f2 <rprintfStr>
    8e6e:	87 01       	movw	r16, r14
    8e70:	51 e0       	ldi	r21, 0x01	; 1
    8e72:	c5 2e       	mov	r12, r21
    8e74:	d1 2c       	mov	r13, r1
	
	while (1)
	{
		// foreach char entered

		while ((ch = uartGetByte())<0) ;
    8e76:	0e 94 9c 22 	call	0x4538	; 0x4538 <uartGetByte>
    8e7a:	ec 01       	movw	r28, r24
    8e7c:	97 fd       	sbrc	r25, 7
    8e7e:	fb cf       	rjmp	.-10     	; 0x8e76 <readLine+0x22>
			
		rprintfChar(ch);	
    8e80:	0e 94 e7 29 	call	0x53ce	; 0x53ce <rprintfChar>
				
		if (ch==13 || (start==line && ch=='.') )
    8e84:	cd 30       	cpi	r28, 0x0D	; 13
    8e86:	d1 05       	cpc	r29, r1
    8e88:	51 f0       	breq	.+20     	; 0x8e9e <readLine+0x4a>
    8e8a:	e0 16       	cp	r14, r16
    8e8c:	f1 06       	cpc	r15, r17
    8e8e:	71 f5       	brne	.+92     	; 0x8eec <readLine+0x98>
    8e90:	ce 32       	cpi	r28, 0x2E	; 46
    8e92:	d1 05       	cpc	r29, r1
    8e94:	79 f4       	brne	.+30     	; 0x8eb4 <readLine+0x60>
		{
			if (ch=='.') *line++='.';
    8e96:	8e e2       	ldi	r24, 0x2E	; 46
    8e98:	f7 01       	movw	r30, r14
    8e9a:	81 93       	st	Z+, r24
    8e9c:	8f 01       	movw	r16, r30
			*line='\0'; 
    8e9e:	f8 01       	movw	r30, r16
    8ea0:	10 82       	st	Z, r1
			rprintf("\r\n");	
    8ea2:	81 e0       	ldi	r24, 0x01	; 1
    8ea4:	9e e3       	ldi	r25, 0x3E	; 62
    8ea6:	9f 93       	push	r25
    8ea8:	8f 93       	push	r24
    8eaa:	81 e0       	ldi	r24, 0x01	; 1
    8eac:	8f 93       	push	r24
    8eae:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
    8eb2:	0c c0       	rjmp	.+24     	; 0x8ecc <readLine+0x78>
			break;
		}
		
		if (start==line && ch=='?' )
    8eb4:	cf 33       	cpi	r28, 0x3F	; 63
    8eb6:	d1 05       	cpc	r29, r1
    8eb8:	c9 f4       	brne	.+50     	; 0x8eec <readLine+0x98>
		{
			rprintf("Program entry mode (. to exit)\r\n");	
    8eba:	80 ee       	ldi	r24, 0xE0	; 224
    8ebc:	9d e3       	ldi	r25, 0x3D	; 61
    8ebe:	9f 93       	push	r25
    8ec0:	8f 93       	push	r24
    8ec2:	81 e0       	ldi	r24, 0x01	; 1
    8ec4:	8f 93       	push	r24
    8ec6:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
    8eca:	87 01       	movw	r16, r14
    8ecc:	0f 90       	pop	r0
    8ece:	0f 90       	pop	r0
    8ed0:	0f 90       	pop	r0
		if (ch==8 || ch==127) //Bsapce ?
		{
			if (line>start) line--;
		}
		else
			*line++ = ch;
    8ed2:	98 01       	movw	r18, r16
    8ed4:	2e 19       	sub	r18, r14
    8ed6:	3f 09       	sbc	r19, r15
	}
	return (line-start);
}
    8ed8:	c9 01       	movw	r24, r18
    8eda:	df 91       	pop	r29
    8edc:	cf 91       	pop	r28
    8ede:	1f 91       	pop	r17
    8ee0:	0f 91       	pop	r16
    8ee2:	ff 90       	pop	r15
    8ee4:	ef 90       	pop	r14
    8ee6:	df 90       	pop	r13
    8ee8:	cf 90       	pop	r12
    8eea:	08 95       	ret
		{
			rprintf("Program entry mode (. to exit)\r\n");	
			break;
		}
		
		if (ch=='"') {qf=!qf;}
    8eec:	c2 32       	cpi	r28, 0x22	; 34
    8eee:	d1 05       	cpc	r29, r1
    8ef0:	39 f4       	brne	.+14     	; 0x8f00 <readLine+0xac>
    8ef2:	80 e0       	ldi	r24, 0x00	; 0
    8ef4:	90 e0       	ldi	r25, 0x00	; 0
    8ef6:	cd 28       	or	r12, r13
    8ef8:	11 f4       	brne	.+4      	; 0x8efe <readLine+0xaa>
    8efa:	81 e0       	ldi	r24, 0x01	; 1
    8efc:	90 e0       	ldi	r25, 0x00	; 0
    8efe:	6c 01       	movw	r12, r24
			
		if (ch >= 'a' && ch <= 'z' && qf) ch = ch-'a'+'A';  // Uppercase only
    8f00:	ce 01       	movw	r24, r28
    8f02:	81 56       	subi	r24, 0x61	; 97
    8f04:	90 40       	sbci	r25, 0x00	; 0
    8f06:	4a 97       	sbiw	r24, 0x1a	; 26
    8f08:	20 f4       	brcc	.+8      	; 0x8f12 <readLine+0xbe>
    8f0a:	c1 14       	cp	r12, r1
    8f0c:	d1 04       	cpc	r13, r1
    8f0e:	09 f0       	breq	.+2      	; 0x8f12 <readLine+0xbe>
    8f10:	a0 97       	sbiw	r28, 0x20	; 32
		
		if (ch==8 || ch==127) //Bsapce ?
    8f12:	c8 30       	cpi	r28, 0x08	; 8
    8f14:	d1 05       	cpc	r29, r1
    8f16:	19 f0       	breq	.+6      	; 0x8f1e <readLine+0xca>
    8f18:	cf 37       	cpi	r28, 0x7F	; 127
    8f1a:	d1 05       	cpc	r29, r1
    8f1c:	39 f4       	brne	.+14     	; 0x8f2c <readLine+0xd8>
		{
			if (line>start) line--;
    8f1e:	e0 16       	cp	r14, r16
    8f20:	f1 06       	cpc	r15, r17
    8f22:	08 f0       	brcs	.+2      	; 0x8f26 <readLine+0xd2>
    8f24:	a8 cf       	rjmp	.-176    	; 0x8e76 <readLine+0x22>
    8f26:	01 50       	subi	r16, 0x01	; 1
    8f28:	10 40       	sbci	r17, 0x00	; 0
    8f2a:	a5 cf       	rjmp	.-182    	; 0x8e76 <readLine+0x22>
		}
		else
			*line++ = ch;
    8f2c:	f8 01       	movw	r30, r16
    8f2e:	c1 93       	st	Z+, r28
    8f30:	8f 01       	movw	r16, r30
    8f32:	a1 cf       	rjmp	.-190    	; 0x8e76 <readLine+0x22>

00008f34 <token_match>:
	*tok='\0';
	return n;
}

int token_match(char *list[], char **p_line, int n)
{
    8f34:	6f 92       	push	r6
    8f36:	7f 92       	push	r7
    8f38:	8f 92       	push	r8
    8f3a:	9f 92       	push	r9
    8f3c:	af 92       	push	r10
    8f3e:	bf 92       	push	r11
    8f40:	cf 92       	push	r12
    8f42:	df 92       	push	r13
    8f44:	ef 92       	push	r14
    8f46:	ff 92       	push	r15
    8f48:	0f 93       	push	r16
    8f4a:	1f 93       	push	r17
    8f4c:	df 93       	push	r29
    8f4e:	cf 93       	push	r28
    8f50:	cd b7       	in	r28, 0x3d	; 61
    8f52:	de b7       	in	r29, 0x3e	; 62
    8f54:	28 97       	sbiw	r28, 0x08	; 8
    8f56:	0f b6       	in	r0, 0x3f	; 63
    8f58:	f8 94       	cli
    8f5a:	de bf       	out	0x3e, r29	; 62
    8f5c:	0f be       	out	0x3f, r0	; 63
    8f5e:	cd bf       	out	0x3d, r28	; 61
    8f60:	9c 01       	movw	r18, r24
    8f62:	6b 01       	movw	r12, r22
    8f64:	4a 01       	movw	r8, r20
	int t;
	int t1;
	char buff[MAX_TOKEN];
	
	t1=getToken(*p_line, buff);  // this could buffer over run - needs fixing
    8f66:	fb 01       	movw	r30, r22
    8f68:	a0 81       	ld	r26, Z
    8f6a:	b1 81       	ldd	r27, Z+1	; 0x01
    8f6c:	ee 24       	eor	r14, r14
    8f6e:	ff 24       	eor	r15, r15
    8f70:	fe 01       	movw	r30, r28
    8f72:	31 96       	adiw	r30, 0x01	; 1
    8f74:	09 c0       	rjmp	.+18     	; 0x8f88 <token_match+0x54>
	int n=0;
	char c;
	while ((c=*str))
	{
		str++;
		if (!(c>= 'A' && c <='Z') )  //must be alpha
    8f76:	89 2f       	mov	r24, r25
    8f78:	81 54       	subi	r24, 0x41	; 65
    8f7a:	8a 31       	cpi	r24, 0x1A	; 26
    8f7c:	40 f4       	brcc	.+16     	; 0x8f8e <token_match+0x5a>
{
	int n=0;
	char c;
	while ((c=*str))
	{
		str++;
    8f7e:	11 96       	adiw	r26, 0x01	; 1
		if (!(c>= 'A' && c <='Z') )  //must be alpha
			break;
		*tok++=c; //copy in dest buff
    8f80:	91 93       	st	Z+, r25
		n++;
    8f82:	08 94       	sec
    8f84:	e1 1c       	adc	r14, r1
    8f86:	f1 1c       	adc	r15, r1

int getToken(char *str, char *tok)
{
	int n=0;
	char c;
	while ((c=*str))
    8f88:	9c 91       	ld	r25, X
    8f8a:	99 23       	and	r25, r25
    8f8c:	a1 f7       	brne	.-24     	; 0x8f76 <token_match+0x42>
		if (!(c>= 'A' && c <='Z') )  //must be alpha
			break;
		*tok++=c; //copy in dest buff
		n++;
	}	
	*tok='\0';
    8f8e:	10 82       	st	Z, r1
    8f90:	59 01       	movw	r10, r18
    8f92:	00 e0       	ldi	r16, 0x00	; 0
    8f94:	10 e0       	ldi	r17, 0x00	; 0
	
	t1=getToken(*p_line, buff);  // this could buffer over run - needs fixing
	
	for (t=0; t<n; t++)
	{
		if (!strcmp(buff, list[t]))
    8f96:	3e 01       	movw	r6, r28
    8f98:	08 94       	sec
    8f9a:	61 1c       	adc	r6, r1
    8f9c:	71 1c       	adc	r7, r1
    8f9e:	0b c0       	rjmp	.+22     	; 0x8fb6 <token_match+0x82>
    8fa0:	f5 01       	movw	r30, r10
    8fa2:	61 91       	ld	r22, Z+
    8fa4:	71 91       	ld	r23, Z+
    8fa6:	5f 01       	movw	r10, r30
    8fa8:	c3 01       	movw	r24, r6
    8faa:	0e 94 84 6d 	call	0xdb08	; 0xdb08 <strcmp>
    8fae:	00 97       	sbiw	r24, 0x00	; 0
    8fb0:	59 f0       	breq	.+22     	; 0x8fc8 <token_match+0x94>
	int t1;
	char buff[MAX_TOKEN];
	
	t1=getToken(*p_line, buff);  // this could buffer over run - needs fixing
	
	for (t=0; t<n; t++)
    8fb2:	0f 5f       	subi	r16, 0xFF	; 255
    8fb4:	1f 4f       	sbci	r17, 0xFF	; 255
    8fb6:	08 15       	cp	r16, r8
    8fb8:	19 05       	cpc	r17, r9
    8fba:	94 f3       	brlt	.-28     	; 0x8fa0 <token_match+0x6c>
	{
		if (!strcmp(buff, list[t]))
			break;
	}
	
	if (t==n)
    8fbc:	08 15       	cp	r16, r8
    8fbe:	19 05       	cpc	r17, r9
    8fc0:	19 f4       	brne	.+6      	; 0x8fc8 <token_match+0x94>
    8fc2:	0f ef       	ldi	r16, 0xFF	; 255
    8fc4:	1f ef       	ldi	r17, 0xFF	; 255
    8fc6:	07 c0       	rjmp	.+14     	; 0x8fd6 <token_match+0xa2>
	{
		return -1; 		// no_match : match
	}
	else {
		*p_line += t1; 
    8fc8:	f6 01       	movw	r30, r12
    8fca:	80 81       	ld	r24, Z
    8fcc:	91 81       	ldd	r25, Z+1	; 0x01
    8fce:	8e 0d       	add	r24, r14
    8fd0:	9f 1d       	adc	r25, r15
    8fd2:	91 83       	std	Z+1, r25	; 0x01
    8fd4:	80 83       	st	Z, r24
		return t;
	} 
}
    8fd6:	c8 01       	movw	r24, r16
    8fd8:	28 96       	adiw	r28, 0x08	; 8
    8fda:	0f b6       	in	r0, 0x3f	; 63
    8fdc:	f8 94       	cli
    8fde:	de bf       	out	0x3e, r29	; 62
    8fe0:	0f be       	out	0x3f, r0	; 63
    8fe2:	cd bf       	out	0x3d, r28	; 61
    8fe4:	cf 91       	pop	r28
    8fe6:	df 91       	pop	r29
    8fe8:	1f 91       	pop	r17
    8fea:	0f 91       	pop	r16
    8fec:	ff 90       	pop	r15
    8fee:	ef 90       	pop	r14
    8ff0:	df 90       	pop	r13
    8ff2:	cf 90       	pop	r12
    8ff4:	bf 90       	pop	r11
    8ff6:	af 90       	pop	r10
    8ff8:	9f 90       	pop	r9
    8ffa:	8f 90       	pop	r8
    8ffc:	7f 90       	pop	r7
    8ffe:	6f 90       	pop	r6
    9000:	08 95       	ret

00009002 <get_special>:
		*port |= mask;  //set bit
	}
}

int get_special(char *str, int *res)
{
    9002:	af 92       	push	r10
    9004:	bf 92       	push	r11
    9006:	cf 92       	push	r12
    9008:	df 92       	push	r13
    900a:	ef 92       	push	r14
    900c:	ff 92       	push	r15
    900e:	0f 93       	push	r16
    9010:	1f 93       	push	r17
    9012:	df 93       	push	r29
    9014:	cf 93       	push	r28
    9016:	00 d0       	rcall	.+0      	; 0x9018 <get_special+0x16>
    9018:	cd b7       	in	r28, 0x3d	; 61
    901a:	de b7       	in	r29, 0x3e	; 62
    901c:	9a 83       	std	Y+2, r25	; 0x02
    901e:	89 83       	std	Y+1, r24	; 0x01
    9020:	6b 01       	movw	r12, r22
	char *p=str;
    9022:	5c 01       	movw	r10, r24
	int t=token_match(specials, &str, sizeof(specials));
    9024:	4e e1       	ldi	r20, 0x1E	; 30
    9026:	50 e0       	ldi	r21, 0x00	; 0
    9028:	7e 01       	movw	r14, r28
    902a:	08 94       	sec
    902c:	e1 1c       	adc	r14, r1
    902e:	f1 1c       	adc	r15, r1
    9030:	b7 01       	movw	r22, r14
    9032:	87 e5       	ldi	r24, 0x57	; 87
    9034:	94 e0       	ldi	r25, 0x04	; 4
    9036:	0e 94 9a 47 	call	0x8f34	; 0x8f34 <token_match>
    903a:	8c 01       	movw	r16, r24
	//if (t==sPSD || t==sVOLT || t==sMIC)
	//{
	//	adc_test(0);
	//}
	
	switch(t) {
    903c:	87 30       	cpi	r24, 0x07	; 7
    903e:	91 05       	cpc	r25, r1
    9040:	09 f4       	brne	.+2      	; 0x9044 <get_special+0x42>
    9042:	63 c0       	rjmp	.+198    	; 0x910a <get_special+0x108>
    9044:	88 30       	cpi	r24, 0x08	; 8
    9046:	91 05       	cpc	r25, r1
    9048:	bc f4       	brge	.+46     	; 0x9078 <get_special+0x76>
    904a:	83 30       	cpi	r24, 0x03	; 3
    904c:	91 05       	cpc	r25, r1
    904e:	e9 f1       	breq	.+122    	; 0x90ca <get_special+0xc8>
    9050:	84 30       	cpi	r24, 0x04	; 4
    9052:	91 05       	cpc	r25, r1
    9054:	54 f4       	brge	.+20     	; 0x906a <get_special+0x68>
    9056:	81 30       	cpi	r24, 0x01	; 1
    9058:	91 05       	cpc	r25, r1
    905a:	61 f1       	breq	.+88     	; 0x90b4 <get_special+0xb2>
    905c:	82 30       	cpi	r24, 0x02	; 2
    905e:	91 05       	cpc	r25, r1
    9060:	64 f5       	brge	.+88     	; 0x90ba <get_special+0xb8>
    9062:	00 97       	sbiw	r24, 0x00	; 0
    9064:	09 f4       	brne	.+2      	; 0x9068 <get_special+0x66>
    9066:	ca c0       	rjmp	.+404    	; 0x91fc <get_special+0x1fa>
    9068:	22 c0       	rjmp	.+68     	; 0x90ae <get_special+0xac>
    906a:	85 30       	cpi	r24, 0x05	; 5
    906c:	91 05       	cpc	r25, r1
    906e:	e9 f1       	breq	.+122    	; 0x90ea <get_special+0xe8>
    9070:	86 30       	cpi	r24, 0x06	; 6
    9072:	91 05       	cpc	r25, r1
    9074:	ec f5       	brge	.+122    	; 0x90f0 <get_special+0xee>
    9076:	31 c0       	rjmp	.+98     	; 0x90da <get_special+0xd8>
    9078:	8b 30       	cpi	r24, 0x0B	; 11
    907a:	91 05       	cpc	r25, r1
    907c:	09 f4       	brne	.+2      	; 0x9080 <get_special+0x7e>
    907e:	64 c0       	rjmp	.+200    	; 0x9148 <get_special+0x146>
    9080:	8c 30       	cpi	r24, 0x0C	; 12
    9082:	91 05       	cpc	r25, r1
    9084:	4c f4       	brge	.+18     	; 0x9098 <get_special+0x96>
    9086:	89 30       	cpi	r24, 0x09	; 9
    9088:	91 05       	cpc	r25, r1
    908a:	09 f4       	brne	.+2      	; 0x908e <get_special+0x8c>
    908c:	48 c0       	rjmp	.+144    	; 0x911e <get_special+0x11c>
    908e:	8a 30       	cpi	r24, 0x0A	; 10
    9090:	91 05       	cpc	r25, r1
    9092:	0c f0       	brlt	.+2      	; 0x9096 <get_special+0x94>
    9094:	47 c0       	rjmp	.+142    	; 0x9124 <get_special+0x122>
    9096:	3e c0       	rjmp	.+124    	; 0x9114 <get_special+0x112>
    9098:	8d 30       	cpi	r24, 0x0D	; 13
    909a:	91 05       	cpc	r25, r1
    909c:	09 f4       	brne	.+2      	; 0x90a0 <get_special+0x9e>
    909e:	96 c0       	rjmp	.+300    	; 0x91cc <get_special+0x1ca>
    90a0:	8d 30       	cpi	r24, 0x0D	; 13
    90a2:	91 05       	cpc	r25, r1
    90a4:	0c f4       	brge	.+2      	; 0x90a8 <get_special+0xa6>
    90a6:	55 c0       	rjmp	.+170    	; 0x9152 <get_special+0x150>
    90a8:	8e 30       	cpi	r24, 0x0E	; 14
    90aa:	91 05       	cpc	r25, r1
    90ac:	21 f1       	breq	.+72     	; 0x90f6 <get_special+0xf4>
    90ae:	af ef       	ldi	r26, 0xFF	; 255
    90b0:	bf ef       	ldi	r27, 0xFF	; 255
    90b2:	b8 c0       	rjmp	.+368    	; 0x9224 <get_special+0x222>
	case sPF1:
		v=0;
		break;
	case sMIC:
		v=adc_mic();
    90b4:	0e 94 fb 2c 	call	0x59f6	; 0x59f6 <adc_mic>
    90b8:	26 c0       	rjmp	.+76     	; 0x9106 <get_special+0x104>
		break;
	case sGX:
		tilt_read(0);
    90ba:	80 e0       	ldi	r24, 0x00	; 0
    90bc:	0e 94 ad 2f 	call	0x5f5a	; 0x5f5a <tilt_read>
		v=x_value;
    90c0:	80 91 a5 0d 	lds	r24, 0x0DA5
    90c4:	90 91 a6 0d 	lds	r25, 0x0DA6
    90c8:	9b c0       	rjmp	.+310    	; 0x9200 <get_special+0x1fe>
		break;	
	case sGY:
		tilt_read(0);
    90ca:	80 e0       	ldi	r24, 0x00	; 0
    90cc:	0e 94 ad 2f 	call	0x5f5a	; 0x5f5a <tilt_read>
		v=y_value;
    90d0:	80 91 a7 0d 	lds	r24, 0x0DA7
    90d4:	90 91 a8 0d 	lds	r25, 0x0DA8
    90d8:	93 c0       	rjmp	.+294    	; 0x9200 <get_special+0x1fe>
		break;		
	case sGZ:
		tilt_read(0);
    90da:	80 e0       	ldi	r24, 0x00	; 0
    90dc:	0e 94 ad 2f 	call	0x5f5a	; 0x5f5a <tilt_read>
		v=z_value;
    90e0:	80 91 af 0d 	lds	r24, 0x0DAF
    90e4:	90 91 b0 0d 	lds	r25, 0x0DB0
    90e8:	8b c0       	rjmp	.+278    	; 0x9200 <get_special+0x1fe>
		break;			
	case sPSD:
		v=adc_psd();
    90ea:	0e 94 9c 2c 	call	0x5938	; 0x5938 <adc_psd>
    90ee:	0b c0       	rjmp	.+22     	; 0x9106 <get_special+0x104>
		break;
	case sVOLT:
		v=adc_volt();
    90f0:	0e 94 d1 2b 	call	0x57a2	; 0x57a2 <adc_volt>
    90f4:	85 c0       	rjmp	.+266    	; 0x9200 <get_special+0x1fe>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    90f6:	e1 99       	sbic	0x1c, 1	; 28
    90f8:	fe cf       	rjmp	.-4      	; 0x90f6 <get_special+0xf4>
#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    90fa:	80 e4       	ldi	r24, 0x40	; 64
    90fc:	90 e0       	ldi	r25, 0x00	; 0
    90fe:	9f bb       	out	0x1f, r25	; 31
    9100:	8e bb       	out	0x1e, r24	; 30
#endif
    EECR |= (1 << EERE);
    9102:	e0 9a       	sbi	0x1c, 0	; 28
    return EEDR;
    9104:	8d b3       	in	r24, 0x1d	; 29
		break;
	case sTYPE:
		v=get_type(); 				// Robot configuration
    9106:	90 e0       	ldi	r25, 0x00	; 0
    9108:	7b c0       	rjmp	.+246    	; 0x9200 <get_special+0x1fe>
		break;
	case sIR:
		while ((v= irGetByte())<0) ; //wait for IR
    910a:	0e 94 3a 2e 	call	0x5c74	; 0x5c74 <irGetByte>
    910e:	97 fd       	sbrc	r25, 7
    9110:	fc cf       	rjmp	.-8      	; 0x910a <get_special+0x108>
    9112:	76 c0       	rjmp	.+236    	; 0x9200 <get_special+0x1fe>
		break;
	case sKBD:
		while ((v= uartGetByte())<0) ; // wait for input
    9114:	0e 94 9c 22 	call	0x4538	; 0x4538 <uartGetByte>
    9118:	97 fd       	sbrc	r25, 7
    911a:	fc cf       	rjmp	.-8      	; 0x9114 <get_special+0x112>
    911c:	71 c0       	rjmp	.+226    	; 0x9200 <get_special+0x1fe>
		break;	
	case sRND:
		v=rand();
    911e:	0e 94 69 6d 	call	0xdad2	; 0xdad2 <rand>
    9122:	6e c0       	rjmp	.+220    	; 0x9200 <get_special+0x1fe>
		break;	
	case sSERVO: // SERVO:nn
		// get position of servo id=nn
		v=0;
		if (*str==':') {
    9124:	e9 81       	ldd	r30, Y+1	; 0x01
    9126:	fa 81       	ldd	r31, Y+2	; 0x02
    9128:	80 81       	ld	r24, Z
    912a:	8a 33       	cpi	r24, 0x3A	; 58
    912c:	09 f0       	breq	.+2      	; 0x9130 <get_special+0x12e>
    912e:	66 c0       	rjmp	.+204    	; 0x91fc <get_special+0x1fa>
			str++;
    9130:	31 96       	adiw	r30, 0x01	; 1
    9132:	fa 83       	std	Y+2, r31	; 0x02
    9134:	e9 83       	std	Y+1, r30	; 0x01
			v=getNum(&str);
    9136:	c7 01       	movw	r24, r14
    9138:	0e 94 9e 42 	call	0x853c	; 0x853c <getNum>
			v = wckPosRead(v); 			// get pos of servo id=v
    913c:	0e 94 62 53 	call	0xa6c4	; 0xa6c4 <wckPosRead>
			*res=v;
    9140:	f6 01       	movw	r30, r12
    9142:	80 83       	st	Z, r24
    9144:	11 82       	std	Z+1, r1	; 0x01
    9146:	3d c0       	rjmp	.+122    	; 0x91c2 <get_special+0x1c0>
			return (str-p);
		}
		break;	
	case sTICK:
		v=gTicks;
    9148:	80 91 82 05 	lds	r24, 0x0582
    914c:	90 91 83 05 	lds	r25, 0x0583
    9150:	57 c0       	rjmp	.+174    	; 0x9200 <get_special+0x1fe>
		break;
	case sPORT: // PORT:A:n
		// get position of servo id=nn
		v=0;
		if (*str==':') {
    9152:	e9 81       	ldd	r30, Y+1	; 0x01
    9154:	fa 81       	ldd	r31, Y+2	; 0x02
    9156:	80 81       	ld	r24, Z
    9158:	8a 33       	cpi	r24, 0x3A	; 58
    915a:	19 f4       	brne	.+6      	; 0x9162 <get_special+0x160>
			str++;
    915c:	31 96       	adiw	r30, 0x01	; 1
    915e:	fa 83       	std	Y+2, r31	; 0x02
    9160:	e9 83       	std	Y+1, r30	; 0x01
			}
		if (*str>='A' && *str<='G' ) {
    9162:	e9 81       	ldd	r30, Y+1	; 0x01
    9164:	fa 81       	ldd	r31, Y+2	; 0x02
    9166:	90 81       	ld	r25, Z
    9168:	89 2f       	mov	r24, r25
    916a:	81 54       	subi	r24, 0x41	; 65
    916c:	87 30       	cpi	r24, 0x07	; 7
    916e:	18 f0       	brcs	.+6      	; 0x9176 <get_special+0x174>
    9170:	40 e0       	ldi	r20, 0x00	; 0
    9172:	50 e0       	ldi	r21, 0x00	; 0
    9174:	07 c0       	rjmp	.+14     	; 0x9184 <get_special+0x182>
			v= (*str-'A');
    9176:	49 2f       	mov	r20, r25
    9178:	50 e0       	ldi	r21, 0x00	; 0
    917a:	41 54       	subi	r20, 0x41	; 65
    917c:	50 40       	sbci	r21, 0x00	; 0
			str++;
    917e:	31 96       	adiw	r30, 0x01	; 1
    9180:	fa 83       	std	Y+2, r31	; 0x02
    9182:	e9 83       	std	Y+1, r30	; 0x01
			}	
		t=8;
		if (*str==':') {   // Optional Bit specficied
    9184:	e9 81       	ldd	r30, Y+1	; 0x01
    9186:	fa 81       	ldd	r31, Y+2	; 0x02
    9188:	80 81       	ld	r24, Z
    918a:	8a 33       	cpi	r24, 0x3A	; 58
    918c:	91 f4       	brne	.+36     	; 0x91b2 <get_special+0x1b0>
			str++;
    918e:	9f 01       	movw	r18, r30
    9190:	2f 5f       	subi	r18, 0xFF	; 255
    9192:	3f 4f       	sbci	r19, 0xFF	; 255
    9194:	3a 83       	std	Y+2, r19	; 0x02
    9196:	29 83       	std	Y+1, r18	; 0x01
			if (*str>='0' && *str<='7' ) {
    9198:	61 81       	ldd	r22, Z+1	; 0x01
    919a:	86 2f       	mov	r24, r22
    919c:	80 53       	subi	r24, 0x30	; 48
    919e:	88 30       	cpi	r24, 0x08	; 8
    91a0:	40 f4       	brcc	.+16     	; 0x91b2 <get_special+0x1b0>
				t=  (*str+ '0');
    91a2:	70 e0       	ldi	r23, 0x00	; 0
    91a4:	60 5d       	subi	r22, 0xD0	; 208
    91a6:	7f 4f       	sbci	r23, 0xFF	; 255
				str++;
    91a8:	2f 5f       	subi	r18, 0xFF	; 255
    91aa:	3f 4f       	sbci	r19, 0xFF	; 255
    91ac:	3a 83       	std	Y+2, r19	; 0x02
    91ae:	29 83       	std	Y+1, r18	; 0x01
    91b0:	02 c0       	rjmp	.+4      	; 0x91b6 <get_special+0x1b4>
    91b2:	68 e0       	ldi	r22, 0x08	; 8
    91b4:	70 e0       	ldi	r23, 0x00	; 0
				}
		}				
		*res=get_bit(v, t);         //need to read port with PINA etc 
    91b6:	ca 01       	movw	r24, r20
    91b8:	0e 94 ec 42 	call	0x85d8	; 0x85d8 <get_bit>
    91bc:	f6 01       	movw	r30, r12
    91be:	91 83       	std	Z+1, r25	; 0x01
    91c0:	80 83       	st	Z, r24
		return (str-p); // not finished yet
    91c2:	a9 81       	ldd	r26, Y+1	; 0x01
    91c4:	ba 81       	ldd	r27, Y+2	; 0x02
    91c6:	aa 19       	sub	r26, r10
    91c8:	bb 09       	sbc	r27, r11
    91ca:	2c c0       	rjmp	.+88     	; 0x9224 <get_special+0x222>
	case sROM: // ROM(x)
		{
		int i=0; // x
		if (*str=='(') 
    91cc:	e9 81       	ldd	r30, Y+1	; 0x01
    91ce:	fa 81       	ldd	r31, Y+2	; 0x02
    91d0:	80 81       	ld	r24, Z
    91d2:	88 32       	cpi	r24, 0x28	; 40
    91d4:	99 f4       	brne	.+38     	; 0x91fc <get_special+0x1fa>
		{   //(Addr)
			str++;
    91d6:	31 96       	adiw	r30, 0x01	; 1
    91d8:	fa 83       	std	Y+2, r31	; 0x02
    91da:	e9 83       	std	Y+1, r30	; 0x01
			i=getNum(&str);
    91dc:	c7 01       	movw	r24, r14
    91de:	0e 94 9e 42 	call	0x853c	; 0x853c <getNum>
    91e2:	9c 01       	movw	r18, r24
			if (*str==')')
    91e4:	e9 81       	ldd	r30, Y+1	; 0x01
    91e6:	fa 81       	ldd	r31, Y+2	; 0x02
    91e8:	80 81       	ld	r24, Z
    91ea:	89 32       	cpi	r24, 0x29	; 41
    91ec:	39 f4       	brne	.+14     	; 0x91fc <get_special+0x1fa>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    91ee:	e1 99       	sbic	0x1c, 1	; 28
    91f0:	fe cf       	rjmp	.-4      	; 0x91ee <get_special+0x1ec>
#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    91f2:	20 50       	subi	r18, 0x00	; 0
    91f4:	30 40       	sbci	r19, 0x00	; 0
    91f6:	3f bb       	out	0x1f, r19	; 31
    91f8:	2e bb       	out	0x1e, r18	; 30
    91fa:	83 cf       	rjmp	.-250    	; 0x9102 <get_special+0x100>
			{
				v = eeprom_read_byte((uint8_t*)(FIRMWARE+i));
    91fc:	80 e0       	ldi	r24, 0x00	; 0
    91fe:	90 e0       	ldi	r25, 0x00	; 0
		}
		break;
	default:
		return -1;
	}
	*res=v;
    9200:	f6 01       	movw	r30, r12
    9202:	91 83       	std	Z+1, r25	; 0x01
    9204:	80 83       	st	Z, r24
	t=strlen(specials[t]);
    9206:	d8 01       	movw	r26, r16
    9208:	aa 0f       	add	r26, r26
    920a:	bb 1f       	adc	r27, r27
    920c:	a9 5a       	subi	r26, 0xA9	; 169
    920e:	bb 4f       	sbci	r27, 0xFB	; 251
    9210:	ec 91       	ld	r30, X
    9212:	11 96       	adiw	r26, 0x01	; 1
    9214:	fc 91       	ld	r31, X
    9216:	df 01       	movw	r26, r30
    9218:	0d 90       	ld	r0, X+
    921a:	00 20       	and	r0, r0
    921c:	e9 f7       	brne	.-6      	; 0x9218 <get_special+0x216>
    921e:	11 97       	sbiw	r26, 0x01	; 1
    9220:	ae 1b       	sub	r26, r30
    9222:	bf 0b       	sbc	r27, r31
	return t;
}
    9224:	cd 01       	movw	r24, r26
    9226:	0f 90       	pop	r0
    9228:	0f 90       	pop	r0
    922a:	cf 91       	pop	r28
    922c:	df 91       	pop	r29
    922e:	1f 91       	pop	r17
    9230:	0f 91       	pop	r16
    9232:	ff 90       	pop	r15
    9234:	ef 90       	pop	r14
    9236:	df 90       	pop	r13
    9238:	cf 90       	pop	r12
    923a:	bf 90       	pop	r11
    923c:	af 90       	pop	r10
    923e:	08 95       	ret

00009240 <eval_expr>:
/*

*/

unsigned char eval_expr(char **str, int *res)
{
    9240:	2f 92       	push	r2
    9242:	3f 92       	push	r3
    9244:	4f 92       	push	r4
    9246:	5f 92       	push	r5
    9248:	6f 92       	push	r6
    924a:	7f 92       	push	r7
    924c:	8f 92       	push	r8
    924e:	9f 92       	push	r9
    9250:	af 92       	push	r10
    9252:	bf 92       	push	r11
    9254:	cf 92       	push	r12
    9256:	df 92       	push	r13
    9258:	ef 92       	push	r14
    925a:	ff 92       	push	r15
    925c:	0f 93       	push	r16
    925e:	1f 93       	push	r17
    9260:	df 93       	push	r29
    9262:	cf 93       	push	r28
    9264:	cd b7       	in	r28, 0x3d	; 61
    9266:	de b7       	in	r29, 0x3e	; 62
    9268:	63 97       	sbiw	r28, 0x13	; 19
    926a:	0f b6       	in	r0, 0x3f	; 63
    926c:	f8 94       	cli
    926e:	de bf       	out	0x3e, r29	; 62
    9270:	0f be       	out	0x3f, r0	; 63
    9272:	cd bf       	out	0x3d, r28	; 61
    9274:	7c 01       	movw	r14, r24
    9276:	2b 01       	movw	r4, r22
	char c;
	
	int n1=0;
    9278:	1a 82       	std	Y+2, r1	; 0x02
    927a:	19 82       	std	Y+1, r1	; 0x01
	int stack[MAX_DEPTH]; 
	char ops[MAX_DEPTH];
	
	int sp=0;
	int op=0;
	int tmp=0;
    927c:	1c 82       	std	Y+4, r1	; 0x04
    927e:	1b 82       	std	Y+3, r1	; 0x03
    9280:	00 e0       	ldi	r16, 0x00	; 0
    9282:	10 e0       	ldi	r17, 0x00	; 0
    9284:	cc 24       	eor	r12, r12
    9286:	dd 24       	eor	r13, r13
    9288:	aa 24       	eor	r10, r10
    928a:	bb 24       	eor	r11, r11
		case '%' :
		case ':' :
			if (c=='>' && **str=='=') {c='g'; (*str)++;}
			if (c=='<' && **str=='=') {c='l'; (*str)++;}
			if (c=='<' && **str=='>') {c='n'; (*str)++;}
			ops[op++]=c;
    928c:	f5 e0       	ldi	r31, 0x05	; 5
    928e:	2f 2e       	mov	r2, r31
    9290:	31 2c       	mov	r3, r1
    9292:	2c 0e       	add	r2, r28
    9294:	3d 1e       	adc	r3, r29
			stack[sp++]=n1;
    9296:	4e 01       	movw	r8, r28
    9298:	08 94       	sec
    929a:	81 1c       	adc	r8, r1
    929c:	91 1c       	adc	r9, r1
		}
		else
		switch (c)
		{
		case '(':
			eval_expr(str, &tmp);
    929e:	e3 e0       	ldi	r30, 0x03	; 3
    92a0:	6e 2e       	mov	r6, r30
    92a2:	71 2c       	mov	r7, r1
    92a4:	6c 0e       	add	r6, r28
    92a6:	7d 1e       	adc	r7, r29
    92a8:	b1 c0       	rjmp	.+354    	; 0x940c <eval_expr+0x1cc>
	int tmp=0;
	int done=0;
	
	while (**str != '\0' && !done)
	{
		if ((c = **str)==')')
    92aa:	49 32       	cpi	r20, 0x29	; 41
    92ac:	09 f4       	brne	.+2      	; 0x92b0 <eval_expr+0x70>
    92ae:	b8 c0       	rjmp	.+368    	; 0x9420 <eval_expr+0x1e0>
			break;
		
		(*str)++;
    92b0:	9f 01       	movw	r18, r30
    92b2:	2f 5f       	subi	r18, 0xFF	; 255
    92b4:	3f 4f       	sbci	r19, 0xFF	; 255
    92b6:	d7 01       	movw	r26, r14
    92b8:	2d 93       	st	X+, r18
    92ba:	3c 93       	st	X, r19

		if (c>='0' && c<='9')
    92bc:	84 2f       	mov	r24, r20
    92be:	80 53       	subi	r24, 0x30	; 48
    92c0:	8a 30       	cpi	r24, 0x0A	; 10
    92c2:	98 f4       	brcc	.+38     	; 0x92ea <eval_expr+0xaa>
		{
			n1 = n1*10 + c - '0';
    92c4:	89 81       	ldd	r24, Y+1	; 0x01
    92c6:	9a 81       	ldd	r25, Y+2	; 0x02
    92c8:	9c 01       	movw	r18, r24
    92ca:	73 e0       	ldi	r23, 0x03	; 3
    92cc:	22 0f       	add	r18, r18
    92ce:	33 1f       	adc	r19, r19
    92d0:	7a 95       	dec	r23
    92d2:	e1 f7       	brne	.-8      	; 0x92cc <eval_expr+0x8c>
    92d4:	88 0f       	add	r24, r24
    92d6:	99 1f       	adc	r25, r25
    92d8:	28 0f       	add	r18, r24
    92da:	39 1f       	adc	r19, r25
    92dc:	20 53       	subi	r18, 0x30	; 48
    92de:	30 40       	sbci	r19, 0x00	; 0
    92e0:	24 0f       	add	r18, r20
    92e2:	31 1d       	adc	r19, r1
    92e4:	3a 83       	std	Y+2, r19	; 0x02
    92e6:	29 83       	std	Y+1, r18	; 0x01
    92e8:	91 c0       	rjmp	.+290    	; 0x940c <eval_expr+0x1cc>
		}
		else
		if (c>='A' && c<='Z')
    92ea:	84 2f       	mov	r24, r20
    92ec:	81 54       	subi	r24, 0x41	; 65
    92ee:	8a 31       	cpi	r24, 0x1A	; 26
    92f0:	58 f4       	brcc	.+22     	; 0x9308 <eval_expr+0xc8>
		{
			n1 = variable[c-'A'];
    92f2:	e4 2f       	mov	r30, r20
    92f4:	f0 e0       	ldi	r31, 0x00	; 0
    92f6:	ee 0f       	add	r30, r30
    92f8:	ff 1f       	adc	r31, r31
    92fa:	e5 5c       	subi	r30, 0xC5	; 197
    92fc:	f2 4f       	sbci	r31, 0xF2	; 242
    92fe:	80 81       	ld	r24, Z
    9300:	91 81       	ldd	r25, Z+1	; 0x01
    9302:	9a 83       	std	Y+2, r25	; 0x02
    9304:	89 83       	std	Y+1, r24	; 0x01
    9306:	82 c0       	rjmp	.+260    	; 0x940c <eval_expr+0x1cc>
		}
		else
		switch (c)
    9308:	4c 32       	cpi	r20, 0x2C	; 44
    930a:	a0 f4       	brcc	.+40     	; 0x9334 <eval_expr+0xf4>
    930c:	4a 32       	cpi	r20, 0x2A	; 42
    930e:	88 f5       	brcc	.+98     	; 0x9372 <eval_expr+0x132>
    9310:	44 32       	cpi	r20, 0x24	; 36
    9312:	09 f4       	brne	.+2      	; 0x9316 <eval_expr+0xd6>
    9314:	63 c0       	rjmp	.+198    	; 0x93dc <eval_expr+0x19c>
    9316:	45 32       	cpi	r20, 0x25	; 37
    9318:	38 f4       	brcc	.+14     	; 0x9328 <eval_expr+0xe8>
    931a:	40 32       	cpi	r20, 0x20	; 32
    931c:	09 f4       	brne	.+2      	; 0x9320 <eval_expr+0xe0>
    931e:	76 c0       	rjmp	.+236    	; 0x940c <eval_expr+0x1cc>
    9320:	42 32       	cpi	r20, 0x22	; 34
    9322:	09 f0       	breq	.+2      	; 0x9326 <eval_expr+0xe6>
    9324:	6d c0       	rjmp	.+218    	; 0x9400 <eval_expr+0x1c0>
    9326:	16 c0       	rjmp	.+44     	; 0x9354 <eval_expr+0x114>
    9328:	45 32       	cpi	r20, 0x25	; 37
    932a:	19 f1       	breq	.+70     	; 0x9372 <eval_expr+0x132>
    932c:	48 32       	cpi	r20, 0x28	; 40
    932e:	09 f0       	breq	.+2      	; 0x9332 <eval_expr+0xf2>
    9330:	67 c0       	rjmp	.+206    	; 0x9400 <eval_expr+0x1c0>
    9332:	12 c0       	rjmp	.+36     	; 0x9358 <eval_expr+0x118>
    9334:	4a 33       	cpi	r20, 0x3A	; 58
    9336:	e9 f0       	breq	.+58     	; 0x9372 <eval_expr+0x132>
    9338:	4b 33       	cpi	r20, 0x3B	; 59
    933a:	30 f4       	brcc	.+12     	; 0x9348 <eval_expr+0x108>
    933c:	4d 32       	cpi	r20, 0x2D	; 45
    933e:	c9 f0       	breq	.+50     	; 0x9372 <eval_expr+0x132>
    9340:	4f 32       	cpi	r20, 0x2F	; 47
    9342:	09 f0       	breq	.+2      	; 0x9346 <eval_expr+0x106>
    9344:	5d c0       	rjmp	.+186    	; 0x9400 <eval_expr+0x1c0>
    9346:	15 c0       	rjmp	.+42     	; 0x9372 <eval_expr+0x132>
    9348:	84 2f       	mov	r24, r20
    934a:	8c 53       	subi	r24, 0x3C	; 60
    934c:	84 30       	cpi	r24, 0x04	; 4
    934e:	08 f0       	brcs	.+2      	; 0x9352 <eval_expr+0x112>
    9350:	57 c0       	rjmp	.+174    	; 0x9400 <eval_expr+0x1c0>
    9352:	0f c0       	rjmp	.+30     	; 0x9372 <eval_expr+0x132>
    9354:	80 e0       	ldi	r24, 0x00	; 0
    9356:	f9 c0       	rjmp	.+498    	; 0x954a <eval_expr+0x30a>
		{
		case '(':
			eval_expr(str, &tmp);
    9358:	b3 01       	movw	r22, r6
    935a:	c7 01       	movw	r24, r14
    935c:	0e 94 20 49 	call	0x9240	; 0x9240 <eval_expr>
			n1 = tmp;
    9360:	8b 81       	ldd	r24, Y+3	; 0x03
    9362:	9c 81       	ldd	r25, Y+4	; 0x04
    9364:	9a 83       	std	Y+2, r25	; 0x02
    9366:	89 83       	std	Y+1, r24	; 0x01
			(*str)++;
    9368:	f7 01       	movw	r30, r14
    936a:	80 81       	ld	r24, Z
    936c:	91 81       	ldd	r25, Z+1	; 0x01
    936e:	01 96       	adiw	r24, 0x01	; 1
    9370:	44 c0       	rjmp	.+136    	; 0x93fa <eval_expr+0x1ba>
		case '>' :
		case '<' :
		case '=' :
		case '%' :
		case ':' :
			if (c=='>' && **str=='=') {c='g'; (*str)++;}
    9372:	4e 33       	cpi	r20, 0x3E	; 62
    9374:	51 f4       	brne	.+20     	; 0x938a <eval_expr+0x14a>
    9376:	81 81       	ldd	r24, Z+1	; 0x01
    9378:	8d 33       	cpi	r24, 0x3D	; 61
    937a:	d9 f4       	brne	.+54     	; 0x93b2 <eval_expr+0x172>
    937c:	2f 5f       	subi	r18, 0xFF	; 255
    937e:	3f 4f       	sbci	r19, 0xFF	; 255
    9380:	d7 01       	movw	r26, r14
    9382:	2d 93       	st	X+, r18
    9384:	3c 93       	st	X, r19
    9386:	47 e6       	ldi	r20, 0x67	; 103
    9388:	14 c0       	rjmp	.+40     	; 0x93b2 <eval_expr+0x172>
			if (c=='<' && **str=='=') {c='l'; (*str)++;}
    938a:	4c 33       	cpi	r20, 0x3C	; 60
    938c:	91 f4       	brne	.+36     	; 0x93b2 <eval_expr+0x172>
    938e:	81 81       	ldd	r24, Z+1	; 0x01
    9390:	8d 33       	cpi	r24, 0x3D	; 61
    9392:	39 f4       	brne	.+14     	; 0x93a2 <eval_expr+0x162>
    9394:	2f 5f       	subi	r18, 0xFF	; 255
    9396:	3f 4f       	sbci	r19, 0xFF	; 255
    9398:	f7 01       	movw	r30, r14
    939a:	31 83       	std	Z+1, r19	; 0x01
    939c:	20 83       	st	Z, r18
    939e:	4c e6       	ldi	r20, 0x6C	; 108
    93a0:	08 c0       	rjmp	.+16     	; 0x93b2 <eval_expr+0x172>
			if (c=='<' && **str=='>') {c='n'; (*str)++;}
    93a2:	8e 33       	cpi	r24, 0x3E	; 62
    93a4:	31 f4       	brne	.+12     	; 0x93b2 <eval_expr+0x172>
    93a6:	2f 5f       	subi	r18, 0xFF	; 255
    93a8:	3f 4f       	sbci	r19, 0xFF	; 255
    93aa:	d7 01       	movw	r26, r14
    93ac:	2d 93       	st	X+, r18
    93ae:	3c 93       	st	X, r19
    93b0:	4e e6       	ldi	r20, 0x6E	; 110
			ops[op++]=c;
    93b2:	f1 01       	movw	r30, r2
    93b4:	ec 0d       	add	r30, r12
    93b6:	fd 1d       	adc	r31, r13
    93b8:	40 83       	st	Z, r20
    93ba:	08 94       	sec
    93bc:	c1 1c       	adc	r12, r1
    93be:	d1 1c       	adc	r13, r1
			stack[sp++]=n1;
    93c0:	f8 01       	movw	r30, r16
    93c2:	ee 0f       	add	r30, r30
    93c4:	ff 1f       	adc	r31, r31
    93c6:	e8 0d       	add	r30, r8
    93c8:	f9 1d       	adc	r31, r9
    93ca:	89 81       	ldd	r24, Y+1	; 0x01
    93cc:	9a 81       	ldd	r25, Y+2	; 0x02
    93ce:	92 87       	std	Z+10, r25	; 0x0a
    93d0:	81 87       	std	Z+9, r24	; 0x09
    93d2:	0f 5f       	subi	r16, 0xFF	; 255
    93d4:	1f 4f       	sbci	r17, 0xFF	; 255
			n1=0;
    93d6:	1a 82       	std	Y+2, r1	; 0x02
    93d8:	19 82       	std	Y+1, r1	; 0x01
    93da:	18 c0       	rjmp	.+48     	; 0x940c <eval_expr+0x1cc>
			return STRING;
		case ' ':
			break; //ignore sp
		case '$':
			//special var?
			if ((tmp=get_special(*str, &n1))>0) 
    93dc:	b4 01       	movw	r22, r8
    93de:	c9 01       	movw	r24, r18
    93e0:	0e 94 01 48 	call	0x9002	; 0x9002 <get_special>
    93e4:	9c 01       	movw	r18, r24
    93e6:	9c 83       	std	Y+4, r25	; 0x04
    93e8:	8b 83       	std	Y+3, r24	; 0x03
    93ea:	18 16       	cp	r1, r24
    93ec:	19 06       	cpc	r1, r25
    93ee:	74 f4       	brge	.+28     	; 0x940c <eval_expr+0x1cc>
			{
				*str += tmp;
    93f0:	f7 01       	movw	r30, r14
    93f2:	80 81       	ld	r24, Z
    93f4:	91 81       	ldd	r25, Z+1	; 0x01
    93f6:	82 0f       	add	r24, r18
    93f8:	93 1f       	adc	r25, r19
    93fa:	91 83       	std	Z+1, r25	; 0x01
    93fc:	80 83       	st	Z, r24
    93fe:	06 c0       	rjmp	.+12     	; 0x940c <eval_expr+0x1cc>
			}
			break;
		default:
			done=1;
			(*str)--;
    9400:	d7 01       	movw	r26, r14
    9402:	ed 93       	st	X+, r30
    9404:	fc 93       	st	X, r31
    9406:	31 e0       	ldi	r19, 0x01	; 1
    9408:	a3 2e       	mov	r10, r19
    940a:	b1 2c       	mov	r11, r1
	int sp=0;
	int op=0;
	int tmp=0;
	int done=0;
	
	while (**str != '\0' && !done)
    940c:	d7 01       	movw	r26, r14
    940e:	ed 91       	ld	r30, X+
    9410:	fc 91       	ld	r31, X
    9412:	40 81       	ld	r20, Z
    9414:	44 23       	and	r20, r20
    9416:	21 f0       	breq	.+8      	; 0x9420 <eval_expr+0x1e0>
    9418:	a1 14       	cp	r10, r1
    941a:	b1 04       	cpc	r11, r1
    941c:	09 f4       	brne	.+2      	; 0x9420 <eval_expr+0x1e0>
    941e:	45 cf       	rjmp	.-374    	; 0x92aa <eval_expr+0x6a>
			done=1;
			(*str)--;
		}
	}

	stack[sp++] = n1;
    9420:	f8 01       	movw	r30, r16
    9422:	ee 0f       	add	r30, r30
    9424:	ff 1f       	adc	r31, r31
    9426:	9e 01       	movw	r18, r28
    9428:	2f 5f       	subi	r18, 0xFF	; 255
    942a:	3f 4f       	sbci	r19, 0xFF	; 255
    942c:	e2 0f       	add	r30, r18
    942e:	f3 1f       	adc	r31, r19
    9430:	89 81       	ldd	r24, Y+1	; 0x01
    9432:	9a 81       	ldd	r25, Y+2	; 0x02
    9434:	92 87       	std	Z+10, r25	; 0x0a
    9436:	81 87       	std	Z+9, r24	; 0x09
    9438:	b8 01       	movw	r22, r16
    943a:	6f 5f       	subi	r22, 0xFF	; 255
    943c:	7f 4f       	sbci	r23, 0xFF	; 255

	while (op>0) {
		if (ops[op-1]==':')
    943e:	95 e0       	ldi	r25, 0x05	; 5
    9440:	69 2e       	mov	r6, r25
    9442:	71 2c       	mov	r7, r1
    9444:	6c 0e       	add	r6, r28
    9446:	7d 1e       	adc	r7, r29
				return ERROR; 
			}
		}
		else
		{
			stack[sp-2] = math(stack[sp-2],stack[sp-1],ops[op-1]);
    9448:	59 01       	movw	r10, r18
	stack[sp++] = n1;

	while (op>0) {
		if (ops[op-1]==':')
		{
			if (op > 1 && ops[op - 2] == '?' && sp>2)
    944a:	83 e0       	ldi	r24, 0x03	; 3
    944c:	88 2e       	mov	r8, r24
    944e:	91 2c       	mov	r9, r1
    9450:	8c 0e       	add	r8, r28
    9452:	9d 1e       	adc	r9, r29
    9454:	70 c0       	rjmp	.+224    	; 0x9536 <eval_expr+0x2f6>
	}

	stack[sp++] = n1;

	while (op>0) {
		if (ops[op-1]==':')
    9456:	96 01       	movw	r18, r12
    9458:	21 50       	subi	r18, 0x01	; 1
    945a:	30 40       	sbci	r19, 0x00	; 0
    945c:	f3 01       	movw	r30, r6
    945e:	e2 0f       	add	r30, r18
    9460:	f3 1f       	adc	r31, r19
    9462:	40 81       	ld	r20, Z
    9464:	4a 33       	cpi	r20, 0x3A	; 58
    9466:	09 f0       	breq	.+2      	; 0x946a <eval_expr+0x22a>
    9468:	46 c0       	rjmp	.+140    	; 0x94f6 <eval_expr+0x2b6>
		{
			if (op > 1 && ops[op - 2] == '?' && sp>2)
    946a:	b1 e0       	ldi	r27, 0x01	; 1
    946c:	cb 16       	cp	r12, r27
    946e:	d1 04       	cpc	r13, r1
    9470:	61 f1       	breq	.+88     	; 0x94ca <eval_expr+0x28a>
    9472:	f4 01       	movw	r30, r8
    9474:	ec 0d       	add	r30, r12
    9476:	fd 1d       	adc	r31, r13
    9478:	80 81       	ld	r24, Z
    947a:	8f 33       	cpi	r24, 0x3F	; 63
    947c:	31 f5       	brne	.+76     	; 0x94ca <eval_expr+0x28a>
    947e:	63 30       	cpi	r22, 0x03	; 3
    9480:	71 05       	cpc	r23, r1
    9482:	1c f1       	brlt	.+70     	; 0x94ca <eval_expr+0x28a>
			{
				if (stack[sp - 3] == 0)
    9484:	db 01       	movw	r26, r22
    9486:	13 97       	sbiw	r26, 0x03	; 3
    9488:	aa 0f       	add	r26, r26
    948a:	bb 1f       	adc	r27, r27
    948c:	aa 0d       	add	r26, r10
    948e:	bb 1d       	adc	r27, r11
    9490:	19 96       	adiw	r26, 0x09	; 9
    9492:	8d 91       	ld	r24, X+
    9494:	9c 91       	ld	r25, X
    9496:	1a 97       	sbiw	r26, 0x0a	; 10
    9498:	89 2b       	or	r24, r25
    949a:	19 f4       	brne	.+6      	; 0x94a2 <eval_expr+0x262>
					stack[sp - 3] = stack[sp - 1];
    949c:	fb 01       	movw	r30, r22
    949e:	31 97       	sbiw	r30, 0x01	; 1
    94a0:	02 c0       	rjmp	.+4      	; 0x94a6 <eval_expr+0x266>
				else
					stack[sp - 3] = stack[sp - 2];
    94a2:	fb 01       	movw	r30, r22
    94a4:	32 97       	sbiw	r30, 0x02	; 2
    94a6:	ee 0f       	add	r30, r30
    94a8:	ff 1f       	adc	r31, r31
    94aa:	ea 0d       	add	r30, r10
    94ac:	fb 1d       	adc	r31, r11
    94ae:	81 85       	ldd	r24, Z+9	; 0x09
    94b0:	92 85       	ldd	r25, Z+10	; 0x0a
    94b2:	1a 96       	adiw	r26, 0x0a	; 10
    94b4:	9c 93       	st	X, r25
    94b6:	8e 93       	st	-X, r24
    94b8:	19 97       	sbiw	r26, 0x09	; 9
				op--;
				sp-=2;
    94ba:	be ef       	ldi	r27, 0xFE	; 254
    94bc:	eb 2e       	mov	r14, r27
    94be:	bf ef       	ldi	r27, 0xFF	; 255
    94c0:	fb 2e       	mov	r15, r27
    94c2:	e6 0e       	add	r14, r22
    94c4:	f7 1e       	adc	r15, r23
    94c6:	69 01       	movw	r12, r18
    94c8:	32 c0       	rjmp	.+100    	; 0x952e <eval_expr+0x2ee>
			}
			else
			{
				rprintf("eval error %d, %d\r\n", op, sp);
    94ca:	7f 93       	push	r23
    94cc:	6f 93       	push	r22
    94ce:	df 92       	push	r13
    94d0:	cf 92       	push	r12
    94d2:	81 e8       	ldi	r24, 0x81	; 129
    94d4:	9d e3       	ldi	r25, 0x3D	; 61
    94d6:	9f 93       	push	r25
    94d8:	8f 93       	push	r24
    94da:	81 e0       	ldi	r24, 0x01	; 1
    94dc:	8f 93       	push	r24
    94de:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
    94e2:	82 e0       	ldi	r24, 0x02	; 2
    94e4:	ed b7       	in	r30, 0x3d	; 61
    94e6:	fe b7       	in	r31, 0x3e	; 62
    94e8:	37 96       	adiw	r30, 0x07	; 7
    94ea:	0f b6       	in	r0, 0x3f	; 63
    94ec:	f8 94       	cli
    94ee:	fe bf       	out	0x3e, r31	; 62
    94f0:	0f be       	out	0x3f, r0	; 63
    94f2:	ed bf       	out	0x3d, r30	; 61
    94f4:	2a c0       	rjmp	.+84     	; 0x954a <eval_expr+0x30a>
				return ERROR; 
			}
		}
		else
		{
			stack[sp-2] = math(stack[sp-2],stack[sp-1],ops[op-1]);
    94f6:	7b 01       	movw	r14, r22
    94f8:	08 94       	sec
    94fa:	e1 08       	sbc	r14, r1
    94fc:	f1 08       	sbc	r15, r1
    94fe:	8b 01       	movw	r16, r22
    9500:	02 50       	subi	r16, 0x02	; 2
    9502:	10 40       	sbci	r17, 0x00	; 0
    9504:	f7 01       	movw	r30, r14
    9506:	ee 0f       	add	r30, r30
    9508:	ff 1f       	adc	r31, r31
    950a:	ea 0d       	add	r30, r10
    950c:	fb 1d       	adc	r31, r11
    950e:	61 85       	ldd	r22, Z+9	; 0x09
    9510:	72 85       	ldd	r23, Z+10	; 0x0a
    9512:	00 0f       	add	r16, r16
    9514:	11 1f       	adc	r17, r17
    9516:	0a 0d       	add	r16, r10
    9518:	1b 1d       	adc	r17, r11
    951a:	d8 01       	movw	r26, r16
    951c:	19 96       	adiw	r26, 0x09	; 9
    951e:	8d 91       	ld	r24, X+
    9520:	9c 91       	ld	r25, X
    9522:	1a 97       	sbiw	r26, 0x0a	; 10
    9524:	0e 94 24 43 	call	0x8648	; 0x8648 <math>
    9528:	f8 01       	movw	r30, r16
    952a:	92 87       	std	Z+10, r25	; 0x0a
    952c:	81 87       	std	Z+9, r24	; 0x09
			sp--;
		}
		op--;
    952e:	08 94       	sec
    9530:	c1 08       	sbc	r12, r1
    9532:	d1 08       	sbc	r13, r1
    9534:	b7 01       	movw	r22, r14
		}
	}

	stack[sp++] = n1;

	while (op>0) {
    9536:	1c 14       	cp	r1, r12
    9538:	1d 04       	cpc	r1, r13
    953a:	0c f4       	brge	.+2      	; 0x953e <eval_expr+0x2fe>
    953c:	8c cf       	rjmp	.-232    	; 0x9456 <eval_expr+0x216>
			sp--;
		}
		op--;
	}

	*res = stack[0];
    953e:	8a 85       	ldd	r24, Y+10	; 0x0a
    9540:	9b 85       	ldd	r25, Y+11	; 0x0b
    9542:	d2 01       	movw	r26, r4
    9544:	8d 93       	st	X+, r24
    9546:	9c 93       	st	X, r25
    9548:	81 e0       	ldi	r24, 0x01	; 1
	return NUMBER;
}
    954a:	63 96       	adiw	r28, 0x13	; 19
    954c:	0f b6       	in	r0, 0x3f	; 63
    954e:	f8 94       	cli
    9550:	de bf       	out	0x3e, r29	; 62
    9552:	0f be       	out	0x3f, r0	; 63
    9554:	cd bf       	out	0x3d, r28	; 61
    9556:	cf 91       	pop	r28
    9558:	df 91       	pop	r29
    955a:	1f 91       	pop	r17
    955c:	0f 91       	pop	r16
    955e:	ff 90       	pop	r15
    9560:	ef 90       	pop	r14
    9562:	df 90       	pop	r13
    9564:	cf 90       	pop	r12
    9566:	bf 90       	pop	r11
    9568:	af 90       	pop	r10
    956a:	9f 90       	pop	r9
    956c:	8f 90       	pop	r8
    956e:	7f 90       	pop	r7
    9570:	6f 90       	pop	r6
    9572:	5f 90       	pop	r5
    9574:	4f 90       	pop	r4
    9576:	3f 90       	pop	r3
    9578:	2f 90       	pop	r2
    957a:	08 95       	ret

0000957c <basic_load>:
//   Convert into tokens
//   Store in Eprom
// Loop

void basic_load()
{
    957c:	2f 92       	push	r2
    957e:	3f 92       	push	r3
    9580:	4f 92       	push	r4
    9582:	5f 92       	push	r5
    9584:	6f 92       	push	r6
    9586:	7f 92       	push	r7
    9588:	8f 92       	push	r8
    958a:	9f 92       	push	r9
    958c:	af 92       	push	r10
    958e:	bf 92       	push	r11
    9590:	cf 92       	push	r12
    9592:	df 92       	push	r13
    9594:	ef 92       	push	r14
    9596:	ff 92       	push	r15
    9598:	0f 93       	push	r16
    959a:	1f 93       	push	r17
    959c:	df 93       	push	r29
    959e:	cf 93       	push	r28
    95a0:	cd b7       	in	r28, 0x3d	; 61
    95a2:	de b7       	in	r29, 0x3e	; 62
    95a4:	c2 59       	subi	r28, 0x92	; 146
    95a6:	d0 40       	sbci	r29, 0x00	; 0
    95a8:	0f b6       	in	r0, 0x3f	; 63
    95aa:	f8 94       	cli
    95ac:	de bf       	out	0x3e, r29	; 62
    95ae:	0f be       	out	0x3f, r0	; 63
    95b0:	cd bf       	out	0x3d, r28	; 61
	rprintfStr("Enter Program '.' to Finish\r\n");
    95b2:	89 ef       	ldi	r24, 0xF9	; 249
    95b4:	92 e0       	ldi	r25, 0x02	; 2
    95b6:	0e 94 f9 29 	call	0x53f2	; 0x53f2 <rprintfStr>
	int n=0;
	int lc=0;
//	int i=0;
	char *cp;
	
	errno=0;
    95ba:	10 92 bc 0d 	sts	0x0DBC, r1
    95be:	10 92 bb 0d 	sts	0x0DBB, r1
    95c2:	44 24       	eor	r4, r4
    95c4:	55 24       	eor	r5, r5
    95c6:	88 24       	eor	r8, r8
    95c8:	99 24       	eor	r9, r9
    95ca:	66 24       	eor	r6, r6
    95cc:	77 24       	eor	r7, r7

		if (errno > 0 && errno<6) {
			rprintfStr ("Error - '" );
			rprintfStr (error_msgs[errno]);
			rprintfStr ("'\r\n" );
			rprintf ("Pos=%d [%c]\r\n", (cp-line), line[cp-line]);
    95ce:	9e 01       	movw	r18, r28
    95d0:	21 5c       	subi	r18, 0xC1	; 193
    95d2:	3f 4f       	sbci	r19, 0xFF	; 255
    95d4:	cf 56       	subi	r28, 0x6F	; 111
    95d6:	df 4f       	sbci	r29, 0xFF	; 255
    95d8:	39 83       	std	Y+1, r19	; 0x01
    95da:	28 83       	st	Y, r18
    95dc:	c1 59       	subi	r28, 0x91	; 145
    95de:	d0 40       	sbci	r29, 0x00	; 0
			
		newline.lineno = getNum(&cp) ;
		
		if (cp>line+n || *cp  !=' ') 
		{
			errno=1;
    95e0:	01 e0       	ldi	r16, 0x01	; 1
    95e2:	20 2e       	mov	r2, r16
    95e4:	31 2c       	mov	r3, r1
	
	while (1)
	{
		// for each line entered

		if (errno > 0 && errno<6) {
    95e6:	20 91 bb 0d 	lds	r18, 0x0DBB
    95ea:	30 91 bc 0d 	lds	r19, 0x0DBC
    95ee:	c9 01       	movw	r24, r18
    95f0:	01 97       	sbiw	r24, 0x01	; 1
    95f2:	05 97       	sbiw	r24, 0x05	; 5
    95f4:	d0 f5       	brcc	.+116    	; 0x966a <basic_load+0xee>
			rprintfStr ("Error - '" );
    95f6:	87 e1       	ldi	r24, 0x17	; 23
    95f8:	93 e0       	ldi	r25, 0x03	; 3
    95fa:	0e 94 f9 29 	call	0x53f2	; 0x53f2 <rprintfStr>
			rprintfStr (error_msgs[errno]);
    95fe:	e0 91 bb 0d 	lds	r30, 0x0DBB
    9602:	f0 91 bc 0d 	lds	r31, 0x0DBC
    9606:	ee 0f       	add	r30, r30
    9608:	ff 1f       	adc	r31, r31
    960a:	e3 56       	subi	r30, 0x63	; 99
    960c:	fc 4f       	sbci	r31, 0xFC	; 252
    960e:	80 81       	ld	r24, Z
    9610:	91 81       	ldd	r25, Z+1	; 0x01
    9612:	0e 94 f9 29 	call	0x53f2	; 0x53f2 <rprintfStr>
			rprintfStr ("'\r\n" );
    9616:	81 e2       	ldi	r24, 0x21	; 33
    9618:	93 e0       	ldi	r25, 0x03	; 3
    961a:	0e 94 f9 29 	call	0x53f2	; 0x53f2 <rprintfStr>
			rprintf ("Pos=%d [%c]\r\n", (cp-line), line[cp-line]);
    961e:	e9 81       	ldd	r30, Y+1	; 0x01
    9620:	fa 81       	ldd	r31, Y+2	; 0x02
    9622:	9f 01       	movw	r18, r30
    9624:	cf 56       	subi	r28, 0x6F	; 111
    9626:	df 4f       	sbci	r29, 0xFF	; 255
    9628:	88 81       	ld	r24, Y
    962a:	99 81       	ldd	r25, Y+1	; 0x01
    962c:	c1 59       	subi	r28, 0x91	; 145
    962e:	d0 40       	sbci	r29, 0x00	; 0
    9630:	28 1b       	sub	r18, r24
    9632:	39 0b       	sbc	r19, r25
    9634:	80 81       	ld	r24, Z
    9636:	90 e0       	ldi	r25, 0x00	; 0
    9638:	9f 93       	push	r25
    963a:	8f 93       	push	r24
    963c:	3f 93       	push	r19
    963e:	2f 93       	push	r18
    9640:	a2 ed       	ldi	r26, 0xD2	; 210
    9642:	bd e3       	ldi	r27, 0x3D	; 61
    9644:	bf 93       	push	r27
    9646:	af 93       	push	r26
    9648:	b1 e0       	ldi	r27, 0x01	; 1
    964a:	bf 93       	push	r27
    964c:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
			errno=0;
    9650:	10 92 bc 0d 	sts	0x0DBC, r1
    9654:	10 92 bb 0d 	sts	0x0DBB, r1
    9658:	ed b7       	in	r30, 0x3d	; 61
    965a:	fe b7       	in	r31, 0x3e	; 62
    965c:	37 96       	adiw	r30, 0x07	; 7
    965e:	0f b6       	in	r0, 0x3f	; 63
    9660:	f8 94       	cli
    9662:	fe bf       	out	0x3e, r31	; 62
    9664:	0f be       	out	0x3f, r0	; 63
    9666:	ed bf       	out	0x3d, r30	; 61
    9668:	13 c0       	rjmp	.+38     	; 0x9690 <basic_load+0x114>
		}
		else if (errno!=0)
    966a:	21 15       	cp	r18, r1
    966c:	31 05       	cpc	r19, r1
    966e:	81 f0       	breq	.+32     	; 0x9690 <basic_load+0x114>
		{
			rprintf ("Panic %d\r\n", errno);
    9670:	3f 93       	push	r19
    9672:	2f 93       	push	r18
    9674:	87 ec       	ldi	r24, 0xC7	; 199
    9676:	9d e3       	ldi	r25, 0x3D	; 61
    9678:	9f 93       	push	r25
    967a:	8f 93       	push	r24
    967c:	81 e0       	ldi	r24, 0x01	; 1
    967e:	8f 93       	push	r24
    9680:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
    9684:	0f 90       	pop	r0
    9686:	0f 90       	pop	r0
    9688:	0f 90       	pop	r0
    968a:	0f 90       	pop	r0
    968c:	0f 90       	pop	r0
    968e:	dd c2       	rjmp	.+1466   	; 0x9c4a <basic_load+0x6ce>
			return;
		}

		cp=&line[0];				
    9690:	2f e3       	ldi	r18, 0x3F	; 63
    9692:	30 e0       	ldi	r19, 0x00	; 0
    9694:	2c 0f       	add	r18, r28
    9696:	3d 1f       	adc	r19, r29
    9698:	3a 83       	std	Y+2, r19	; 0x02
    969a:	29 83       	std	Y+1, r18	; 0x01
		n=readLine(cp);
    969c:	c9 01       	movw	r24, r18
    969e:	0e 94 2a 47 	call	0x8e54	; 0x8e54 <readLine>
    96a2:	7c 01       	movw	r14, r24
		
		if ( line[0] =='.' && n==1)
    96a4:	8f ad       	ldd	r24, Y+63	; 0x3f
    96a6:	8e 32       	cpi	r24, 0x2E	; 46
    96a8:	e9 f4       	brne	.+58     	; 0x96e4 <basic_load+0x168>
    96aa:	31 e0       	ldi	r19, 0x01	; 1
    96ac:	e3 16       	cp	r14, r19
    96ae:	f1 04       	cpc	r15, r1
    96b0:	c9 f4       	brne	.+50     	; 0x96e4 <basic_load+0x168>
		{
			rprintf("\r\n%d lines entered, [%d/%d] Bytes\r\n", lc, psize, EEPROM_MEM_SZ);
    96b2:	80 e0       	ldi	r24, 0x00	; 0
    96b4:	94 e0       	ldi	r25, 0x04	; 4
    96b6:	9f 93       	push	r25
    96b8:	8f 93       	push	r24
    96ba:	9f 92       	push	r9
    96bc:	8f 92       	push	r8
    96be:	5f 92       	push	r5
    96c0:	4f 92       	push	r4
    96c2:	83 ea       	ldi	r24, 0xA3	; 163
    96c4:	9d e3       	ldi	r25, 0x3D	; 61
    96c6:	9f 93       	push	r25
    96c8:	8f 93       	push	r24
    96ca:	81 e0       	ldi	r24, 0x01	; 1
    96cc:	8f 93       	push	r24
    96ce:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
    96d2:	8d b7       	in	r24, 0x3d	; 61
    96d4:	9e b7       	in	r25, 0x3e	; 62
    96d6:	09 96       	adiw	r24, 0x09	; 9
    96d8:	0f b6       	in	r0, 0x3f	; 63
    96da:	f8 94       	cli
    96dc:	9e bf       	out	0x3e, r25	; 62
    96de:	0f be       	out	0x3f, r0	; 63
    96e0:	8d bf       	out	0x3d, r24	; 61
    96e2:	b3 c2       	rjmp	.+1382   	; 0x9c4a <basic_load+0x6ce>
			return;
		}
		
		if (n==0) continue; //ignore blank lines
    96e4:	e1 14       	cp	r14, r1
    96e6:	f1 04       	cpc	r15, r1
    96e8:	09 f4       	brne	.+2      	; 0x96ec <basic_load+0x170>
    96ea:	7d cf       	rjmp	.-262    	; 0x95e6 <basic_load+0x6a>
		
		newline.var=0;
		newline.value=0;
		newline.text=0;
			
		newline.lineno = getNum(&cp) ;
    96ec:	ce 01       	movw	r24, r28
    96ee:	01 96       	adiw	r24, 0x01	; 1
    96f0:	0e 94 9e 42 	call	0x853c	; 0x853c <getNum>
    96f4:	c1 57       	subi	r28, 0x71	; 113
    96f6:	df 4f       	sbci	r29, 0xFF	; 255
    96f8:	99 83       	std	Y+1, r25	; 0x01
    96fa:	88 83       	st	Y, r24
    96fc:	cf 58       	subi	r28, 0x8F	; 143
    96fe:	d0 40       	sbci	r29, 0x00	; 0
		
		if (cp>line+n || *cp  !=' ') 
    9700:	e9 81       	ldd	r30, Y+1	; 0x01
    9702:	fa 81       	ldd	r31, Y+2	; 0x02
    9704:	af e3       	ldi	r26, 0x3F	; 63
    9706:	b0 e0       	ldi	r27, 0x00	; 0
    9708:	ac 0f       	add	r26, r28
    970a:	bd 1f       	adc	r27, r29
    970c:	ea 0e       	add	r14, r26
    970e:	fb 1e       	adc	r15, r27
    9710:	ee 16       	cp	r14, r30
    9712:	ff 06       	cpc	r15, r31
    9714:	18 f0       	brcs	.+6      	; 0x971c <basic_load+0x1a0>
    9716:	80 81       	ld	r24, Z
    9718:	80 32       	cpi	r24, 0x20	; 32
    971a:	29 f0       	breq	.+10     	; 0x9726 <basic_load+0x1aa>
		{
			errno=1;
    971c:	30 92 bc 0d 	sts	0x0DBC, r3
    9720:	20 92 bb 0d 	sts	0x0DBB, r2
    9724:	60 cf       	rjmp	.-320    	; 0x95e6 <basic_load+0x6a>
			continue;
		}
		cp++;
    9726:	31 96       	adiw	r30, 0x01	; 1
    9728:	fa 83       	std	Y+2, r31	; 0x02
    972a:	e9 83       	std	Y+1, r30	; 0x01
		//int token_match(char *list[], char **p_line, int n)
		//if ( (newline.token=token_match(tokens, &cp, sizeof(tokens)))<0)
		if ( (newline.token=token_match((char **)tokens, &cp, sizeof(tokens)))<0)
    972c:	46 e2       	ldi	r20, 0x26	; 38
    972e:	50 e0       	ldi	r21, 0x00	; 0
    9730:	be 01       	movw	r22, r28
    9732:	6f 5f       	subi	r22, 0xFF	; 255
    9734:	7f 4f       	sbci	r23, 0xFF	; 255
    9736:	8d ef       	ldi	r24, 0xFD	; 253
    9738:	93 e0       	ldi	r25, 0x03	; 3
    973a:	0e 94 9a 47 	call	0x8f34	; 0x8f34 <token_match>
    973e:	a8 2e       	mov	r10, r24
		{
			errno=2;
			continue;
		}
			
		cp++;
    9740:	c9 80       	ldd	r12, Y+1	; 0x01
    9742:	da 80       	ldd	r13, Y+2	; 0x02
    9744:	d6 01       	movw	r26, r12
    9746:	11 96       	adiw	r26, 0x01	; 1
    9748:	ba 83       	std	Y+2, r27	; 0x02
    974a:	a9 83       	std	Y+1, r26	; 0x01
		
		switch (newline.token)
    974c:	e8 2f       	mov	r30, r24
    974e:	f0 e0       	ldi	r31, 0x00	; 0
    9750:	e3 31       	cpi	r30, 0x13	; 19
    9752:	f1 05       	cpc	r31, r1
    9754:	08 f0       	brcs	.+2      	; 0x9758 <basic_load+0x1dc>
    9756:	de c1       	rjmp	.+956    	; 0x9b14 <basic_load+0x598>
    9758:	ea 5b       	subi	r30, 0xBA	; 186
    975a:	ff 4f       	sbci	r31, 0xFF	; 255
    975c:	ee 0f       	add	r30, r30
    975e:	ff 1f       	adc	r31, r31
    9760:	05 90       	lpm	r0, Z+
    9762:	f4 91       	lpm	r31, Z+
    9764:	e0 2d       	mov	r30, r0
    9766:	09 94       	ijmp
int errno;

//next no space char
char getNext(char **p_line) 
{
	char c1=**p_line;
    9768:	2c 91       	ld	r18, X
    976a:	07 c0       	rjmp	.+14     	; 0x977a <basic_load+0x1fe>
	
	while (c1 == ' ' )
	{
		(*p_line)++;
    976c:	e9 81       	ldd	r30, Y+1	; 0x01
    976e:	fa 81       	ldd	r31, Y+2	; 0x02
    9770:	31 96       	adiw	r30, 0x01	; 1
    9772:	fa 83       	std	Y+2, r31	; 0x02
    9774:	e9 83       	std	Y+1, r30	; 0x01
    9776:	31 97       	sbiw	r30, 0x01	; 1
		c1=**p_line;
    9778:	21 81       	ldd	r18, Z+1	; 0x01
//next no space char
char getNext(char **p_line) 
{
	char c1=**p_line;
	
	while (c1 == ' ' )
    977a:	20 32       	cpi	r18, 0x20	; 32
    977c:	b9 f3       	breq	.-18     	; 0x976c <basic_load+0x1f0>
	{
		(*p_line)++;
		c1=**p_line;
	}
	if (c1 != '\0') (*p_line)++;
    977e:	22 23       	and	r18, r18
    9780:	29 f0       	breq	.+10     	; 0x978c <basic_load+0x210>
    9782:	89 81       	ldd	r24, Y+1	; 0x01
    9784:	9a 81       	ldd	r25, Y+2	; 0x02
    9786:	01 96       	adiw	r24, 0x01	; 1
    9788:	9a 83       	std	Y+2, r25	; 0x02
    978a:	89 83       	std	Y+1, r24	; 0x01
// More complex later
int getVar(char **p_line) 
{
	char c1=getNext(p_line);
	
	if (c1>='A' && c1<= 'Z' )
    978c:	82 2f       	mov	r24, r18
    978e:	81 54       	subi	r24, 0x41	; 65
    9790:	8a 31       	cpi	r24, 0x1A	; 26
    9792:	18 f0       	brcs	.+6      	; 0x979a <basic_load+0x21e>
    9794:	8f ef       	ldi	r24, 0xFF	; 255
    9796:	9f ef       	ldi	r25, 0xFF	; 255
    9798:	04 c0       	rjmp	.+8      	; 0x97a2 <basic_load+0x226>
	{
		return c1-'A';
    979a:	82 2f       	mov	r24, r18
    979c:	90 e0       	ldi	r25, 0x00	; 0
    979e:	81 54       	subi	r24, 0x41	; 65
    97a0:	90 40       	sbci	r25, 0x00	; 0
		{
		case LET: 
		case GET: 
		case FOR:
			// read Variable		
			if ((newline.var = getVar(&cp))<0)
    97a2:	b8 2e       	mov	r11, r24
int errno;

//next no space char
char getNext(char **p_line) 
{
	char c1=**p_line;
    97a4:	e9 81       	ldd	r30, Y+1	; 0x01
    97a6:	fa 81       	ldd	r31, Y+2	; 0x02
    97a8:	e0 81       	ld	r30, Z
    97aa:	07 c0       	rjmp	.+14     	; 0x97ba <basic_load+0x23e>
	
	while (c1 == ' ' )
	{
		(*p_line)++;
    97ac:	e9 81       	ldd	r30, Y+1	; 0x01
    97ae:	fa 81       	ldd	r31, Y+2	; 0x02
    97b0:	31 96       	adiw	r30, 0x01	; 1
    97b2:	fa 83       	std	Y+2, r31	; 0x02
    97b4:	e9 83       	std	Y+1, r30	; 0x01
    97b6:	31 97       	sbiw	r30, 0x01	; 1
		c1=**p_line;
    97b8:	e1 81       	ldd	r30, Z+1	; 0x01
//next no space char
char getNext(char **p_line) 
{
	char c1=**p_line;
	
	while (c1 == ' ' )
    97ba:	e0 32       	cpi	r30, 0x20	; 32
    97bc:	b9 f3       	breq	.-18     	; 0x97ac <basic_load+0x230>
	{
		(*p_line)++;
		c1=**p_line;
	}
	if (c1 != '\0') (*p_line)++;
    97be:	ee 23       	and	r30, r30
    97c0:	39 f0       	breq	.+14     	; 0x97d0 <basic_load+0x254>
    97c2:	89 81       	ldd	r24, Y+1	; 0x01
    97c4:	9a 81       	ldd	r25, Y+2	; 0x02
    97c6:	01 96       	adiw	r24, 0x01	; 1
    97c8:	9a 83       	std	Y+2, r25	; 0x02
    97ca:	89 83       	std	Y+1, r24	; 0x01
			if ((newline.var = getVar(&cp))<0)
			{
				errno=3;
			}
			// '='
			if (getNext(&cp) != '=')
    97cc:	ed 33       	cpi	r30, 0x3D	; 61
    97ce:	21 f0       	breq	.+8      	; 0x97d8 <basic_load+0x25c>
			{
				errno=1;
    97d0:	30 92 bc 0d 	sts	0x0DBC, r3
    97d4:	20 92 bb 0d 	sts	0x0DBB, r2
    97d8:	29 81       	ldd	r18, Y+1	; 0x01
    97da:	3a 81       	ldd	r19, Y+2	; 0x02
			}
			// expression
			if (newline.token==FOR)
    97dc:	b1 e0       	ldi	r27, 0x01	; 1
    97de:	ab 16       	cp	r10, r27
    97e0:	39 f5       	brne	.+78     	; 0x9830 <basic_load+0x2b4>
			{
				char *to = strstr(cp," TO ");
    97e2:	65 e2       	ldi	r22, 0x25	; 37
    97e4:	73 e0       	ldi	r23, 0x03	; 3
    97e6:	c9 01       	movw	r24, r18
    97e8:	0e 94 94 6d 	call	0xdb28	; 0xdb28 <strstr>
    97ec:	fc 01       	movw	r30, r24
				if (to==0) errno=1;
    97ee:	00 97       	sbiw	r24, 0x00	; 0
    97f0:	29 f4       	brne	.+10     	; 0x97fc <basic_load+0x280>
    97f2:	30 92 bc 0d 	sts	0x0DBC, r3
    97f6:	20 92 bb 0d 	sts	0x0DBB, r2
    97fa:	89 c1       	rjmp	.+786    	; 0x9b0e <basic_load+0x592>
				else
				{
					*to='\0'; // null terminate expr1
    97fc:	10 82       	st	Z, r1
					newline.text=cp;
    97fe:	c9 80       	ldd	r12, Y+1	; 0x01
    9800:	da 80       	ldd	r13, Y+2	; 0x02
					strcpy(forbuf[fb++],to+4); // store expr2
    9802:	24 e1       	ldi	r18, 0x14	; 20
    9804:	30 e0       	ldi	r19, 0x00	; 0
    9806:	62 9e       	mul	r6, r18
    9808:	c0 01       	movw	r24, r0
    980a:	63 9e       	mul	r6, r19
    980c:	90 0d       	add	r25, r0
    980e:	72 9e       	mul	r7, r18
    9810:	90 0d       	add	r25, r0
    9812:	11 24       	eor	r1, r1
    9814:	08 94       	sec
    9816:	61 1c       	adc	r6, r1
    9818:	71 1c       	adc	r7, r1
    981a:	34 96       	adiw	r30, 0x04	; 4
    981c:	bf 01       	movw	r22, r30
    981e:	a3 e0       	ldi	r26, 0x03	; 3
    9820:	b0 e0       	ldi	r27, 0x00	; 0
    9822:	ac 0f       	add	r26, r28
    9824:	bd 1f       	adc	r27, r29
    9826:	8a 0f       	add	r24, r26
    9828:	9b 1f       	adc	r25, r27
    982a:	0e 94 8d 6d 	call	0xdb1a	; 0xdb1a <strcpy>
    982e:	02 c0       	rjmp	.+4      	; 0x9834 <basic_load+0x2b8>
				}
			}
			else
				newline.text=cp;
    9830:	c9 01       	movw	r24, r18
    9832:	6c 01       	movw	r12, r24
    9834:	00 e0       	ldi	r16, 0x00	; 0
    9836:	10 e0       	ldi	r17, 0x00	; 0
    9838:	78 c1       	rjmp	.+752    	; 0x9b2a <basic_load+0x5ae>
			break;
		case POKE: 
		    //poke address, byte
			newline.var = getNum(&cp);
    983a:	ce 01       	movw	r24, r28
    983c:	01 96       	adiw	r24, 0x01	; 1
    983e:	0e 94 9e 42 	call	0x853c	; 0x853c <getNum>
    9842:	28 2f       	mov	r18, r24
int errno;

//next no space char
char getNext(char **p_line) 
{
	char c1=**p_line;
    9844:	e9 81       	ldd	r30, Y+1	; 0x01
    9846:	fa 81       	ldd	r31, Y+2	; 0x02
    9848:	e0 81       	ld	r30, Z
    984a:	07 c0       	rjmp	.+14     	; 0x985a <basic_load+0x2de>
	
	while (c1 == ' ' )
	{
		(*p_line)++;
    984c:	e9 81       	ldd	r30, Y+1	; 0x01
    984e:	fa 81       	ldd	r31, Y+2	; 0x02
    9850:	31 96       	adiw	r30, 0x01	; 1
    9852:	fa 83       	std	Y+2, r31	; 0x02
    9854:	e9 83       	std	Y+1, r30	; 0x01
    9856:	31 97       	sbiw	r30, 0x01	; 1
		c1=**p_line;
    9858:	e1 81       	ldd	r30, Z+1	; 0x01
//next no space char
char getNext(char **p_line) 
{
	char c1=**p_line;
	
	while (c1 == ' ' )
    985a:	e0 32       	cpi	r30, 0x20	; 32
    985c:	b9 f3       	breq	.-18     	; 0x984c <basic_load+0x2d0>
	{
		(*p_line)++;
		c1=**p_line;
	}
	if (c1 != '\0') (*p_line)++;
    985e:	ee 23       	and	r30, r30
    9860:	09 f4       	brne	.+2      	; 0x9864 <basic_load+0x2e8>
    9862:	c9 c0       	rjmp	.+402    	; 0x99f6 <basic_load+0x47a>
    9864:	89 81       	ldd	r24, Y+1	; 0x01
    9866:	9a 81       	ldd	r25, Y+2	; 0x02
    9868:	01 96       	adiw	r24, 0x01	; 1
    986a:	9a 83       	std	Y+2, r25	; 0x02
    986c:	89 83       	std	Y+1, r24	; 0x01
				newline.text=cp;
			break;
		case POKE: 
		    //poke address, byte
			newline.var = getNum(&cp);
			if (getNext(&cp) != ',')
    986e:	ec 32       	cpi	r30, 0x2C	; 44
    9870:	09 f4       	brne	.+2      	; 0x9874 <basic_load+0x2f8>
    9872:	c5 c0       	rjmp	.+394    	; 0x99fe <basic_load+0x482>
    9874:	c0 c0       	rjmp	.+384    	; 0x99f6 <basic_load+0x47a>
				errno=1;
			}			
			newline.text=cp;
			break;
		case PUT: 
			if ((newline.var = token_match(specials, &cp, sizeof(specials)))<0)
    9876:	4e e1       	ldi	r20, 0x1E	; 30
    9878:	50 e0       	ldi	r21, 0x00	; 0
    987a:	be 01       	movw	r22, r28
    987c:	6f 5f       	subi	r22, 0xFF	; 255
    987e:	7f 4f       	sbci	r23, 0xFF	; 255
    9880:	87 e5       	ldi	r24, 0x57	; 87
    9882:	94 e0       	ldi	r25, 0x04	; 4
    9884:	0e 94 9a 47 	call	0x8f34	; 0x8f34 <token_match>
    9888:	b8 2e       	mov	r11, r24
			{
				errno=3;
			}
			
			if (newline.var == sPORT)
    988a:	bc e0       	ldi	r27, 0x0C	; 12
    988c:	8b 17       	cp	r24, r27
    988e:	09 f0       	breq	.+2      	; 0x9892 <basic_load+0x316>
    9890:	7c c0       	rjmp	.+248    	; 0x998a <basic_load+0x40e>
int errno;

//next no space char
char getNext(char **p_line) 
{
	char c1=**p_line;
    9892:	e9 81       	ldd	r30, Y+1	; 0x01
    9894:	fa 81       	ldd	r31, Y+2	; 0x02
    9896:	e0 81       	ld	r30, Z
    9898:	07 c0       	rjmp	.+14     	; 0x98a8 <basic_load+0x32c>
	
	while (c1 == ' ' )
	{
		(*p_line)++;
    989a:	e9 81       	ldd	r30, Y+1	; 0x01
    989c:	fa 81       	ldd	r31, Y+2	; 0x02
    989e:	31 96       	adiw	r30, 0x01	; 1
    98a0:	fa 83       	std	Y+2, r31	; 0x02
    98a2:	e9 83       	std	Y+1, r30	; 0x01
    98a4:	31 97       	sbiw	r30, 0x01	; 1
		c1=**p_line;
    98a6:	e1 81       	ldd	r30, Z+1	; 0x01
//next no space char
char getNext(char **p_line) 
{
	char c1=**p_line;
	
	while (c1 == ' ' )
    98a8:	e0 32       	cpi	r30, 0x20	; 32
    98aa:	b9 f3       	breq	.-18     	; 0x989a <basic_load+0x31e>
	{
		(*p_line)++;
		c1=**p_line;
	}
	if (c1 != '\0') (*p_line)++;
    98ac:	ee 23       	and	r30, r30
    98ae:	39 f0       	breq	.+14     	; 0x98be <basic_load+0x342>
    98b0:	89 81       	ldd	r24, Y+1	; 0x01
    98b2:	9a 81       	ldd	r25, Y+2	; 0x02
    98b4:	01 96       	adiw	r24, 0x01	; 1
    98b6:	9a 83       	std	Y+2, r25	; 0x02
    98b8:	89 83       	std	Y+1, r24	; 0x01
				errno=3;
			}
			
			if (newline.var == sPORT)
			{
				if (getNext(&cp) != ':')
    98ba:	ea 33       	cpi	r30, 0x3A	; 58
    98bc:	31 f0       	breq	.+12     	; 0x98ca <basic_load+0x34e>
				{
					errno=3;
    98be:	83 e0       	ldi	r24, 0x03	; 3
    98c0:	90 e0       	ldi	r25, 0x00	; 0
    98c2:	90 93 bc 0d 	sts	0x0DBC, r25
    98c6:	80 93 bb 0d 	sts	0x0DBB, r24
int errno;

//next no space char
char getNext(char **p_line) 
{
	char c1=**p_line;
    98ca:	e9 81       	ldd	r30, Y+1	; 0x01
    98cc:	fa 81       	ldd	r31, Y+2	; 0x02
    98ce:	20 81       	ld	r18, Z
    98d0:	07 c0       	rjmp	.+14     	; 0x98e0 <basic_load+0x364>
	
	while (c1 == ' ' )
	{
		(*p_line)++;
    98d2:	e9 81       	ldd	r30, Y+1	; 0x01
    98d4:	fa 81       	ldd	r31, Y+2	; 0x02
    98d6:	31 96       	adiw	r30, 0x01	; 1
    98d8:	fa 83       	std	Y+2, r31	; 0x02
    98da:	e9 83       	std	Y+1, r30	; 0x01
    98dc:	31 97       	sbiw	r30, 0x01	; 1
		c1=**p_line;
    98de:	21 81       	ldd	r18, Z+1	; 0x01
//next no space char
char getNext(char **p_line) 
{
	char c1=**p_line;
	
	while (c1 == ' ' )
    98e0:	20 32       	cpi	r18, 0x20	; 32
    98e2:	b9 f3       	breq	.-18     	; 0x98d2 <basic_load+0x356>
	{
		(*p_line)++;
		c1=**p_line;
	}
	if (c1 != '\0') (*p_line)++;
    98e4:	22 23       	and	r18, r18
    98e6:	29 f0       	breq	.+10     	; 0x98f2 <basic_load+0x376>
    98e8:	89 81       	ldd	r24, Y+1	; 0x01
    98ea:	9a 81       	ldd	r25, Y+2	; 0x02
    98ec:	01 96       	adiw	r24, 0x01	; 1
    98ee:	9a 83       	std	Y+2, r25	; 0x02
    98f0:	89 83       	std	Y+1, r24	; 0x01
					errno=3;
				}	

				char pn = getNext(&cp) ;
				
				if (pn<'A' || pn >'G') 
    98f2:	82 2f       	mov	r24, r18
    98f4:	81 54       	subi	r24, 0x41	; 65
    98f6:	87 30       	cpi	r24, 0x07	; 7
    98f8:	30 f0       	brcs	.+12     	; 0x9906 <basic_load+0x38a>
				{
					errno=3;
    98fa:	83 e0       	ldi	r24, 0x03	; 3
    98fc:	90 e0       	ldi	r25, 0x00	; 0
    98fe:	90 93 bc 0d 	sts	0x0DBC, r25
    9902:	80 93 bb 0d 	sts	0x0DBB, r24
int errno;

//next no space char
char getNext(char **p_line) 
{
	char c1=**p_line;
    9906:	e9 81       	ldd	r30, Y+1	; 0x01
    9908:	fa 81       	ldd	r31, Y+2	; 0x02
    990a:	e0 81       	ld	r30, Z
    990c:	07 c0       	rjmp	.+14     	; 0x991c <basic_load+0x3a0>
	
	while (c1 == ' ' )
	{
		(*p_line)++;
    990e:	e9 81       	ldd	r30, Y+1	; 0x01
    9910:	fa 81       	ldd	r31, Y+2	; 0x02
    9912:	31 96       	adiw	r30, 0x01	; 1
    9914:	fa 83       	std	Y+2, r31	; 0x02
    9916:	e9 83       	std	Y+1, r30	; 0x01
    9918:	31 97       	sbiw	r30, 0x01	; 1
		c1=**p_line;
    991a:	e1 81       	ldd	r30, Z+1	; 0x01
//next no space char
char getNext(char **p_line) 
{
	char c1=**p_line;
	
	while (c1 == ' ' )
    991c:	e0 32       	cpi	r30, 0x20	; 32
    991e:	b9 f3       	breq	.-18     	; 0x990e <basic_load+0x392>
	{
		(*p_line)++;
		c1=**p_line;
	}
	if (c1 != '\0') (*p_line)++;
    9920:	ee 23       	and	r30, r30
    9922:	39 f0       	breq	.+14     	; 0x9932 <basic_load+0x3b6>
    9924:	89 81       	ldd	r24, Y+1	; 0x01
    9926:	9a 81       	ldd	r25, Y+2	; 0x02
    9928:	01 96       	adiw	r24, 0x01	; 1
    992a:	9a 83       	std	Y+2, r25	; 0x02
    992c:	89 83       	std	Y+1, r24	; 0x01
				if (pn<'A' || pn >'G') 
				{
					errno=3;
				}
				
				if (getNext(&cp) != ':')
    992e:	ea 33       	cpi	r30, 0x3A	; 58
    9930:	31 f0       	breq	.+12     	; 0x993e <basic_load+0x3c2>
				{
					errno=3;
    9932:	83 e0       	ldi	r24, 0x03	; 3
    9934:	90 e0       	ldi	r25, 0x00	; 0
    9936:	90 93 bc 0d 	sts	0x0DBC, r25
    993a:	80 93 bb 0d 	sts	0x0DBB, r24
int errno;

//next no space char
char getNext(char **p_line) 
{
	char c1=**p_line;
    993e:	e9 81       	ldd	r30, Y+1	; 0x01
    9940:	fa 81       	ldd	r31, Y+2	; 0x02
    9942:	e0 81       	ld	r30, Z
    9944:	07 c0       	rjmp	.+14     	; 0x9954 <basic_load+0x3d8>
	
	while (c1 == ' ' )
	{
		(*p_line)++;
    9946:	e9 81       	ldd	r30, Y+1	; 0x01
    9948:	fa 81       	ldd	r31, Y+2	; 0x02
    994a:	31 96       	adiw	r30, 0x01	; 1
    994c:	fa 83       	std	Y+2, r31	; 0x02
    994e:	e9 83       	std	Y+1, r30	; 0x01
    9950:	31 97       	sbiw	r30, 0x01	; 1
		c1=**p_line;
    9952:	e1 81       	ldd	r30, Z+1	; 0x01
//next no space char
char getNext(char **p_line) 
{
	char c1=**p_line;
	
	while (c1 == ' ' )
    9954:	e0 32       	cpi	r30, 0x20	; 32
    9956:	b9 f3       	breq	.-18     	; 0x9946 <basic_load+0x3ca>
	{
		(*p_line)++;
		c1=**p_line;
	}
	if (c1 != '\0') (*p_line)++;
    9958:	ee 23       	and	r30, r30
    995a:	29 f0       	breq	.+10     	; 0x9966 <basic_load+0x3ea>
    995c:	89 81       	ldd	r24, Y+1	; 0x01
    995e:	9a 81       	ldd	r25, Y+2	; 0x02
    9960:	01 96       	adiw	r24, 0x01	; 1
    9962:	9a 83       	std	Y+2, r25	; 0x02
    9964:	89 83       	std	Y+1, r24	; 0x01
					errno=3;
				}	
				
				char pb = getNext(&cp) ;
				
				if ((pb<'0' || pb >'8'))
    9966:	8e 2f       	mov	r24, r30
    9968:	80 53       	subi	r24, 0x30	; 48
    996a:	89 30       	cpi	r24, 0x09	; 9
    996c:	30 f0       	brcs	.+12     	; 0x997a <basic_load+0x3fe>
				{
					errno=3;
    996e:	83 e0       	ldi	r24, 0x03	; 3
    9970:	90 e0       	ldi	r25, 0x00	; 0
    9972:	90 93 bc 0d 	sts	0x0DBC, r25
    9976:	80 93 bb 0d 	sts	0x0DBB, r24
				}
				
				//Now have PORT:$pn:$pb
				
				newline.var = 30 + (pn-'A')*10 + (pb-'0') ;
    997a:	8a e0       	ldi	r24, 0x0A	; 10
    997c:	28 9f       	mul	r18, r24
    997e:	c0 01       	movw	r24, r0
    9980:	11 24       	eor	r1, r1
    9982:	b4 e6       	ldi	r27, 0x64	; 100
    9984:	bb 2e       	mov	r11, r27
    9986:	b8 0e       	add	r11, r24
    9988:	be 0e       	add	r11, r30
int errno;

//next no space char
char getNext(char **p_line) 
{
	char c1=**p_line;
    998a:	e9 81       	ldd	r30, Y+1	; 0x01
    998c:	fa 81       	ldd	r31, Y+2	; 0x02
    998e:	e0 81       	ld	r30, Z
    9990:	07 c0       	rjmp	.+14     	; 0x99a0 <basic_load+0x424>
	
	while (c1 == ' ' )
	{
		(*p_line)++;
    9992:	e9 81       	ldd	r30, Y+1	; 0x01
    9994:	fa 81       	ldd	r31, Y+2	; 0x02
    9996:	31 96       	adiw	r30, 0x01	; 1
    9998:	fa 83       	std	Y+2, r31	; 0x02
    999a:	e9 83       	std	Y+1, r30	; 0x01
    999c:	31 97       	sbiw	r30, 0x01	; 1
		c1=**p_line;
    999e:	e1 81       	ldd	r30, Z+1	; 0x01
//next no space char
char getNext(char **p_line) 
{
	char c1=**p_line;
	
	while (c1 == ' ' )
    99a0:	e0 32       	cpi	r30, 0x20	; 32
    99a2:	b9 f3       	breq	.-18     	; 0x9992 <basic_load+0x416>
	{
		(*p_line)++;
		c1=**p_line;
	}
	if (c1 != '\0') (*p_line)++;
    99a4:	ee 23       	and	r30, r30
    99a6:	39 f0       	breq	.+14     	; 0x99b6 <basic_load+0x43a>
    99a8:	89 81       	ldd	r24, Y+1	; 0x01
    99aa:	9a 81       	ldd	r25, Y+2	; 0x02
    99ac:	01 96       	adiw	r24, 0x01	; 1
    99ae:	9a 83       	std	Y+2, r25	; 0x02
    99b0:	89 83       	std	Y+1, r24	; 0x01
				newline.var = 30 + (pn-'A')*10 + (pb-'0') ;
				
				//rprintf("debug: %d %c %c \r\n", newline.var, pn, pb);
			}
			// '='
			if (getNext(&cp) != '=')
    99b2:	ed 33       	cpi	r30, 0x3D	; 61
    99b4:	81 f1       	breq	.+96     	; 0x9a16 <basic_load+0x49a>
			{
				errno=1;
    99b6:	30 92 bc 0d 	sts	0x0DBC, r3
    99ba:	20 92 bb 0d 	sts	0x0DBB, r2
    99be:	2b c0       	rjmp	.+86     	; 0x9a16 <basic_load+0x49a>
			newline.text=cp;
			break;

		case SERVO:
			// read servo ID		
			if ((newline.var = getNum(&cp))<0)
    99c0:	ce 01       	movw	r24, r28
    99c2:	01 96       	adiw	r24, 0x01	; 1
    99c4:	0e 94 9e 42 	call	0x853c	; 0x853c <getNum>
    99c8:	28 2f       	mov	r18, r24
int errno;

//next no space char
char getNext(char **p_line) 
{
	char c1=**p_line;
    99ca:	e9 81       	ldd	r30, Y+1	; 0x01
    99cc:	fa 81       	ldd	r31, Y+2	; 0x02
    99ce:	e0 81       	ld	r30, Z
    99d0:	07 c0       	rjmp	.+14     	; 0x99e0 <basic_load+0x464>
	
	while (c1 == ' ' )
	{
		(*p_line)++;
    99d2:	e9 81       	ldd	r30, Y+1	; 0x01
    99d4:	fa 81       	ldd	r31, Y+2	; 0x02
    99d6:	31 96       	adiw	r30, 0x01	; 1
    99d8:	fa 83       	std	Y+2, r31	; 0x02
    99da:	e9 83       	std	Y+1, r30	; 0x01
    99dc:	31 97       	sbiw	r30, 0x01	; 1
		c1=**p_line;
    99de:	e1 81       	ldd	r30, Z+1	; 0x01
//next no space char
char getNext(char **p_line) 
{
	char c1=**p_line;
	
	while (c1 == ' ' )
    99e0:	e0 32       	cpi	r30, 0x20	; 32
    99e2:	b9 f3       	breq	.-18     	; 0x99d2 <basic_load+0x456>
	{
		(*p_line)++;
		c1=**p_line;
	}
	if (c1 != '\0') (*p_line)++;
    99e4:	ee 23       	and	r30, r30
    99e6:	39 f0       	breq	.+14     	; 0x99f6 <basic_load+0x47a>
    99e8:	89 81       	ldd	r24, Y+1	; 0x01
    99ea:	9a 81       	ldd	r25, Y+2	; 0x02
    99ec:	01 96       	adiw	r24, 0x01	; 1
    99ee:	9a 83       	std	Y+2, r25	; 0x02
    99f0:	89 83       	std	Y+1, r24	; 0x01
			if ((newline.var = getNum(&cp))<0)
			{
				errno=3;
			}
			// '='
			if (getNext(&cp) != '=')
    99f2:	ed 33       	cpi	r30, 0x3D	; 61
    99f4:	21 f0       	breq	.+8      	; 0x99fe <basic_load+0x482>
			{
				errno=1;
    99f6:	30 92 bc 0d 	sts	0x0DBC, r3
    99fa:	20 92 bb 0d 	sts	0x0DBB, r2
			newline.text=cp;
			break;

		case SERVO:
			// read servo ID		
			if ((newline.var = getNum(&cp))<0)
    99fe:	b2 2e       	mov	r11, r18
    9a00:	0a c0       	rjmp	.+20     	; 0x9a16 <basic_load+0x49a>
				errno=1;
			}			
			newline.text=cp;
			break;
		case PRINT:
		    if (*cp=='#') { newline.var=1; cp++;}
    9a02:	8c 91       	ld	r24, X
    9a04:	83 32       	cpi	r24, 0x23	; 35
    9a06:	31 f4       	brne	.+12     	; 0x9a14 <basic_load+0x498>
    9a08:	11 96       	adiw	r26, 0x01	; 1
    9a0a:	ba 83       	std	Y+2, r27	; 0x02
    9a0c:	a9 83       	std	Y+1, r26	; 0x01
    9a0e:	bb 24       	eor	r11, r11
    9a10:	b3 94       	inc	r11
    9a12:	01 c0       	rjmp	.+2      	; 0x9a16 <basic_load+0x49a>
    9a14:	bb 24       	eor	r11, r11
		case MOVE:
		case SCENE:
			newline.text=cp;
    9a16:	c9 80       	ldd	r12, Y+1	; 0x01
    9a18:	da 80       	ldd	r13, Y+2	; 0x02
    9a1a:	0c cf       	rjmp	.-488    	; 0x9834 <basic_load+0x2b8>
			// We should check for THEN and ELSE
			// and handle error
			// replace THEN with ? and ELSE with :
			// IF A THEN B ELSE C =>  GOTO (A)?B:C
			newline.text=cp-1;
			*(cp-1)='(';
    9a1c:	28 e2       	ldi	r18, 0x28	; 40
    9a1e:	f6 01       	movw	r30, r12
    9a20:	20 83       	st	Z, r18
			char *p_then = strstr(cp, "THEN");
    9a22:	09 81       	ldd	r16, Y+1	; 0x01
    9a24:	1a 81       	ldd	r17, Y+2	; 0x02
    9a26:	6a e2       	ldi	r22, 0x2A	; 42
    9a28:	73 e0       	ldi	r23, 0x03	; 3
    9a2a:	c8 01       	movw	r24, r16
    9a2c:	0e 94 94 6d 	call	0xdb28	; 0xdb28 <strstr>
    9a30:	7c 01       	movw	r14, r24
			char *p_else = strstr(cp, "ELSE");
    9a32:	6f e2       	ldi	r22, 0x2F	; 47
    9a34:	73 e0       	ldi	r23, 0x03	; 3
    9a36:	c8 01       	movw	r24, r16
    9a38:	0e 94 94 6d 	call	0xdb28	; 0xdb28 <strstr>
    9a3c:	fc 01       	movw	r30, r24
			if (p_then != 0) 
    9a3e:	e1 14       	cp	r14, r1
    9a40:	f1 04       	cpc	r15, r1
    9a42:	59 f0       	breq	.+22     	; 0x9a5a <basic_load+0x4de>
				strncpy(p_then, ")?  ",4);
    9a44:	29 e2       	ldi	r18, 0x29	; 41
    9a46:	3f e3       	ldi	r19, 0x3F	; 63
    9a48:	40 e2       	ldi	r20, 0x20	; 32
    9a4a:	50 e2       	ldi	r21, 0x20	; 32
    9a4c:	d7 01       	movw	r26, r14
    9a4e:	2d 93       	st	X+, r18
    9a50:	3d 93       	st	X+, r19
    9a52:	4d 93       	st	X+, r20
    9a54:	5c 93       	st	X, r21
    9a56:	13 97       	sbiw	r26, 0x03	; 3
    9a58:	06 c0       	rjmp	.+12     	; 0x9a66 <basic_load+0x4ea>
			else
				errno=3;
    9a5a:	83 e0       	ldi	r24, 0x03	; 3
    9a5c:	90 e0       	ldi	r25, 0x00	; 0
    9a5e:	90 93 bc 0d 	sts	0x0DBC, r25
    9a62:	80 93 bb 0d 	sts	0x0DBB, r24
				
			if (p_else != 0) 
    9a66:	30 97       	sbiw	r30, 0x00	; 0
    9a68:	49 f0       	breq	.+18     	; 0x9a7c <basic_load+0x500>
				strncpy(p_else,":   ",4);
    9a6a:	8a e3       	ldi	r24, 0x3A	; 58
    9a6c:	90 e2       	ldi	r25, 0x20	; 32
    9a6e:	a0 e2       	ldi	r26, 0x20	; 32
    9a70:	b0 e2       	ldi	r27, 0x20	; 32
    9a72:	80 83       	st	Z, r24
    9a74:	91 83       	std	Z+1, r25	; 0x01
    9a76:	a2 83       	std	Z+2, r26	; 0x02
    9a78:	b3 83       	std	Z+3, r27	; 0x03
    9a7a:	54 c0       	rjmp	.+168    	; 0x9b24 <basic_load+0x5a8>
			else
				strcat(cp,":0");
    9a7c:	64 e3       	ldi	r22, 0x34	; 52
    9a7e:	73 e0       	ldi	r23, 0x03	; 3
    9a80:	89 81       	ldd	r24, Y+1	; 0x01
    9a82:	9a 81       	ldd	r25, Y+2	; 0x02
    9a84:	0e 94 79 6d 	call	0xdaf2	; 0xdaf2 <strcat>
    9a88:	4d c0       	rjmp	.+154    	; 0x9b24 <basic_load+0x5a8>
		case WAIT: 
		case GOTO: 
		case XACT:
		case GOSUB:
			// read line
			newline.value = getNum(&cp);			
    9a8a:	ce 01       	movw	r24, r28
    9a8c:	01 96       	adiw	r24, 0x01	; 1
    9a8e:	0e 94 9e 42 	call	0x853c	; 0x853c <getNum>
    9a92:	8c 01       	movw	r16, r24
    9a94:	cc 24       	eor	r12, r12
    9a96:	dd 24       	eor	r13, r13
    9a98:	47 c0       	rjmp	.+142    	; 0x9b28 <basic_load+0x5ac>
int errno;

//next no space char
char getNext(char **p_line) 
{
	char c1=**p_line;
    9a9a:	2c 91       	ld	r18, X
    9a9c:	07 c0       	rjmp	.+14     	; 0x9aac <basic_load+0x530>
	
	while (c1 == ' ' )
	{
		(*p_line)++;
    9a9e:	e9 81       	ldd	r30, Y+1	; 0x01
    9aa0:	fa 81       	ldd	r31, Y+2	; 0x02
    9aa2:	31 96       	adiw	r30, 0x01	; 1
    9aa4:	fa 83       	std	Y+2, r31	; 0x02
    9aa6:	e9 83       	std	Y+1, r30	; 0x01
    9aa8:	31 97       	sbiw	r30, 0x01	; 1
		c1=**p_line;
    9aaa:	21 81       	ldd	r18, Z+1	; 0x01
//next no space char
char getNext(char **p_line) 
{
	char c1=**p_line;
	
	while (c1 == ' ' )
    9aac:	20 32       	cpi	r18, 0x20	; 32
    9aae:	b9 f3       	breq	.-18     	; 0x9a9e <basic_load+0x522>
	{
		(*p_line)++;
		c1=**p_line;
	}
	if (c1 != '\0') (*p_line)++;
    9ab0:	22 23       	and	r18, r18
    9ab2:	29 f0       	breq	.+10     	; 0x9abe <basic_load+0x542>
    9ab4:	89 81       	ldd	r24, Y+1	; 0x01
    9ab6:	9a 81       	ldd	r25, Y+2	; 0x02
    9ab8:	01 96       	adiw	r24, 0x01	; 1
    9aba:	9a 83       	std	Y+2, r25	; 0x02
    9abc:	89 83       	std	Y+1, r24	; 0x01
// More complex later
int getVar(char **p_line) 
{
	char c1=getNext(p_line);
	
	if (c1>='A' && c1<= 'Z' )
    9abe:	82 2f       	mov	r24, r18
    9ac0:	81 54       	subi	r24, 0x41	; 65
    9ac2:	8a 31       	cpi	r24, 0x1A	; 26
    9ac4:	18 f0       	brcs	.+6      	; 0x9acc <basic_load+0x550>
    9ac6:	8f ef       	ldi	r24, 0xFF	; 255
    9ac8:	9f ef       	ldi	r25, 0xFF	; 255
    9aca:	04 c0       	rjmp	.+8      	; 0x9ad4 <basic_load+0x558>
	{
		return c1-'A';
    9acc:	82 2f       	mov	r24, r18
    9ace:	90 e0       	ldi	r25, 0x00	; 0
    9ad0:	81 54       	subi	r24, 0x41	; 65
    9ad2:	90 40       	sbci	r25, 0x00	; 0
		case END:
		case RETURN:
			newline.text=0;
			break;
		case NEXT:
			if ((newline.var = getVar(&cp))<0)
    9ad4:	b8 2e       	mov	r11, r24
			{
				errno=3;
			}
			if (fb>0) {
    9ad6:	61 14       	cp	r6, r1
    9ad8:	71 04       	cpc	r7, r1
    9ada:	99 f0       	breq	.+38     	; 0x9b02 <basic_load+0x586>
				newline.text=forbuf[--fb];
    9adc:	08 94       	sec
    9ade:	61 08       	sbc	r6, r1
    9ae0:	71 08       	sbc	r7, r1
    9ae2:	a4 e1       	ldi	r26, 0x14	; 20
    9ae4:	b0 e0       	ldi	r27, 0x00	; 0
    9ae6:	6a 9e       	mul	r6, r26
    9ae8:	60 01       	movw	r12, r0
    9aea:	6b 9e       	mul	r6, r27
    9aec:	d0 0c       	add	r13, r0
    9aee:	7a 9e       	mul	r7, r26
    9af0:	d0 0c       	add	r13, r0
    9af2:	11 24       	eor	r1, r1
    9af4:	e3 e0       	ldi	r30, 0x03	; 3
    9af6:	f0 e0       	ldi	r31, 0x00	; 0
    9af8:	ec 0f       	add	r30, r28
    9afa:	fd 1f       	adc	r31, r29
    9afc:	ce 0e       	add	r12, r30
    9afe:	df 1e       	adc	r13, r31
    9b00:	99 ce       	rjmp	.-718    	; 0x9834 <basic_load+0x2b8>
			} else {
				// next without FOR
				errno=5;
    9b02:	25 e0       	ldi	r18, 0x05	; 5
    9b04:	30 e0       	ldi	r19, 0x00	; 0
    9b06:	30 93 bc 0d 	sts	0x0DBC, r19
    9b0a:	20 93 bb 0d 	sts	0x0DBB, r18
    9b0e:	cc 24       	eor	r12, r12
    9b10:	dd 24       	eor	r13, r13
    9b12:	90 ce       	rjmp	.-736    	; 0x9834 <basic_load+0x2b8>
			}
			break;
		default:
			errno=2;
    9b14:	82 e0       	ldi	r24, 0x02	; 2
    9b16:	90 e0       	ldi	r25, 0x00	; 0
    9b18:	90 93 bc 0d 	sts	0x0DBC, r25
    9b1c:	80 93 bb 0d 	sts	0x0DBB, r24
    9b20:	cc 24       	eor	r12, r12
    9b22:	dd 24       	eor	r13, r13
    9b24:	00 e0       	ldi	r16, 0x00	; 0
    9b26:	10 e0       	ldi	r17, 0x00	; 0
    9b28:	bb 24       	eor	r11, r11
			break;
		}		
		
		// store struct in eeprom
		
		if (errno==0)
    9b2a:	80 91 bb 0d 	lds	r24, 0x0DBB
    9b2e:	90 91 bc 0d 	lds	r25, 0x0DBC
    9b32:	89 2b       	or	r24, r25
    9b34:	09 f0       	breq	.+2      	; 0x9b38 <basic_load+0x5bc>
    9b36:	57 cd       	rjmp	.-1362   	; 0x95e6 <basic_load+0x6a>
		{	
			lc++;
			if (psize==0)
    9b38:	81 14       	cp	r8, r1
    9b3a:	91 04       	cpc	r9, r1
    9b3c:	81 f4       	brne	.+32     	; 0x9b5e <basic_load+0x5e2>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    9b3e:	e1 99       	sbic	0x1c, 1	; 28
    9b40:	fe cf       	rjmp	.-4      	; 0x9b3e <basic_load+0x5c2>
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    9b42:	a1 e4       	ldi	r26, 0x41	; 65
    9b44:	b0 e0       	ldi	r27, 0x00	; 0
    9b46:	bf bb       	out	0x1f, r27	; 31
    9b48:	ae bb       	out	0x1e, r26	; 30
#endif
    EEDR = __value;
    9b4a:	ba ea       	ldi	r27, 0xAA	; 170
    9b4c:	bd bb       	out	0x1d, r27	; 29

    __asm__ __volatile__ (
    9b4e:	0f b6       	in	r0, 0x3f	; 63
    9b50:	f8 94       	cli
    9b52:	e2 9a       	sbi	0x1c, 2	; 28
    9b54:	e1 9a       	sbi	0x1c, 1	; 28
    9b56:	0f be       	out	0x3f, r0	; 63
    9b58:	a1 e0       	ldi	r26, 0x01	; 1
    9b5a:	8a 2e       	mov	r8, r26
    9b5c:	91 2c       	mov	r9, r1
/** \ingroup avr_eeprom
    Write a word \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_word (uint16_t *__p, uint16_t __value)
{
    __eewr_word (__p, __value, eeprom_write_byte);
    9b5e:	40 e2       	ldi	r20, 0x20	; 32
    9b60:	52 e4       	ldi	r21, 0x42	; 66
    9b62:	c1 57       	subi	r28, 0x71	; 113
    9b64:	df 4f       	sbci	r29, 0xFF	; 255
    9b66:	68 81       	ld	r22, Y
    9b68:	79 81       	ldd	r23, Y+1	; 0x01
    9b6a:	cf 58       	subi	r28, 0x8F	; 143
    9b6c:	d0 40       	sbci	r29, 0x00	; 0
    9b6e:	c4 01       	movw	r24, r8
    9b70:	8f 5b       	subi	r24, 0xBF	; 191
    9b72:	9f 4f       	sbci	r25, 0xFF	; 255
    9b74:	0e 94 fc 6d 	call	0xdbf8	; 0xdbf8 <__eewr_word>
				uint8_t data= 0xAA; // start of program byte		
				eeprom_write_byte(BASIC_PROG_SPACE, data);
				psize++;
			}
			eeprom_write_word((uint16_t *)(BASIC_PROG_SPACE+psize), newline.lineno);	
			psize+=2;
    9b78:	94 01       	movw	r18, r8
    9b7a:	2e 5f       	subi	r18, 0xFE	; 254
    9b7c:	3f 4f       	sbci	r19, 0xFF	; 255
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    9b7e:	e1 99       	sbic	0x1c, 1	; 28
    9b80:	fe cf       	rjmp	.-4      	; 0x9b7e <basic_load+0x602>
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    9b82:	c9 01       	movw	r24, r18
    9b84:	8f 5b       	subi	r24, 0xBF	; 191
    9b86:	9f 4f       	sbci	r25, 0xFF	; 255
    9b88:	9f bb       	out	0x1f, r25	; 31
    9b8a:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    9b8c:	ad ba       	out	0x1d, r10	; 29

    __asm__ __volatile__ (
    9b8e:	0f b6       	in	r0, 0x3f	; 63
    9b90:	f8 94       	cli
    9b92:	e2 9a       	sbi	0x1c, 2	; 28
    9b94:	e1 9a       	sbi	0x1c, 1	; 28
    9b96:	0f be       	out	0x3f, r0	; 63
			eeprom_write_byte(BASIC_PROG_SPACE+psize, newline.token);	
			psize++;		
    9b98:	79 01       	movw	r14, r18
    9b9a:	08 94       	sec
    9b9c:	e1 1c       	adc	r14, r1
    9b9e:	f1 1c       	adc	r15, r1
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    9ba0:	e1 99       	sbic	0x1c, 1	; 28
    9ba2:	fe cf       	rjmp	.-4      	; 0x9ba0 <basic_load+0x624>
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    9ba4:	c7 01       	movw	r24, r14
    9ba6:	8f 5b       	subi	r24, 0xBF	; 191
    9ba8:	9f 4f       	sbci	r25, 0xFF	; 255
    9baa:	9f bb       	out	0x1f, r25	; 31
    9bac:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    9bae:	bd ba       	out	0x1d, r11	; 29

    __asm__ __volatile__ (
    9bb0:	0f b6       	in	r0, 0x3f	; 63
    9bb2:	f8 94       	cli
    9bb4:	e2 9a       	sbi	0x1c, 2	; 28
    9bb6:	e1 9a       	sbi	0x1c, 1	; 28
    9bb8:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a word \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_word (uint16_t *__p, uint16_t __value)
{
    __eewr_word (__p, __value, eeprom_write_byte);
    9bba:	40 e2       	ldi	r20, 0x20	; 32
    9bbc:	52 e4       	ldi	r21, 0x42	; 66
    9bbe:	b8 01       	movw	r22, r16
    9bc0:	c7 01       	movw	r24, r14
    9bc2:	8e 5b       	subi	r24, 0xBE	; 190
    9bc4:	9f 4f       	sbci	r25, 0xFF	; 255
    9bc6:	0e 94 fc 6d 	call	0xdbf8	; 0xdbf8 <__eewr_word>
			eeprom_write_byte(BASIC_PROG_SPACE+psize, newline.var);	
			psize++;	
			eeprom_write_word((uint16_t *)(BASIC_PROG_SPACE+psize), newline.value);	
			psize+=2;
    9bca:	97 01       	movw	r18, r14
    9bcc:	2d 5f       	subi	r18, 0xFD	; 253
    9bce:	3f 4f       	sbci	r19, 0xFF	; 255
			
			uint8_t l=0;
			if (newline.text != 0) l = strlen(newline.text);
    9bd0:	c1 14       	cp	r12, r1
    9bd2:	d1 04       	cpc	r13, r1
    9bd4:	11 f4       	brne	.+4      	; 0x9bda <basic_load+0x65e>
    9bd6:	00 e0       	ldi	r16, 0x00	; 0
    9bd8:	07 c0       	rjmp	.+14     	; 0x9be8 <basic_load+0x66c>
    9bda:	f6 01       	movw	r30, r12
    9bdc:	01 90       	ld	r0, Z+
    9bde:	00 20       	and	r0, r0
    9be0:	e9 f7       	brne	.-6      	; 0x9bdc <basic_load+0x660>
    9be2:	31 97       	sbiw	r30, 0x01	; 1
    9be4:	0e 2f       	mov	r16, r30
    9be6:	0c 19       	sub	r16, r12
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    9be8:	e1 99       	sbic	0x1c, 1	; 28
    9bea:	fe cf       	rjmp	.-4      	; 0x9be8 <basic_load+0x66c>
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    9bec:	c9 01       	movw	r24, r18
    9bee:	8f 5b       	subi	r24, 0xBF	; 191
    9bf0:	9f 4f       	sbci	r25, 0xFF	; 255
    9bf2:	9f bb       	out	0x1f, r25	; 31
    9bf4:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    9bf6:	0d bb       	out	0x1d, r16	; 29

    __asm__ __volatile__ (
    9bf8:	0f b6       	in	r0, 0x3f	; 63
    9bfa:	f8 94       	cli
    9bfc:	e2 9a       	sbi	0x1c, 2	; 28
    9bfe:	e1 9a       	sbi	0x1c, 1	; 28
    9c00:	0f be       	out	0x3f, r0	; 63
			eeprom_write_byte(BASIC_PROG_SPACE+psize, l);	
			psize++;
    9c02:	49 01       	movw	r8, r18
    9c04:	08 94       	sec
    9c06:	81 1c       	adc	r8, r1
    9c08:	91 1c       	adc	r9, r1
			if (l>0)
    9c0a:	00 23       	and	r16, r16
    9c0c:	61 f0       	breq	.+24     	; 0x9c26 <basic_load+0x6aa>
			{
				eeprom_write_block(newline.text, BASIC_PROG_SPACE+psize, l);			
    9c0e:	10 e0       	ldi	r17, 0x00	; 0
    \note The argument order is mismatch with common functions like strcpy().
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    9c10:	20 e2       	ldi	r18, 0x20	; 32
    9c12:	32 e4       	ldi	r19, 0x42	; 66
    9c14:	a8 01       	movw	r20, r16
    9c16:	b6 01       	movw	r22, r12
    9c18:	c4 01       	movw	r24, r8
    9c1a:	8f 5b       	subi	r24, 0xBF	; 191
    9c1c:	9f 4f       	sbci	r25, 0xFF	; 255
    9c1e:	0e 94 e0 6d 	call	0xdbc0	; 0xdbc0 <__eewr_block>
				psize+=l;
    9c22:	80 0e       	add	r8, r16
    9c24:	91 1e       	adc	r9, r17
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    9c26:	e1 99       	sbic	0x1c, 1	; 28
    9c28:	fe cf       	rjmp	.-4      	; 0x9c26 <basic_load+0x6aa>
		
		// store struct in eeprom
		
		if (errno==0)
		{	
			lc++;
    9c2a:	08 94       	sec
    9c2c:	41 1c       	adc	r4, r1
    9c2e:	51 1c       	adc	r5, r1
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    9c30:	c4 01       	movw	r24, r8
    9c32:	8f 5b       	subi	r24, 0xBF	; 191
    9c34:	9f 4f       	sbci	r25, 0xFF	; 255
    9c36:	9f bb       	out	0x1f, r25	; 31
    9c38:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    9c3a:	ec ec       	ldi	r30, 0xCC	; 204
    9c3c:	ed bb       	out	0x1d, r30	; 29

    __asm__ __volatile__ (
    9c3e:	0f b6       	in	r0, 0x3f	; 63
    9c40:	f8 94       	cli
    9c42:	e2 9a       	sbi	0x1c, 2	; 28
    9c44:	e1 9a       	sbi	0x1c, 1	; 28
    9c46:	0f be       	out	0x3f, r0	; 63
    9c48:	ce cc       	rjmp	.-1636   	; 0x95e6 <basic_load+0x6a>
			}

			eeprom_write_byte(BASIC_PROG_SPACE+psize, 0xCC);	// terminator character
		}
	}
}
    9c4a:	ce 56       	subi	r28, 0x6E	; 110
    9c4c:	df 4f       	sbci	r29, 0xFF	; 255
    9c4e:	0f b6       	in	r0, 0x3f	; 63
    9c50:	f8 94       	cli
    9c52:	de bf       	out	0x3e, r29	; 62
    9c54:	0f be       	out	0x3f, r0	; 63
    9c56:	cd bf       	out	0x3d, r28	; 61
    9c58:	cf 91       	pop	r28
    9c5a:	df 91       	pop	r29
    9c5c:	1f 91       	pop	r17
    9c5e:	0f 91       	pop	r16
    9c60:	ff 90       	pop	r15
    9c62:	ef 90       	pop	r14
    9c64:	df 90       	pop	r13
    9c66:	cf 90       	pop	r12
    9c68:	bf 90       	pop	r11
    9c6a:	af 90       	pop	r10
    9c6c:	9f 90       	pop	r9
    9c6e:	8f 90       	pop	r8
    9c70:	7f 90       	pop	r7
    9c72:	6f 90       	pop	r6
    9c74:	5f 90       	pop	r5
    9c76:	4f 90       	pop	r4
    9c78:	3f 90       	pop	r3
    9c7a:	2f 90       	pop	r2
    9c7c:	08 95       	ret

00009c7e <send_bus_str>:
	return eeprom_read_byte(HUNO_TYPE);
}


void send_bus_str(char *bus_str, int n)
{
    9c7e:	af 92       	push	r10
    9c80:	bf 92       	push	r11
    9c82:	cf 92       	push	r12
    9c84:	df 92       	push	r13
    9c86:	ef 92       	push	r14
    9c88:	ff 92       	push	r15
    9c8a:	0f 93       	push	r16
    9c8c:	1f 93       	push	r17
    9c8e:	cf 93       	push	r28
    9c90:	df 93       	push	r29
    9c92:	ec 01       	movw	r28, r24
    9c94:	7b 01       	movw	r14, r22
		wckReInit(BR9600);
    9c96:	8f e5       	ldi	r24, 0x5F	; 95
    9c98:	90 e0       	ldi	r25, 0x00	; 0
    9c9a:	0e 94 b5 52 	call	0xa56a	; 0xa56a <wckReInit>
		
		BYTE b;
		int ch;
		char *eos = bus_str+n;
    9c9e:	ec 0e       	add	r14, r28
    9ca0:	fd 1e       	adc	r15, r29
    9ca2:	90 e7       	ldi	r25, 0x70	; 112
    9ca4:	c9 2e       	mov	r12, r25
    9ca6:	91 e0       	ldi	r25, 0x01	; 1
    9ca8:	d9 2e       	mov	r13, r25
				if (*bus_str != 0) wckSendByte(*bus_str++);
				
			}		
			_delay_ms(100);		
			ch = wckGetByte(1000);
			rprintf ("BUS=%d\r\n", ch);
    9caa:	84 e0       	ldi	r24, 0x04	; 4
    9cac:	a8 2e       	mov	r10, r24
    9cae:	8e e3       	ldi	r24, 0x3E	; 62
    9cb0:	b8 2e       	mov	r11, r24
    9cb2:	01 e0       	ldi	r16, 0x01	; 1
    9cb4:	3d c0       	rjmp	.+122    	; 0x9d30 <send_bus_str+0xb2>
		
		BYTE b;
		int ch;
		char *eos = bus_str+n;
		
		while  ((bus_str<eos) && (b=*bus_str++) != 0)
    9cb6:	21 96       	adiw	r28, 0x01	; 1
		{			
			wckSendByte('S');
    9cb8:	83 e5       	ldi	r24, 0x53	; 83
    9cba:	0e 94 c6 52 	call	0xa58c	; 0xa58c <wckSendByte>
			wckSendByte(b);
    9cbe:	81 2f       	mov	r24, r17
    9cc0:	0e 94 c6 52 	call	0xa58c	; 0xa58c <wckSendByte>
			
			if (b=='p' || b=='t')
    9cc4:	10 37       	cpi	r17, 0x70	; 112
    9cc6:	11 f0       	breq	.+4      	; 0x9ccc <send_bus_str+0x4e>
    9cc8:	14 37       	cpi	r17, 0x74	; 116
    9cca:	d1 f4       	brne	.+52     	; 0x9d00 <send_bus_str+0x82>
    9ccc:	88 ee       	ldi	r24, 0xE8	; 232
    9cce:	93 e0       	ldi	r25, 0x03	; 3
    9cd0:	f6 01       	movw	r30, r12
    9cd2:	31 97       	sbiw	r30, 0x01	; 1
    9cd4:	f1 f7       	brne	.-4      	; 0x9cd2 <send_bus_str+0x54>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    9cd6:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    9cd8:	d9 f7       	brne	.-10     	; 0x9cd0 <send_bus_str+0x52>
			{
				_delay_ms(100);	
				if (*bus_str != 0) wckSendByte(*bus_str++);
    9cda:	88 81       	ld	r24, Y
    9cdc:	88 23       	and	r24, r24
    9cde:	19 f0       	breq	.+6      	; 0x9ce6 <send_bus_str+0x68>
    9ce0:	21 96       	adiw	r28, 0x01	; 1
    9ce2:	0e 94 c6 52 	call	0xa58c	; 0xa58c <wckSendByte>
    9ce6:	88 ee       	ldi	r24, 0xE8	; 232
    9ce8:	93 e0       	ldi	r25, 0x03	; 3
    9cea:	f6 01       	movw	r30, r12
    9cec:	31 97       	sbiw	r30, 0x01	; 1
    9cee:	f1 f7       	brne	.-4      	; 0x9cec <send_bus_str+0x6e>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    9cf0:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    9cf2:	d9 f7       	brne	.-10     	; 0x9cea <send_bus_str+0x6c>
				_delay_ms(100);	
				if (*bus_str != 0) wckSendByte(*bus_str++);
    9cf4:	88 81       	ld	r24, Y
    9cf6:	88 23       	and	r24, r24
    9cf8:	19 f0       	breq	.+6      	; 0x9d00 <send_bus_str+0x82>
    9cfa:	21 96       	adiw	r28, 0x01	; 1
    9cfc:	0e 94 c6 52 	call	0xa58c	; 0xa58c <wckSendByte>
    9d00:	88 ee       	ldi	r24, 0xE8	; 232
    9d02:	93 e0       	ldi	r25, 0x03	; 3
    9d04:	f6 01       	movw	r30, r12
    9d06:	31 97       	sbiw	r30, 0x01	; 1
    9d08:	f1 f7       	brne	.-4      	; 0x9d06 <send_bus_str+0x88>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    9d0a:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    9d0c:	d9 f7       	brne	.-10     	; 0x9d04 <send_bus_str+0x86>
				
			}		
			_delay_ms(100);		
			ch = wckGetByte(1000);
    9d0e:	88 ee       	ldi	r24, 0xE8	; 232
    9d10:	93 e0       	ldi	r25, 0x03	; 3
    9d12:	0e 94 ca 52 	call	0xa594	; 0xa594 <wckGetByte>
			rprintf ("BUS=%d\r\n", ch);
    9d16:	90 e0       	ldi	r25, 0x00	; 0
    9d18:	9f 93       	push	r25
    9d1a:	8f 93       	push	r24
    9d1c:	bf 92       	push	r11
    9d1e:	af 92       	push	r10
    9d20:	0f 93       	push	r16
    9d22:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
    9d26:	0f 90       	pop	r0
    9d28:	0f 90       	pop	r0
    9d2a:	0f 90       	pop	r0
    9d2c:	0f 90       	pop	r0
    9d2e:	0f 90       	pop	r0
		
		BYTE b;
		int ch;
		char *eos = bus_str+n;
		
		while  ((bus_str<eos) && (b=*bus_str++) != 0)
    9d30:	ce 15       	cp	r28, r14
    9d32:	df 05       	cpc	r29, r15
    9d34:	20 f4       	brcc	.+8      	; 0x9d3e <send_bus_str+0xc0>
    9d36:	18 81       	ld	r17, Y
    9d38:	11 23       	and	r17, r17
    9d3a:	09 f0       	breq	.+2      	; 0x9d3e <send_bus_str+0xc0>
    9d3c:	bc cf       	rjmp	.-136    	; 0x9cb6 <send_bus_str+0x38>
			_delay_ms(100);		
			ch = wckGetByte(1000);
			rprintf ("BUS=%d\r\n", ch);
		}
		
		wckReInit(BR115200);
    9d3e:	87 e0       	ldi	r24, 0x07	; 7
    9d40:	90 e0       	ldi	r25, 0x00	; 0
    9d42:	0e 94 b5 52 	call	0xa56a	; 0xa56a <wckReInit>
		wckFlush(); // flush the buffer
    9d46:	0e 94 c1 52 	call	0xa582	; 0xa582 <wckFlush>
}
    9d4a:	df 91       	pop	r29
    9d4c:	cf 91       	pop	r28
    9d4e:	1f 91       	pop	r17
    9d50:	0f 91       	pop	r16
    9d52:	ff 90       	pop	r15
    9d54:	ef 90       	pop	r14
    9d56:	df 90       	pop	r13
    9d58:	cf 90       	pop	r12
    9d5a:	bf 90       	pop	r11
    9d5c:	af 90       	pop	r10
    9d5e:	08 95       	ret

00009d60 <basic_run>:
		}
	return 0;
}
		
void basic_run(int dbf)
{
    9d60:	2f 92       	push	r2
    9d62:	3f 92       	push	r3
    9d64:	4f 92       	push	r4
    9d66:	5f 92       	push	r5
    9d68:	6f 92       	push	r6
    9d6a:	7f 92       	push	r7
    9d6c:	8f 92       	push	r8
    9d6e:	9f 92       	push	r9
    9d70:	af 92       	push	r10
    9d72:	bf 92       	push	r11
    9d74:	cf 92       	push	r12
    9d76:	df 92       	push	r13
    9d78:	ef 92       	push	r14
    9d7a:	ff 92       	push	r15
    9d7c:	0f 93       	push	r16
    9d7e:	1f 93       	push	r17
    9d80:	df 93       	push	r29
    9d82:	cf 93       	push	r28
    9d84:	cd b7       	in	r28, 0x3d	; 61
    9d86:	de b7       	in	r29, 0x3e	; 62
    9d88:	c9 56       	subi	r28, 0x69	; 105
    9d8a:	d0 40       	sbci	r29, 0x00	; 0
    9d8c:	0f b6       	in	r0, 0x3f	; 63
    9d8e:	f8 94       	cli
    9d90:	de bf       	out	0x3e, r29	; 62
    9d92:	0f be       	out	0x3f, r0	; 63
    9d94:	cd bf       	out	0x3d, r28	; 61
    9d96:	a9 96       	adiw	r28, 0x29	; 41
    9d98:	9f af       	std	Y+63, r25	; 0x3f
    9d9a:	8e af       	std	Y+62, r24	; 0x3e
    9d9c:	a9 97       	sbiw	r28, 0x29	; 41
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    9d9e:	e1 99       	sbic	0x1c, 1	; 28
    9da0:	fe cf       	rjmp	.-4      	; 0x9d9e <basic_run+0x3e>
#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    9da2:	81 e4       	ldi	r24, 0x41	; 65
    9da4:	90 e0       	ldi	r25, 0x00	; 0
    9da6:	9f bb       	out	0x1f, r25	; 31
    9da8:	8e bb       	out	0x1e, r24	; 30
#endif
    EECR |= (1 << EERE);
    9daa:	e0 9a       	sbi	0x1c, 0	; 28
    return EEDR;
    9dac:	8d b3       	in	r24, 0x1d	; 29
	//	 Move to next line
	// Loop
	
	uint8_t data = eeprom_read_byte((uint8_t*)(BASIC_PROG_SPACE));

	if (data==0xAA) {
    9dae:	8a 3a       	cpi	r24, 0xAA	; 170
    9db0:	a9 f4       	brne	.+42     	; 0x9ddc <basic_run+0x7c>
		rprintfStr("Run Program \r\n");
    9db2:	87 e3       	ldi	r24, 0x37	; 55
    9db4:	93 e0       	ldi	r25, 0x03	; 3
    9db6:	0e 94 f9 29 	call	0x53f2	; 0x53f2 <rprintfStr>
	char scene[16];
	
	line.text=buf;
	int n;
	
	errno=0;
    9dba:	10 92 bc 0d 	sts	0x0DBC, r1
    9dbe:	10 92 bb 0d 	sts	0x0DBB, r1
    9dc2:	44 24       	eor	r4, r4
    9dc4:	55 24       	eor	r5, r5
    9dc6:	21 e0       	ldi	r18, 0x01	; 1
    9dc8:	62 2e       	mov	r6, r18
    9dca:	71 2c       	mov	r7, r1
    9dcc:	88 24       	eor	r8, r8
    9dce:	99 24       	eor	r9, r9
    \a __dst.
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    9dd0:	95 e2       	ldi	r25, 0x25	; 37
    9dd2:	29 2e       	mov	r2, r25
    9dd4:	31 2c       	mov	r3, r1
    9dd6:	2c 0e       	add	r2, r28
    9dd8:	3d 1e       	adc	r3, r29
    9dda:	04 c0       	rjmp	.+8      	; 0x9de4 <basic_run+0x84>
	if (data==0xAA) {
		rprintfStr("Run Program \r\n");
	}
	else
	{
		rprintfStr("No program loaded\r\n");
    9ddc:	8e ed       	ldi	r24, 0xDE	; 222
    9dde:	92 e0       	ldi	r25, 0x02	; 2
    9de0:	5f c3       	rjmp	.+1726   	; 0xa4a0 <basic_run+0x740>
		return;
    9de2:	47 01       	movw	r8, r14
	
	errno=0;
	
	while (tmp != 0xCC && ptr < EEPROM_MEM_SZ )
	{
		if (errno !=0)
    9de4:	80 91 bb 0d 	lds	r24, 0x0DBB
    9de8:	90 91 bc 0d 	lds	r25, 0x0DBC
    9dec:	00 97       	sbiw	r24, 0x00	; 0
    9dee:	29 f0       	breq	.+10     	; 0x9dfa <basic_run+0x9a>
		{
			rprintf("Runtime error %d\r\n", errno);
    9df0:	9f 93       	push	r25
    9df2:	8f 93       	push	r24
    9df4:	8b e3       	ldi	r24, 0x3B	; 59
    9df6:	9d e3       	ldi	r25, 0x3D	; 61
    9df8:	78 c0       	rjmp	.+240    	; 0x9eea <basic_run+0x18a>
/** \ingroup avr_eeprom
    Read one 16-bit word (little endian) from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint16_t eeprom_read_word (const uint16_t *__p)
{
    return __eerd_word (__p, eeprom_read_byte);
    9dfa:	68 e1       	ldi	r22, 0x18	; 24
    9dfc:	72 e4       	ldi	r23, 0x42	; 66
    9dfe:	c3 01       	movw	r24, r6
    9e00:	8f 5b       	subi	r24, 0xBF	; 191
    9e02:	9f 4f       	sbci	r25, 0xFF	; 255
    9e04:	0e 94 ca 6d 	call	0xdb94	; 0xdb94 <__eerd_word>
			return;
		}
		line.lineno=(int)eeprom_read_word((uint16_t *)(BASIC_PROG_SPACE+ptr));	
    9e08:	6c 01       	movw	r12, r24
		ptr+=2;
    9e0a:	83 01       	movw	r16, r6
    9e0c:	0e 5f       	subi	r16, 0xFE	; 254
    9e0e:	1f 4f       	sbci	r17, 0xFF	; 255
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    9e10:	e1 99       	sbic	0x1c, 1	; 28
    9e12:	fe cf       	rjmp	.-4      	; 0x9e10 <basic_run+0xb0>
#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    9e14:	c8 01       	movw	r24, r16
    9e16:	8f 5b       	subi	r24, 0xBF	; 191
    9e18:	9f 4f       	sbci	r25, 0xFF	; 255
    9e1a:	9f bb       	out	0x1f, r25	; 31
    9e1c:	8e bb       	out	0x1e, r24	; 30
#endif
    EECR |= (1 << EERE);
    9e1e:	e0 9a       	sbi	0x1c, 0	; 28
    return EEDR;
    9e20:	8d b3       	in	r24, 0x1d	; 29
    9e22:	a6 96       	adiw	r28, 0x26	; 38
    9e24:	8f af       	std	Y+63, r24	; 0x3f
    9e26:	a6 97       	sbiw	r28, 0x26	; 38
		line.token=eeprom_read_byte(BASIC_PROG_SPACE+ptr);	
		ptr++;		
    9e28:	0f 5f       	subi	r16, 0xFF	; 255
    9e2a:	1f 4f       	sbci	r17, 0xFF	; 255
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    9e2c:	e1 99       	sbic	0x1c, 1	; 28
    9e2e:	fe cf       	rjmp	.-4      	; 0x9e2c <basic_run+0xcc>
#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    9e30:	c8 01       	movw	r24, r16
    9e32:	8f 5b       	subi	r24, 0xBF	; 191
    9e34:	9f 4f       	sbci	r25, 0xFF	; 255
    9e36:	9f bb       	out	0x1f, r25	; 31
    9e38:	8e bb       	out	0x1e, r24	; 30
#endif
    EECR |= (1 << EERE);
    9e3a:	e0 9a       	sbi	0x1c, 0	; 28
    return EEDR;
    9e3c:	bd b2       	in	r11, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one 16-bit word (little endian) from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint16_t eeprom_read_word (const uint16_t *__p)
{
    return __eerd_word (__p, eeprom_read_byte);
    9e3e:	68 e1       	ldi	r22, 0x18	; 24
    9e40:	72 e4       	ldi	r23, 0x42	; 66
    9e42:	c8 01       	movw	r24, r16
    9e44:	8e 5b       	subi	r24, 0xBE	; 190
    9e46:	9f 4f       	sbci	r25, 0xFF	; 255
    9e48:	0e 94 ca 6d 	call	0xdb94	; 0xdb94 <__eerd_word>
    9e4c:	a8 2e       	mov	r10, r24
    9e4e:	aa 96       	adiw	r28, 0x2a	; 42
    9e50:	9f af       	std	Y+63, r25	; 0x3f
    9e52:	aa 97       	sbiw	r28, 0x2a	; 42
		line.var=eeprom_read_byte(BASIC_PROG_SPACE+ptr);	
		ptr++;	
		line.value=(int)eeprom_read_word((uint16_t *)(BASIC_PROG_SPACE+ptr));	
		ptr+=2;
    9e54:	83 e0       	ldi	r24, 0x03	; 3
    9e56:	e8 2e       	mov	r14, r24
    9e58:	f1 2c       	mov	r15, r1
    9e5a:	e0 0e       	add	r14, r16
    9e5c:	f1 1e       	adc	r15, r17
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    9e5e:	e1 99       	sbic	0x1c, 1	; 28
    9e60:	fe cf       	rjmp	.-4      	; 0x9e5e <basic_run+0xfe>
#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    9e62:	c7 01       	movw	r24, r14
    9e64:	8f 5b       	subi	r24, 0xBF	; 191
    9e66:	9f 4f       	sbci	r25, 0xFF	; 255
    9e68:	9f bb       	out	0x1f, r25	; 31
    9e6a:	8e bb       	out	0x1e, r24	; 30
#endif
    EECR |= (1 << EERE);
    9e6c:	e0 9a       	sbi	0x1c, 0	; 28
    return EEDR;
    9e6e:	0d b3       	in	r16, 0x1d	; 29
		
		uint8_t l=eeprom_read_byte((uint8_t *)(BASIC_PROG_SPACE+ptr));	

		eeprom_read_block(line.text, BASIC_PROG_SPACE+ptr+1, l);	
    9e70:	10 e0       	ldi	r17, 0x00	; 0
    \a __dst.
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    9e72:	b7 01       	movw	r22, r14
    9e74:	6e 5b       	subi	r22, 0xBE	; 190
    9e76:	7f 4f       	sbci	r23, 0xFF	; 255
    9e78:	28 e1       	ldi	r18, 0x18	; 24
    9e7a:	32 e4       	ldi	r19, 0x42	; 66
    9e7c:	a8 01       	movw	r20, r16
    9e7e:	c1 01       	movw	r24, r2
    9e80:	0e 94 ae 6d 	call	0xdb5c	; 0xdb5c <__eerd_block>
		line.text[l]='\0';
    9e84:	f1 01       	movw	r30, r2
    9e86:	e0 0f       	add	r30, r16
    9e88:	f1 1f       	adc	r31, r17
    9e8a:	10 82       	st	Z, r1
		
		ptr += (l+1);
    9e8c:	38 01       	movw	r6, r16
    9e8e:	08 94       	sec
    9e90:	61 1c       	adc	r6, r1
    9e92:	71 1c       	adc	r7, r1
    9e94:	6e 0c       	add	r6, r14
    9e96:	7f 1c       	adc	r7, r15
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    9e98:	e1 99       	sbic	0x1c, 1	; 28
    9e9a:	fe cf       	rjmp	.-4      	; 0x9e98 <basic_run+0x138>
#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    9e9c:	c3 01       	movw	r24, r6
    9e9e:	8f 5b       	subi	r24, 0xBF	; 191
    9ea0:	9f 4f       	sbci	r25, 0xFF	; 255
    9ea2:	9f bb       	out	0x1f, r25	; 31
    9ea4:	8e bb       	out	0x1e, r24	; 30
#endif
    EECR |= (1 << EERE);
    9ea6:	e0 9a       	sbi	0x1c, 0	; 28
    return EEDR;
    9ea8:	9d b3       	in	r25, 0x1d	; 29
    9eaa:	a7 96       	adiw	r28, 0x27	; 39
    9eac:	9f af       	std	Y+63, r25	; 0x3f
    9eae:	a7 97       	sbiw	r28, 0x27	; 39
		
		tmp = eeprom_read_byte(BASIC_PROG_SPACE+ptr);	// terminator character ?

		/* execute code */
	
		if (dbf) rprintf (": %d - ", line.lineno); // debug mode
    9eb0:	a9 96       	adiw	r28, 0x29	; 41
    9eb2:	ee ad       	ldd	r30, Y+62	; 0x3e
    9eb4:	ff ad       	ldd	r31, Y+63	; 0x3f
    9eb6:	a9 97       	sbiw	r28, 0x29	; 41
    9eb8:	ef 2b       	or	r30, r31
    9eba:	79 f0       	breq	.+30     	; 0x9eda <basic_run+0x17a>
    9ebc:	df 92       	push	r13
    9ebe:	cf 92       	push	r12
    9ec0:	83 e3       	ldi	r24, 0x33	; 51
    9ec2:	9d e3       	ldi	r25, 0x3D	; 61
    9ec4:	9f 93       	push	r25
    9ec6:	8f 93       	push	r24
    9ec8:	91 e0       	ldi	r25, 0x01	; 1
    9eca:	9f 93       	push	r25
    9ecc:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
    9ed0:	0f 90       	pop	r0
    9ed2:	0f 90       	pop	r0
    9ed4:	0f 90       	pop	r0
    9ed6:	0f 90       	pop	r0
    9ed8:	0f 90       	pop	r0
		
		if (uartGetByte() == 27)  {
    9eda:	0e 94 9c 22 	call	0x4538	; 0x4538 <uartGetByte>
    9ede:	4b 97       	sbiw	r24, 0x1b	; 27
    9ee0:	81 f4       	brne	.+32     	; 0x9f02 <basic_run+0x1a2>
			rprintf ("User Break on line %d\r\n", line.lineno); 
    9ee2:	df 92       	push	r13
    9ee4:	cf 92       	push	r12
    9ee6:	8b e1       	ldi	r24, 0x1B	; 27
    9ee8:	9d e3       	ldi	r25, 0x3D	; 61
    9eea:	9f 93       	push	r25
    9eec:	8f 93       	push	r24
    9eee:	81 e0       	ldi	r24, 0x01	; 1
    9ef0:	8f 93       	push	r24
    9ef2:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
    9ef6:	0f 90       	pop	r0
    9ef8:	0f 90       	pop	r0
    9efa:	0f 90       	pop	r0
    9efc:	0f 90       	pop	r0
    9efe:	0f 90       	pop	r0
    9f00:	1a c3       	rjmp	.+1588   	; 0xa536 <basic_run+0x7d6>
		ptr+=2;
		line.token=eeprom_read_byte(BASIC_PROG_SPACE+ptr);	
		ptr++;		
		line.var=eeprom_read_byte(BASIC_PROG_SPACE+ptr);	
		ptr++;	
		line.value=(int)eeprom_read_word((uint16_t *)(BASIC_PROG_SPACE+ptr));	
    9f02:	2a 2d       	mov	r18, r10
    9f04:	aa 96       	adiw	r28, 0x2a	; 42
    9f06:	3f ad       	ldd	r19, Y+63	; 0x3f
    9f08:	aa 97       	sbiw	r28, 0x2a	; 42
		if (uartGetByte() == 27)  {
			rprintf ("User Break on line %d\r\n", line.lineno); 
			return;
		}
		
		switch (line.token)
    9f0a:	a6 96       	adiw	r28, 0x26	; 38
    9f0c:	8f ad       	ldd	r24, Y+63	; 0x3f
    9f0e:	a6 97       	sbiw	r28, 0x26	; 38
    9f10:	e8 2f       	mov	r30, r24
    9f12:	f0 e0       	ldi	r31, 0x00	; 0
    9f14:	e3 31       	cpi	r30, 0x13	; 19
    9f16:	f1 05       	cpc	r31, r1
    9f18:	08 f0       	brcs	.+2      	; 0x9f1c <basic_run+0x1bc>
    9f1a:	f3 c2       	rjmp	.+1510   	; 0xa502 <basic_run+0x7a2>
    9f1c:	e7 5a       	subi	r30, 0xA7	; 167
    9f1e:	ff 4f       	sbci	r31, 0xFF	; 255
    9f20:	ee 0f       	add	r30, r30
    9f22:	ff 1f       	adc	r31, r31
    9f24:	05 90       	lpm	r0, Z+
    9f26:	f4 91       	lpm	r31, Z+
    9f28:	e0 2d       	mov	r30, r0
    9f2a:	09 94       	ijmp
		{
		case FOR: 
			// remember where next in struction is
			forptr[fp++] = ptr;
    9f2c:	f4 01       	movw	r30, r8
    9f2e:	ee 0f       	add	r30, r30
    9f30:	ff 1f       	adc	r31, r31
    9f32:	81 e0       	ldi	r24, 0x01	; 1
    9f34:	90 e0       	ldi	r25, 0x00	; 0
    9f36:	8c 0f       	add	r24, r28
    9f38:	9d 1f       	adc	r25, r29
    9f3a:	e8 0f       	add	r30, r24
    9f3c:	f9 1f       	adc	r31, r25
    9f3e:	71 86       	std	Z+9, r7	; 0x09
    9f40:	60 86       	std	Z+8, r6	; 0x08
    9f42:	74 01       	movw	r14, r8
    9f44:	08 94       	sec
    9f46:	e1 1c       	adc	r14, r1
    9f48:	f1 1c       	adc	r15, r1
			// eval expr1 of line.text = "expr1 TO expr2"
			// i.e var=expr1
			n=0;
    9f4a:	18 86       	std	Y+8, r1	; 0x08
    9f4c:	1f 82       	std	Y+7, r1	; 0x07
			p=line.text;
    9f4e:	3e 82       	std	Y+6, r3	; 0x06
    9f50:	2d 82       	std	Y+5, r2	; 0x05
			if (eval_expr(&p, &n)==NUMBER)
    9f52:	be 01       	movw	r22, r28
    9f54:	69 5f       	subi	r22, 0xF9	; 249
    9f56:	7f 4f       	sbci	r23, 0xFF	; 255
    9f58:	ce 01       	movw	r24, r28
    9f5a:	05 96       	adiw	r24, 0x05	; 5
    9f5c:	0e 94 20 49 	call	0x9240	; 0x9240 <eval_expr>
    9f60:	81 30       	cpi	r24, 0x01	; 1
    9f62:	09 f0       	breq	.+2      	; 0x9f66 <basic_run+0x206>
    9f64:	d6 c2       	rjmp	.+1452   	; 0xa512 <basic_run+0x7b2>
				variable[line.var] = n;					
    9f66:	eb 2d       	mov	r30, r11
    9f68:	f0 e0       	ldi	r31, 0x00	; 0
    9f6a:	ee 0f       	add	r30, r30
    9f6c:	ff 1f       	adc	r31, r31
    9f6e:	e3 54       	subi	r30, 0x43	; 67
    9f70:	f2 4f       	sbci	r31, 0xF2	; 242
    9f72:	8f 81       	ldd	r24, Y+7	; 0x07
    9f74:	98 85       	ldd	r25, Y+8	; 0x08
    9f76:	91 83       	std	Z+1, r25	; 0x01
    9f78:	80 83       	st	Z, r24
    9f7a:	cb c2       	rjmp	.+1430   	; 0xa512 <basic_run+0x7b2>
			break;
		case NEXT: 
			// increment var and check condiiton
			if (fp>0) {
    9f7c:	81 14       	cp	r8, r1
    9f7e:	91 04       	cpc	r9, r1
    9f80:	09 f4       	brne	.+2      	; 0x9f84 <basic_run+0x224>
    9f82:	c6 c2       	rjmp	.+1420   	; 0xa510 <basic_run+0x7b0>
				int t_ptr=forptr[fp-1];
    9f84:	74 01       	movw	r14, r8
    9f86:	08 94       	sec
    9f88:	e1 08       	sbc	r14, r1
    9f8a:	f1 08       	sbc	r15, r1
    9f8c:	f7 01       	movw	r30, r14
    9f8e:	ee 0f       	add	r30, r30
    9f90:	ff 1f       	adc	r31, r31
    9f92:	81 e0       	ldi	r24, 0x01	; 1
    9f94:	90 e0       	ldi	r25, 0x00	; 0
    9f96:	8c 0f       	add	r24, r28
    9f98:	9d 1f       	adc	r25, r29
    9f9a:	e8 0f       	add	r30, r24
    9f9c:	f9 1f       	adc	r31, r25
    9f9e:	d0 84       	ldd	r13, Z+8	; 0x08
    9fa0:	c1 84       	ldd	r12, Z+9	; 0x09
				// increment var
				variable[line.var]++;
    9fa2:	0b 2d       	mov	r16, r11
    9fa4:	10 e0       	ldi	r17, 0x00	; 0
    9fa6:	00 0f       	add	r16, r16
    9fa8:	11 1f       	adc	r17, r17
    9faa:	03 54       	subi	r16, 0x43	; 67
    9fac:	12 4f       	sbci	r17, 0xF2	; 242
    9fae:	f8 01       	movw	r30, r16
    9fb0:	80 81       	ld	r24, Z
    9fb2:	91 81       	ldd	r25, Z+1	; 0x01
    9fb4:	01 96       	adiw	r24, 0x01	; 1
    9fb6:	91 83       	std	Z+1, r25	; 0x01
    9fb8:	80 83       	st	Z, r24
				// test against expr2 i.e var<=expr2
				n=0;
    9fba:	18 86       	std	Y+8, r1	; 0x08
    9fbc:	1f 82       	std	Y+7, r1	; 0x07
				p=line.text;
    9fbe:	3e 82       	std	Y+6, r3	; 0x06
    9fc0:	2d 82       	std	Y+5, r2	; 0x05
				if (eval_expr(&p, &n)!=NUMBER)
    9fc2:	be 01       	movw	r22, r28
    9fc4:	69 5f       	subi	r22, 0xF9	; 249
    9fc6:	7f 4f       	sbci	r23, 0xFF	; 255
    9fc8:	ce 01       	movw	r24, r28
    9fca:	05 96       	adiw	r24, 0x05	; 5
    9fcc:	0e 94 20 49 	call	0x9240	; 0x9240 <eval_expr>
    9fd0:	81 30       	cpi	r24, 0x01	; 1
    9fd2:	09 f0       	breq	.+2      	; 0x9fd6 <basic_run+0x276>
    9fd4:	68 c0       	rjmp	.+208    	; 0xa0a6 <basic_run+0x346>
				{
					errno=1;
					break; //need to handle error	
				}			
				if (variable[line.var] <= n) { 
    9fd6:	f8 01       	movw	r30, r16
    9fd8:	20 81       	ld	r18, Z
    9fda:	31 81       	ldd	r19, Z+1	; 0x01
    9fdc:	8f 81       	ldd	r24, Y+7	; 0x07
    9fde:	98 85       	ldd	r25, Y+8	; 0x08
    9fe0:	82 17       	cp	r24, r18
    9fe2:	93 07       	cpc	r25, r19
    9fe4:	0c f0       	brlt	.+2      	; 0x9fe8 <basic_run+0x288>
    9fe6:	a1 c2       	rjmp	.+1346   	; 0xa52a <basic_run+0x7ca>
    9fe8:	94 c2       	rjmp	.+1320   	; 0xa512 <basic_run+0x7b2>
					fp--;
				}
			}
			break;
		case GET: 
			n=0;
    9fea:	18 86       	std	Y+8, r1	; 0x08
    9fec:	1f 82       	std	Y+7, r1	; 0x07
			if (get_special(line.text, &n)<0)
    9fee:	be 01       	movw	r22, r28
    9ff0:	69 5f       	subi	r22, 0xF9	; 249
    9ff2:	7f 4f       	sbci	r23, 0xFF	; 255
    9ff4:	c1 01       	movw	r24, r2
    9ff6:	0e 94 01 48 	call	0x9002	; 0x9002 <get_special>
    9ffa:	97 ff       	sbrs	r25, 7
    9ffc:	49 c0       	rjmp	.+146    	; 0xa090 <basic_run+0x330>
				errno=2;
    9ffe:	82 e0       	ldi	r24, 0x02	; 2
    a000:	90 e0       	ldi	r25, 0x00	; 0
    a002:	90 93 bc 0d 	sts	0x0DBC, r25
    a006:	80 93 bb 0d 	sts	0x0DBB, r24
    a00a:	42 c0       	rjmp	.+132    	; 0xa090 <basic_run+0x330>
			variable[line.var]=n;	
			break;
		case POKE:
 			n=0;
    a00c:	18 86       	std	Y+8, r1	; 0x08
    a00e:	1f 82       	std	Y+7, r1	; 0x07
			p=line.text;
    a010:	3e 82       	std	Y+6, r3	; 0x06
    a012:	2d 82       	std	Y+5, r2	; 0x05
			if (eval_expr(&p, &n)==NUMBER)
    a014:	be 01       	movw	r22, r28
    a016:	69 5f       	subi	r22, 0xF9	; 249
    a018:	7f 4f       	sbci	r23, 0xFF	; 255
    a01a:	ce 01       	movw	r24, r28
    a01c:	05 96       	adiw	r24, 0x05	; 5
    a01e:	0e 94 20 49 	call	0x9240	; 0x9240 <eval_expr>
    a022:	81 30       	cpi	r24, 0x01	; 1
    a024:	09 f0       	breq	.+2      	; 0xa028 <basic_run+0x2c8>
    a026:	3f c0       	rjmp	.+126    	; 0xa0a6 <basic_run+0x346>
			{
				// put result into address line.var
				uint8_t addr=line.var;
				eeprom_write_byte(FIRMWARE+addr, n);
    a028:	2f 81       	ldd	r18, Y+7	; 0x07
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    a02a:	e1 99       	sbic	0x1c, 1	; 28
    a02c:	fe cf       	rjmp	.-4      	; 0xa02a <basic_run+0x2ca>
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    a02e:	8b 2d       	mov	r24, r11
    a030:	90 e0       	ldi	r25, 0x00	; 0
    a032:	80 50       	subi	r24, 0x00	; 0
    a034:	90 40       	sbci	r25, 0x00	; 0
    a036:	9f bb       	out	0x1f, r25	; 31
    a038:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    a03a:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
    a03c:	0f b6       	in	r0, 0x3f	; 63
    a03e:	f8 94       	cli
    a040:	e2 9a       	sbi	0x1c, 2	; 28
    a042:	e1 9a       	sbi	0x1c, 1	; 28
    a044:	0f be       	out	0x3f, r0	; 63
    a046:	64 c2       	rjmp	.+1224   	; 0xa510 <basic_run+0x7b0>
			}
			else
				errno=1;
			break;
		case PUT: 
			n=0;
    a048:	18 86       	std	Y+8, r1	; 0x08
    a04a:	1f 82       	std	Y+7, r1	; 0x07
			p=line.text;
    a04c:	3e 82       	std	Y+6, r3	; 0x06
    a04e:	2d 82       	std	Y+5, r2	; 0x05
			if (eval_expr(&p, &n)==NUMBER)
    a050:	be 01       	movw	r22, r28
    a052:	69 5f       	subi	r22, 0xF9	; 249
    a054:	7f 4f       	sbci	r23, 0xFF	; 255
    a056:	ce 01       	movw	r24, r28
    a058:	05 96       	adiw	r24, 0x05	; 5
    a05a:	0e 94 20 49 	call	0x9240	; 0x9240 <eval_expr>
    a05e:	81 30       	cpi	r24, 0x01	; 1
    a060:	39 f4       	brne	.+14     	; 0xa070 <basic_run+0x310>
				put_special(line.var, n);
    a062:	6f 81       	ldd	r22, Y+7	; 0x07
    a064:	78 85       	ldd	r23, Y+8	; 0x08
    a066:	8b 2d       	mov	r24, r11
    a068:	90 e0       	ldi	r25, 0x00	; 0
    a06a:	0e 94 7a 45 	call	0x8af4	; 0x8af4 <put_special>
    a06e:	50 c2       	rjmp	.+1184   	; 0xa510 <basic_run+0x7b0>
			else
				errno=1;
    a070:	e1 e0       	ldi	r30, 0x01	; 1
    a072:	f0 e0       	ldi	r31, 0x00	; 0
    a074:	41 c2       	rjmp	.+1154   	; 0xa4f8 <basic_run+0x798>
			break;
		case LET: 
			n=0;
    a076:	18 86       	std	Y+8, r1	; 0x08
    a078:	1f 82       	std	Y+7, r1	; 0x07
			p=line.text;
    a07a:	3e 82       	std	Y+6, r3	; 0x06
    a07c:	2d 82       	std	Y+5, r2	; 0x05
			if (eval_expr(&p, &n)==NUMBER)
    a07e:	be 01       	movw	r22, r28
    a080:	69 5f       	subi	r22, 0xF9	; 249
    a082:	7f 4f       	sbci	r23, 0xFF	; 255
    a084:	ce 01       	movw	r24, r28
    a086:	05 96       	adiw	r24, 0x05	; 5
    a088:	0e 94 20 49 	call	0x9240	; 0x9240 <eval_expr>
    a08c:	81 30       	cpi	r24, 0x01	; 1
    a08e:	59 f4       	brne	.+22     	; 0xa0a6 <basic_run+0x346>
				variable[line.var] = n;
    a090:	eb 2d       	mov	r30, r11
    a092:	f0 e0       	ldi	r31, 0x00	; 0
    a094:	ee 0f       	add	r30, r30
    a096:	ff 1f       	adc	r31, r31
    a098:	e3 54       	subi	r30, 0x43	; 67
    a09a:	f2 4f       	sbci	r31, 0xF2	; 242
    a09c:	8f 81       	ldd	r24, Y+7	; 0x07
    a09e:	98 85       	ldd	r25, Y+8	; 0x08
    a0a0:	91 83       	std	Z+1, r25	; 0x01
    a0a2:	80 83       	st	Z, r24
    a0a4:	35 c2       	rjmp	.+1130   	; 0xa510 <basic_run+0x7b0>
			else
				errno=1;
    a0a6:	81 e0       	ldi	r24, 0x01	; 1
    a0a8:	90 e0       	ldi	r25, 0x00	; 0
    a0aa:	c2 c0       	rjmp	.+388    	; 0xa230 <basic_run+0x4d0>
			//else
			//handle error
			//rprintf ("assign %c= %d\r\n", line.var, n); // DEBUG
			break;
		case SERVO:
			n=0;
    a0ac:	18 86       	std	Y+8, r1	; 0x08
    a0ae:	1f 82       	std	Y+7, r1	; 0x07
			p=line.text;
    a0b0:	3e 82       	std	Y+6, r3	; 0x06
    a0b2:	2d 82       	std	Y+5, r2	; 0x05
			if (*p=='@') // set passive mode
    a0b4:	8d a1       	ldd	r24, Y+37	; 0x25
    a0b6:	80 34       	cpi	r24, 0x40	; 64
    a0b8:	21 f4       	brne	.+8      	; 0xa0c2 <basic_run+0x362>
			{
				// set pass servo id=line.var
				wckSetPassive(line.var);
    a0ba:	8b 2d       	mov	r24, r11
    a0bc:	0e 94 ee 53 	call	0xa7dc	; 0xa7dc <wckSetPassive>
    a0c0:	27 c2       	rjmp	.+1102   	; 0xa510 <basic_run+0x7b0>
			}
			else
			{
				eval_expr(&p, &n);
    a0c2:	be 01       	movw	r22, r28
    a0c4:	69 5f       	subi	r22, 0xF9	; 249
    a0c6:	7f 4f       	sbci	r23, 0xFF	; 255
    a0c8:	ce 01       	movw	r24, r28
    a0ca:	05 96       	adiw	r24, 0x05	; 5
    a0cc:	0e 94 20 49 	call	0x9240	; 0x9240 <eval_expr>
				if (n>00 && n<=254)
    a0d0:	4f 81       	ldd	r20, Y+7	; 0x07
    a0d2:	58 85       	ldd	r21, Y+8	; 0x08
    a0d4:	ca 01       	movw	r24, r20
    a0d6:	01 97       	sbiw	r24, 0x01	; 1
    a0d8:	8e 3f       	cpi	r24, 0xFE	; 254
    a0da:	91 05       	cpc	r25, r1
    a0dc:	08 f0       	brcs	.+2      	; 0xa0e0 <basic_run+0x380>
    a0de:	18 c2       	rjmp	.+1072   	; 0xa510 <basic_run+0x7b0>
				{
					// set pos servo id=line.var, n
					// char SpeedLevel
					wckPosSend(line.var, 2, n);
    a0e0:	62 e0       	ldi	r22, 0x02	; 2
    a0e2:	8b 2d       	mov	r24, r11
    a0e4:	0e 94 15 53 	call	0xa62a	; 0xa62a <wckPosSend>
    a0e8:	13 c2       	rjmp	.+1062   	; 0xa510 <basic_run+0x7b0>
				}
			}
			break;
		case GOTO: 
			if ((ptr = gotoln(line.value))<0)
    a0ea:	c9 01       	movw	r24, r18
    a0ec:	0e 94 e0 44 	call	0x89c0	; 0x89c0 <gotoln>
    a0f0:	9c 01       	movw	r18, r24
    a0f2:	97 ff       	sbrs	r25, 7
    a0f4:	1d c2       	rjmp	.+1082   	; 0xa530 <basic_run+0x7d0>
			{
				errno=3; return;	
    a0f6:	83 e0       	ldi	r24, 0x03	; 3
    a0f8:	90 e0       	ldi	r25, 0x00	; 0
    a0fa:	05 c2       	rjmp	.+1034   	; 0xa506 <basic_run+0x7a6>
			}		
			tmp=0;
			break;	
		case PRINT: 
			n=0;
    a0fc:	18 86       	std	Y+8, r1	; 0x08
    a0fe:	1f 82       	std	Y+7, r1	; 0x07
			p=line.text;
    a100:	3e 82       	std	Y+6, r3	; 0x06
    a102:	2d 82       	std	Y+5, r2	; 0x05
			while (1)
			{
				switch (eval_expr(&p, &n))
    a104:	be 01       	movw	r22, r28
    a106:	69 5f       	subi	r22, 0xF9	; 249
    a108:	7f 4f       	sbci	r23, 0xFF	; 255
    a10a:	ce 01       	movw	r24, r28
    a10c:	05 96       	adiw	r24, 0x05	; 5
    a10e:	0e 94 20 49 	call	0x9240	; 0x9240 <eval_expr>
    a112:	28 2f       	mov	r18, r24
    a114:	88 23       	and	r24, r24
    a116:	99 f0       	breq	.+38     	; 0xa13e <basic_run+0x3de>
    a118:	81 30       	cpi	r24, 0x01	; 1
    a11a:	a9 f5       	brne	.+106    	; 0xa186 <basic_run+0x426>
				{
				case NUMBER:
					rprintf ("%d", n);
    a11c:	8f 81       	ldd	r24, Y+7	; 0x07
    a11e:	98 85       	ldd	r25, Y+8	; 0x08
    a120:	9f 93       	push	r25
    a122:	8f 93       	push	r24
    a124:	e8 e1       	ldi	r30, 0x18	; 24
    a126:	fd e3       	ldi	r31, 0x3D	; 61
    a128:	ff 93       	push	r31
    a12a:	ef 93       	push	r30
    a12c:	2f 93       	push	r18
    a12e:	0e 94 3d 2b 	call	0x567a	; 0x567a <rprintf1RamRom>
    a132:	0f 90       	pop	r0
    a134:	0f 90       	pop	r0
    a136:	0f 90       	pop	r0
    a138:	0f 90       	pop	r0
    a13a:	0f 90       	pop	r0
    a13c:	24 c0       	rjmp	.+72     	; 0xa186 <basic_run+0x426>
					break;
				case STRING:
					n=str_expr(p);
    a13e:	2d 81       	ldd	r18, Y+5	; 0x05
    a140:	3e 81       	ldd	r19, Y+6	; 0x06
    a142:	f9 01       	movw	r30, r18
    a144:	01 c0       	rjmp	.+2      	; 0xa148 <basic_run+0x3e8>
}

int str_expr(char *str)
{
	char *p=str;
	while (*str != '"') str++;
    a146:	31 96       	adiw	r30, 0x01	; 1
    a148:	80 81       	ld	r24, Z
    a14a:	82 32       	cpi	r24, 0x22	; 34
    a14c:	e1 f7       	brne	.-8      	; 0xa146 <basic_run+0x3e6>
	return str-p;
    a14e:	af 01       	movw	r20, r30
    a150:	42 1b       	sub	r20, r18
    a152:	53 0b       	sbc	r21, r19
				{
				case NUMBER:
					rprintf ("%d", n);
					break;
				case STRING:
					n=str_expr(p);
    a154:	58 87       	std	Y+8, r21	; 0x08
    a156:	4f 83       	std	Y+7, r20	; 0x07
					if (line.var==1)
    a158:	f1 e0       	ldi	r31, 0x01	; 1
    a15a:	bf 16       	cp	r11, r31
    a15c:	29 f4       	brne	.+10     	; 0xa168 <basic_run+0x408>
					{
						send_bus_str(p, n);
    a15e:	ba 01       	movw	r22, r20
    a160:	c9 01       	movw	r24, r18
    a162:	0e 94 3f 4e 	call	0x9c7e	; 0x9c7e <send_bus_str>
    a166:	05 c0       	rjmp	.+10     	; 0xa172 <basic_run+0x412>
					}
					else
					{
						rprintfStrLen(p,0,n);
    a168:	60 e0       	ldi	r22, 0x00	; 0
    a16a:	70 e0       	ldi	r23, 0x00	; 0
    a16c:	c9 01       	movw	r24, r18
    a16e:	0e 94 08 2a 	call	0x5410	; 0x5410 <rprintfStrLen>
					}
					p=p+n+1;
    a172:	2f 81       	ldd	r18, Y+7	; 0x07
    a174:	38 85       	ldd	r19, Y+8	; 0x08
    a176:	2f 5f       	subi	r18, 0xFF	; 255
    a178:	3f 4f       	sbci	r19, 0xFF	; 255
    a17a:	8d 81       	ldd	r24, Y+5	; 0x05
    a17c:	9e 81       	ldd	r25, Y+6	; 0x06
    a17e:	82 0f       	add	r24, r18
    a180:	93 1f       	adc	r25, r19
    a182:	9e 83       	std	Y+6, r25	; 0x06
    a184:	8d 83       	std	Y+5, r24	; 0x05
					break;
				}
				if (*p=='\0') break; // done
    a186:	ed 81       	ldd	r30, Y+5	; 0x05
    a188:	fe 81       	ldd	r31, Y+6	; 0x06
    a18a:	80 81       	ld	r24, Z
    a18c:	88 23       	and	r24, r24
    a18e:	91 f0       	breq	.+36     	; 0xa1b4 <basic_run+0x454>
				
				if (*p!=';' && *p!=',') {
    a190:	8b 33       	cpi	r24, 0x3B	; 59
    a192:	49 f0       	breq	.+18     	; 0xa1a6 <basic_run+0x446>
    a194:	8c 32       	cpi	r24, 0x2C	; 44
    a196:	51 f0       	breq	.+20     	; 0xa1ac <basic_run+0x44c>
					errno=4; //rprintf ("synatx prob= [%d]\r\n", *p); // DEBUG
    a198:	84 e0       	ldi	r24, 0x04	; 4
    a19a:	90 e0       	ldi	r25, 0x00	; 0
    a19c:	90 93 bc 0d 	sts	0x0DBC, r25
    a1a0:	80 93 bb 0d 	sts	0x0DBB, r24
    a1a4:	07 c0       	rjmp	.+14     	; 0xa1b4 <basic_run+0x454>
					break;
				}
				if (*p==';' && *(p+1)=='\0') // last one
    a1a6:	81 81       	ldd	r24, Z+1	; 0x01
    a1a8:	88 23       	and	r24, r24
    a1aa:	21 f0       	breq	.+8      	; 0xa1b4 <basic_run+0x454>
					break;
				p++;
    a1ac:	31 96       	adiw	r30, 0x01	; 1
    a1ae:	fe 83       	std	Y+6, r31	; 0x06
    a1b0:	ed 83       	std	Y+5, r30	; 0x05
    a1b2:	a8 cf       	rjmp	.-176    	; 0xa104 <basic_run+0x3a4>
			}
			// check for last ; (no crlf)
			if (*p!=';')	
    a1b4:	80 81       	ld	r24, Z
    a1b6:	8b 33       	cpi	r24, 0x3B	; 59
    a1b8:	09 f4       	brne	.+2      	; 0xa1bc <basic_run+0x45c>
    a1ba:	aa c1       	rjmp	.+852    	; 0xa510 <basic_run+0x7b0>
				rprintfStr ("\r\n"); 			
    a1bc:	8a eb       	ldi	r24, 0xBA	; 186
    a1be:	92 e0       	ldi	r25, 0x02	; 2
    a1c0:	0e 94 f9 29 	call	0x53f2	; 0x53f2 <rprintfStr>
    a1c4:	a5 c1       	rjmp	.+842    	; 0xa510 <basic_run+0x7b0>
			break;	
		case IF:		
			n=0;
    a1c6:	18 86       	std	Y+8, r1	; 0x08
    a1c8:	1f 82       	std	Y+7, r1	; 0x07
			p=line.text;
    a1ca:	3e 82       	std	Y+6, r3	; 0x06
    a1cc:	2d 82       	std	Y+5, r2	; 0x05

			if (eval_expr(&p, &n)==NUMBER)
    a1ce:	be 01       	movw	r22, r28
    a1d0:	69 5f       	subi	r22, 0xF9	; 249
    a1d2:	7f 4f       	sbci	r23, 0xFF	; 255
    a1d4:	ce 01       	movw	r24, r28
    a1d6:	05 96       	adiw	r24, 0x05	; 5
    a1d8:	0e 94 20 49 	call	0x9240	; 0x9240 <eval_expr>
    a1dc:	81 30       	cpi	r24, 0x01	; 1
    a1de:	09 f0       	breq	.+2      	; 0xa1e2 <basic_run+0x482>
    a1e0:	97 c1       	rjmp	.+814    	; 0xa510 <basic_run+0x7b0>
			{
				if (n != 0)
    a1e2:	8f 81       	ldd	r24, Y+7	; 0x07
    a1e4:	98 85       	ldd	r25, Y+8	; 0x08
    a1e6:	00 97       	sbiw	r24, 0x00	; 0
    a1e8:	09 f4       	brne	.+2      	; 0xa1ec <basic_run+0x48c>
    a1ea:	92 c1       	rjmp	.+804    	; 0xa510 <basic_run+0x7b0>
				{	
					if ((ptr = gotoln(n))<0) {errno=5; }			
    a1ec:	0e 94 e0 44 	call	0x89c0	; 0x89c0 <gotoln>
    a1f0:	9c 01       	movw	r18, r24
    a1f2:	97 ff       	sbrs	r25, 7
    a1f4:	9d c1       	rjmp	.+826    	; 0xa530 <basic_run+0x7d0>
    a1f6:	85 e0       	ldi	r24, 0x05	; 5
    a1f8:	90 e0       	ldi	r25, 0x00	; 0
    a1fa:	90 93 bc 0d 	sts	0x0DBC, r25
    a1fe:	80 93 bb 0d 	sts	0x0DBB, r24
    a202:	96 c1       	rjmp	.+812    	; 0xa530 <basic_run+0x7d0>
			}
			break;		
		case MOVE: 
			// No args - send servo positions syncronously
			// with args (No Frames / Time in Ms) - use MotionBuffer
			fm=0; tm=0;
    a204:	1c 82       	std	Y+4, r1	; 0x04
    a206:	1b 82       	std	Y+3, r1	; 0x03
    a208:	1a 82       	std	Y+2, r1	; 0x02
    a20a:	19 82       	std	Y+1, r1	; 0x01
			p=line.text;
    a20c:	3e 82       	std	Y+6, r3	; 0x06
    a20e:	2d 82       	std	Y+5, r2	; 0x05
			if (p!=0)
			{
				eval_expr(&p, &fm);
    a210:	be 01       	movw	r22, r28
    a212:	6d 5f       	subi	r22, 0xFD	; 253
    a214:	7f 4f       	sbci	r23, 0xFF	; 255
    a216:	ce 01       	movw	r24, r28
    a218:	05 96       	adiw	r24, 0x05	; 5
    a21a:	0e 94 20 49 	call	0x9240	; 0x9240 <eval_expr>
				if (*p++ != ',') { errno=5; break;}
    a21e:	ed 81       	ldd	r30, Y+5	; 0x05
    a220:	fe 81       	ldd	r31, Y+6	; 0x06
    a222:	81 91       	ld	r24, Z+
    a224:	fe 83       	std	Y+6, r31	; 0x06
    a226:	ed 83       	std	Y+5, r30	; 0x05
    a228:	8c 32       	cpi	r24, 0x2C	; 44
    a22a:	39 f0       	breq	.+14     	; 0xa23a <basic_run+0x4da>
    a22c:	85 e0       	ldi	r24, 0x05	; 5
    a22e:	90 e0       	ldi	r25, 0x00	; 0
    a230:	90 93 bc 0d 	sts	0x0DBC, r25
    a234:	80 93 bb 0d 	sts	0x0DBB, r24
    a238:	6b c1       	rjmp	.+726    	; 0xa510 <basic_run+0x7b0>
				eval_expr(&p, &tm);
    a23a:	be 01       	movw	r22, r28
    a23c:	6f 5f       	subi	r22, 0xFF	; 255
    a23e:	7f 4f       	sbci	r23, 0xFF	; 255
    a240:	ce 01       	movw	r24, r28
    a242:	05 96       	adiw	r24, 0x05	; 5
    a244:	0e 94 20 49 	call	0x9240	; 0x9240 <eval_expr>
				//rprintf ("Move %d, %d\r\n", fm, tm); // DEBUG
				
				motionBuf = GetNextMotionBuffer();
    a248:	0e 94 8d 23 	call	0x471a	; 0x471a <GetNextMotionBuffer>
    a24c:	fc 01       	movw	r30, r24
    a24e:	90 93 8f 0a 	sts	0x0A8F, r25
    a252:	80 93 8e 0a 	sts	0x0A8E, r24
				motionBuf[0]= (unsigned char)1; //number of scenes
    a256:	81 e0       	ldi	r24, 0x01	; 1
    a258:	80 83       	st	Z, r24
				motionBuf[1]= (unsigned char)C; //number of servos
    a25a:	e0 91 8e 0a 	lds	r30, 0x0A8E
    a25e:	f0 91 8f 0a 	lds	r31, 0x0A8F
    a262:	80 e1       	ldi	r24, 0x10	; 16
    a264:	81 83       	std	Z+1, r24	; 0x01
				
				for (n=0;n<C;n++) { motionBuf[2+n]= PGAIN; } //PGAIN
    a266:	18 86       	std	Y+8, r1	; 0x08
    a268:	1f 82       	std	Y+7, r1	; 0x07
    a26a:	0d c0       	rjmp	.+26     	; 0xa286 <basic_run+0x526>
    a26c:	e0 91 8e 0a 	lds	r30, 0x0A8E
    a270:	f0 91 8f 0a 	lds	r31, 0x0A8F
    a274:	e8 0f       	add	r30, r24
    a276:	f9 1f       	adc	r31, r25
    a278:	94 e1       	ldi	r25, 0x14	; 20
    a27a:	92 83       	std	Z+2, r25	; 0x02
    a27c:	8f 81       	ldd	r24, Y+7	; 0x07
    a27e:	98 85       	ldd	r25, Y+8	; 0x08
    a280:	01 96       	adiw	r24, 0x01	; 1
    a282:	98 87       	std	Y+8, r25	; 0x08
    a284:	8f 83       	std	Y+7, r24	; 0x07
    a286:	8f 81       	ldd	r24, Y+7	; 0x07
    a288:	98 85       	ldd	r25, Y+8	; 0x08
    a28a:	80 31       	cpi	r24, 0x10	; 16
    a28c:	91 05       	cpc	r25, r1
    a28e:	74 f3       	brlt	.-36     	; 0xa26c <basic_run+0x50c>

				for (n=0;n<C;n++) { motionBuf[2+C+n]=DGAIN; } //DGAIN
    a290:	18 86       	std	Y+8, r1	; 0x08
    a292:	1f 82       	std	Y+7, r1	; 0x07
    a294:	0d c0       	rjmp	.+26     	; 0xa2b0 <basic_run+0x550>
    a296:	e0 91 8e 0a 	lds	r30, 0x0A8E
    a29a:	f0 91 8f 0a 	lds	r31, 0x0A8F
    a29e:	e8 0f       	add	r30, r24
    a2a0:	f9 1f       	adc	r31, r25
    a2a2:	8e e1       	ldi	r24, 0x1E	; 30
    a2a4:	82 8b       	std	Z+18, r24	; 0x12
    a2a6:	8f 81       	ldd	r24, Y+7	; 0x07
    a2a8:	98 85       	ldd	r25, Y+8	; 0x08
    a2aa:	01 96       	adiw	r24, 0x01	; 1
    a2ac:	98 87       	std	Y+8, r25	; 0x08
    a2ae:	8f 83       	std	Y+7, r24	; 0x07
    a2b0:	8f 81       	ldd	r24, Y+7	; 0x07
    a2b2:	98 85       	ldd	r25, Y+8	; 0x08
    a2b4:	80 31       	cpi	r24, 0x10	; 16
    a2b6:	91 05       	cpc	r25, r1
    a2b8:	74 f3       	brlt	.-36     	; 0xa296 <basic_run+0x536>

				for (n=0;n<C;n++) { motionBuf[2+2*C+n]=IGAIN; } //IGAIN		
    a2ba:	18 86       	std	Y+8, r1	; 0x08
    a2bc:	1f 82       	std	Y+7, r1	; 0x07
    a2be:	08 c0       	rjmp	.+16     	; 0xa2d0 <basic_run+0x570>
    a2c0:	e8 0f       	add	r30, r24
    a2c2:	f9 1f       	adc	r31, r25
    a2c4:	12 a2       	std	Z+34, r1	; 0x22
    a2c6:	8f 81       	ldd	r24, Y+7	; 0x07
    a2c8:	98 85       	ldd	r25, Y+8	; 0x08
    a2ca:	01 96       	adiw	r24, 0x01	; 1
    a2cc:	98 87       	std	Y+8, r25	; 0x08
    a2ce:	8f 83       	std	Y+7, r24	; 0x07
    a2d0:	8f 81       	ldd	r24, Y+7	; 0x07
    a2d2:	98 85       	ldd	r25, Y+8	; 0x08
    a2d4:	e0 91 8e 0a 	lds	r30, 0x0A8E
    a2d8:	f0 91 8f 0a 	lds	r31, 0x0A8F
    a2dc:	80 31       	cpi	r24, 0x10	; 16
    a2de:	91 05       	cpc	r25, r1
    a2e0:	7c f3       	brlt	.-34     	; 0xa2c0 <basic_run+0x560>
				
				motionBuf[S]   =(WORD)tm;
    a2e2:	89 81       	ldd	r24, Y+1	; 0x01
    a2e4:	82 ab       	std	Z+50, r24	; 0x32
				motionBuf[S+1] =(WORD)(tm)>>8;
    a2e6:	e0 91 8e 0a 	lds	r30, 0x0A8E
    a2ea:	f0 91 8f 0a 	lds	r31, 0x0A8F
    a2ee:	8a 81       	ldd	r24, Y+2	; 0x02
    a2f0:	83 ab       	std	Z+51, r24	; 0x33
				motionBuf[S+2] =(WORD)fm;
    a2f2:	e0 91 8e 0a 	lds	r30, 0x0A8E
    a2f6:	f0 91 8f 0a 	lds	r31, 0x0A8F
    a2fa:	8b 81       	ldd	r24, Y+3	; 0x03
    a2fc:	84 ab       	std	Z+52, r24	; 0x34
				motionBuf[S+3] =(WORD)(fm)>>8;
    a2fe:	e0 91 8e 0a 	lds	r30, 0x0A8E
    a302:	f0 91 8f 0a 	lds	r31, 0x0A8F
    a306:	8c 81       	ldd	r24, Y+4	; 0x04
    a308:	85 ab       	std	Z+53, r24	; 0x35
				
				for (n=0;n<C;n++) { motionBuf[S+4+n]=scene[n]; }
    a30a:	18 86       	std	Y+8, r1	; 0x08
    a30c:	1f 82       	std	Y+7, r1	; 0x07
    a30e:	13 c0       	rjmp	.+38     	; 0xa336 <basic_run+0x5d6>
    a310:	e0 91 8e 0a 	lds	r30, 0x0A8E
    a314:	f0 91 8f 0a 	lds	r31, 0x0A8F
    a318:	ea 0f       	add	r30, r26
    a31a:	fb 1f       	adc	r31, r27
    a31c:	85 e1       	ldi	r24, 0x15	; 21
    a31e:	90 e0       	ldi	r25, 0x00	; 0
    a320:	8c 0f       	add	r24, r28
    a322:	9d 1f       	adc	r25, r29
    a324:	a8 0f       	add	r26, r24
    a326:	b9 1f       	adc	r27, r25
    a328:	8c 91       	ld	r24, X
    a32a:	86 ab       	std	Z+54, r24	; 0x36
    a32c:	8f 81       	ldd	r24, Y+7	; 0x07
    a32e:	98 85       	ldd	r25, Y+8	; 0x08
    a330:	01 96       	adiw	r24, 0x01	; 1
    a332:	98 87       	std	Y+8, r25	; 0x08
    a334:	8f 83       	std	Y+7, r24	; 0x07
    a336:	af 81       	ldd	r26, Y+7	; 0x07
    a338:	b8 85       	ldd	r27, Y+8	; 0x08
    a33a:	a0 31       	cpi	r26, 0x10	; 16
    a33c:	b1 05       	cpc	r27, r1
    a33e:	44 f3       	brlt	.-48     	; 0xa310 <basic_run+0x5b0>
				for (n=0;n<C;n++) { motionBuf[S+4+n+C]=3; } //torquw
    a340:	18 86       	std	Y+8, r1	; 0x08
    a342:	1f 82       	std	Y+7, r1	; 0x07
    a344:	0f c0       	rjmp	.+30     	; 0xa364 <basic_run+0x604>
    a346:	e0 91 8e 0a 	lds	r30, 0x0A8E
    a34a:	f0 91 8f 0a 	lds	r31, 0x0A8F
    a34e:	e8 0f       	add	r30, r24
    a350:	f9 1f       	adc	r31, r25
    a352:	ea 5b       	subi	r30, 0xBA	; 186
    a354:	ff 4f       	sbci	r31, 0xFF	; 255
    a356:	93 e0       	ldi	r25, 0x03	; 3
    a358:	90 83       	st	Z, r25
    a35a:	8f 81       	ldd	r24, Y+7	; 0x07
    a35c:	98 85       	ldd	r25, Y+8	; 0x08
    a35e:	01 96       	adiw	r24, 0x01	; 1
    a360:	98 87       	std	Y+8, r25	; 0x08
    a362:	8f 83       	std	Y+7, r24	; 0x07
    a364:	8f 81       	ldd	r24, Y+7	; 0x07
    a366:	98 85       	ldd	r25, Y+8	; 0x08
    a368:	80 31       	cpi	r24, 0x10	; 16
    a36a:	91 05       	cpc	r25, r1
    a36c:	64 f3       	brlt	.-40     	; 0xa346 <basic_run+0x5e6>
				for (n=0;n<C;n++) { motionBuf[S+4+n+C*2]=0; } //ext data
    a36e:	18 86       	std	Y+8, r1	; 0x08
    a370:	1f 82       	std	Y+7, r1	; 0x07
    a372:	0a c0       	rjmp	.+20     	; 0xa388 <basic_run+0x628>
    a374:	e8 0f       	add	r30, r24
    a376:	f9 1f       	adc	r31, r25
    a378:	ea 5a       	subi	r30, 0xAA	; 170
    a37a:	ff 4f       	sbci	r31, 0xFF	; 255
    a37c:	10 82       	st	Z, r1
    a37e:	8f 81       	ldd	r24, Y+7	; 0x07
    a380:	98 85       	ldd	r25, Y+8	; 0x08
    a382:	01 96       	adiw	r24, 0x01	; 1
    a384:	98 87       	std	Y+8, r25	; 0x08
    a386:	8f 83       	std	Y+7, r24	; 0x07
    a388:	8f 81       	ldd	r24, Y+7	; 0x07
    a38a:	98 85       	ldd	r25, Y+8	; 0x08
    a38c:	e0 91 8e 0a 	lds	r30, 0x0A8E
    a390:	f0 91 8f 0a 	lds	r31, 0x0A8F
    a394:	80 31       	cpi	r24, 0x10	; 16
    a396:	91 05       	cpc	r25, r1
    a398:	6c f3       	brlt	.-38     	; 0xa374 <basic_run+0x614>
				
				LoadMotionFromBuffer(motionBuf);
    a39a:	cf 01       	movw	r24, r30
    a39c:	0e 94 76 27 	call	0x4eec	; 0x4eec <LoadMotionFromBuffer>
				
				//rprintf ("Play? "); DPAUSE
				PlaySceneFromBuffer(motionBuf, 0);
    a3a0:	60 e0       	ldi	r22, 0x00	; 0
    a3a2:	70 e0       	ldi	r23, 0x00	; 0
    a3a4:	80 91 8e 0a 	lds	r24, 0x0A8E
    a3a8:	90 91 8f 0a 	lds	r25, 0x0A8F
    a3ac:	0e 94 81 25 	call	0x4b02	; 0x4b02 <PlaySceneFromBuffer>
				complete_motion(motionBuf);
    a3b0:	80 91 8e 0a 	lds	r24, 0x0A8E
    a3b4:	90 91 8f 0a 	lds	r25, 0x0A8F
    a3b8:	0e 94 71 26 	call	0x4ce2	; 0x4ce2 <complete_motion>
    a3bc:	a9 c0       	rjmp	.+338    	; 0xa510 <basic_run+0x7b0>
			}
			//
			break;
		case SCENE: 
			// read in 16 servo position values and store
			p=line.text;
    a3be:	3e 82       	std	Y+6, r3	; 0x06
    a3c0:	2d 82       	std	Y+5, r2	; 0x05
    a3c2:	00 e0       	ldi	r16, 0x00	; 0
    a3c4:	10 e0       	ldi	r17, 0x00	; 0
			for (int i=0;i<16;i++)
			{
				n=0;
    a3c6:	18 86       	std	Y+8, r1	; 0x08
    a3c8:	1f 82       	std	Y+7, r1	; 0x07
				eval_expr(&p, &n);
    a3ca:	be 01       	movw	r22, r28
    a3cc:	69 5f       	subi	r22, 0xF9	; 249
    a3ce:	7f 4f       	sbci	r23, 0xFF	; 255
    a3d0:	ce 01       	movw	r24, r28
    a3d2:	05 96       	adiw	r24, 0x05	; 5
    a3d4:	0e 94 20 49 	call	0x9240	; 0x9240 <eval_expr>
				if (i!=15 && *p++ != ',') { errno=6;break; }
    a3d8:	0f 30       	cpi	r16, 0x0F	; 15
    a3da:	11 05       	cpc	r17, r1
    a3dc:	51 f0       	breq	.+20     	; 0xa3f2 <basic_run+0x692>
    a3de:	ed 81       	ldd	r30, Y+5	; 0x05
    a3e0:	fe 81       	ldd	r31, Y+6	; 0x06
    a3e2:	81 91       	ld	r24, Z+
    a3e4:	fe 83       	std	Y+6, r31	; 0x06
    a3e6:	ed 83       	std	Y+5, r30	; 0x05
    a3e8:	8c 32       	cpi	r24, 0x2C	; 44
    a3ea:	19 f0       	breq	.+6      	; 0xa3f2 <basic_run+0x692>
    a3ec:	86 e0       	ldi	r24, 0x06	; 6
    a3ee:	90 e0       	ldi	r25, 0x00	; 0
    a3f0:	1f cf       	rjmp	.-450    	; 0xa230 <basic_run+0x4d0>
				scene[i]=n;
    a3f2:	e5 e1       	ldi	r30, 0x15	; 21
    a3f4:	f0 e0       	ldi	r31, 0x00	; 0
    a3f6:	ec 0f       	add	r30, r28
    a3f8:	fd 1f       	adc	r31, r29
    a3fa:	e0 0f       	add	r30, r16
    a3fc:	f1 1f       	adc	r31, r17
    a3fe:	8f 81       	ldd	r24, Y+7	; 0x07
    a400:	80 83       	st	Z, r24
			//
			break;
		case SCENE: 
			// read in 16 servo position values and store
			p=line.text;
			for (int i=0;i<16;i++)
    a402:	0f 5f       	subi	r16, 0xFF	; 255
    a404:	1f 4f       	sbci	r17, 0xFF	; 255
    a406:	00 31       	cpi	r16, 0x10	; 16
    a408:	11 05       	cpc	r17, r1
    a40a:	e9 f6       	brne	.-70     	; 0xa3c6 <basic_run+0x666>
    a40c:	81 c0       	rjmp	.+258    	; 0xa510 <basic_run+0x7b0>
				scene[i]=n;
			}
			//
			break;
		case XACT: 
			Perform_Action (line.value);
    a40e:	8a 2d       	mov	r24, r10
    a410:	0e 94 c0 32 	call	0x6580	; 0x6580 <Perform_Action>
    a414:	7d c0       	rjmp	.+250    	; 0xa510 <basic_run+0x7b0>
			break;
		case WAIT: 
			_delay_ms(line.value);
    a416:	b9 01       	movw	r22, r18
    a418:	88 27       	eor	r24, r24
    a41a:	77 fd       	sbrc	r23, 7
    a41c:	80 95       	com	r24
    a41e:	98 2f       	mov	r25, r24
    a420:	0e 94 f8 69 	call	0xd3f0	; 0xd3f0 <__floatsisf>
    a424:	5b 01       	movw	r10, r22
    a426:	6c 01       	movw	r12, r24
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    a428:	20 e0       	ldi	r18, 0x00	; 0
    a42a:	34 e6       	ldi	r19, 0x64	; 100
    a42c:	46 e6       	ldi	r20, 0x66	; 102
    a42e:	55 e4       	ldi	r21, 0x45	; 69
    a430:	0e 94 c4 67 	call	0xcf88	; 0xcf88 <__mulsf3>
    a434:	7b 01       	movw	r14, r22
    a436:	8c 01       	movw	r16, r24
	if (__tmp < 1.0)
    a438:	20 e0       	ldi	r18, 0x00	; 0
    a43a:	30 e0       	ldi	r19, 0x00	; 0
    a43c:	40 e8       	ldi	r20, 0x80	; 128
    a43e:	5f e3       	ldi	r21, 0x3F	; 63
    a440:	0e 94 c8 69 	call	0xd390	; 0xd390 <__ltsf2>
    a444:	88 23       	and	r24, r24
    a446:	1c f4       	brge	.+6      	; 0xa44e <basic_run+0x6ee>
    a448:	61 e0       	ldi	r22, 0x01	; 1
    a44a:	70 e0       	ldi	r23, 0x00	; 0
    a44c:	23 c0       	rjmp	.+70     	; 0xa494 <basic_run+0x734>
		__ticks = 1;
	else if (__tmp > 65535)
    a44e:	20 e0       	ldi	r18, 0x00	; 0
    a450:	3f ef       	ldi	r19, 0xFF	; 255
    a452:	4f e7       	ldi	r20, 0x7F	; 127
    a454:	57 e4       	ldi	r21, 0x47	; 71
    a456:	c8 01       	movw	r24, r16
    a458:	b7 01       	movw	r22, r14
    a45a:	0e 94 68 69 	call	0xd2d0	; 0xd2d0 <__gtsf2>
    a45e:	18 16       	cp	r1, r24
    a460:	ac f4       	brge	.+42     	; 0xa48c <basic_run+0x72c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    a462:	20 e0       	ldi	r18, 0x00	; 0
    a464:	30 e0       	ldi	r19, 0x00	; 0
    a466:	40 e2       	ldi	r20, 0x20	; 32
    a468:	51 e4       	ldi	r21, 0x41	; 65
    a46a:	c6 01       	movw	r24, r12
    a46c:	b5 01       	movw	r22, r10
    a46e:	0e 94 c4 67 	call	0xcf88	; 0xcf88 <__mulsf3>
    a472:	0e 94 ee 65 	call	0xcbdc	; 0xcbdc <__fixunssfsi>
    a476:	06 c0       	rjmp	.+12     	; 0xa484 <basic_run+0x724>
    a478:	80 e7       	ldi	r24, 0x70	; 112
    a47a:	91 e0       	ldi	r25, 0x01	; 1
    a47c:	01 97       	sbiw	r24, 0x01	; 1
    a47e:	f1 f7       	brne	.-4      	; 0xa47c <basic_run+0x71c>
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    a480:	61 50       	subi	r22, 0x01	; 1
    a482:	70 40       	sbci	r23, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    a484:	61 15       	cp	r22, r1
    a486:	71 05       	cpc	r23, r1
    a488:	b9 f7       	brne	.-18     	; 0xa478 <basic_run+0x718>
    a48a:	42 c0       	rjmp	.+132    	; 0xa510 <basic_run+0x7b0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    a48c:	c8 01       	movw	r24, r16
    a48e:	b7 01       	movw	r22, r14
    a490:	0e 94 ee 65 	call	0xcbdc	; 0xcbdc <__fixunssfsi>
    a494:	cb 01       	movw	r24, r22
    a496:	01 97       	sbiw	r24, 0x01	; 1
    a498:	f1 f7       	brne	.-4      	; 0xa496 <basic_run+0x736>
    a49a:	3a c0       	rjmp	.+116    	; 0xa510 <basic_run+0x7b0>
			break;
		case END: 
			rprintfStr ("End of program\r\n"); 
    a49c:	86 e4       	ldi	r24, 0x46	; 70
    a49e:	93 e0       	ldi	r25, 0x03	; 3
    a4a0:	0e 94 f9 29 	call	0x53f2	; 0x53f2 <rprintfStr>
    a4a4:	48 c0       	rjmp	.+144    	; 0xa536 <basic_run+0x7d6>
			return;
		case GOSUB: 
			//rprintfStr ("gosub\r\n");  //debug
			gosub[gp++]=ptr;
			if ((ptr = gotoln(line.value))<0)
    a4a6:	c9 01       	movw	r24, r18
    a4a8:	0e 94 e0 44 	call	0x89c0	; 0x89c0 <gotoln>
    a4ac:	9c 01       	movw	r18, r24
    a4ae:	97 fd       	sbrc	r25, 7
    a4b0:	42 c0       	rjmp	.+132    	; 0xa536 <basic_run+0x7d6>
		case END: 
			rprintfStr ("End of program\r\n"); 
			return;
		case GOSUB: 
			//rprintfStr ("gosub\r\n");  //debug
			gosub[gp++]=ptr;
    a4b2:	f2 01       	movw	r30, r4
    a4b4:	ee 0f       	add	r30, r30
    a4b6:	ff 1f       	adc	r31, r31
    a4b8:	81 e0       	ldi	r24, 0x01	; 1
    a4ba:	90 e0       	ldi	r25, 0x00	; 0
    a4bc:	8c 0f       	add	r24, r28
    a4be:	9d 1f       	adc	r25, r29
    a4c0:	e8 0f       	add	r30, r24
    a4c2:	f9 1f       	adc	r31, r25
    a4c4:	77 86       	std	Z+15, r7	; 0x0f
    a4c6:	66 86       	std	Z+14, r6	; 0x0e
    a4c8:	08 94       	sec
    a4ca:	41 1c       	adc	r4, r1
    a4cc:	51 1c       	adc	r5, r1
    a4ce:	30 c0       	rjmp	.+96     	; 0xa530 <basic_run+0x7d0>
				return;	// this needs an error message		
			tmp=0;		
			break;
		case RETURN: 
			//rprintfStr ("return\r\n"); //debug
			if (gp>0) {
    a4d0:	41 14       	cp	r4, r1
    a4d2:	51 04       	cpc	r5, r1
    a4d4:	79 f0       	breq	.+30     	; 0xa4f4 <basic_run+0x794>
				ptr=gosub[--gp];
    a4d6:	08 94       	sec
    a4d8:	41 08       	sbc	r4, r1
    a4da:	51 08       	sbc	r5, r1
    a4dc:	f2 01       	movw	r30, r4
    a4de:	ee 0f       	add	r30, r30
    a4e0:	ff 1f       	adc	r31, r31
    a4e2:	81 e0       	ldi	r24, 0x01	; 1
    a4e4:	90 e0       	ldi	r25, 0x00	; 0
    a4e6:	8c 0f       	add	r24, r28
    a4e8:	9d 1f       	adc	r25, r29
    a4ea:	e8 0f       	add	r30, r24
    a4ec:	f9 1f       	adc	r31, r25
    a4ee:	26 85       	ldd	r18, Z+14	; 0x0e
    a4f0:	37 85       	ldd	r19, Z+15	; 0x0f
    a4f2:	1e c0       	rjmp	.+60     	; 0xa530 <basic_run+0x7d0>
				tmp=0;
			} else {
				errno=7;
    a4f4:	e7 e0       	ldi	r30, 0x07	; 7
    a4f6:	f0 e0       	ldi	r31, 0x00	; 0
    a4f8:	f0 93 bc 0d 	sts	0x0DBC, r31
    a4fc:	e0 93 bb 0d 	sts	0x0DBB, r30
    a500:	07 c0       	rjmp	.+14     	; 0xa510 <basic_run+0x7b0>
			}
			break;
		default:
			errno=8; // DEBUG
    a502:	88 e0       	ldi	r24, 0x08	; 8
    a504:	90 e0       	ldi	r25, 0x00	; 0
    a506:	90 93 bc 0d 	sts	0x0DBC, r25
    a50a:	80 93 bb 0d 	sts	0x0DBB, r24
    a50e:	13 c0       	rjmp	.+38     	; 0xa536 <basic_run+0x7d6>
    a510:	74 01       	movw	r14, r8
	line.text=buf;
	int n;
	
	errno=0;
	
	while (tmp != 0xCC && ptr < EEPROM_MEM_SZ )
    a512:	a7 96       	adiw	r28, 0x27	; 39
    a514:	ff ad       	ldd	r31, Y+63	; 0x3f
    a516:	a7 97       	sbiw	r28, 0x27	; 39
    a518:	fc 3c       	cpi	r31, 0xCC	; 204
    a51a:	69 f0       	breq	.+26     	; 0xa536 <basic_run+0x7d6>
    a51c:	80 e0       	ldi	r24, 0x00	; 0
    a51e:	68 16       	cp	r6, r24
    a520:	84 e0       	ldi	r24, 0x04	; 4
    a522:	78 06       	cpc	r7, r24
    a524:	0c f4       	brge	.+2      	; 0xa528 <basic_run+0x7c8>
    a526:	5d cc       	rjmp	.-1862   	; 0x9de2 <basic_run+0x82>
    a528:	06 c0       	rjmp	.+12     	; 0xa536 <basic_run+0x7d6>
    a52a:	8d 2d       	mov	r24, r13
    a52c:	9c 2d       	mov	r25, r12
    a52e:	9c 01       	movw	r18, r24
    a530:	39 01       	movw	r6, r18
    a532:	74 01       	movw	r14, r8
    a534:	f3 cf       	rjmp	.-26     	; 0xa51c <basic_run+0x7bc>
			errno=8; // DEBUG
			tmp=0xCC;
		}		
	}
	
}
    a536:	c7 59       	subi	r28, 0x97	; 151
    a538:	df 4f       	sbci	r29, 0xFF	; 255
    a53a:	0f b6       	in	r0, 0x3f	; 63
    a53c:	f8 94       	cli
    a53e:	de bf       	out	0x3e, r29	; 62
    a540:	0f be       	out	0x3f, r0	; 63
    a542:	cd bf       	out	0x3d, r28	; 61
    a544:	cf 91       	pop	r28
    a546:	df 91       	pop	r29
    a548:	1f 91       	pop	r17
    a54a:	0f 91       	pop	r16
    a54c:	ff 90       	pop	r15
    a54e:	ef 90       	pop	r14
    a550:	df 90       	pop	r13
    a552:	cf 90       	pop	r12
    a554:	bf 90       	pop	r11
    a556:	af 90       	pop	r10
    a558:	9f 90       	pop	r9
    a55a:	8f 90       	pop	r8
    a55c:	7f 90       	pop	r7
    a55e:	6f 90       	pop	r6
    a560:	5f 90       	pop	r5
    a562:	4f 90       	pop	r4
    a564:	3f 90       	pop	r3
    a566:	2f 90       	pop	r2
    a568:	08 95       	ret

0000a56a <wckReInit>:
#define TIME_OUT2  250	// timeout for Set routines that change baudrate, etc.

//////////////////////////////// Serial Interface Functions ///////////////////////////

void wckReInit(unsigned int ubrr)
{
    a56a:	28 2f       	mov	r18, r24
	while ((UCSR0A & (1 << TXC)) == 0) ; //wait until any transmission complete
    a56c:	5e 9b       	sbis	0x0b, 6	; 11
    a56e:	fe cf       	rjmp	.-4      	; 0xa56c <wckReInit+0x2>

	/* Dis-able receiver and transmitter */
	UCSR0B &= ~((1<<RXEN)|(1<<TXEN));
    a570:	8a b1       	in	r24, 0x0a	; 10
    a572:	87 7e       	andi	r24, 0xE7	; 231
    a574:	8a b9       	out	0x0a, r24	; 10

	/* Set baud rate */
	UBRR0H = (unsigned char)(ubrr>>8);
    a576:	90 93 90 00 	sts	0x0090, r25
	UBRR0L = (unsigned char)ubrr;
    a57a:	29 b9       	out	0x09, r18	; 9
	
	/* Set frame format: 8data, 2stop bit */
	//UCSR0C = (1<<USBS)|(3<<UCSZ0);

	/* Enable receiver and transmitter */
	UCSR0B = (1<<RXEN)|(1<<TXEN);
    a57c:	88 e1       	ldi	r24, 0x18	; 24
    a57e:	8a b9       	out	0x0a, r24	; 10
}
    a580:	08 95       	ret

0000a582 <wckFlush>:

//------------------------------------------------------------------------------
// Transmit char to UART when UART is ready
//------------------------------------------------------------------------------
void wckFlush( void )
{
    a582:	01 c0       	rjmp	.+2      	; 0xa586 <wckFlush+0x4>
	unsigned char dummy;
	while ( UCSR0A & (1<<RXC) ) dummy = UDR0;
    a584:	8c b1       	in	r24, 0x0c	; 12
    a586:	5f 99       	sbic	0x0b, 7	; 11
    a588:	fd cf       	rjmp	.-6      	; 0xa584 <wckFlush+0x2>
}
    a58a:	08 95       	ret

0000a58c <wckSendByte>:

//------------------------------------------------------------------------------
// Transmit char to UART when UART is ready
//------------------------------------------------------------------------------
void wckSendByte(char td)
{
    a58c:	5d 9b       	sbis	0x0b, 5	; 11
    a58e:	fe cf       	rjmp	.-4      	; 0xa58c <wckSendByte>
	while(!(UCSR0A&(1<<UDRE))); 	// wait until data register is empty
	UDR0=td;
    a590:	8c b9       	out	0x0c, r24	; 12
}
    a592:	08 95       	ret

0000a594 <wckGetByte>:

//------------------------------------------------------------------------------
// Get character when received. or timeout
//------------------------------------------------------------------------------
char wckGetByte(WORD timeout)
{
    a594:	ac 01       	movw	r20, r24
	WORD	startT;
	startT = gMSEC;
    a596:	20 91 be 0a 	lds	r18, 0x0ABE
    a59a:	30 91 bf 0a 	lds	r19, 0x0ABF
    a59e:	17 c0       	rjmp	.+46     	; 0xa5ce <wckGetByte+0x3a>
	while(!(UCSR0A&(1<<RXC)) ){ 	// test for received character
        if(gMSEC<startT) {
    a5a0:	80 91 be 0a 	lds	r24, 0x0ABE
    a5a4:	90 91 bf 0a 	lds	r25, 0x0ABF
    a5a8:	82 17       	cp	r24, r18
    a5aa:	93 07       	cpc	r25, r19
    a5ac:	38 f4       	brcc	.+14     	; 0xa5bc <wckGetByte+0x28>
			// wait RX_T_OUT for a character
            if((1000 - startT + gMSEC) > timeout) break;
    a5ae:	80 91 be 0a 	lds	r24, 0x0ABE
    a5b2:	90 91 bf 0a 	lds	r25, 0x0ABF
    a5b6:	88 51       	subi	r24, 0x18	; 24
    a5b8:	9c 4f       	sbci	r25, 0xFC	; 252
    a5ba:	04 c0       	rjmp	.+8      	; 0xa5c4 <wckGetByte+0x30>
        }
		else if((gMSEC - startT) > timeout) break;
    a5bc:	80 91 be 0a 	lds	r24, 0x0ABE
    a5c0:	90 91 bf 0a 	lds	r25, 0x0ABF
    a5c4:	82 1b       	sub	r24, r18
    a5c6:	93 0b       	sbc	r25, r19
    a5c8:	48 17       	cp	r20, r24
    a5ca:	59 07       	cpc	r21, r25
    a5cc:	10 f0       	brcs	.+4      	; 0xa5d2 <wckGetByte+0x3e>
//------------------------------------------------------------------------------
char wckGetByte(WORD timeout)
{
	WORD	startT;
	startT = gMSEC;
	while(!(UCSR0A&(1<<RXC)) ){ 	// test for received character
    a5ce:	5f 9b       	sbis	0x0b, 7	; 11
    a5d0:	e7 cf       	rjmp	.-50     	; 0xa5a0 <wckGetByte+0xc>
			// wait RX_T_OUT for a character
            if((1000 - startT + gMSEC) > timeout) break;
        }
		else if((gMSEC - startT) > timeout) break;
	}
	return UDR0;
    a5d2:	8c b1       	in	r24, 0x0c	; 12
}
    a5d4:	08 95       	ret

0000a5d6 <wckSendOperCommand>:
/* Function that sends Operation Command Packet(4 Byte) to wCK module */
/* Input : Data1, Data2 */
/* Output : None */
/******************************************************************************/
void wckSendOperCommand(char Data1, char Data2)
{
    a5d6:	98 2f       	mov	r25, r24
//------------------------------------------------------------------------------
// Transmit char to UART when UART is ready
//------------------------------------------------------------------------------
void wckSendByte(char td)
{
	while(!(UCSR0A&(1<<UDRE))); 	// wait until data register is empty
    a5d8:	5d 9b       	sbis	0x0b, 5	; 11
    a5da:	fe cf       	rjmp	.-4      	; 0xa5d8 <wckSendOperCommand+0x2>
	UDR0=td;
    a5dc:	8f ef       	ldi	r24, 0xFF	; 255
    a5de:	8c b9       	out	0x0c, r24	; 12
//------------------------------------------------------------------------------
// Transmit char to UART when UART is ready
//------------------------------------------------------------------------------
void wckSendByte(char td)
{
	while(!(UCSR0A&(1<<UDRE))); 	// wait until data register is empty
    a5e0:	5d 9b       	sbis	0x0b, 5	; 11
    a5e2:	fe cf       	rjmp	.-4      	; 0xa5e0 <wckSendOperCommand+0xa>
	UDR0=td;
    a5e4:	9c b9       	out	0x0c, r25	; 12
//------------------------------------------------------------------------------
// Transmit char to UART when UART is ready
//------------------------------------------------------------------------------
void wckSendByte(char td)
{
	while(!(UCSR0A&(1<<UDRE))); 	// wait until data register is empty
    a5e6:	5d 9b       	sbis	0x0b, 5	; 11
    a5e8:	fe cf       	rjmp	.-4      	; 0xa5e6 <wckSendOperCommand+0x10>
	UDR0=td;
    a5ea:	6c b9       	out	0x0c, r22	; 12
//------------------------------------------------------------------------------
// Transmit char to UART when UART is ready
//------------------------------------------------------------------------------
void wckSendByte(char td)
{
	while(!(UCSR0A&(1<<UDRE))); 	// wait until data register is empty
    a5ec:	5d 9b       	sbis	0x0b, 5	; 11
    a5ee:	fe cf       	rjmp	.-4      	; 0xa5ec <wckSendOperCommand+0x16>
/* Output : None */
/******************************************************************************/
void wckSendOperCommand(char Data1, char Data2)
{
	char CheckSum;
	CheckSum = (Data1^Data2)&0x7f;
    a5f0:	69 27       	eor	r22, r25
    a5f2:	6f 77       	andi	r22, 0x7F	; 127
// Transmit char to UART when UART is ready
//------------------------------------------------------------------------------
void wckSendByte(char td)
{
	while(!(UCSR0A&(1<<UDRE))); 	// wait until data register is empty
	UDR0=td;
    a5f4:	6c b9       	out	0x0c, r22	; 12
	CheckSum = (Data1^Data2)&0x7f;
	wckSendByte(HEADER);
	wckSendByte(Data1);
	wckSendByte(Data2);
	wckSendByte(CheckSum);
}
    a5f6:	08 95       	ret

0000a5f8 <wckSendSetCommand>:
/* Function that sends Set Command Packet(6 Byte) to wCK module */
/* Input : Data1, Data2, Data3, Data4 */
/* Output : None */
/******************************************************************************/
void wckSendSetCommand(char Data1, char Data2, char Data3, char Data4)
{
    a5f8:	98 2f       	mov	r25, r24
//------------------------------------------------------------------------------
// Transmit char to UART when UART is ready
//------------------------------------------------------------------------------
void wckSendByte(char td)
{
	while(!(UCSR0A&(1<<UDRE))); 	// wait until data register is empty
    a5fa:	5d 9b       	sbis	0x0b, 5	; 11
    a5fc:	fe cf       	rjmp	.-4      	; 0xa5fa <wckSendSetCommand+0x2>
	UDR0=td;
    a5fe:	8f ef       	ldi	r24, 0xFF	; 255
    a600:	8c b9       	out	0x0c, r24	; 12
//------------------------------------------------------------------------------
// Transmit char to UART when UART is ready
//------------------------------------------------------------------------------
void wckSendByte(char td)
{
	while(!(UCSR0A&(1<<UDRE))); 	// wait until data register is empty
    a602:	5d 9b       	sbis	0x0b, 5	; 11
    a604:	fe cf       	rjmp	.-4      	; 0xa602 <wckSendSetCommand+0xa>
	UDR0=td;
    a606:	9c b9       	out	0x0c, r25	; 12
//------------------------------------------------------------------------------
// Transmit char to UART when UART is ready
//------------------------------------------------------------------------------
void wckSendByte(char td)
{
	while(!(UCSR0A&(1<<UDRE))); 	// wait until data register is empty
    a608:	5d 9b       	sbis	0x0b, 5	; 11
    a60a:	fe cf       	rjmp	.-4      	; 0xa608 <wckSendSetCommand+0x10>
	UDR0=td;
    a60c:	6c b9       	out	0x0c, r22	; 12
//------------------------------------------------------------------------------
// Transmit char to UART when UART is ready
//------------------------------------------------------------------------------
void wckSendByte(char td)
{
	while(!(UCSR0A&(1<<UDRE))); 	// wait until data register is empty
    a60e:	5d 9b       	sbis	0x0b, 5	; 11
    a610:	fe cf       	rjmp	.-4      	; 0xa60e <wckSendSetCommand+0x16>
	UDR0=td;
    a612:	4c b9       	out	0x0c, r20	; 12
//------------------------------------------------------------------------------
// Transmit char to UART when UART is ready
//------------------------------------------------------------------------------
void wckSendByte(char td)
{
	while(!(UCSR0A&(1<<UDRE))); 	// wait until data register is empty
    a614:	5d 9b       	sbis	0x0b, 5	; 11
    a616:	fe cf       	rjmp	.-4      	; 0xa614 <wckSendSetCommand+0x1c>
	UDR0=td;
    a618:	2c b9       	out	0x0c, r18	; 12
//------------------------------------------------------------------------------
// Transmit char to UART when UART is ready
//------------------------------------------------------------------------------
void wckSendByte(char td)
{
	while(!(UCSR0A&(1<<UDRE))); 	// wait until data register is empty
    a61a:	5d 9b       	sbis	0x0b, 5	; 11
    a61c:	fe cf       	rjmp	.-4      	; 0xa61a <wckSendSetCommand+0x22>
/* Output : None */
/******************************************************************************/
void wckSendSetCommand(char Data1, char Data2, char Data3, char Data4)
{
	char CheckSum;
	CheckSum = (Data1^Data2^Data3^Data4)&0x7f;
    a61e:	69 27       	eor	r22, r25
    a620:	64 27       	eor	r22, r20
    a622:	62 27       	eor	r22, r18
    a624:	6f 77       	andi	r22, 0x7F	; 127
// Transmit char to UART when UART is ready
//------------------------------------------------------------------------------
void wckSendByte(char td)
{
	while(!(UCSR0A&(1<<UDRE))); 	// wait until data register is empty
	UDR0=td;
    a626:	6c b9       	out	0x0c, r22	; 12
	wckSendByte(Data1);
	wckSendByte(Data2);
	wckSendByte(Data3);
	wckSendByte(Data4);
	wckSendByte(CheckSum);
}
    a628:	08 95       	ret

0000a62a <wckPosSend>:
/* Function that sends Position Move Command to wCK module */
/* Input : ServoID, Torque (0(Max) to 4 (Min)), Position */
/* Output : Load * 256 + Position */
/*************************************************************************************************/
WORD wckPosSend(char ServoID, char Torque, char Position)
{
    a62a:	96 2f       	mov	r25, r22
	WORD Load, curPosition;
	wckSendOperCommand((Torque<<5)|ServoID, Position);
    a62c:	92 95       	swap	r25
    a62e:	99 0f       	add	r25, r25
    a630:	90 7e       	andi	r25, 0xE0	; 224
    a632:	64 2f       	mov	r22, r20
    a634:	89 2b       	or	r24, r25
    a636:	0e 94 eb 52 	call	0xa5d6	; 0xa5d6 <wckSendOperCommand>
// Get character when received. or timeout
//------------------------------------------------------------------------------
char wckGetByte(WORD timeout)
{
	WORD	startT;
	startT = gMSEC;
    a63a:	20 91 be 0a 	lds	r18, 0x0ABE
    a63e:	30 91 bf 0a 	lds	r19, 0x0ABF
    a642:	17 c0       	rjmp	.+46     	; 0xa672 <wckPosSend+0x48>
	while(!(UCSR0A&(1<<RXC)) ){ 	// test for received character
        if(gMSEC<startT) {
    a644:	80 91 be 0a 	lds	r24, 0x0ABE
    a648:	90 91 bf 0a 	lds	r25, 0x0ABF
    a64c:	82 17       	cp	r24, r18
    a64e:	93 07       	cpc	r25, r19
    a650:	38 f4       	brcc	.+14     	; 0xa660 <wckPosSend+0x36>
			// wait RX_T_OUT for a character
            if((1000 - startT + gMSEC) > timeout) break;
    a652:	80 91 be 0a 	lds	r24, 0x0ABE
    a656:	90 91 bf 0a 	lds	r25, 0x0ABF
    a65a:	88 51       	subi	r24, 0x18	; 24
    a65c:	9c 4f       	sbci	r25, 0xFC	; 252
    a65e:	04 c0       	rjmp	.+8      	; 0xa668 <wckPosSend+0x3e>
        }
		else if((gMSEC - startT) > timeout) break;
    a660:	80 91 be 0a 	lds	r24, 0x0ABE
    a664:	90 91 bf 0a 	lds	r25, 0x0ABF
    a668:	82 1b       	sub	r24, r18
    a66a:	93 0b       	sbc	r25, r19
    a66c:	85 36       	cpi	r24, 0x65	; 101
    a66e:	91 05       	cpc	r25, r1
    a670:	10 f4       	brcc	.+4      	; 0xa676 <wckPosSend+0x4c>
//------------------------------------------------------------------------------
char wckGetByte(WORD timeout)
{
	WORD	startT;
	startT = gMSEC;
	while(!(UCSR0A&(1<<RXC)) ){ 	// test for received character
    a672:	5f 9b       	sbis	0x0b, 7	; 11
    a674:	e7 cf       	rjmp	.-50     	; 0xa644 <wckPosSend+0x1a>
			// wait RX_T_OUT for a character
            if((1000 - startT + gMSEC) > timeout) break;
        }
		else if((gMSEC - startT) > timeout) break;
	}
	return UDR0;
    a676:	4c b1       	in	r20, 0x0c	; 12
// Get character when received. or timeout
//------------------------------------------------------------------------------
char wckGetByte(WORD timeout)
{
	WORD	startT;
	startT = gMSEC;
    a678:	20 91 be 0a 	lds	r18, 0x0ABE
    a67c:	30 91 bf 0a 	lds	r19, 0x0ABF
    a680:	17 c0       	rjmp	.+46     	; 0xa6b0 <wckPosSend+0x86>
	while(!(UCSR0A&(1<<RXC)) ){ 	// test for received character
        if(gMSEC<startT) {
    a682:	80 91 be 0a 	lds	r24, 0x0ABE
    a686:	90 91 bf 0a 	lds	r25, 0x0ABF
    a68a:	82 17       	cp	r24, r18
    a68c:	93 07       	cpc	r25, r19
    a68e:	38 f4       	brcc	.+14     	; 0xa69e <wckPosSend+0x74>
			// wait RX_T_OUT for a character
            if((1000 - startT + gMSEC) > timeout) break;
    a690:	80 91 be 0a 	lds	r24, 0x0ABE
    a694:	90 91 bf 0a 	lds	r25, 0x0ABF
    a698:	88 51       	subi	r24, 0x18	; 24
    a69a:	9c 4f       	sbci	r25, 0xFC	; 252
    a69c:	04 c0       	rjmp	.+8      	; 0xa6a6 <wckPosSend+0x7c>
        }
		else if((gMSEC - startT) > timeout) break;
    a69e:	80 91 be 0a 	lds	r24, 0x0ABE
    a6a2:	90 91 bf 0a 	lds	r25, 0x0ABF
    a6a6:	82 1b       	sub	r24, r18
    a6a8:	93 0b       	sbc	r25, r19
    a6aa:	85 36       	cpi	r24, 0x65	; 101
    a6ac:	91 05       	cpc	r25, r1
    a6ae:	10 f4       	brcc	.+4      	; 0xa6b4 <wckPosSend+0x8a>
//------------------------------------------------------------------------------
char wckGetByte(WORD timeout)
{
	WORD	startT;
	startT = gMSEC;
	while(!(UCSR0A&(1<<RXC)) ){ 	// test for received character
    a6b0:	5f 9b       	sbis	0x0b, 7	; 11
    a6b2:	e7 cf       	rjmp	.-50     	; 0xa682 <wckPosSend+0x58>
			// wait RX_T_OUT for a character
            if((1000 - startT + gMSEC) > timeout) break;
        }
		else if((gMSEC - startT) > timeout) break;
	}
	return UDR0;
    a6b4:	2c b1       	in	r18, 0x0c	; 12
    a6b6:	94 2f       	mov	r25, r20
    a6b8:	80 e0       	ldi	r24, 0x00	; 0
    a6ba:	30 e0       	ldi	r19, 0x00	; 0
    a6bc:	28 2b       	or	r18, r24
    a6be:	39 2b       	or	r19, r25
	WORD Load, curPosition;
	wckSendOperCommand((Torque<<5)|ServoID, Position);
	Load = wckGetByte(TIME_OUT1);
	curPosition = wckGetByte(TIME_OUT1);
	return (Load << 8) | curPosition;
}
    a6c0:	c9 01       	movw	r24, r18
    a6c2:	08 95       	ret

0000a6c4 <wckPosRead>:
/* Function that sends Position Read Command to wCK module, and returns the Position. */
/* Input : ServoID */
/* Output : Position */
/************************************************************************************************/
char wckPosRead(char ServoID)
{
    a6c4:	60 e0       	ldi	r22, 0x00	; 0
    a6c6:	80 6a       	ori	r24, 0xA0	; 160
    a6c8:	0e 94 eb 52 	call	0xa5d6	; 0xa5d6 <wckSendOperCommand>
// Get character when received. or timeout
//------------------------------------------------------------------------------
char wckGetByte(WORD timeout)
{
	WORD	startT;
	startT = gMSEC;
    a6cc:	20 91 be 0a 	lds	r18, 0x0ABE
    a6d0:	30 91 bf 0a 	lds	r19, 0x0ABF
    a6d4:	17 c0       	rjmp	.+46     	; 0xa704 <wckPosRead+0x40>
	while(!(UCSR0A&(1<<RXC)) ){ 	// test for received character
        if(gMSEC<startT) {
    a6d6:	80 91 be 0a 	lds	r24, 0x0ABE
    a6da:	90 91 bf 0a 	lds	r25, 0x0ABF
    a6de:	82 17       	cp	r24, r18
    a6e0:	93 07       	cpc	r25, r19
    a6e2:	38 f4       	brcc	.+14     	; 0xa6f2 <wckPosRead+0x2e>
			// wait RX_T_OUT for a character
            if((1000 - startT + gMSEC) > timeout) break;
    a6e4:	80 91 be 0a 	lds	r24, 0x0ABE
    a6e8:	90 91 bf 0a 	lds	r25, 0x0ABF
    a6ec:	88 51       	subi	r24, 0x18	; 24
    a6ee:	9c 4f       	sbci	r25, 0xFC	; 252
    a6f0:	04 c0       	rjmp	.+8      	; 0xa6fa <wckPosRead+0x36>
        }
		else if((gMSEC - startT) > timeout) break;
    a6f2:	80 91 be 0a 	lds	r24, 0x0ABE
    a6f6:	90 91 bf 0a 	lds	r25, 0x0ABF
    a6fa:	82 1b       	sub	r24, r18
    a6fc:	93 0b       	sbc	r25, r19
    a6fe:	85 36       	cpi	r24, 0x65	; 101
    a700:	91 05       	cpc	r25, r1
    a702:	10 f4       	brcc	.+4      	; 0xa708 <wckPosRead+0x44>
//------------------------------------------------------------------------------
char wckGetByte(WORD timeout)
{
	WORD	startT;
	startT = gMSEC;
	while(!(UCSR0A&(1<<RXC)) ){ 	// test for received character
    a704:	5f 9b       	sbis	0x0b, 7	; 11
    a706:	e7 cf       	rjmp	.-50     	; 0xa6d6 <wckPosRead+0x12>
			// wait RX_T_OUT for a character
            if((1000 - startT + gMSEC) > timeout) break;
        }
		else if((gMSEC - startT) > timeout) break;
	}
	return UDR0;
    a708:	8c b1       	in	r24, 0x0c	; 12
// Get character when received. or timeout
//------------------------------------------------------------------------------
char wckGetByte(WORD timeout)
{
	WORD	startT;
	startT = gMSEC;
    a70a:	20 91 be 0a 	lds	r18, 0x0ABE
    a70e:	30 91 bf 0a 	lds	r19, 0x0ABF
    a712:	17 c0       	rjmp	.+46     	; 0xa742 <wckPosRead+0x7e>
	while(!(UCSR0A&(1<<RXC)) ){ 	// test for received character
        if(gMSEC<startT) {
    a714:	80 91 be 0a 	lds	r24, 0x0ABE
    a718:	90 91 bf 0a 	lds	r25, 0x0ABF
    a71c:	82 17       	cp	r24, r18
    a71e:	93 07       	cpc	r25, r19
    a720:	38 f4       	brcc	.+14     	; 0xa730 <wckPosRead+0x6c>
			// wait RX_T_OUT for a character
            if((1000 - startT + gMSEC) > timeout) break;
    a722:	80 91 be 0a 	lds	r24, 0x0ABE
    a726:	90 91 bf 0a 	lds	r25, 0x0ABF
    a72a:	88 51       	subi	r24, 0x18	; 24
    a72c:	9c 4f       	sbci	r25, 0xFC	; 252
    a72e:	04 c0       	rjmp	.+8      	; 0xa738 <wckPosRead+0x74>
        }
		else if((gMSEC - startT) > timeout) break;
    a730:	80 91 be 0a 	lds	r24, 0x0ABE
    a734:	90 91 bf 0a 	lds	r25, 0x0ABF
    a738:	82 1b       	sub	r24, r18
    a73a:	93 0b       	sbc	r25, r19
    a73c:	85 36       	cpi	r24, 0x65	; 101
    a73e:	91 05       	cpc	r25, r1
    a740:	10 f4       	brcc	.+4      	; 0xa746 <wckPosRead+0x82>
//------------------------------------------------------------------------------
char wckGetByte(WORD timeout)
{
	WORD	startT;
	startT = gMSEC;
	while(!(UCSR0A&(1<<RXC)) ){ 	// test for received character
    a742:	5f 9b       	sbis	0x0b, 7	; 11
    a744:	e7 cf       	rjmp	.-50     	; 0xa714 <wckPosRead+0x50>
			// wait RX_T_OUT for a character
            if((1000 - startT + gMSEC) > timeout) break;
        }
		else if((gMSEC - startT) > timeout) break;
	}
	return UDR0;
    a746:	8c b1       	in	r24, 0x0c	; 12
	char Position;
	wckSendOperCommand(0xa0|ServoID, NULL);
	wckGetByte(TIME_OUT1);
	Position = wckGetByte(TIME_OUT1);
	return Position;
}
    a748:	08 95       	ret

0000a74a <wckPosAndLoadRead>:
/* Function that sends Position Read Command to wCK module, and returns the Load and Position. */
/* Input : ServoID */
/* Output : Load * 256 + Position */
/************************************************************************************************/
WORD wckPosAndLoadRead(char ServoID)
{
    a74a:	60 e0       	ldi	r22, 0x00	; 0
    a74c:	80 6a       	ori	r24, 0xA0	; 160
    a74e:	0e 94 eb 52 	call	0xa5d6	; 0xa5d6 <wckSendOperCommand>
// Get character when received. or timeout
//------------------------------------------------------------------------------
char wckGetByte(WORD timeout)
{
	WORD	startT;
	startT = gMSEC;
    a752:	20 91 be 0a 	lds	r18, 0x0ABE
    a756:	30 91 bf 0a 	lds	r19, 0x0ABF
    a75a:	17 c0       	rjmp	.+46     	; 0xa78a <wckPosAndLoadRead+0x40>
	while(!(UCSR0A&(1<<RXC)) ){ 	// test for received character
        if(gMSEC<startT) {
    a75c:	80 91 be 0a 	lds	r24, 0x0ABE
    a760:	90 91 bf 0a 	lds	r25, 0x0ABF
    a764:	82 17       	cp	r24, r18
    a766:	93 07       	cpc	r25, r19
    a768:	38 f4       	brcc	.+14     	; 0xa778 <wckPosAndLoadRead+0x2e>
			// wait RX_T_OUT for a character
            if((1000 - startT + gMSEC) > timeout) break;
    a76a:	80 91 be 0a 	lds	r24, 0x0ABE
    a76e:	90 91 bf 0a 	lds	r25, 0x0ABF
    a772:	88 51       	subi	r24, 0x18	; 24
    a774:	9c 4f       	sbci	r25, 0xFC	; 252
    a776:	04 c0       	rjmp	.+8      	; 0xa780 <wckPosAndLoadRead+0x36>
        }
		else if((gMSEC - startT) > timeout) break;
    a778:	80 91 be 0a 	lds	r24, 0x0ABE
    a77c:	90 91 bf 0a 	lds	r25, 0x0ABF
    a780:	82 1b       	sub	r24, r18
    a782:	93 0b       	sbc	r25, r19
    a784:	85 36       	cpi	r24, 0x65	; 101
    a786:	91 05       	cpc	r25, r1
    a788:	10 f4       	brcc	.+4      	; 0xa78e <wckPosAndLoadRead+0x44>
//------------------------------------------------------------------------------
char wckGetByte(WORD timeout)
{
	WORD	startT;
	startT = gMSEC;
	while(!(UCSR0A&(1<<RXC)) ){ 	// test for received character
    a78a:	5f 9b       	sbis	0x0b, 7	; 11
    a78c:	e7 cf       	rjmp	.-50     	; 0xa75c <wckPosAndLoadRead+0x12>
			// wait RX_T_OUT for a character
            if((1000 - startT + gMSEC) > timeout) break;
        }
		else if((gMSEC - startT) > timeout) break;
	}
	return UDR0;
    a78e:	4c b1       	in	r20, 0x0c	; 12
// Get character when received. or timeout
//------------------------------------------------------------------------------
char wckGetByte(WORD timeout)
{
	WORD	startT;
	startT = gMSEC;
    a790:	20 91 be 0a 	lds	r18, 0x0ABE
    a794:	30 91 bf 0a 	lds	r19, 0x0ABF
    a798:	17 c0       	rjmp	.+46     	; 0xa7c8 <wckPosAndLoadRead+0x7e>
	while(!(UCSR0A&(1<<RXC)) ){ 	// test for received character
        if(gMSEC<startT) {
    a79a:	80 91 be 0a 	lds	r24, 0x0ABE
    a79e:	90 91 bf 0a 	lds	r25, 0x0ABF
    a7a2:	82 17       	cp	r24, r18
    a7a4:	93 07       	cpc	r25, r19
    a7a6:	38 f4       	brcc	.+14     	; 0xa7b6 <wckPosAndLoadRead+0x6c>
			// wait RX_T_OUT for a character
            if((1000 - startT + gMSEC) > timeout) break;
    a7a8:	80 91 be 0a 	lds	r24, 0x0ABE
    a7ac:	90 91 bf 0a 	lds	r25, 0x0ABF
    a7b0:	88 51       	subi	r24, 0x18	; 24
    a7b2:	9c 4f       	sbci	r25, 0xFC	; 252
    a7b4:	04 c0       	rjmp	.+8      	; 0xa7be <wckPosAndLoadRead+0x74>
        }
		else if((gMSEC - startT) > timeout) break;
    a7b6:	80 91 be 0a 	lds	r24, 0x0ABE
    a7ba:	90 91 bf 0a 	lds	r25, 0x0ABF
    a7be:	82 1b       	sub	r24, r18
    a7c0:	93 0b       	sbc	r25, r19
    a7c2:	85 36       	cpi	r24, 0x65	; 101
    a7c4:	91 05       	cpc	r25, r1
    a7c6:	10 f4       	brcc	.+4      	; 0xa7cc <wckPosAndLoadRead+0x82>
//------------------------------------------------------------------------------
char wckGetByte(WORD timeout)
{
	WORD	startT;
	startT = gMSEC;
	while(!(UCSR0A&(1<<RXC)) ){ 	// test for received character
    a7c8:	5f 9b       	sbis	0x0b, 7	; 11
    a7ca:	e7 cf       	rjmp	.-50     	; 0xa79a <wckPosAndLoadRead+0x50>
			// wait RX_T_OUT for a character
            if((1000 - startT + gMSEC) > timeout) break;
        }
		else if((gMSEC - startT) > timeout) break;
	}
	return UDR0;
    a7cc:	2c b1       	in	r18, 0x0c	; 12
    a7ce:	94 2f       	mov	r25, r20
    a7d0:	80 e0       	ldi	r24, 0x00	; 0
    a7d2:	30 e0       	ldi	r19, 0x00	; 0
    a7d4:	28 2b       	or	r18, r24
    a7d6:	39 2b       	or	r19, r25
	WORD Load, Position;
	wckSendOperCommand(0xa0|ServoID, NULL);
	Load = wckGetByte(TIME_OUT1);
	Position = wckGetByte(TIME_OUT1);
	return (Load << 8) | Position;
}
    a7d8:	c9 01       	movw	r24, r18
    a7da:	08 95       	ret

0000a7dc <wckSetPassive>:
/* Function that sends Passive wCK Command to wCK module */
/* Input : ServoID */
/* Output : Position */
/******************************************************************************/
char wckSetPassive(char ServoID)
{
    a7dc:	60 e1       	ldi	r22, 0x10	; 16
    a7de:	80 6c       	ori	r24, 0xC0	; 192
    a7e0:	0e 94 eb 52 	call	0xa5d6	; 0xa5d6 <wckSendOperCommand>
// Get character when received. or timeout
//------------------------------------------------------------------------------
char wckGetByte(WORD timeout)
{
	WORD	startT;
	startT = gMSEC;
    a7e4:	20 91 be 0a 	lds	r18, 0x0ABE
    a7e8:	30 91 bf 0a 	lds	r19, 0x0ABF
    a7ec:	17 c0       	rjmp	.+46     	; 0xa81c <wckSetPassive+0x40>
	while(!(UCSR0A&(1<<RXC)) ){ 	// test for received character
        if(gMSEC<startT) {
    a7ee:	80 91 be 0a 	lds	r24, 0x0ABE
    a7f2:	90 91 bf 0a 	lds	r25, 0x0ABF
    a7f6:	82 17       	cp	r24, r18
    a7f8:	93 07       	cpc	r25, r19
    a7fa:	38 f4       	brcc	.+14     	; 0xa80a <wckSetPassive+0x2e>
			// wait RX_T_OUT for a character
            if((1000 - startT + gMSEC) > timeout) break;
    a7fc:	80 91 be 0a 	lds	r24, 0x0ABE
    a800:	90 91 bf 0a 	lds	r25, 0x0ABF
    a804:	88 51       	subi	r24, 0x18	; 24
    a806:	9c 4f       	sbci	r25, 0xFC	; 252
    a808:	04 c0       	rjmp	.+8      	; 0xa812 <wckSetPassive+0x36>
        }
		else if((gMSEC - startT) > timeout) break;
    a80a:	80 91 be 0a 	lds	r24, 0x0ABE
    a80e:	90 91 bf 0a 	lds	r25, 0x0ABF
    a812:	82 1b       	sub	r24, r18
    a814:	93 0b       	sbc	r25, r19
    a816:	85 36       	cpi	r24, 0x65	; 101
    a818:	91 05       	cpc	r25, r1
    a81a:	10 f4       	brcc	.+4      	; 0xa820 <wckSetPassive+0x44>
//------------------------------------------------------------------------------
char wckGetByte(WORD timeout)
{
	WORD	startT;
	startT = gMSEC;
	while(!(UCSR0A&(1<<RXC)) ){ 	// test for received character
    a81c:	5f 9b       	sbis	0x0b, 7	; 11
    a81e:	e7 cf       	rjmp	.-50     	; 0xa7ee <wckSetPassive+0x12>
			// wait RX_T_OUT for a character
            if((1000 - startT + gMSEC) > timeout) break;
        }
		else if((gMSEC - startT) > timeout) break;
	}
	return UDR0;
    a820:	8c b1       	in	r24, 0x0c	; 12
// Get character when received. or timeout
//------------------------------------------------------------------------------
char wckGetByte(WORD timeout)
{
	WORD	startT;
	startT = gMSEC;
    a822:	20 91 be 0a 	lds	r18, 0x0ABE
    a826:	30 91 bf 0a 	lds	r19, 0x0ABF
    a82a:	17 c0       	rjmp	.+46     	; 0xa85a <wckSetPassive+0x7e>
	while(!(UCSR0A&(1<<RXC)) ){ 	// test for received character
        if(gMSEC<startT) {
    a82c:	80 91 be 0a 	lds	r24, 0x0ABE
    a830:	90 91 bf 0a 	lds	r25, 0x0ABF
    a834:	82 17       	cp	r24, r18
    a836:	93 07       	cpc	r25, r19
    a838:	38 f4       	brcc	.+14     	; 0xa848 <wckSetPassive+0x6c>
			// wait RX_T_OUT for a character
            if((1000 - startT + gMSEC) > timeout) break;
    a83a:	80 91 be 0a 	lds	r24, 0x0ABE
    a83e:	90 91 bf 0a 	lds	r25, 0x0ABF
    a842:	88 51       	subi	r24, 0x18	; 24
    a844:	9c 4f       	sbci	r25, 0xFC	; 252
    a846:	04 c0       	rjmp	.+8      	; 0xa850 <wckSetPassive+0x74>
        }
		else if((gMSEC - startT) > timeout) break;
    a848:	80 91 be 0a 	lds	r24, 0x0ABE
    a84c:	90 91 bf 0a 	lds	r25, 0x0ABF
    a850:	82 1b       	sub	r24, r18
    a852:	93 0b       	sbc	r25, r19
    a854:	85 36       	cpi	r24, 0x65	; 101
    a856:	91 05       	cpc	r25, r1
    a858:	10 f4       	brcc	.+4      	; 0xa85e <wckSetPassive+0x82>
//------------------------------------------------------------------------------
char wckGetByte(WORD timeout)
{
	WORD	startT;
	startT = gMSEC;
	while(!(UCSR0A&(1<<RXC)) ){ 	// test for received character
    a85a:	5f 9b       	sbis	0x0b, 7	; 11
    a85c:	e7 cf       	rjmp	.-50     	; 0xa82c <wckSetPassive+0x50>
			// wait RX_T_OUT for a character
            if((1000 - startT + gMSEC) > timeout) break;
        }
		else if((gMSEC - startT) > timeout) break;
	}
	return UDR0;
    a85e:	8c b1       	in	r24, 0x0c	; 12
	char Position;
	wckSendOperCommand(0xc0|ServoID, 0x10);
	wckGetByte(TIME_OUT1);
	Position = wckGetByte(TIME_OUT1);
	return Position;
}
    a860:	08 95       	ret

0000a862 <wckPowerDown>:
/* Function that sends Break wCK Command to wCK module */
/* Input : None */
/* Output : ServoID if succeed, 0xff if fail */
/**************************************************************************/
char wckPowerDown(void)
{
    a862:	60 e2       	ldi	r22, 0x20	; 32
    a864:	8f ed       	ldi	r24, 0xDF	; 223
    a866:	0e 94 eb 52 	call	0xa5d6	; 0xa5d6 <wckSendOperCommand>
// Get character when received. or timeout
//------------------------------------------------------------------------------
char wckGetByte(WORD timeout)
{
	WORD	startT;
	startT = gMSEC;
    a86a:	20 91 be 0a 	lds	r18, 0x0ABE
    a86e:	30 91 bf 0a 	lds	r19, 0x0ABF
    a872:	17 c0       	rjmp	.+46     	; 0xa8a2 <wckPowerDown+0x40>
	while(!(UCSR0A&(1<<RXC)) ){ 	// test for received character
        if(gMSEC<startT) {
    a874:	80 91 be 0a 	lds	r24, 0x0ABE
    a878:	90 91 bf 0a 	lds	r25, 0x0ABF
    a87c:	82 17       	cp	r24, r18
    a87e:	93 07       	cpc	r25, r19
    a880:	38 f4       	brcc	.+14     	; 0xa890 <wckPowerDown+0x2e>
			// wait RX_T_OUT for a character
            if((1000 - startT + gMSEC) > timeout) break;
    a882:	80 91 be 0a 	lds	r24, 0x0ABE
    a886:	90 91 bf 0a 	lds	r25, 0x0ABF
    a88a:	88 51       	subi	r24, 0x18	; 24
    a88c:	9c 4f       	sbci	r25, 0xFC	; 252
    a88e:	04 c0       	rjmp	.+8      	; 0xa898 <wckPowerDown+0x36>
        }
		else if((gMSEC - startT) > timeout) break;
    a890:	80 91 be 0a 	lds	r24, 0x0ABE
    a894:	90 91 bf 0a 	lds	r25, 0x0ABF
    a898:	82 1b       	sub	r24, r18
    a89a:	93 0b       	sbc	r25, r19
    a89c:	85 36       	cpi	r24, 0x65	; 101
    a89e:	91 05       	cpc	r25, r1
    a8a0:	10 f4       	brcc	.+4      	; 0xa8a6 <wckPowerDown+0x44>
//------------------------------------------------------------------------------
char wckGetByte(WORD timeout)
{
	WORD	startT;
	startT = gMSEC;
	while(!(UCSR0A&(1<<RXC)) ){ 	// test for received character
    a8a2:	5f 9b       	sbis	0x0b, 7	; 11
    a8a4:	e7 cf       	rjmp	.-50     	; 0xa874 <wckPowerDown+0x12>
			// wait RX_T_OUT for a character
            if((1000 - startT + gMSEC) > timeout) break;
        }
		else if((gMSEC - startT) > timeout) break;
	}
	return UDR0;
    a8a6:	4c b1       	in	r20, 0x0c	; 12
// Get character when received. or timeout
//------------------------------------------------------------------------------
char wckGetByte(WORD timeout)
{
	WORD	startT;
	startT = gMSEC;
    a8a8:	20 91 be 0a 	lds	r18, 0x0ABE
    a8ac:	30 91 bf 0a 	lds	r19, 0x0ABF
    a8b0:	17 c0       	rjmp	.+46     	; 0xa8e0 <wckPowerDown+0x7e>
	while(!(UCSR0A&(1<<RXC)) ){ 	// test for received character
        if(gMSEC<startT) {
    a8b2:	80 91 be 0a 	lds	r24, 0x0ABE
    a8b6:	90 91 bf 0a 	lds	r25, 0x0ABF
    a8ba:	82 17       	cp	r24, r18
    a8bc:	93 07       	cpc	r25, r19
    a8be:	38 f4       	brcc	.+14     	; 0xa8ce <wckPowerDown+0x6c>
			// wait RX_T_OUT for a character
            if((1000 - startT + gMSEC) > timeout) break;
    a8c0:	80 91 be 0a 	lds	r24, 0x0ABE
    a8c4:	90 91 bf 0a 	lds	r25, 0x0ABF
    a8c8:	88 51       	subi	r24, 0x18	; 24
    a8ca:	9c 4f       	sbci	r25, 0xFC	; 252
    a8cc:	04 c0       	rjmp	.+8      	; 0xa8d6 <wckPowerDown+0x74>
        }
		else if((gMSEC - startT) > timeout) break;
    a8ce:	80 91 be 0a 	lds	r24, 0x0ABE
    a8d2:	90 91 bf 0a 	lds	r25, 0x0ABF
    a8d6:	82 1b       	sub	r24, r18
    a8d8:	93 0b       	sbc	r25, r19
    a8da:	85 36       	cpi	r24, 0x65	; 101
    a8dc:	91 05       	cpc	r25, r1
    a8de:	10 f4       	brcc	.+4      	; 0xa8e4 <wckPowerDown+0x82>
//------------------------------------------------------------------------------
char wckGetByte(WORD timeout)
{
	WORD	startT;
	startT = gMSEC;
	while(!(UCSR0A&(1<<RXC)) ){ 	// test for received character
    a8e0:	5f 9b       	sbis	0x0b, 7	; 11
    a8e2:	e7 cf       	rjmp	.-50     	; 0xa8b2 <wckPowerDown+0x50>
			// wait RX_T_OUT for a character
            if((1000 - startT + gMSEC) > timeout) break;
        }
		else if((gMSEC - startT) > timeout) break;
	}
	return UDR0;
    a8e4:	8c b1       	in	r24, 0x0c	; 12
{
	char ServoID;
	wckSendOperCommand(0xdf, 0x20);
	ServoID = wckGetByte(TIME_OUT1);
	wckGetByte(TIME_OUT1);
	if(ServoID<31) 
    a8e6:	4f 31       	cpi	r20, 0x1F	; 31
    a8e8:	08 f0       	brcs	.+2      	; 0xa8ec <wckPowerDown+0x8a>
    a8ea:	4f ef       	ldi	r20, 0xFF	; 255
		return ServoID;
	return 0xff; //Receive error
}
    a8ec:	84 2f       	mov	r24, r20
    a8ee:	08 95       	ret

0000a8f0 <wckRotation360>:
/* Function that sends 360 degree Wheel wCK Command */
/* Input : ServoID, SpeedLevel, RotationDir */
/* Return : Rotation Number */
/*****************************************************************/
char wckRotation360(char ServoID, char SpeedLevel, char RotationDir)
{
    a8f0:	43 30       	cpi	r20, 0x03	; 3
    a8f2:	11 f4       	brne	.+4      	; 0xa8f8 <wckRotation360+0x8>
	char RotNum;
	if (RotationDir == ROTATE_CCW) {
		wckSendOperCommand((6<<5)|ServoID, (ROTATE_CCW<<4)|SpeedLevel);
    a8f4:	60 63       	ori	r22, 0x30	; 48
    a8f6:	03 c0       	rjmp	.+6      	; 0xa8fe <wckRotation360+0xe>
	} else if (RotationDir == ROTATE_CW) {
    a8f8:	44 30       	cpi	r20, 0x04	; 4
    a8fa:	21 f4       	brne	.+8      	; 0xa904 <wckRotation360+0x14>
		wckSendOperCommand((6<<5)|ServoID, (ROTATE_CW<<4)|SpeedLevel);
    a8fc:	60 64       	ori	r22, 0x40	; 64
    a8fe:	80 6c       	ori	r24, 0xC0	; 192
    a900:	0e 94 eb 52 	call	0xa5d6	; 0xa5d6 <wckSendOperCommand>
// Get character when received. or timeout
//------------------------------------------------------------------------------
char wckGetByte(WORD timeout)
{
	WORD	startT;
	startT = gMSEC;
    a904:	20 91 be 0a 	lds	r18, 0x0ABE
    a908:	30 91 bf 0a 	lds	r19, 0x0ABF
    a90c:	17 c0       	rjmp	.+46     	; 0xa93c <wckRotation360+0x4c>
	while(!(UCSR0A&(1<<RXC)) ){ 	// test for received character
        if(gMSEC<startT) {
    a90e:	80 91 be 0a 	lds	r24, 0x0ABE
    a912:	90 91 bf 0a 	lds	r25, 0x0ABF
    a916:	82 17       	cp	r24, r18
    a918:	93 07       	cpc	r25, r19
    a91a:	38 f4       	brcc	.+14     	; 0xa92a <wckRotation360+0x3a>
			// wait RX_T_OUT for a character
            if((1000 - startT + gMSEC) > timeout) break;
    a91c:	80 91 be 0a 	lds	r24, 0x0ABE
    a920:	90 91 bf 0a 	lds	r25, 0x0ABF
    a924:	88 51       	subi	r24, 0x18	; 24
    a926:	9c 4f       	sbci	r25, 0xFC	; 252
    a928:	04 c0       	rjmp	.+8      	; 0xa932 <wckRotation360+0x42>
        }
		else if((gMSEC - startT) > timeout) break;
    a92a:	80 91 be 0a 	lds	r24, 0x0ABE
    a92e:	90 91 bf 0a 	lds	r25, 0x0ABF
    a932:	82 1b       	sub	r24, r18
    a934:	93 0b       	sbc	r25, r19
    a936:	85 36       	cpi	r24, 0x65	; 101
    a938:	91 05       	cpc	r25, r1
    a93a:	10 f4       	brcc	.+4      	; 0xa940 <wckRotation360+0x50>
//------------------------------------------------------------------------------
char wckGetByte(WORD timeout)
{
	WORD	startT;
	startT = gMSEC;
	while(!(UCSR0A&(1<<RXC)) ){ 	// test for received character
    a93c:	5f 9b       	sbis	0x0b, 7	; 11
    a93e:	e7 cf       	rjmp	.-50     	; 0xa90e <wckRotation360+0x1e>
			// wait RX_T_OUT for a character
            if((1000 - startT + gMSEC) > timeout) break;
        }
		else if((gMSEC - startT) > timeout) break;
	}
	return UDR0;
    a940:	4c b1       	in	r20, 0x0c	; 12
// Get character when received. or timeout
//------------------------------------------------------------------------------
char wckGetByte(WORD timeout)
{
	WORD	startT;
	startT = gMSEC;
    a942:	20 91 be 0a 	lds	r18, 0x0ABE
    a946:	30 91 bf 0a 	lds	r19, 0x0ABF
    a94a:	17 c0       	rjmp	.+46     	; 0xa97a <wckRotation360+0x8a>
	while(!(UCSR0A&(1<<RXC)) ){ 	// test for received character
        if(gMSEC<startT) {
    a94c:	80 91 be 0a 	lds	r24, 0x0ABE
    a950:	90 91 bf 0a 	lds	r25, 0x0ABF
    a954:	82 17       	cp	r24, r18
    a956:	93 07       	cpc	r25, r19
    a958:	38 f4       	brcc	.+14     	; 0xa968 <wckRotation360+0x78>
			// wait RX_T_OUT for a character
            if((1000 - startT + gMSEC) > timeout) break;
    a95a:	80 91 be 0a 	lds	r24, 0x0ABE
    a95e:	90 91 bf 0a 	lds	r25, 0x0ABF
    a962:	88 51       	subi	r24, 0x18	; 24
    a964:	9c 4f       	sbci	r25, 0xFC	; 252
    a966:	04 c0       	rjmp	.+8      	; 0xa970 <wckRotation360+0x80>
        }
		else if((gMSEC - startT) > timeout) break;
    a968:	80 91 be 0a 	lds	r24, 0x0ABE
    a96c:	90 91 bf 0a 	lds	r25, 0x0ABF
    a970:	82 1b       	sub	r24, r18
    a972:	93 0b       	sbc	r25, r19
    a974:	85 36       	cpi	r24, 0x65	; 101
    a976:	91 05       	cpc	r25, r1
    a978:	10 f4       	brcc	.+4      	; 0xa97e <wckRotation360+0x8e>
//------------------------------------------------------------------------------
char wckGetByte(WORD timeout)
{
	WORD	startT;
	startT = gMSEC;
	while(!(UCSR0A&(1<<RXC)) ){ 	// test for received character
    a97a:	5f 9b       	sbis	0x0b, 7	; 11
    a97c:	e7 cf       	rjmp	.-50     	; 0xa94c <wckRotation360+0x5c>
			// wait RX_T_OUT for a character
            if((1000 - startT + gMSEC) > timeout) break;
        }
		else if((gMSEC - startT) > timeout) break;
	}
	return UDR0;
    a97e:	8c b1       	in	r24, 0x0c	; 12
		wckSendOperCommand((6<<5)|ServoID, (ROTATE_CW<<4)|SpeedLevel);
	}
	RotNum = wckGetByte(TIME_OUT1);
	wckGetByte(TIME_OUT1);
	return RotNum;
}
    a980:	84 2f       	mov	r24, r20
    a982:	08 95       	ret

0000a984 <wckSyncPosSend>:
/* Function that sends Synchronized Position Move Command to wCK module */
/* Input : LastID, SpeedLevel, *TargetArray, Index */
/* Return : None */
/****************************************************************************/
void wckSyncPosSend(char LastID, char SpeedLevel, char *TargetArray, char Index)
{
    a984:	38 2f       	mov	r19, r24
//------------------------------------------------------------------------------
// Transmit char to UART when UART is ready
//------------------------------------------------------------------------------
void wckSendByte(char td)
{
	while(!(UCSR0A&(1<<UDRE))); 	// wait until data register is empty
    a986:	5d 9b       	sbis	0x0b, 5	; 11
    a988:	fe cf       	rjmp	.-4      	; 0xa986 <wckSyncPosSend+0x2>
	UDR0=td;
    a98a:	8f ef       	ldi	r24, 0xFF	; 255
    a98c:	8c b9       	out	0x0c, r24	; 12
//------------------------------------------------------------------------------
// Transmit char to UART when UART is ready
//------------------------------------------------------------------------------
void wckSendByte(char td)
{
	while(!(UCSR0A&(1<<UDRE))); 	// wait until data register is empty
    a98e:	5d 9b       	sbis	0x0b, 5	; 11
    a990:	fe cf       	rjmp	.-4      	; 0xa98e <wckSyncPosSend+0xa>
	int i;
	char CheckSum;
	i = 0;
	CheckSum = 0;
	wckSendByte(HEADER);
	wckSendByte((SpeedLevel<<5)|0x1f);
    a992:	62 95       	swap	r22
    a994:	66 0f       	add	r22, r22
    a996:	60 7e       	andi	r22, 0xE0	; 224
    a998:	6f 61       	ori	r22, 0x1F	; 31
// Transmit char to UART when UART is ready
//------------------------------------------------------------------------------
void wckSendByte(char td)
{
	while(!(UCSR0A&(1<<UDRE))); 	// wait until data register is empty
	UDR0=td;
    a99a:	6c b9       	out	0x0c, r22	; 12
//------------------------------------------------------------------------------
// Transmit char to UART when UART is ready
//------------------------------------------------------------------------------
void wckSendByte(char td)
{
	while(!(UCSR0A&(1<<UDRE))); 	// wait until data register is empty
    a99c:	5d 9b       	sbis	0x0b, 5	; 11
    a99e:	fe cf       	rjmp	.-4      	; 0xa99c <wckSyncPosSend+0x18>
	char CheckSum;
	i = 0;
	CheckSum = 0;
	wckSendByte(HEADER);
	wckSendByte((SpeedLevel<<5)|0x1f);
	wckSendByte(LastID+1);
    a9a0:	3f 5f       	subi	r19, 0xFF	; 255
// Transmit char to UART when UART is ready
//------------------------------------------------------------------------------
void wckSendByte(char td)
{
	while(!(UCSR0A&(1<<UDRE))); 	// wait until data register is empty
	UDR0=td;
    a9a2:	3c b9       	out	0x0c, r19	; 12
    a9a4:	31 50       	subi	r19, 0x01	; 1
	wckSendByte(HEADER);
	wckSendByte((SpeedLevel<<5)|0x1f);
	wckSendByte(LastID+1);
	while(1) 
	{
		if(i>LastID) 
    a9a6:	63 2f       	mov	r22, r19
    a9a8:	70 e0       	ldi	r23, 0x00	; 0
    a9aa:	82 2f       	mov	r24, r18
    a9ac:	90 e0       	ldi	r25, 0x00	; 0
    a9ae:	6f 5f       	subi	r22, 0xFF	; 255
    a9b0:	7f 4f       	sbci	r23, 0xFF	; 255
    a9b2:	86 9f       	mul	r24, r22
    a9b4:	f0 01       	movw	r30, r0
    a9b6:	87 9f       	mul	r24, r23
    a9b8:	f0 0d       	add	r31, r0
    a9ba:	96 9f       	mul	r25, r22
    a9bc:	f0 0d       	add	r31, r0
    a9be:	11 24       	eor	r1, r1
    a9c0:	61 50       	subi	r22, 0x01	; 1
    a9c2:	70 40       	sbci	r23, 0x00	; 0
    a9c4:	e4 0f       	add	r30, r20
    a9c6:	f5 1f       	adc	r31, r21
    a9c8:	80 e0       	ldi	r24, 0x00	; 0
    a9ca:	90 e0       	ldi	r25, 0x00	; 0
    a9cc:	20 e0       	ldi	r18, 0x00	; 0
			break;
		wckSendByte(TargetArray[Index*(LastID+1)+i]);
    a9ce:	30 81       	ld	r19, Z
//------------------------------------------------------------------------------
// Transmit char to UART when UART is ready
//------------------------------------------------------------------------------
void wckSendByte(char td)
{
	while(!(UCSR0A&(1<<UDRE))); 	// wait until data register is empty
    a9d0:	5d 9b       	sbis	0x0b, 5	; 11
    a9d2:	fe cf       	rjmp	.-4      	; 0xa9d0 <wckSyncPosSend+0x4c>
	UDR0=td;
    a9d4:	3c b9       	out	0x0c, r19	; 12
	while(1) 
	{
		if(i>LastID) 
			break;
		wckSendByte(TargetArray[Index*(LastID+1)+i]);
		CheckSum = CheckSum ^ TargetArray[Index*(LastID+1)+i];
    a9d6:	23 27       	eor	r18, r19
		i++;
    a9d8:	01 96       	adiw	r24, 0x01	; 1
    a9da:	31 96       	adiw	r30, 0x01	; 1
	wckSendByte(HEADER);
	wckSendByte((SpeedLevel<<5)|0x1f);
	wckSendByte(LastID+1);
	while(1) 
	{
		if(i>LastID) 
    a9dc:	68 17       	cp	r22, r24
    a9de:	79 07       	cpc	r23, r25
    a9e0:	b4 f7       	brge	.-20     	; 0xa9ce <wckSyncPosSend+0x4a>
//------------------------------------------------------------------------------
// Transmit char to UART when UART is ready
//------------------------------------------------------------------------------
void wckSendByte(char td)
{
	while(!(UCSR0A&(1<<UDRE))); 	// wait until data register is empty
    a9e2:	5d 9b       	sbis	0x0b, 5	; 11
    a9e4:	fe cf       	rjmp	.-4      	; 0xa9e2 <wckSyncPosSend+0x5e>
			break;
		wckSendByte(TargetArray[Index*(LastID+1)+i]);
		CheckSum = CheckSum ^ TargetArray[Index*(LastID+1)+i];
		i++;
	}
	CheckSum = CheckSum & 0x7f;
    a9e6:	2f 77       	andi	r18, 0x7F	; 127
// Transmit char to UART when UART is ready
//------------------------------------------------------------------------------
void wckSendByte(char td)
{
	while(!(UCSR0A&(1<<UDRE))); 	// wait until data register is empty
	UDR0=td;
    a9e8:	2c b9       	out	0x0c, r18	; 12
		CheckSum = CheckSum ^ TargetArray[Index*(LastID+1)+i];
		i++;
	}
	CheckSum = CheckSum & 0x7f;
	wckSendByte(CheckSum);
}
    a9ea:	08 95       	ret

0000a9ec <wckBaudrateSet>:
/* Function that sends Baud rate Set Command to wCK module */
/* Input : ServoID, NewBaud */
/* Return : New Baudrate if succeed, 0xff if fail */
/********************************************************************/
char wckBaudrateSet(char ServoID, char NewBaud)
{
    a9ec:	1f 93       	push	r17
    a9ee:	16 2f       	mov	r17, r22
	wckSendSetCommand((7<<5)|ServoID, 0x08, NewBaud, NewBaud);
    a9f0:	26 2f       	mov	r18, r22
    a9f2:	46 2f       	mov	r20, r22
    a9f4:	68 e0       	ldi	r22, 0x08	; 8
    a9f6:	80 6e       	ori	r24, 0xE0	; 224
    a9f8:	0e 94 fc 52 	call	0xa5f8	; 0xa5f8 <wckSendSetCommand>
// Get character when received. or timeout
//------------------------------------------------------------------------------
char wckGetByte(WORD timeout)
{
	WORD	startT;
	startT = gMSEC;
    a9fc:	20 91 be 0a 	lds	r18, 0x0ABE
    aa00:	30 91 bf 0a 	lds	r19, 0x0ABF
    aa04:	17 c0       	rjmp	.+46     	; 0xaa34 <wckBaudrateSet+0x48>
	while(!(UCSR0A&(1<<RXC)) ){ 	// test for received character
        if(gMSEC<startT) {
    aa06:	80 91 be 0a 	lds	r24, 0x0ABE
    aa0a:	90 91 bf 0a 	lds	r25, 0x0ABF
    aa0e:	82 17       	cp	r24, r18
    aa10:	93 07       	cpc	r25, r19
    aa12:	38 f4       	brcc	.+14     	; 0xaa22 <wckBaudrateSet+0x36>
			// wait RX_T_OUT for a character
            if((1000 - startT + gMSEC) > timeout) break;
    aa14:	80 91 be 0a 	lds	r24, 0x0ABE
    aa18:	90 91 bf 0a 	lds	r25, 0x0ABF
    aa1c:	88 51       	subi	r24, 0x18	; 24
    aa1e:	9c 4f       	sbci	r25, 0xFC	; 252
    aa20:	04 c0       	rjmp	.+8      	; 0xaa2a <wckBaudrateSet+0x3e>
        }
		else if((gMSEC - startT) > timeout) break;
    aa22:	80 91 be 0a 	lds	r24, 0x0ABE
    aa26:	90 91 bf 0a 	lds	r25, 0x0ABF
    aa2a:	82 1b       	sub	r24, r18
    aa2c:	93 0b       	sbc	r25, r19
    aa2e:	8b 3f       	cpi	r24, 0xFB	; 251
    aa30:	91 05       	cpc	r25, r1
    aa32:	10 f4       	brcc	.+4      	; 0xaa38 <wckBaudrateSet+0x4c>
//------------------------------------------------------------------------------
char wckGetByte(WORD timeout)
{
	WORD	startT;
	startT = gMSEC;
	while(!(UCSR0A&(1<<RXC)) ){ 	// test for received character
    aa34:	5f 9b       	sbis	0x0b, 7	; 11
    aa36:	e7 cf       	rjmp	.-50     	; 0xaa06 <wckBaudrateSet+0x1a>
			// wait RX_T_OUT for a character
            if((1000 - startT + gMSEC) > timeout) break;
        }
		else if((gMSEC - startT) > timeout) break;
	}
	return UDR0;
    aa38:	8c b1       	in	r24, 0x0c	; 12
// Get character when received. or timeout
//------------------------------------------------------------------------------
char wckGetByte(WORD timeout)
{
	WORD	startT;
	startT = gMSEC;
    aa3a:	20 91 be 0a 	lds	r18, 0x0ABE
    aa3e:	30 91 bf 0a 	lds	r19, 0x0ABF
    aa42:	17 c0       	rjmp	.+46     	; 0xaa72 <wckBaudrateSet+0x86>
	while(!(UCSR0A&(1<<RXC)) ){ 	// test for received character
        if(gMSEC<startT) {
    aa44:	80 91 be 0a 	lds	r24, 0x0ABE
    aa48:	90 91 bf 0a 	lds	r25, 0x0ABF
    aa4c:	82 17       	cp	r24, r18
    aa4e:	93 07       	cpc	r25, r19
    aa50:	38 f4       	brcc	.+14     	; 0xaa60 <wckBaudrateSet+0x74>
			// wait RX_T_OUT for a character
            if((1000 - startT + gMSEC) > timeout) break;
    aa52:	80 91 be 0a 	lds	r24, 0x0ABE
    aa56:	90 91 bf 0a 	lds	r25, 0x0ABF
    aa5a:	88 51       	subi	r24, 0x18	; 24
    aa5c:	9c 4f       	sbci	r25, 0xFC	; 252
    aa5e:	04 c0       	rjmp	.+8      	; 0xaa68 <wckBaudrateSet+0x7c>
        }
		else if((gMSEC - startT) > timeout) break;
    aa60:	80 91 be 0a 	lds	r24, 0x0ABE
    aa64:	90 91 bf 0a 	lds	r25, 0x0ABF
    aa68:	82 1b       	sub	r24, r18
    aa6a:	93 0b       	sbc	r25, r19
    aa6c:	8b 3f       	cpi	r24, 0xFB	; 251
    aa6e:	91 05       	cpc	r25, r1
    aa70:	10 f4       	brcc	.+4      	; 0xaa76 <wckBaudrateSet+0x8a>
//------------------------------------------------------------------------------
char wckGetByte(WORD timeout)
{
	WORD	startT;
	startT = gMSEC;
	while(!(UCSR0A&(1<<RXC)) ){ 	// test for received character
    aa72:	5f 9b       	sbis	0x0b, 7	; 11
    aa74:	e7 cf       	rjmp	.-50     	; 0xaa44 <wckBaudrateSet+0x58>
			// wait RX_T_OUT for a character
            if((1000 - startT + gMSEC) > timeout) break;
        }
		else if((gMSEC - startT) > timeout) break;
	}
	return UDR0;
    aa76:	8c b1       	in	r24, 0x0c	; 12
/********************************************************************/
char wckBaudrateSet(char ServoID, char NewBaud)
{
	wckSendSetCommand((7<<5)|ServoID, 0x08, NewBaud, NewBaud);
	wckGetByte(TIME_OUT2);
	if(wckGetByte(TIME_OUT2)==NewBaud) 
    aa78:	81 13       	cpse	r24, r17
    aa7a:	8f ef       	ldi	r24, 0xFF	; 255
		return NewBaud;
	return 0xff;
}
    aa7c:	1f 91       	pop	r17
    aa7e:	08 95       	ret

0000aa80 <wckGainSet>:
/* Function that sends Gain Set Command to wCK module */
/* Input : ServoID, *NewPgain, *NewDgain */
/* Return : 1 if succeed, 0 if fail */
/********************************************************************/
char wckGainSet(char ServoID, char *NewPgain, char *NewDgain)
{
    aa80:	0f 93       	push	r16
    aa82:	1f 93       	push	r17
    aa84:	cf 93       	push	r28
    aa86:	df 93       	push	r29
    aa88:	eb 01       	movw	r28, r22
    aa8a:	8a 01       	movw	r16, r20
	char Data1,Data2;
	wckSendSetCommand((7<<5)|ServoID, 0x09, *NewPgain, *NewDgain);
    aa8c:	fa 01       	movw	r30, r20
    aa8e:	20 81       	ld	r18, Z
    aa90:	48 81       	ld	r20, Y
    aa92:	69 e0       	ldi	r22, 0x09	; 9
    aa94:	80 6e       	ori	r24, 0xE0	; 224
    aa96:	0e 94 fc 52 	call	0xa5f8	; 0xa5f8 <wckSendSetCommand>
// Get character when received. or timeout
//------------------------------------------------------------------------------
char wckGetByte(WORD timeout)
{
	WORD	startT;
	startT = gMSEC;
    aa9a:	20 91 be 0a 	lds	r18, 0x0ABE
    aa9e:	30 91 bf 0a 	lds	r19, 0x0ABF
    aaa2:	17 c0       	rjmp	.+46     	; 0xaad2 <wckGainSet+0x52>
	while(!(UCSR0A&(1<<RXC)) ){ 	// test for received character
        if(gMSEC<startT) {
    aaa4:	80 91 be 0a 	lds	r24, 0x0ABE
    aaa8:	90 91 bf 0a 	lds	r25, 0x0ABF
    aaac:	82 17       	cp	r24, r18
    aaae:	93 07       	cpc	r25, r19
    aab0:	38 f4       	brcc	.+14     	; 0xaac0 <wckGainSet+0x40>
			// wait RX_T_OUT for a character
            if((1000 - startT + gMSEC) > timeout) break;
    aab2:	80 91 be 0a 	lds	r24, 0x0ABE
    aab6:	90 91 bf 0a 	lds	r25, 0x0ABF
    aaba:	88 51       	subi	r24, 0x18	; 24
    aabc:	9c 4f       	sbci	r25, 0xFC	; 252
    aabe:	04 c0       	rjmp	.+8      	; 0xaac8 <wckGainSet+0x48>
        }
		else if((gMSEC - startT) > timeout) break;
    aac0:	80 91 be 0a 	lds	r24, 0x0ABE
    aac4:	90 91 bf 0a 	lds	r25, 0x0ABF
    aac8:	82 1b       	sub	r24, r18
    aaca:	93 0b       	sbc	r25, r19
    aacc:	8b 3f       	cpi	r24, 0xFB	; 251
    aace:	91 05       	cpc	r25, r1
    aad0:	10 f4       	brcc	.+4      	; 0xaad6 <wckGainSet+0x56>
//------------------------------------------------------------------------------
char wckGetByte(WORD timeout)
{
	WORD	startT;
	startT = gMSEC;
	while(!(UCSR0A&(1<<RXC)) ){ 	// test for received character
    aad2:	5f 9b       	sbis	0x0b, 7	; 11
    aad4:	e7 cf       	rjmp	.-50     	; 0xaaa4 <wckGainSet+0x24>
			// wait RX_T_OUT for a character
            if((1000 - startT + gMSEC) > timeout) break;
        }
		else if((gMSEC - startT) > timeout) break;
	}
	return UDR0;
    aad6:	4c b1       	in	r20, 0x0c	; 12
// Get character when received. or timeout
//------------------------------------------------------------------------------
char wckGetByte(WORD timeout)
{
	WORD	startT;
	startT = gMSEC;
    aad8:	20 91 be 0a 	lds	r18, 0x0ABE
    aadc:	30 91 bf 0a 	lds	r19, 0x0ABF
    aae0:	17 c0       	rjmp	.+46     	; 0xab10 <wckGainSet+0x90>
	while(!(UCSR0A&(1<<RXC)) ){ 	// test for received character
        if(gMSEC<startT) {
    aae2:	80 91 be 0a 	lds	r24, 0x0ABE
    aae6:	90 91 bf 0a 	lds	r25, 0x0ABF
    aaea:	82 17       	cp	r24, r18
    aaec:	93 07       	cpc	r25, r19
    aaee:	38 f4       	brcc	.+14     	; 0xaafe <wckGainSet+0x7e>
			// wait RX_T_OUT for a character
            if((1000 - startT + gMSEC) > timeout) break;
    aaf0:	80 91 be 0a 	lds	r24, 0x0ABE
    aaf4:	90 91 bf 0a 	lds	r25, 0x0ABF
    aaf8:	88 51       	subi	r24, 0x18	; 24
    aafa:	9c 4f       	sbci	r25, 0xFC	; 252
    aafc:	04 c0       	rjmp	.+8      	; 0xab06 <wckGainSet+0x86>
        }
		else if((gMSEC - startT) > timeout) break;
    aafe:	80 91 be 0a 	lds	r24, 0x0ABE
    ab02:	90 91 bf 0a 	lds	r25, 0x0ABF
    ab06:	82 1b       	sub	r24, r18
    ab08:	93 0b       	sbc	r25, r19
    ab0a:	8b 3f       	cpi	r24, 0xFB	; 251
    ab0c:	91 05       	cpc	r25, r1
    ab0e:	10 f4       	brcc	.+4      	; 0xab14 <wckGainSet+0x94>
//------------------------------------------------------------------------------
char wckGetByte(WORD timeout)
{
	WORD	startT;
	startT = gMSEC;
	while(!(UCSR0A&(1<<RXC)) ){ 	// test for received character
    ab10:	5f 9b       	sbis	0x0b, 7	; 11
    ab12:	e7 cf       	rjmp	.-50     	; 0xaae2 <wckGainSet+0x62>
			// wait RX_T_OUT for a character
            if((1000 - startT + gMSEC) > timeout) break;
        }
		else if((gMSEC - startT) > timeout) break;
	}
	return UDR0;
    ab14:	2c b1       	in	r18, 0x0c	; 12
{
	char Data1,Data2;
	wckSendSetCommand((7<<5)|ServoID, 0x09, *NewPgain, *NewDgain);
	Data1 = wckGetByte(TIME_OUT2);
	Data2 = wckGetByte(TIME_OUT2);
	if((Data1==*NewPgain) && (Data2==*NewDgain)) 
    ab16:	88 81       	ld	r24, Y
    ab18:	48 17       	cp	r20, r24
    ab1a:	11 f0       	breq	.+4      	; 0xab20 <wckGainSet+0xa0>
    ab1c:	90 e0       	ldi	r25, 0x00	; 0
    ab1e:	06 c0       	rjmp	.+12     	; 0xab2c <wckGainSet+0xac>
    ab20:	90 e0       	ldi	r25, 0x00	; 0
    ab22:	f8 01       	movw	r30, r16
    ab24:	80 81       	ld	r24, Z
    ab26:	28 17       	cp	r18, r24
    ab28:	09 f4       	brne	.+2      	; 0xab2c <wckGainSet+0xac>
    ab2a:	91 e0       	ldi	r25, 0x01	; 1
		return 1;
	return 0;
}
    ab2c:	89 2f       	mov	r24, r25
    ab2e:	df 91       	pop	r29
    ab30:	cf 91       	pop	r28
    ab32:	1f 91       	pop	r17
    ab34:	0f 91       	pop	r16
    ab36:	08 95       	ret

0000ab38 <wckIdSet>:
/* Function that sends ID Set Command to wCK module */
/* Input : ServoID, NewId */
/* Return : New ID if succeed, 0xff if fail */
/***********************************************************/
char wckIdSet(char ServoID, char NewId)
{
    ab38:	1f 93       	push	r17
    ab3a:	16 2f       	mov	r17, r22
	wckSendSetCommand((7<<5)|ServoID, 0x0a, NewId, NewId);
    ab3c:	26 2f       	mov	r18, r22
    ab3e:	46 2f       	mov	r20, r22
    ab40:	6a e0       	ldi	r22, 0x0A	; 10
    ab42:	80 6e       	ori	r24, 0xE0	; 224
    ab44:	0e 94 fc 52 	call	0xa5f8	; 0xa5f8 <wckSendSetCommand>
// Get character when received. or timeout
//------------------------------------------------------------------------------
char wckGetByte(WORD timeout)
{
	WORD	startT;
	startT = gMSEC;
    ab48:	20 91 be 0a 	lds	r18, 0x0ABE
    ab4c:	30 91 bf 0a 	lds	r19, 0x0ABF
    ab50:	17 c0       	rjmp	.+46     	; 0xab80 <wckIdSet+0x48>
	while(!(UCSR0A&(1<<RXC)) ){ 	// test for received character
        if(gMSEC<startT) {
    ab52:	80 91 be 0a 	lds	r24, 0x0ABE
    ab56:	90 91 bf 0a 	lds	r25, 0x0ABF
    ab5a:	82 17       	cp	r24, r18
    ab5c:	93 07       	cpc	r25, r19
    ab5e:	38 f4       	brcc	.+14     	; 0xab6e <wckIdSet+0x36>
			// wait RX_T_OUT for a character
            if((1000 - startT + gMSEC) > timeout) break;
    ab60:	80 91 be 0a 	lds	r24, 0x0ABE
    ab64:	90 91 bf 0a 	lds	r25, 0x0ABF
    ab68:	88 51       	subi	r24, 0x18	; 24
    ab6a:	9c 4f       	sbci	r25, 0xFC	; 252
    ab6c:	04 c0       	rjmp	.+8      	; 0xab76 <wckIdSet+0x3e>
        }
		else if((gMSEC - startT) > timeout) break;
    ab6e:	80 91 be 0a 	lds	r24, 0x0ABE
    ab72:	90 91 bf 0a 	lds	r25, 0x0ABF
    ab76:	82 1b       	sub	r24, r18
    ab78:	93 0b       	sbc	r25, r19
    ab7a:	8b 3f       	cpi	r24, 0xFB	; 251
    ab7c:	91 05       	cpc	r25, r1
    ab7e:	10 f4       	brcc	.+4      	; 0xab84 <wckIdSet+0x4c>
//------------------------------------------------------------------------------
char wckGetByte(WORD timeout)
{
	WORD	startT;
	startT = gMSEC;
	while(!(UCSR0A&(1<<RXC)) ){ 	// test for received character
    ab80:	5f 9b       	sbis	0x0b, 7	; 11
    ab82:	e7 cf       	rjmp	.-50     	; 0xab52 <wckIdSet+0x1a>
			// wait RX_T_OUT for a character
            if((1000 - startT + gMSEC) > timeout) break;
        }
		else if((gMSEC - startT) > timeout) break;
	}
	return UDR0;
    ab84:	8c b1       	in	r24, 0x0c	; 12
// Get character when received. or timeout
//------------------------------------------------------------------------------
char wckGetByte(WORD timeout)
{
	WORD	startT;
	startT = gMSEC;
    ab86:	20 91 be 0a 	lds	r18, 0x0ABE
    ab8a:	30 91 bf 0a 	lds	r19, 0x0ABF
    ab8e:	17 c0       	rjmp	.+46     	; 0xabbe <wckIdSet+0x86>
	while(!(UCSR0A&(1<<RXC)) ){ 	// test for received character
        if(gMSEC<startT) {
    ab90:	80 91 be 0a 	lds	r24, 0x0ABE
    ab94:	90 91 bf 0a 	lds	r25, 0x0ABF
    ab98:	82 17       	cp	r24, r18
    ab9a:	93 07       	cpc	r25, r19
    ab9c:	38 f4       	brcc	.+14     	; 0xabac <wckIdSet+0x74>
			// wait RX_T_OUT for a character
            if((1000 - startT + gMSEC) > timeout) break;
    ab9e:	80 91 be 0a 	lds	r24, 0x0ABE
    aba2:	90 91 bf 0a 	lds	r25, 0x0ABF
    aba6:	88 51       	subi	r24, 0x18	; 24
    aba8:	9c 4f       	sbci	r25, 0xFC	; 252
    abaa:	04 c0       	rjmp	.+8      	; 0xabb4 <wckIdSet+0x7c>
        }
		else if((gMSEC - startT) > timeout) break;
    abac:	80 91 be 0a 	lds	r24, 0x0ABE
    abb0:	90 91 bf 0a 	lds	r25, 0x0ABF
    abb4:	82 1b       	sub	r24, r18
    abb6:	93 0b       	sbc	r25, r19
    abb8:	8b 3f       	cpi	r24, 0xFB	; 251
    abba:	91 05       	cpc	r25, r1
    abbc:	10 f4       	brcc	.+4      	; 0xabc2 <wckIdSet+0x8a>
//------------------------------------------------------------------------------
char wckGetByte(WORD timeout)
{
	WORD	startT;
	startT = gMSEC;
	while(!(UCSR0A&(1<<RXC)) ){ 	// test for received character
    abbe:	5f 9b       	sbis	0x0b, 7	; 11
    abc0:	e7 cf       	rjmp	.-50     	; 0xab90 <wckIdSet+0x58>
			// wait RX_T_OUT for a character
            if((1000 - startT + gMSEC) > timeout) break;
        }
		else if((gMSEC - startT) > timeout) break;
	}
	return UDR0;
    abc2:	8c b1       	in	r24, 0x0c	; 12
/***********************************************************/
char wckIdSet(char ServoID, char NewId)
{
	wckSendSetCommand((7<<5)|ServoID, 0x0a, NewId, NewId);
	wckGetByte(TIME_OUT2);
	if(wckGetByte(TIME_OUT2)==NewId) 
    abc4:	81 13       	cpse	r24, r17
    abc6:	8f ef       	ldi	r24, 0xFF	; 255
		return NewId;
	return 0xff;
}
    abc8:	1f 91       	pop	r17
    abca:	08 95       	ret

0000abcc <wckGainRead>:
/* Function that sends Gain Read Command to wCK module */
/* Input : ServoID, *NewPgain, *NewDgain */
/* Return : 1 if succeed, 0 if fail */
/*****************************************************************/
char wckGainRead(char ServoID, char *Pgain, char *Dgain)
{
    abcc:	0f 93       	push	r16
    abce:	1f 93       	push	r17
    abd0:	cf 93       	push	r28
    abd2:	df 93       	push	r29
    abd4:	eb 01       	movw	r28, r22
    abd6:	8a 01       	movw	r16, r20
	wckSendSetCommand((7<<5)|ServoID, 0x0c, 0, 0);
    abd8:	20 e0       	ldi	r18, 0x00	; 0
    abda:	40 e0       	ldi	r20, 0x00	; 0
    abdc:	6c e0       	ldi	r22, 0x0C	; 12
    abde:	80 6e       	ori	r24, 0xE0	; 224
    abe0:	0e 94 fc 52 	call	0xa5f8	; 0xa5f8 <wckSendSetCommand>
// Get character when received. or timeout
//------------------------------------------------------------------------------
char wckGetByte(WORD timeout)
{
	WORD	startT;
	startT = gMSEC;
    abe4:	20 91 be 0a 	lds	r18, 0x0ABE
    abe8:	30 91 bf 0a 	lds	r19, 0x0ABF
    abec:	17 c0       	rjmp	.+46     	; 0xac1c <wckGainRead+0x50>
	while(!(UCSR0A&(1<<RXC)) ){ 	// test for received character
        if(gMSEC<startT) {
    abee:	80 91 be 0a 	lds	r24, 0x0ABE
    abf2:	90 91 bf 0a 	lds	r25, 0x0ABF
    abf6:	82 17       	cp	r24, r18
    abf8:	93 07       	cpc	r25, r19
    abfa:	38 f4       	brcc	.+14     	; 0xac0a <wckGainRead+0x3e>
			// wait RX_T_OUT for a character
            if((1000 - startT + gMSEC) > timeout) break;
    abfc:	80 91 be 0a 	lds	r24, 0x0ABE
    ac00:	90 91 bf 0a 	lds	r25, 0x0ABF
    ac04:	88 51       	subi	r24, 0x18	; 24
    ac06:	9c 4f       	sbci	r25, 0xFC	; 252
    ac08:	04 c0       	rjmp	.+8      	; 0xac12 <wckGainRead+0x46>
        }
		else if((gMSEC - startT) > timeout) break;
    ac0a:	80 91 be 0a 	lds	r24, 0x0ABE
    ac0e:	90 91 bf 0a 	lds	r25, 0x0ABF
    ac12:	82 1b       	sub	r24, r18
    ac14:	93 0b       	sbc	r25, r19
    ac16:	85 36       	cpi	r24, 0x65	; 101
    ac18:	91 05       	cpc	r25, r1
    ac1a:	10 f4       	brcc	.+4      	; 0xac20 <wckGainRead+0x54>
//------------------------------------------------------------------------------
char wckGetByte(WORD timeout)
{
	WORD	startT;
	startT = gMSEC;
	while(!(UCSR0A&(1<<RXC)) ){ 	// test for received character
    ac1c:	5f 9b       	sbis	0x0b, 7	; 11
    ac1e:	e7 cf       	rjmp	.-50     	; 0xabee <wckGainRead+0x22>
			// wait RX_T_OUT for a character
            if((1000 - startT + gMSEC) > timeout) break;
        }
		else if((gMSEC - startT) > timeout) break;
	}
	return UDR0;
    ac20:	8c b1       	in	r24, 0x0c	; 12
/* Return : 1 if succeed, 0 if fail */
/*****************************************************************/
char wckGainRead(char ServoID, char *Pgain, char *Dgain)
{
	wckSendSetCommand((7<<5)|ServoID, 0x0c, 0, 0);
	*Pgain = wckGetByte(TIME_OUT1);
    ac22:	88 83       	st	Y, r24
// Get character when received. or timeout
//------------------------------------------------------------------------------
char wckGetByte(WORD timeout)
{
	WORD	startT;
	startT = gMSEC;
    ac24:	20 91 be 0a 	lds	r18, 0x0ABE
    ac28:	30 91 bf 0a 	lds	r19, 0x0ABF
    ac2c:	17 c0       	rjmp	.+46     	; 0xac5c <wckGainRead+0x90>
	while(!(UCSR0A&(1<<RXC)) ){ 	// test for received character
        if(gMSEC<startT) {
    ac2e:	80 91 be 0a 	lds	r24, 0x0ABE
    ac32:	90 91 bf 0a 	lds	r25, 0x0ABF
    ac36:	82 17       	cp	r24, r18
    ac38:	93 07       	cpc	r25, r19
    ac3a:	38 f4       	brcc	.+14     	; 0xac4a <wckGainRead+0x7e>
			// wait RX_T_OUT for a character
            if((1000 - startT + gMSEC) > timeout) break;
    ac3c:	80 91 be 0a 	lds	r24, 0x0ABE
    ac40:	90 91 bf 0a 	lds	r25, 0x0ABF
    ac44:	88 51       	subi	r24, 0x18	; 24
    ac46:	9c 4f       	sbci	r25, 0xFC	; 252
    ac48:	04 c0       	rjmp	.+8      	; 0xac52 <wckGainRead+0x86>
        }
		else if((gMSEC - startT) > timeout) break;
    ac4a:	80 91 be 0a 	lds	r24, 0x0ABE
    ac4e:	90 91 bf 0a 	lds	r25, 0x0ABF
    ac52:	82 1b       	sub	r24, r18
    ac54:	93 0b       	sbc	r25, r19
    ac56:	85 36       	cpi	r24, 0x65	; 101
    ac58:	91 05       	cpc	r25, r1
    ac5a:	10 f4       	brcc	.+4      	; 0xac60 <wckGainRead+0x94>
//------------------------------------------------------------------------------
char wckGetByte(WORD timeout)
{
	WORD	startT;
	startT = gMSEC;
	while(!(UCSR0A&(1<<RXC)) ){ 	// test for received character
    ac5c:	5f 9b       	sbis	0x0b, 7	; 11
    ac5e:	e7 cf       	rjmp	.-50     	; 0xac2e <wckGainRead+0x62>
			// wait RX_T_OUT for a character
            if((1000 - startT + gMSEC) > timeout) break;
        }
		else if((gMSEC - startT) > timeout) break;
	}
	return UDR0;
    ac60:	9c b1       	in	r25, 0x0c	; 12
/*****************************************************************/
char wckGainRead(char ServoID, char *Pgain, char *Dgain)
{
	wckSendSetCommand((7<<5)|ServoID, 0x0c, 0, 0);
	*Pgain = wckGetByte(TIME_OUT1);
	*Dgain = wckGetByte(TIME_OUT1);
    ac62:	f8 01       	movw	r30, r16
    ac64:	90 83       	st	Z, r25
	if((*Pgain>0) && (*Pgain<51) && (*Dgain<101)) 
    ac66:	88 81       	ld	r24, Y
    ac68:	81 50       	subi	r24, 0x01	; 1
    ac6a:	82 33       	cpi	r24, 0x32	; 50
    ac6c:	10 f0       	brcs	.+4      	; 0xac72 <wckGainRead+0xa6>
    ac6e:	80 e0       	ldi	r24, 0x00	; 0
    ac70:	04 c0       	rjmp	.+8      	; 0xac7a <wckGainRead+0xae>
    ac72:	80 e0       	ldi	r24, 0x00	; 0
    ac74:	95 36       	cpi	r25, 0x65	; 101
    ac76:	08 f4       	brcc	.+2      	; 0xac7a <wckGainRead+0xae>
    ac78:	81 e0       	ldi	r24, 0x01	; 1
		return 1;
	return 0;
}
    ac7a:	df 91       	pop	r29
    ac7c:	cf 91       	pop	r28
    ac7e:	1f 91       	pop	r17
    ac80:	0f 91       	pop	r16
    ac82:	08 95       	ret

0000ac84 <wckOverCTSet>:
/* Function that sends Over Load Set Command to wCK module */
/* Input : ServoID, NewOverCT */
/* Return : New Overcurrent Threshold if succeed, 0xff if fail */
/**********************************************************************************/
char wckOverCTSet(char ServoID, char NewOverCT)
{
    ac84:	46 2f       	mov	r20, r22
	char Data1;
	wckSendSetCommand((7<<5)|ServoID, 0x0f, NewOverCT, NewOverCT);
    ac86:	26 2f       	mov	r18, r22
    ac88:	6f e0       	ldi	r22, 0x0F	; 15
    ac8a:	80 6e       	ori	r24, 0xE0	; 224
    ac8c:	0e 94 fc 52 	call	0xa5f8	; 0xa5f8 <wckSendSetCommand>
// Get character when received. or timeout
//------------------------------------------------------------------------------
char wckGetByte(WORD timeout)
{
	WORD	startT;
	startT = gMSEC;
    ac90:	20 91 be 0a 	lds	r18, 0x0ABE
    ac94:	30 91 bf 0a 	lds	r19, 0x0ABF
    ac98:	17 c0       	rjmp	.+46     	; 0xacc8 <wckOverCTSet+0x44>
	while(!(UCSR0A&(1<<RXC)) ){ 	// test for received character
        if(gMSEC<startT) {
    ac9a:	80 91 be 0a 	lds	r24, 0x0ABE
    ac9e:	90 91 bf 0a 	lds	r25, 0x0ABF
    aca2:	82 17       	cp	r24, r18
    aca4:	93 07       	cpc	r25, r19
    aca6:	38 f4       	brcc	.+14     	; 0xacb6 <wckOverCTSet+0x32>
			// wait RX_T_OUT for a character
            if((1000 - startT + gMSEC) > timeout) break;
    aca8:	80 91 be 0a 	lds	r24, 0x0ABE
    acac:	90 91 bf 0a 	lds	r25, 0x0ABF
    acb0:	88 51       	subi	r24, 0x18	; 24
    acb2:	9c 4f       	sbci	r25, 0xFC	; 252
    acb4:	04 c0       	rjmp	.+8      	; 0xacbe <wckOverCTSet+0x3a>
        }
		else if((gMSEC - startT) > timeout) break;
    acb6:	80 91 be 0a 	lds	r24, 0x0ABE
    acba:	90 91 bf 0a 	lds	r25, 0x0ABF
    acbe:	82 1b       	sub	r24, r18
    acc0:	93 0b       	sbc	r25, r19
    acc2:	8b 3f       	cpi	r24, 0xFB	; 251
    acc4:	91 05       	cpc	r25, r1
    acc6:	10 f4       	brcc	.+4      	; 0xaccc <wckOverCTSet+0x48>
//------------------------------------------------------------------------------
char wckGetByte(WORD timeout)
{
	WORD	startT;
	startT = gMSEC;
	while(!(UCSR0A&(1<<RXC)) ){ 	// test for received character
    acc8:	5f 9b       	sbis	0x0b, 7	; 11
    acca:	e7 cf       	rjmp	.-50     	; 0xac9a <wckOverCTSet+0x16>
			// wait RX_T_OUT for a character
            if((1000 - startT + gMSEC) > timeout) break;
        }
		else if((gMSEC - startT) > timeout) break;
	}
	return UDR0;
    accc:	8c b1       	in	r24, 0x0c	; 12
// Get character when received. or timeout
//------------------------------------------------------------------------------
char wckGetByte(WORD timeout)
{
	WORD	startT;
	startT = gMSEC;
    acce:	20 91 be 0a 	lds	r18, 0x0ABE
    acd2:	30 91 bf 0a 	lds	r19, 0x0ABF
    acd6:	17 c0       	rjmp	.+46     	; 0xad06 <wckOverCTSet+0x82>
	while(!(UCSR0A&(1<<RXC)) ){ 	// test for received character
        if(gMSEC<startT) {
    acd8:	80 91 be 0a 	lds	r24, 0x0ABE
    acdc:	90 91 bf 0a 	lds	r25, 0x0ABF
    ace0:	82 17       	cp	r24, r18
    ace2:	93 07       	cpc	r25, r19
    ace4:	38 f4       	brcc	.+14     	; 0xacf4 <wckOverCTSet+0x70>
			// wait RX_T_OUT for a character
            if((1000 - startT + gMSEC) > timeout) break;
    ace6:	80 91 be 0a 	lds	r24, 0x0ABE
    acea:	90 91 bf 0a 	lds	r25, 0x0ABF
    acee:	88 51       	subi	r24, 0x18	; 24
    acf0:	9c 4f       	sbci	r25, 0xFC	; 252
    acf2:	04 c0       	rjmp	.+8      	; 0xacfc <wckOverCTSet+0x78>
        }
		else if((gMSEC - startT) > timeout) break;
    acf4:	80 91 be 0a 	lds	r24, 0x0ABE
    acf8:	90 91 bf 0a 	lds	r25, 0x0ABF
    acfc:	82 1b       	sub	r24, r18
    acfe:	93 0b       	sbc	r25, r19
    ad00:	8b 3f       	cpi	r24, 0xFB	; 251
    ad02:	91 05       	cpc	r25, r1
    ad04:	10 f4       	brcc	.+4      	; 0xad0a <wckOverCTSet+0x86>
//------------------------------------------------------------------------------
char wckGetByte(WORD timeout)
{
	WORD	startT;
	startT = gMSEC;
	while(!(UCSR0A&(1<<RXC)) ){ 	// test for received character
    ad06:	5f 9b       	sbis	0x0b, 7	; 11
    ad08:	e7 cf       	rjmp	.-50     	; 0xacd8 <wckOverCTSet+0x54>
			// wait RX_T_OUT for a character
            if((1000 - startT + gMSEC) > timeout) break;
        }
		else if((gMSEC - startT) > timeout) break;
	}
	return UDR0;
    ad0a:	8c b1       	in	r24, 0x0c	; 12
	wckGetByte(TIME_OUT2);
	Data1=wckGetByte(TIME_OUT2);
	if(Data1!=0xff) 
		return Data1;
	return 0xff;
}
    ad0c:	08 95       	ret

0000ad0e <wckOverCTRead>:
/* Function that sends Over Load Read Command to wCK module */
/* Input : ServoID */
/* Return : Overcurrent Threshold if succeed, 0xff if fail */
/******************************************************************************/
char wckOverCTRead(char ServoID)
{
    ad0e:	20 e0       	ldi	r18, 0x00	; 0
    ad10:	40 e0       	ldi	r20, 0x00	; 0
    ad12:	60 e1       	ldi	r22, 0x10	; 16
    ad14:	80 6e       	ori	r24, 0xE0	; 224
    ad16:	0e 94 fc 52 	call	0xa5f8	; 0xa5f8 <wckSendSetCommand>
// Get character when received. or timeout
//------------------------------------------------------------------------------
char wckGetByte(WORD timeout)
{
	WORD	startT;
	startT = gMSEC;
    ad1a:	20 91 be 0a 	lds	r18, 0x0ABE
    ad1e:	30 91 bf 0a 	lds	r19, 0x0ABF
    ad22:	17 c0       	rjmp	.+46     	; 0xad52 <wckOverCTRead+0x44>
	while(!(UCSR0A&(1<<RXC)) ){ 	// test for received character
        if(gMSEC<startT) {
    ad24:	80 91 be 0a 	lds	r24, 0x0ABE
    ad28:	90 91 bf 0a 	lds	r25, 0x0ABF
    ad2c:	82 17       	cp	r24, r18
    ad2e:	93 07       	cpc	r25, r19
    ad30:	38 f4       	brcc	.+14     	; 0xad40 <wckOverCTRead+0x32>
			// wait RX_T_OUT for a character
            if((1000 - startT + gMSEC) > timeout) break;
    ad32:	80 91 be 0a 	lds	r24, 0x0ABE
    ad36:	90 91 bf 0a 	lds	r25, 0x0ABF
    ad3a:	88 51       	subi	r24, 0x18	; 24
    ad3c:	9c 4f       	sbci	r25, 0xFC	; 252
    ad3e:	04 c0       	rjmp	.+8      	; 0xad48 <wckOverCTRead+0x3a>
        }
		else if((gMSEC - startT) > timeout) break;
    ad40:	80 91 be 0a 	lds	r24, 0x0ABE
    ad44:	90 91 bf 0a 	lds	r25, 0x0ABF
    ad48:	82 1b       	sub	r24, r18
    ad4a:	93 0b       	sbc	r25, r19
    ad4c:	85 36       	cpi	r24, 0x65	; 101
    ad4e:	91 05       	cpc	r25, r1
    ad50:	10 f4       	brcc	.+4      	; 0xad56 <wckOverCTRead+0x48>
//------------------------------------------------------------------------------
char wckGetByte(WORD timeout)
{
	WORD	startT;
	startT = gMSEC;
	while(!(UCSR0A&(1<<RXC)) ){ 	// test for received character
    ad52:	5f 9b       	sbis	0x0b, 7	; 11
    ad54:	e7 cf       	rjmp	.-50     	; 0xad24 <wckOverCTRead+0x16>
			// wait RX_T_OUT for a character
            if((1000 - startT + gMSEC) > timeout) break;
        }
		else if((gMSEC - startT) > timeout) break;
	}
	return UDR0;
    ad56:	8c b1       	in	r24, 0x0c	; 12
// Get character when received. or timeout
//------------------------------------------------------------------------------
char wckGetByte(WORD timeout)
{
	WORD	startT;
	startT = gMSEC;
    ad58:	20 91 be 0a 	lds	r18, 0x0ABE
    ad5c:	30 91 bf 0a 	lds	r19, 0x0ABF
    ad60:	17 c0       	rjmp	.+46     	; 0xad90 <wckOverCTRead+0x82>
	while(!(UCSR0A&(1<<RXC)) ){ 	// test for received character
        if(gMSEC<startT) {
    ad62:	80 91 be 0a 	lds	r24, 0x0ABE
    ad66:	90 91 bf 0a 	lds	r25, 0x0ABF
    ad6a:	82 17       	cp	r24, r18
    ad6c:	93 07       	cpc	r25, r19
    ad6e:	38 f4       	brcc	.+14     	; 0xad7e <wckOverCTRead+0x70>
			// wait RX_T_OUT for a character
            if((1000 - startT + gMSEC) > timeout) break;
    ad70:	80 91 be 0a 	lds	r24, 0x0ABE
    ad74:	90 91 bf 0a 	lds	r25, 0x0ABF
    ad78:	88 51       	subi	r24, 0x18	; 24
    ad7a:	9c 4f       	sbci	r25, 0xFC	; 252
    ad7c:	04 c0       	rjmp	.+8      	; 0xad86 <wckOverCTRead+0x78>
        }
		else if((gMSEC - startT) > timeout) break;
    ad7e:	80 91 be 0a 	lds	r24, 0x0ABE
    ad82:	90 91 bf 0a 	lds	r25, 0x0ABF
    ad86:	82 1b       	sub	r24, r18
    ad88:	93 0b       	sbc	r25, r19
    ad8a:	85 36       	cpi	r24, 0x65	; 101
    ad8c:	91 05       	cpc	r25, r1
    ad8e:	10 f4       	brcc	.+4      	; 0xad94 <wckOverCTRead+0x86>
//------------------------------------------------------------------------------
char wckGetByte(WORD timeout)
{
	WORD	startT;
	startT = gMSEC;
	while(!(UCSR0A&(1<<RXC)) ){ 	// test for received character
    ad90:	5f 9b       	sbis	0x0b, 7	; 11
    ad92:	e7 cf       	rjmp	.-50     	; 0xad62 <wckOverCTRead+0x54>
			// wait RX_T_OUT for a character
            if((1000 - startT + gMSEC) > timeout) break;
        }
		else if((gMSEC - startT) > timeout) break;
	}
	return UDR0;
    ad94:	8c b1       	in	r24, 0x0c	; 12
	wckGetByte(TIME_OUT1);
	Data1=wckGetByte(TIME_OUT1);
	if(Data1!=0xff) 
		return Data1;
	return 0xff;
}
    ad96:	08 95       	ret

0000ad98 <wckBoundSet>:
/* Function that sends Boundary Set Command to wCK module */
/* Input : ServoID, *NewLBound, *NewUBound */
/* Return : 1 if succeed, 0 if fail */
/**********************************************************************/
char wckBoundSet(char ServoID, char *NewLBound, char *NewUBound)
{
    ad98:	0f 93       	push	r16
    ad9a:	1f 93       	push	r17
    ad9c:	cf 93       	push	r28
    ad9e:	df 93       	push	r29
    ada0:	eb 01       	movw	r28, r22
    ada2:	8a 01       	movw	r16, r20
	char Data1,Data2;
	wckSendSetCommand((7<<5)|ServoID, 0x11, *NewLBound, *NewUBound);
    ada4:	fa 01       	movw	r30, r20
    ada6:	20 81       	ld	r18, Z
    ada8:	48 81       	ld	r20, Y
    adaa:	61 e1       	ldi	r22, 0x11	; 17
    adac:	80 6e       	ori	r24, 0xE0	; 224
    adae:	0e 94 fc 52 	call	0xa5f8	; 0xa5f8 <wckSendSetCommand>
// Get character when received. or timeout
//------------------------------------------------------------------------------
char wckGetByte(WORD timeout)
{
	WORD	startT;
	startT = gMSEC;
    adb2:	20 91 be 0a 	lds	r18, 0x0ABE
    adb6:	30 91 bf 0a 	lds	r19, 0x0ABF
    adba:	17 c0       	rjmp	.+46     	; 0xadea <wckBoundSet+0x52>
	while(!(UCSR0A&(1<<RXC)) ){ 	// test for received character
        if(gMSEC<startT) {
    adbc:	80 91 be 0a 	lds	r24, 0x0ABE
    adc0:	90 91 bf 0a 	lds	r25, 0x0ABF
    adc4:	82 17       	cp	r24, r18
    adc6:	93 07       	cpc	r25, r19
    adc8:	38 f4       	brcc	.+14     	; 0xadd8 <wckBoundSet+0x40>
			// wait RX_T_OUT for a character
            if((1000 - startT + gMSEC) > timeout) break;
    adca:	80 91 be 0a 	lds	r24, 0x0ABE
    adce:	90 91 bf 0a 	lds	r25, 0x0ABF
    add2:	88 51       	subi	r24, 0x18	; 24
    add4:	9c 4f       	sbci	r25, 0xFC	; 252
    add6:	04 c0       	rjmp	.+8      	; 0xade0 <wckBoundSet+0x48>
        }
		else if((gMSEC - startT) > timeout) break;
    add8:	80 91 be 0a 	lds	r24, 0x0ABE
    addc:	90 91 bf 0a 	lds	r25, 0x0ABF
    ade0:	82 1b       	sub	r24, r18
    ade2:	93 0b       	sbc	r25, r19
    ade4:	8b 3f       	cpi	r24, 0xFB	; 251
    ade6:	91 05       	cpc	r25, r1
    ade8:	10 f4       	brcc	.+4      	; 0xadee <wckBoundSet+0x56>
//------------------------------------------------------------------------------
char wckGetByte(WORD timeout)
{
	WORD	startT;
	startT = gMSEC;
	while(!(UCSR0A&(1<<RXC)) ){ 	// test for received character
    adea:	5f 9b       	sbis	0x0b, 7	; 11
    adec:	e7 cf       	rjmp	.-50     	; 0xadbc <wckBoundSet+0x24>
			// wait RX_T_OUT for a character
            if((1000 - startT + gMSEC) > timeout) break;
        }
		else if((gMSEC - startT) > timeout) break;
	}
	return UDR0;
    adee:	4c b1       	in	r20, 0x0c	; 12
// Get character when received. or timeout
//------------------------------------------------------------------------------
char wckGetByte(WORD timeout)
{
	WORD	startT;
	startT = gMSEC;
    adf0:	20 91 be 0a 	lds	r18, 0x0ABE
    adf4:	30 91 bf 0a 	lds	r19, 0x0ABF
    adf8:	17 c0       	rjmp	.+46     	; 0xae28 <wckBoundSet+0x90>
	while(!(UCSR0A&(1<<RXC)) ){ 	// test for received character
        if(gMSEC<startT) {
    adfa:	80 91 be 0a 	lds	r24, 0x0ABE
    adfe:	90 91 bf 0a 	lds	r25, 0x0ABF
    ae02:	82 17       	cp	r24, r18
    ae04:	93 07       	cpc	r25, r19
    ae06:	38 f4       	brcc	.+14     	; 0xae16 <wckBoundSet+0x7e>
			// wait RX_T_OUT for a character
            if((1000 - startT + gMSEC) > timeout) break;
    ae08:	80 91 be 0a 	lds	r24, 0x0ABE
    ae0c:	90 91 bf 0a 	lds	r25, 0x0ABF
    ae10:	88 51       	subi	r24, 0x18	; 24
    ae12:	9c 4f       	sbci	r25, 0xFC	; 252
    ae14:	04 c0       	rjmp	.+8      	; 0xae1e <wckBoundSet+0x86>
        }
		else if((gMSEC - startT) > timeout) break;
    ae16:	80 91 be 0a 	lds	r24, 0x0ABE
    ae1a:	90 91 bf 0a 	lds	r25, 0x0ABF
    ae1e:	82 1b       	sub	r24, r18
    ae20:	93 0b       	sbc	r25, r19
    ae22:	8b 3f       	cpi	r24, 0xFB	; 251
    ae24:	91 05       	cpc	r25, r1
    ae26:	10 f4       	brcc	.+4      	; 0xae2c <wckBoundSet+0x94>
//------------------------------------------------------------------------------
char wckGetByte(WORD timeout)
{
	WORD	startT;
	startT = gMSEC;
	while(!(UCSR0A&(1<<RXC)) ){ 	// test for received character
    ae28:	5f 9b       	sbis	0x0b, 7	; 11
    ae2a:	e7 cf       	rjmp	.-50     	; 0xadfa <wckBoundSet+0x62>
			// wait RX_T_OUT for a character
            if((1000 - startT + gMSEC) > timeout) break;
        }
		else if((gMSEC - startT) > timeout) break;
	}
	return UDR0;
    ae2c:	2c b1       	in	r18, 0x0c	; 12
{
	char Data1,Data2;
	wckSendSetCommand((7<<5)|ServoID, 0x11, *NewLBound, *NewUBound);
	Data1 = wckGetByte(TIME_OUT2);
	Data2 = wckGetByte(TIME_OUT2);
	if((Data1==*NewLBound) && (Data2==*NewUBound)) 
    ae2e:	88 81       	ld	r24, Y
    ae30:	48 17       	cp	r20, r24
    ae32:	11 f0       	breq	.+4      	; 0xae38 <wckBoundSet+0xa0>
    ae34:	90 e0       	ldi	r25, 0x00	; 0
    ae36:	06 c0       	rjmp	.+12     	; 0xae44 <wckBoundSet+0xac>
    ae38:	90 e0       	ldi	r25, 0x00	; 0
    ae3a:	f8 01       	movw	r30, r16
    ae3c:	80 81       	ld	r24, Z
    ae3e:	28 17       	cp	r18, r24
    ae40:	09 f4       	brne	.+2      	; 0xae44 <wckBoundSet+0xac>
    ae42:	91 e0       	ldi	r25, 0x01	; 1
		return 1;
	return 0;
}
    ae44:	89 2f       	mov	r24, r25
    ae46:	df 91       	pop	r29
    ae48:	cf 91       	pop	r28
    ae4a:	1f 91       	pop	r17
    ae4c:	0f 91       	pop	r16
    ae4e:	08 95       	ret

0000ae50 <wckBoundRead>:
/* Function that sends Boundary Read Command to wCK module */
/* Input : ServoID, *NewLBound, *NewUBound */
/* Return : 1 if succeed, 0 if fail */
/*************************************************************************/
char wckBoundRead(char ServoID, char *LBound, char *UBound)
{
    ae50:	0f 93       	push	r16
    ae52:	1f 93       	push	r17
    ae54:	cf 93       	push	r28
    ae56:	df 93       	push	r29
    ae58:	eb 01       	movw	r28, r22
    ae5a:	8a 01       	movw	r16, r20
	wckSendSetCommand((7<<5)|ServoID, 0x12, 0, 0);
    ae5c:	20 e0       	ldi	r18, 0x00	; 0
    ae5e:	40 e0       	ldi	r20, 0x00	; 0
    ae60:	62 e1       	ldi	r22, 0x12	; 18
    ae62:	80 6e       	ori	r24, 0xE0	; 224
    ae64:	0e 94 fc 52 	call	0xa5f8	; 0xa5f8 <wckSendSetCommand>
// Get character when received. or timeout
//------------------------------------------------------------------------------
char wckGetByte(WORD timeout)
{
	WORD	startT;
	startT = gMSEC;
    ae68:	20 91 be 0a 	lds	r18, 0x0ABE
    ae6c:	30 91 bf 0a 	lds	r19, 0x0ABF
    ae70:	17 c0       	rjmp	.+46     	; 0xaea0 <wckBoundRead+0x50>
	while(!(UCSR0A&(1<<RXC)) ){ 	// test for received character
        if(gMSEC<startT) {
    ae72:	80 91 be 0a 	lds	r24, 0x0ABE
    ae76:	90 91 bf 0a 	lds	r25, 0x0ABF
    ae7a:	82 17       	cp	r24, r18
    ae7c:	93 07       	cpc	r25, r19
    ae7e:	38 f4       	brcc	.+14     	; 0xae8e <wckBoundRead+0x3e>
			// wait RX_T_OUT for a character
            if((1000 - startT + gMSEC) > timeout) break;
    ae80:	80 91 be 0a 	lds	r24, 0x0ABE
    ae84:	90 91 bf 0a 	lds	r25, 0x0ABF
    ae88:	88 51       	subi	r24, 0x18	; 24
    ae8a:	9c 4f       	sbci	r25, 0xFC	; 252
    ae8c:	04 c0       	rjmp	.+8      	; 0xae96 <wckBoundRead+0x46>
        }
		else if((gMSEC - startT) > timeout) break;
    ae8e:	80 91 be 0a 	lds	r24, 0x0ABE
    ae92:	90 91 bf 0a 	lds	r25, 0x0ABF
    ae96:	82 1b       	sub	r24, r18
    ae98:	93 0b       	sbc	r25, r19
    ae9a:	85 36       	cpi	r24, 0x65	; 101
    ae9c:	91 05       	cpc	r25, r1
    ae9e:	10 f4       	brcc	.+4      	; 0xaea4 <wckBoundRead+0x54>
//------------------------------------------------------------------------------
char wckGetByte(WORD timeout)
{
	WORD	startT;
	startT = gMSEC;
	while(!(UCSR0A&(1<<RXC)) ){ 	// test for received character
    aea0:	5f 9b       	sbis	0x0b, 7	; 11
    aea2:	e7 cf       	rjmp	.-50     	; 0xae72 <wckBoundRead+0x22>
			// wait RX_T_OUT for a character
            if((1000 - startT + gMSEC) > timeout) break;
        }
		else if((gMSEC - startT) > timeout) break;
	}
	return UDR0;
    aea4:	8c b1       	in	r24, 0x0c	; 12
/* Return : 1 if succeed, 0 if fail */
/*************************************************************************/
char wckBoundRead(char ServoID, char *LBound, char *UBound)
{
	wckSendSetCommand((7<<5)|ServoID, 0x12, 0, 0);
	*LBound = wckGetByte(TIME_OUT1);
    aea6:	88 83       	st	Y, r24
// Get character when received. or timeout
//------------------------------------------------------------------------------
char wckGetByte(WORD timeout)
{
	WORD	startT;
	startT = gMSEC;
    aea8:	20 91 be 0a 	lds	r18, 0x0ABE
    aeac:	30 91 bf 0a 	lds	r19, 0x0ABF
    aeb0:	17 c0       	rjmp	.+46     	; 0xaee0 <wckBoundRead+0x90>
	while(!(UCSR0A&(1<<RXC)) ){ 	// test for received character
        if(gMSEC<startT) {
    aeb2:	80 91 be 0a 	lds	r24, 0x0ABE
    aeb6:	90 91 bf 0a 	lds	r25, 0x0ABF
    aeba:	82 17       	cp	r24, r18
    aebc:	93 07       	cpc	r25, r19
    aebe:	38 f4       	brcc	.+14     	; 0xaece <wckBoundRead+0x7e>
			// wait RX_T_OUT for a character
            if((1000 - startT + gMSEC) > timeout) break;
    aec0:	80 91 be 0a 	lds	r24, 0x0ABE
    aec4:	90 91 bf 0a 	lds	r25, 0x0ABF
    aec8:	88 51       	subi	r24, 0x18	; 24
    aeca:	9c 4f       	sbci	r25, 0xFC	; 252
    aecc:	04 c0       	rjmp	.+8      	; 0xaed6 <wckBoundRead+0x86>
        }
		else if((gMSEC - startT) > timeout) break;
    aece:	80 91 be 0a 	lds	r24, 0x0ABE
    aed2:	90 91 bf 0a 	lds	r25, 0x0ABF
    aed6:	82 1b       	sub	r24, r18
    aed8:	93 0b       	sbc	r25, r19
    aeda:	85 36       	cpi	r24, 0x65	; 101
    aedc:	91 05       	cpc	r25, r1
    aede:	10 f4       	brcc	.+4      	; 0xaee4 <wckBoundRead+0x94>
//------------------------------------------------------------------------------
char wckGetByte(WORD timeout)
{
	WORD	startT;
	startT = gMSEC;
	while(!(UCSR0A&(1<<RXC)) ){ 	// test for received character
    aee0:	5f 9b       	sbis	0x0b, 7	; 11
    aee2:	e7 cf       	rjmp	.-50     	; 0xaeb2 <wckBoundRead+0x62>
			// wait RX_T_OUT for a character
            if((1000 - startT + gMSEC) > timeout) break;
        }
		else if((gMSEC - startT) > timeout) break;
	}
	return UDR0;
    aee4:	9c b1       	in	r25, 0x0c	; 12
/*************************************************************************/
char wckBoundRead(char ServoID, char *LBound, char *UBound)
{
	wckSendSetCommand((7<<5)|ServoID, 0x12, 0, 0);
	*LBound = wckGetByte(TIME_OUT1);
	*UBound = wckGetByte(TIME_OUT1);
    aee6:	f8 01       	movw	r30, r16
    aee8:	90 83       	st	Z, r25
    aeea:	20 e0       	ldi	r18, 0x00	; 0
    aeec:	88 81       	ld	r24, Y
    aeee:	89 17       	cp	r24, r25
    aef0:	08 f4       	brcc	.+2      	; 0xaef4 <wckBoundRead+0xa4>
    aef2:	21 e0       	ldi	r18, 0x01	; 1
	if(*LBound<*UBound) 
		return 1;
	return 0;
}
    aef4:	82 2f       	mov	r24, r18
    aef6:	df 91       	pop	r29
    aef8:	cf 91       	pop	r28
    aefa:	1f 91       	pop	r17
    aefc:	0f 91       	pop	r16
    aefe:	08 95       	ret

0000af00 <bin_read_x>:
int buff[MAX_INP_BUF];
int bsize;


int bin_read_x()
{
    af00:	ef 92       	push	r14
    af02:	ff 92       	push	r15
    af04:	0f 93       	push	r16
    af06:	1f 93       	push	r17
    af08:	cf 93       	push	r28
    af0a:	df 93       	push	r29
	int c;
	int b0;
	int cs;
	
	while ((bsize=uartGetByte())<0); // 1 byte length
    af0c:	0e 94 9c 22 	call	0x4538	; 0x4538 <uartGetByte>
    af10:	ec 01       	movw	r28, r24
    af12:	90 93 42 0e 	sts	0x0E42, r25
    af16:	80 93 41 0e 	sts	0x0E41, r24
    af1a:	97 fd       	sbrc	r25, 7
    af1c:	f7 cf       	rjmp	.-18     	; 0xaf0c <bin_read_x+0xc>
    af1e:	81 ef       	ldi	r24, 0xF1	; 241
    af20:	e8 2e       	mov	r14, r24
    af22:	8d e0       	ldi	r24, 0x0D	; 13
    af24:	f8 2e       	mov	r15, r24
    af26:	00 e0       	ldi	r16, 0x00	; 0
    af28:	10 e0       	ldi	r17, 0x00	; 0
    af2a:	0c c0       	rjmp	.+24     	; 0xaf44 <bin_read_x+0x44>
	
	cs=bsize;
	
	for (c=0; (c<bsize && c<MAX_INP_BUF); c++)
	{			
		while ((b0=uartGetByte())<0);
    af2c:	0e 94 9c 22 	call	0x4538	; 0x4538 <uartGetByte>
    af30:	97 fd       	sbrc	r25, 7
    af32:	fc cf       	rjmp	.-8      	; 0xaf2c <bin_read_x+0x2c>
		buff[c]=b0; 	// load each byte			
    af34:	f7 01       	movw	r30, r14
    af36:	81 93       	st	Z+, r24
    af38:	91 93       	st	Z+, r25
    af3a:	7f 01       	movw	r14, r30
		cs ^= b0;		// calculate checksum
    af3c:	c8 27       	eor	r28, r24
    af3e:	d9 27       	eor	r29, r25
	
	while ((bsize=uartGetByte())<0); // 1 byte length
	
	cs=bsize;
	
	for (c=0; (c<bsize && c<MAX_INP_BUF); c++)
    af40:	0f 5f       	subi	r16, 0xFF	; 255
    af42:	1f 4f       	sbci	r17, 0xFF	; 255
    af44:	80 91 41 0e 	lds	r24, 0x0E41
    af48:	90 91 42 0e 	lds	r25, 0x0E42
    af4c:	08 17       	cp	r16, r24
    af4e:	19 07       	cpc	r17, r25
    af50:	1c f4       	brge	.+6      	; 0xaf58 <bin_read_x+0x58>
    af52:	08 32       	cpi	r16, 0x28	; 40
    af54:	11 05       	cpc	r17, r1
    af56:	51 f7       	brne	.-44     	; 0xaf2c <bin_read_x+0x2c>
	{			
		while ((b0=uartGetByte())<0);
		buff[c]=b0; 	// load each byte			
		cs ^= b0;		// calculate checksum
	}
	while ((b0=uartGetByte())<0);
    af58:	0e 94 9c 22 	call	0x4538	; 0x4538 <uartGetByte>
    af5c:	97 fd       	sbrc	r25, 7
    af5e:	fc cf       	rjmp	.-8      	; 0xaf58 <bin_read_x+0x58>
    af60:	20 e0       	ldi	r18, 0x00	; 0
    af62:	30 e0       	ldi	r19, 0x00	; 0
    af64:	cf 77       	andi	r28, 0x7F	; 127
    af66:	d0 70       	andi	r29, 0x00	; 0
    af68:	8c 17       	cp	r24, r28
    af6a:	9d 07       	cpc	r25, r29
    af6c:	11 f0       	breq	.+4      	; 0xaf72 <bin_read_x+0x72>
    af6e:	21 e0       	ldi	r18, 0x01	; 1
    af70:	30 e0       	ldi	r19, 0x00	; 0

	return (b0 != (cs&0x7f));
}
    af72:	c9 01       	movw	r24, r18
    af74:	df 91       	pop	r29
    af76:	cf 91       	pop	r28
    af78:	1f 91       	pop	r17
    af7a:	0f 91       	pop	r16
    af7c:	ff 90       	pop	r15
    af7e:	ef 90       	pop	r14
    af80:	08 95       	ret

0000af82 <bin_downloadbasic>:

extern uint8_t EEMEM BASIC_PROG_SPACE[];  // this is where the tokenised code will be stored


int bin_downloadbasic()
{
    af82:	ef 92       	push	r14
    af84:	ff 92       	push	r15
    af86:	0f 93       	push	r16
    af88:	1f 93       	push	r17
    af8a:	cf 93       	push	r28
    af8c:	df 93       	push	r29
	int i;
	uint8_t b0=0, b1=0;
	int cs = 0;

	while ((b0=uartGetByte())<0);      
    af8e:	0e 94 9c 22 	call	0x4538	; 0x4538 <uartGetByte>
    af92:	08 2f       	mov	r16, r24
	while ((b1=uartGetByte())<0);
    af94:	0e 94 9c 22 	call	0x4538	; 0x4538 <uartGetByte>
	int bytes = ((int)b1 << 8) | b0;
    af98:	90 e0       	ldi	r25, 0x00	; 0
    af9a:	10 e0       	ldi	r17, 0x00	; 0
    af9c:	f8 2e       	mov	r15, r24
    af9e:	ee 24       	eor	r14, r14
    afa0:	e0 2a       	or	r14, r16
    afa2:	f1 2a       	or	r15, r17
	cs ^= b0;
	cs ^= b1;
    afa4:	08 27       	eor	r16, r24
    afa6:	19 27       	eor	r17, r25
    afa8:	c0 e0       	ldi	r28, 0x00	; 0
    afaa:	d0 e0       	ldi	r29, 0x00	; 0
    afac:	15 c0       	rjmp	.+42     	; 0xafd8 <bin_downloadbasic+0x56>
	
	for (i=0; i<bytes; i++)
	{
		while ((b0=uartGetByte())<0); 	
    afae:	0e 94 9c 22 	call	0x4538	; 0x4538 <uartGetByte>
    afb2:	28 2f       	mov	r18, r24
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    afb4:	e1 99       	sbic	0x1c, 1	; 28
    afb6:	fe cf       	rjmp	.-4      	; 0xafb4 <bin_downloadbasic+0x32>
		cs ^= b0;
    afb8:	82 2f       	mov	r24, r18
    afba:	90 e0       	ldi	r25, 0x00	; 0
    afbc:	08 27       	eor	r16, r24
    afbe:	19 27       	eor	r17, r25
    afc0:	ce 01       	movw	r24, r28
    afc2:	8f 5b       	subi	r24, 0xBF	; 191
    afc4:	9f 4f       	sbci	r25, 0xFF	; 255
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    afc6:	9f bb       	out	0x1f, r25	; 31
    afc8:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    afca:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
    afcc:	0f b6       	in	r0, 0x3f	; 63
    afce:	f8 94       	cli
    afd0:	e2 9a       	sbi	0x1c, 2	; 28
    afd2:	e1 9a       	sbi	0x1c, 1	; 28
    afd4:	0f be       	out	0x3f, r0	; 63
	while ((b1=uartGetByte())<0);
	int bytes = ((int)b1 << 8) | b0;
	cs ^= b0;
	cs ^= b1;
	
	for (i=0; i<bytes; i++)
    afd6:	21 96       	adiw	r28, 0x01	; 1
    afd8:	ce 15       	cp	r28, r14
    afda:	df 05       	cpc	r29, r15
    afdc:	44 f3       	brlt	.-48     	; 0xafae <bin_downloadbasic+0x2c>
		while ((b0=uartGetByte())<0); 	
		cs ^= b0;
		eeprom_write_byte(BASIC_PROG_SPACE+i, b0);	
	}
	
	while ((b0=uartGetByte())<0);
    afde:	0e 94 9c 22 	call	0x4538	; 0x4538 <uartGetByte>
    afe2:	20 e0       	ldi	r18, 0x00	; 0
    afe4:	30 e0       	ldi	r19, 0x00	; 0
    afe6:	90 e0       	ldi	r25, 0x00	; 0
    afe8:	0f 77       	andi	r16, 0x7F	; 127
    afea:	10 70       	andi	r17, 0x00	; 0
    afec:	80 17       	cp	r24, r16
    afee:	91 07       	cpc	r25, r17
    aff0:	11 f0       	breq	.+4      	; 0xaff6 <bin_downloadbasic+0x74>
    aff2:	21 e0       	ldi	r18, 0x01	; 1
    aff4:	30 e0       	ldi	r19, 0x00	; 0
	return (b0 != (cs&0x7f));
}
    aff6:	c9 01       	movw	r24, r18
    aff8:	df 91       	pop	r29
    affa:	cf 91       	pop	r28
    affc:	1f 91       	pop	r17
    affe:	0f 91       	pop	r16
    b000:	ff 90       	pop	r15
    b002:	ef 90       	pop	r14
    b004:	08 95       	ret

0000b006 <bin_read_m>:
m command read / response

***************************/

int bin_read_m()
{
    b006:	ef 92       	push	r14
    b008:	ff 92       	push	r15
    b00a:	0f 93       	push	r16
    b00c:	1f 93       	push	r17
    b00e:	cf 93       	push	r28
    b010:	df 93       	push	r29
	int nb=0;
	int b0;
	int b1;
	int cs;
	
	motionBuf = GetNextMotionBuffer();
    b012:	0e 94 8d 23 	call	0x471a	; 0x471a <GetNextMotionBuffer>
    b016:	90 93 91 0a 	sts	0x0A91, r25
    b01a:	80 93 90 0a 	sts	0x0A90, r24
	
	while ((b0=uartGetByte())<0);
    b01e:	0e 94 9c 22 	call	0x4538	; 0x4538 <uartGetByte>
    b022:	ec 01       	movw	r28, r24
    b024:	97 fd       	sbrc	r25, 7
    b026:	fb cf       	rjmp	.-10     	; 0xb01e <bin_read_m+0x18>
	while ((b1=uartGetByte())<0);
    b028:	0e 94 9c 22 	call	0x4538	; 0x4538 <uartGetByte>
    b02c:	97 fd       	sbrc	r25, 7
    b02e:	fc cf       	rjmp	.-8      	; 0xb028 <bin_read_m+0x22>
	int bytes = ((int)b1 << 8) | b0;
    b030:	18 2f       	mov	r17, r24
    b032:	00 27       	eor	r16, r16
    b034:	0c 2b       	or	r16, r28
    b036:	1d 2b       	or	r17, r29
    b038:	78 01       	movw	r14, r16
    b03a:	c0 e0       	ldi	r28, 0x00	; 0
    b03c:	d0 e0       	ldi	r29, 0x00	; 0
    b03e:	0e c0       	rjmp	.+28     	; 0xb05c <bin_read_m+0x56>

	cs = bytes;

	while (nb<bytes)
	{				
		while ((b0=uartGetByte())<0);
    b040:	0e 94 9c 22 	call	0x4538	; 0x4538 <uartGetByte>
    b044:	97 fd       	sbrc	r25, 7
    b046:	fc cf       	rjmp	.-8      	; 0xb040 <bin_read_m+0x3a>
		motionBuf[nb++] = b0;
    b048:	e0 91 90 0a 	lds	r30, 0x0A90
    b04c:	f0 91 91 0a 	lds	r31, 0x0A91
    b050:	ec 0f       	add	r30, r28
    b052:	fd 1f       	adc	r31, r29
    b054:	80 83       	st	Z, r24
    b056:	21 96       	adiw	r28, 0x01	; 1
		cs ^= b0;					// calculate checksum
    b058:	e8 26       	eor	r14, r24
    b05a:	f9 26       	eor	r15, r25
	while ((b1=uartGetByte())<0);
	int bytes = ((int)b1 << 8) | b0;

	cs = bytes;

	while (nb<bytes)
    b05c:	c0 17       	cp	r28, r16
    b05e:	d1 07       	cpc	r29, r17
    b060:	7c f3       	brlt	.-34     	; 0xb040 <bin_read_m+0x3a>
		while ((b0=uartGetByte())<0);
		motionBuf[nb++] = b0;
		cs ^= b0;					// calculate checksum
	}

	while ((b0=uartGetByte())<0); 	// read cs sent
    b062:	0e 94 9c 22 	call	0x4538	; 0x4538 <uartGetByte>
    b066:	97 fd       	sbrc	r25, 7
    b068:	fc cf       	rjmp	.-8      	; 0xb062 <bin_read_m+0x5c>
    b06a:	20 e0       	ldi	r18, 0x00	; 0
    b06c:	30 e0       	ldi	r19, 0x00	; 0
    b06e:	4f e7       	ldi	r20, 0x7F	; 127
    b070:	e4 22       	and	r14, r20
    b072:	ff 24       	eor	r15, r15
    b074:	8e 15       	cp	r24, r14
    b076:	9f 05       	cpc	r25, r15
    b078:	11 f0       	breq	.+4      	; 0xb07e <bin_read_m+0x78>
    b07a:	21 e0       	ldi	r18, 0x01	; 1
    b07c:	30 e0       	ldi	r19, 0x00	; 0

	return (b0 != (cs&0x7f));  		// Do they match
}
    b07e:	c9 01       	movw	r24, r18
    b080:	df 91       	pop	r29
    b082:	cf 91       	pop	r28
    b084:	1f 91       	pop	r17
    b086:	0f 91       	pop	r16
    b088:	ff 90       	pop	r15
    b08a:	ef 90       	pop	r14
    b08c:	08 95       	ret

0000b08e <bin_read_p>:
p2 = readPSD

***************************/

int bin_read_p(int mt)
{
    b08e:	cf 93       	push	r28
    b090:	df 93       	push	r29
    b092:	ec 01       	movw	r28, r24
	int cs;

	while ((cs=uartGetByte())<0); 	// read cs sent
    b094:	0e 94 9c 22 	call	0x4538	; 0x4538 <uartGetByte>
    b098:	9c 01       	movw	r18, r24
    b09a:	97 fd       	sbrc	r25, 7
    b09c:	fb cf       	rjmp	.-10     	; 0xb094 <bin_read_p+0x6>

	if  (((mt ^ MAGIC_REQUEST) & 0x7f) == cs)		// Do they match
    b09e:	8d ec       	ldi	r24, 0xCD	; 205
    b0a0:	90 e0       	ldi	r25, 0x00	; 0
    b0a2:	8c 27       	eor	r24, r28
    b0a4:	9d 27       	eor	r25, r29
    b0a6:	8f 77       	andi	r24, 0x7F	; 127
    b0a8:	90 70       	andi	r25, 0x00	; 0
    b0aa:	82 17       	cp	r24, r18
    b0ac:	93 07       	cpc	r25, r19
    b0ae:	a9 f4       	brne	.+42     	; 0xb0da <bin_read_p+0x4c>
	{
		switch(mt)
    b0b0:	c9 35       	cpi	r28, 0x59	; 89
    b0b2:	d1 05       	cpc	r29, r1
    b0b4:	39 f0       	breq	.+14     	; 0xb0c4 <bin_read_p+0x36>
    b0b6:	c9 37       	cpi	r28, 0x79	; 121
    b0b8:	d1 05       	cpc	r29, r1
    b0ba:	39 f0       	breq	.+14     	; 0xb0ca <bin_read_p+0x3c>
    b0bc:	c0 35       	cpi	r28, 0x50	; 80
    b0be:	d1 05       	cpc	r29, r1
    b0c0:	61 f4       	brne	.+24     	; 0xb0da <bin_read_p+0x4c>
    b0c2:	08 c0       	rjmp	.+16     	; 0xb0d4 <bin_read_p+0x46>
		{
		case 'Y':
			PSD_on();
    b0c4:	0e 94 1d 2c 	call	0x583a	; 0x583a <PSD_on>
    b0c8:	02 c0       	rjmp	.+4      	; 0xb0ce <bin_read_p+0x40>
			break;
		case 'y':
			PSD_off();
    b0ca:	0e 94 28 2c 	call	0x5850	; 0x5850 <PSD_off>
    b0ce:	20 e5       	ldi	r18, 0x50	; 80
    b0d0:	30 e0       	ldi	r19, 0x00	; 0
    b0d2:	05 c0       	rjmp	.+10     	; 0xb0de <bin_read_p+0x50>
			break;
		case 'P':
			Get_AD_PSD();
    b0d4:	0e 94 2a 2c 	call	0x5854	; 0x5854 <Get_AD_PSD>
    b0d8:	fa cf       	rjmp	.-12     	; 0xb0ce <bin_read_p+0x40>
			break;
    b0da:	2f ef       	ldi	r18, 0xFF	; 255
    b0dc:	3f ef       	ldi	r19, 0xFF	; 255
			return -1;
		}
		return 'P';
	}
	return -1;
}
    b0de:	c9 01       	movw	r24, r18
    b0e0:	df 91       	pop	r29
    b0e2:	cf 91       	pop	r28
    b0e4:	08 95       	ret

0000b0e6 <bin_respond_Iquery>:

I command response (IR and PF1/PF2 values)

***************************/
int bin_respond_Iquery(int mt)
{
    b0e6:	1f 93       	push	r17
    b0e8:	cf 93       	push	r28
    b0ea:	df 93       	push	r29
    b0ec:	ec 01       	movw	r28, r24
	BYTE	tmpB;
	int cs = mt;
		
	uartSendByte(MAGIC_RESPONSE);
    b0ee:	8a ee       	ldi	r24, 0xEA	; 234
    b0f0:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
	uartSendByte(mt);	
    b0f4:	8c 2f       	mov	r24, r28
    b0f6:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
	
	if ( gIRReady) 
    b0fa:	80 91 9d 0d 	lds	r24, 0x0D9D
    b0fe:	88 23       	and	r24, r24
    b100:	11 f4       	brne	.+4      	; 0xb106 <bin_respond_Iquery+0x20>
    b102:	10 e0       	ldi	r17, 0x00	; 0
    b104:	04 c0       	rjmp	.+8      	; 0xb10e <bin_respond_Iquery+0x28>
	{
		gIRReady = FALSE;
    b106:	10 92 9d 0d 	sts	0x0D9D, r1
		tmpB = gIRData;
    b10a:	10 91 a0 0d 	lds	r17, 0x0DA0
	}
	else
	{
		tmpB=0;
	}
	uartSendByte(tmpB); 	
    b10e:	81 2f       	mov	r24, r17
    b110:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
    cs ^= tmpB;
	
	tmpB=PINA & 3;
    b114:	89 b3       	in	r24, 0x19	; 25
    b116:	83 70       	andi	r24, 0x03	; 3
	else
	{
		tmpB=0;
	}
	uartSendByte(tmpB); 	
    cs ^= tmpB;
    b118:	28 2f       	mov	r18, r24
    b11a:	30 e0       	ldi	r19, 0x00	; 0
    b11c:	c2 27       	eor	r28, r18
    b11e:	d3 27       	eor	r29, r19
	
	tmpB=PINA & 3;
    cs ^= tmpB;	
	uartSendByte(tmpB); 	
    b120:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
	
	uartSendByte( (cs) & 0x7F); 	
    b124:	1c 27       	eor	r17, r28
    b126:	81 2f       	mov	r24, r17
    b128:	8f 77       	andi	r24, 0x7F	; 127
    b12a:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>

	return 0;
}
    b12e:	80 e0       	ldi	r24, 0x00	; 0
    b130:	90 e0       	ldi	r25, 0x00	; 0
    b132:	df 91       	pop	r29
    b134:	cf 91       	pop	r28
    b136:	1f 91       	pop	r17
    b138:	08 95       	ret

0000b13a <SendResponse>:
	uartSendByte(x&0xff);
	uartSendByte(x>>8);
}

void SendResponse(char mt, uint8_t d)
{
    b13a:	0f 93       	push	r16
    b13c:	1f 93       	push	r17
    b13e:	08 2f       	mov	r16, r24
    b140:	16 2f       	mov	r17, r22
	uartSendByte(MAGIC_RESPONSE);
    b142:	8a ee       	ldi	r24, 0xEA	; 234
    b144:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
	uartSendByte(mt);
    b148:	80 2f       	mov	r24, r16
    b14a:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
	uartSendByte(d);
    b14e:	81 2f       	mov	r24, r17
    b150:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
	uartSendByte( (mt ^ d) & 0x7F);
    b154:	10 27       	eor	r17, r16
    b156:	81 2f       	mov	r24, r17
    b158:	8f 77       	andi	r24, 0x7F	; 127
    b15a:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
}
    b15e:	1f 91       	pop	r17
    b160:	0f 91       	pop	r16
    b162:	08 95       	ret

0000b164 <bin_respond_m>:
	return (b0 != (cs&0x7f));  		// Do they match
}


int bin_respond_m(int mt)
{
    b164:	1f 93       	push	r17
    b166:	18 2f       	mov	r17, r24
	int b1 =0 ;
	
	LoadMotionFromBuffer(motionBuf);			
    b168:	80 91 90 0a 	lds	r24, 0x0A90
    b16c:	90 91 91 0a 	lds	r25, 0x0A91
    b170:	0e 94 76 27 	call	0x4eec	; 0x4eec <LoadMotionFromBuffer>
	
	//left in for now
	//till happy they can't clash
	//could be moded to main loop after that
	
	PlaySceneFromBuffer(motionBuf, 0);
    b174:	60 e0       	ldi	r22, 0x00	; 0
    b176:	70 e0       	ldi	r23, 0x00	; 0
    b178:	80 91 90 0a 	lds	r24, 0x0A90
    b17c:	90 91 91 0a 	lds	r25, 0x0A91
    b180:	0e 94 81 25 	call	0x4b02	; 0x4b02 <PlaySceneFromBuffer>
	complete_motion(motionBuf);
    b184:	80 91 90 0a 	lds	r24, 0x0A90
    b188:	90 91 91 0a 	lds	r25, 0x0A91
    b18c:	0e 94 71 26 	call	0x4ce2	; 0x4ce2 <complete_motion>
	
	// tells client it can send again
	
	SendResponse(mt, b1);
    b190:	60 e0       	ldi	r22, 0x00	; 0
    b192:	81 2f       	mov	r24, r17
    b194:	0e 94 9d 58 	call	0xb13a	; 0xb13a <SendResponse>
	
	return 0;
}
    b198:	80 e0       	ldi	r24, 0x00	; 0
    b19a:	90 e0       	ldi	r25, 0x00	; 0
    b19c:	1f 91       	pop	r17
    b19e:	08 95       	ret

0000b1a0 <bin_respond_p>:
	}
	return -1;
}

int bin_respond_p(int mt)
{
    b1a0:	60 91 99 0d 	lds	r22, 0x0D99
    b1a4:	0e 94 9d 58 	call	0xb13a	; 0xb13a <SendResponse>
	SendResponse(mt, gDistance);
	return 0;
}
    b1a8:	80 e0       	ldi	r24, 0x00	; 0
    b1aa:	90 e0       	ldi	r25, 0x00	; 0
    b1ac:	08 95       	ret

0000b1ae <bin_respond_basicdownload>:
l basic command response

***************************/

int bin_respond_basicdownload(int mt)
{
    b1ae:	62 e1       	ldi	r22, 0x12	; 18
    b1b0:	8c e6       	ldi	r24, 0x6C	; 108
    b1b2:	0e 94 9d 58 	call	0xb13a	; 0xb13a <SendResponse>

	SendResponse('l', VERSION);
	return 0;
}
    b1b6:	80 e0       	ldi	r24, 0x00	; 0
    b1b8:	90 e0       	ldi	r25, 0x00	; 0
    b1ba:	08 95       	ret

0000b1bc <bin_respond_H>:
	return (b1 != (cs&0x7f));
}


int bin_respond_H(int mt)
{
    b1bc:	62 e1       	ldi	r22, 0x12	; 18
    b1be:	88 e4       	ldi	r24, 0x48	; 72
    b1c0:	0e 94 9d 58 	call	0xb13a	; 0xb13a <SendResponse>
	SendResponse('H', VERSION);
	return 0;
}
    b1c4:	80 e0       	ldi	r24, 0x00	; 0
    b1c6:	90 e0       	ldi	r25, 0x00	; 0
    b1c8:	08 95       	ret

0000b1ca <bin_respond_ver>:
ver command response

***************************/

int bin_respond_ver()
{
    b1ca:	62 e1       	ldi	r22, 0x12	; 18
    b1cc:	86 e7       	ldi	r24, 0x76	; 118
    b1ce:	0e 94 9d 58 	call	0xb13a	; 0xb13a <SendResponse>
	SendResponse('v', VERSION);
	return 0;
}
    b1d2:	80 e0       	ldi	r24, 0x00	; 0
    b1d4:	90 e0       	ldi	r25, 0x00	; 0
    b1d6:	08 95       	ret

0000b1d8 <bin_respond_error>:
do we need this or should it ignore

***************************/

int bin_respond_error(int errno)
{
    b1d8:	68 2f       	mov	r22, r24
    b1da:	8a e7       	ldi	r24, 0x7A	; 122
    b1dc:	0e 94 9d 58 	call	0xb13a	; 0xb13a <SendResponse>
	SendResponse('z', errno);
	return 0;
}
    b1e0:	80 e0       	ldi	r24, 0x00	; 0
    b1e2:	90 e0       	ldi	r25, 0x00	; 0
    b1e4:	08 95       	ret

0000b1e6 <SendWord>:

#define PROTOCOL_ERROR	01


void SendWord(WORD x) 
{
    b1e6:	1f 93       	push	r17
    b1e8:	19 2f       	mov	r17, r25
	uartSendByte(x&0xff);
    b1ea:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
	uartSendByte(x>>8);
    b1ee:	81 2f       	mov	r24, r17
    b1f0:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
}
    b1f4:	1f 91       	pop	r17
    b1f6:	08 95       	ret

0000b1f8 <bin_respond_x>:

	return (b0 != (cs&0x7f));
}

int bin_respond_x(int mt)
{
    b1f8:	0f 93       	push	r16
    b1fa:	1f 93       	push	r17
    b1fc:	cf 93       	push	r28
    b1fe:	df 93       	push	r29
    b200:	8c 01       	movw	r16, r24
	int c;
	BYTE b1;
	BYTE b2;
	
	uartSendByte(MAGIC_RESPONSE);
    b202:	8a ee       	ldi	r24, 0xEA	; 234
    b204:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
	uartSendByte(mt);
    b208:	80 2f       	mov	r24, r16
    b20a:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>

	if (mt=='X')
    b20e:	08 35       	cpi	r16, 0x58	; 88
    b210:	11 05       	cpc	r17, r1
    b212:	41 f5       	brne	.+80     	; 0xb264 <bin_respond_x+0x6c>
    b214:	c1 ef       	ldi	r28, 0xF1	; 241
    b216:	dd e0       	ldi	r29, 0x0D	; 13
    b218:	00 e0       	ldi	r16, 0x00	; 0
    b21a:	10 e0       	ldi	r17, 0x00	; 0
    b21c:	06 c0       	rjmp	.+12     	; 0xb22a <bin_respond_x+0x32>
	{
		// transmit  buffer
		for (c=0; (c<bsize && c<MAX_INP_BUF); c++)
		{	
			sciTx0Data(buff[c]&0xFF);
    b21e:	88 81       	ld	r24, Y
    b220:	0e 94 9f 23 	call	0x473e	; 0x473e <sciTx0Data>
	uartSendByte(mt);

	if (mt=='X')
	{
		// transmit  buffer
		for (c=0; (c<bsize && c<MAX_INP_BUF); c++)
    b224:	0f 5f       	subi	r16, 0xFF	; 255
    b226:	1f 4f       	sbci	r17, 0xFF	; 255
    b228:	22 96       	adiw	r28, 0x02	; 2
    b22a:	80 91 41 0e 	lds	r24, 0x0E41
    b22e:	90 91 42 0e 	lds	r25, 0x0E42
    b232:	08 17       	cp	r16, r24
    b234:	19 07       	cpc	r17, r25
    b236:	1c f4       	brge	.+6      	; 0xb23e <bin_respond_x+0x46>
    b238:	08 32       	cpi	r16, 0x28	; 40
    b23a:	11 05       	cpc	r17, r1
    b23c:	81 f7       	brne	.-32     	; 0xb21e <bin_respond_x+0x26>
		{	
			sciTx0Data(buff[c]&0xFF);
		}	
		// get response (or timeout)				
		b1 = sciRx0Ready();
    b23e:	0e 94 a3 23 	call	0x4746	; 0x4746 <sciRx0Ready>
    b242:	18 2f       	mov	r17, r24
		b2 = sciRx0Ready();
    b244:	0e 94 a3 23 	call	0x4746	; 0x4746 <sciRx0Ready>
    b248:	08 2f       	mov	r16, r24
		
		uartSendByte(b1);
    b24a:	81 2f       	mov	r24, r17
    b24c:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
		uartSendByte(b2);
    b250:	80 2f       	mov	r24, r16
    b252:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
		uartSendByte( (mt ^ b1 ^ b2 ) & 0x7F);
    b256:	10 27       	eor	r17, r16
    b258:	88 e5       	ldi	r24, 0x58	; 88
    b25a:	81 27       	eor	r24, r17
    b25c:	8f 77       	andi	r24, 0x7F	; 127
    b25e:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
    b262:	1f c0       	rjmp	.+62     	; 0xb2a2 <bin_respond_x+0xaa>
	}
	else
	{
		b1 = 0; 			// could use to send status	
		uartSendByte(b1);  	// junk
    b264:	80 e0       	ldi	r24, 0x00	; 0
    b266:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
		uartSendByte(b1);  	// junk
    b26a:	80 e0       	ldi	r24, 0x00	; 0
    b26c:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
		uartSendByte( (mt ^ b1 ^ b1) & 0x7F); //checksum
    b270:	80 2f       	mov	r24, r16
    b272:	8f 77       	andi	r24, 0x7F	; 127
    b274:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
    b278:	c1 ef       	ldi	r28, 0xF1	; 241
    b27a:	dd e0       	ldi	r29, 0x0D	; 13
    b27c:	00 e0       	ldi	r16, 0x00	; 0
    b27e:	10 e0       	ldi	r17, 0x00	; 0
    b280:	06 c0       	rjmp	.+12     	; 0xb28e <bin_respond_x+0x96>
		
		// transmit  buffer (after sending respose - should be quicker - 
		// not waiting for reply
		for (c=0; (c<bsize && c<MAX_INP_BUF); c++)
		{	
			sciTx0Data(buff[c]&0xFF);
    b282:	88 81       	ld	r24, Y
    b284:	0e 94 9f 23 	call	0x473e	; 0x473e <sciTx0Data>
		uartSendByte(b1);  	// junk
		uartSendByte( (mt ^ b1 ^ b1) & 0x7F); //checksum
		
		// transmit  buffer (after sending respose - should be quicker - 
		// not waiting for reply
		for (c=0; (c<bsize && c<MAX_INP_BUF); c++)
    b288:	0f 5f       	subi	r16, 0xFF	; 255
    b28a:	1f 4f       	sbci	r17, 0xFF	; 255
    b28c:	22 96       	adiw	r28, 0x02	; 2
    b28e:	80 91 41 0e 	lds	r24, 0x0E41
    b292:	90 91 42 0e 	lds	r25, 0x0E42
    b296:	08 17       	cp	r16, r24
    b298:	19 07       	cpc	r17, r25
    b29a:	1c f4       	brge	.+6      	; 0xb2a2 <bin_respond_x+0xaa>
    b29c:	08 32       	cpi	r16, 0x28	; 40
    b29e:	11 05       	cpc	r17, r1
    b2a0:	81 f7       	brne	.-32     	; 0xb282 <bin_respond_x+0x8a>
		{	
			sciTx0Data(buff[c]&0xFF);
		}
	}
	return 0;
}
    b2a2:	80 e0       	ldi	r24, 0x00	; 0
    b2a4:	90 e0       	ldi	r25, 0x00	; 0
    b2a6:	df 91       	pop	r29
    b2a8:	cf 91       	pop	r28
    b2aa:	1f 91       	pop	r17
    b2ac:	0f 91       	pop	r16
    b2ae:	08 95       	ret

0000b2b0 <bin_respond_Dquery>:

D command response (PSD only)

***************************/
int bin_respond_Dquery(int mt)
{
    b2b0:	0f 93       	push	r16
    b2b2:	1f 93       	push	r17
    b2b4:	08 2f       	mov	r16, r24
	BYTE	tmpB;
		
	uartSendByte(MAGIC_RESPONSE);
    b2b6:	8a ee       	ldi	r24, 0xEA	; 234
    b2b8:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
	uartSendByte(mt);	
    b2bc:	80 2f       	mov	r24, r16
    b2be:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
	
	tmpB=adc_psd();
    b2c2:	0e 94 9c 2c 	call	0x5938	; 0x5938 <adc_psd>
    b2c6:	18 2f       	mov	r17, r24
	uartSendByte(tmpB); 			//0
    b2c8:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>

	uartSendByte( (mt ^ tmpB) & 0x7F); 	//7
    b2cc:	10 27       	eor	r17, r16
    b2ce:	81 2f       	mov	r24, r17
    b2d0:	8f 77       	andi	r24, 0x7F	; 127
    b2d2:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>

	return 0;
}
    b2d6:	80 e0       	ldi	r24, 0x00	; 0
    b2d8:	90 e0       	ldi	r25, 0x00	; 0
    b2da:	1f 91       	pop	r17
    b2dc:	0f 91       	pop	r16
    b2de:	08 95       	ret

0000b2e0 <bin_respond_query>:
q command response

***************************/

int bin_respond_query(int mt)
{
    b2e0:	8f 92       	push	r8
    b2e2:	9f 92       	push	r9
    b2e4:	af 92       	push	r10
    b2e6:	bf 92       	push	r11
    b2e8:	cf 92       	push	r12
    b2ea:	df 92       	push	r13
    b2ec:	ef 92       	push	r14
    b2ee:	ff 92       	push	r15
    b2f0:	0f 93       	push	r16
    b2f2:	1f 93       	push	r17
    b2f4:	cf 93       	push	r28
    b2f6:	df 93       	push	r29
    b2f8:	08 2f       	mov	r16, r24
    b2fa:	f9 2e       	mov	r15, r25
	BYTE	tmpB;
	WORD	tmpW;
	
	int noservos =  get_noservos();
    b2fc:	0e 94 43 42 	call	0x8486	; 0x8486 <get_noservos>
    b300:	18 2f       	mov	r17, r24
    b302:	c8 2e       	mov	r12, r24
    b304:	dd 24       	eor	r13, r13
	
	uartSendByte(MAGIC_RESPONSE);
    b306:	8a ee       	ldi	r24, 0xEA	; 234
    b308:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
	uartSendByte(mt);	
    b30c:	80 2f       	mov	r24, r16
    b30e:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
	uartSendByte(noservos); 		//0
    b312:	81 2f       	mov	r24, r17
    b314:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
    b318:	20 2f       	mov	r18, r16
    b31a:	3f 2d       	mov	r19, r15
    b31c:	c9 01       	movw	r24, r18
    b31e:	ec 01       	movw	r28, r24
    b320:	ff 24       	eor	r15, r15
    b322:	0e c0       	rjmp	.+28     	; 0xb340 <bin_respond_query+0x60>
	
	//query mode
	int cs=mt;
	for (BYTE id=0; id<noservos; id++)
	{
			tmpW = wckPosAndLoadRead(id);
    b324:	8f 2d       	mov	r24, r15
    b326:	0e 94 a5 53 	call	0xa74a	; 0xa74a <wckPosAndLoadRead>
    b32a:	8c 01       	movw	r16, r24
			SendWord(tmpW);	
    b32c:	0e 94 f3 58 	call	0xb1e6	; 0xb1e6 <SendWord>
			cs = cs ^ (tmpW & 0xff) ^ (tmpW >> 8) ;
    b330:	81 2f       	mov	r24, r17
    b332:	99 27       	eor	r25, r25
    b334:	10 70       	andi	r17, 0x00	; 0
    b336:	80 27       	eor	r24, r16
    b338:	91 27       	eor	r25, r17
    b33a:	c8 27       	eor	r28, r24
    b33c:	d9 27       	eor	r29, r25
	uartSendByte(mt);	
	uartSendByte(noservos); 		//0
	
	//query mode
	int cs=mt;
	for (BYTE id=0; id<noservos; id++)
    b33e:	f3 94       	inc	r15
    b340:	8f 2d       	mov	r24, r15
    b342:	90 e0       	ldi	r25, 0x00	; 0
    b344:	8c 15       	cp	r24, r12
    b346:	9d 05       	cpc	r25, r13
    b348:	6c f3       	brlt	.-38     	; 0xb324 <bin_respond_query+0x44>
			tmpW = wckPosAndLoadRead(id);
			SendWord(tmpW);	
			cs = cs ^ (tmpW & 0xff) ^ (tmpW >> 8) ;
	} 								//0 + nos*2
	
	tmpB=adc_psd();
    b34a:	0e 94 9c 2c 	call	0x5938	; 0x5938 <adc_psd>
    b34e:	c8 2e       	mov	r12, r24
	uartSendByte(tmpB); 			//1 + nos*2
    b350:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
	cs ^= tmpB;	

	tmpB=adc_mic();
    b354:	0e 94 fb 2c 	call	0x59f6	; 0x59f6 <adc_mic>
    b358:	08 2f       	mov	r16, r24
	uartSendByte(tmpB); 			//2  + nos*2
    b35a:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
			cs = cs ^ (tmpW & 0xff) ^ (tmpW >> 8) ;
	} 								//0 + nos*2
	
	tmpB=adc_psd();
	uartSendByte(tmpB); 			//1 + nos*2
	cs ^= tmpB;	
    b35e:	dd 24       	eor	r13, r13
    b360:	10 e0       	ldi	r17, 0x00	; 0
    b362:	c0 26       	eor	r12, r16
    b364:	d1 26       	eor	r13, r17

	tmpB=adc_mic();
	uartSendByte(tmpB); 			//2  + nos*2
	cs ^= tmpB;	
	
	tmpW=adc_volt();
    b366:	0e 94 d1 2b 	call	0x57a2	; 0x57a2 <adc_volt>
    b36a:	8c 01       	movw	r16, r24
	SendWord(tmpW);	    			//4  + nos*2
    b36c:	0e 94 f3 58 	call	0xb1e6	; 0xb1e6 <SendWord>
	cs = cs ^ (tmpW & 0xff) ^ (tmpW >> 8) ;
    b370:	81 2f       	mov	r24, r17
    b372:	99 27       	eor	r25, r25
    b374:	10 70       	andi	r17, 0x00	; 0
    b376:	80 27       	eor	r24, r16
    b378:	91 27       	eor	r25, r17
    b37a:	cc 26       	eor	r12, r28
    b37c:	dd 26       	eor	r13, r29
    b37e:	c8 26       	eor	r12, r24
    b380:	d9 26       	eor	r13, r25

	tilt_read(0);
    b382:	80 e0       	ldi	r24, 0x00	; 0
    b384:	0e 94 ad 2f 	call	0x5f5a	; 0x5f5a <tilt_read>
	
	SendWord((WORD)x_value);  		// 6  + nos*2
    b388:	80 91 a5 0d 	lds	r24, 0x0DA5
    b38c:	90 91 a6 0d 	lds	r25, 0x0DA6
    b390:	0e 94 f3 58 	call	0xb1e6	; 0xb1e6 <SendWord>
	cs = cs ^ (x_value & 0xff) ^ (x_value >> 8) ;
    b394:	80 90 a5 0d 	lds	r8, 0x0DA5
    b398:	90 90 a6 0d 	lds	r9, 0x0DA6
    b39c:	00 91 a5 0d 	lds	r16, 0x0DA5
    b3a0:	10 91 a6 0d 	lds	r17, 0x0DA6
	SendWord((WORD)y_value);  		// 8  + nos*2
    b3a4:	80 91 a7 0d 	lds	r24, 0x0DA7
    b3a8:	90 91 a8 0d 	lds	r25, 0x0DA8
    b3ac:	0e 94 f3 58 	call	0xb1e6	; 0xb1e6 <SendWord>
	cs = cs ^ (y_value & 0xff) ^ (y_value >> 8) ;
    b3b0:	e0 90 a7 0d 	lds	r14, 0x0DA7
    b3b4:	f0 90 a8 0d 	lds	r15, 0x0DA8
    b3b8:	a0 90 a7 0d 	lds	r10, 0x0DA7
    b3bc:	b0 90 a8 0d 	lds	r11, 0x0DA8
	SendWord((WORD)z_value);  		//10  + nos*2
    b3c0:	80 91 af 0d 	lds	r24, 0x0DAF
    b3c4:	90 91 b0 0d 	lds	r25, 0x0DB0
    b3c8:	0e 94 f3 58 	call	0xb1e6	; 0xb1e6 <SendWord>
	cs = cs ^ (z_value & 0xff) ^ (z_value >> 8) ;
    b3cc:	80 91 af 0d 	lds	r24, 0x0DAF
    b3d0:	90 91 b0 0d 	lds	r25, 0x0DB0
    b3d4:	20 91 af 0d 	lds	r18, 0x0DAF
    b3d8:	30 91 b0 0d 	lds	r19, 0x0DB0
	tilt_read(0);
	
	SendWord((WORD)x_value);  		// 6  + nos*2
	cs = cs ^ (x_value & 0xff) ^ (x_value >> 8) ;
	SendWord((WORD)y_value);  		// 8  + nos*2
	cs = cs ^ (y_value & 0xff) ^ (y_value >> 8) ;
    b3dc:	01 2f       	mov	r16, r17
    b3de:	11 0f       	add	r17, r17
    b3e0:	11 0b       	sbc	r17, r17
    b3e2:	4f ef       	ldi	r20, 0xFF	; 255
    b3e4:	84 22       	and	r8, r20
    b3e6:	99 24       	eor	r9, r9
    b3e8:	08 25       	eor	r16, r8
    b3ea:	19 25       	eor	r17, r9
    b3ec:	4f ef       	ldi	r20, 0xFF	; 255
    b3ee:	e4 22       	and	r14, r20
    b3f0:	ff 24       	eor	r15, r15
    b3f2:	0e 25       	eor	r16, r14
    b3f4:	1f 25       	eor	r17, r15
    b3f6:	ab 2c       	mov	r10, r11
    b3f8:	bb 0c       	add	r11, r11
    b3fa:	bb 08       	sbc	r11, r11
    b3fc:	0a 25       	eor	r16, r10
    b3fe:	1b 25       	eor	r17, r11
	SendWord((WORD)z_value);  		//10  + nos*2
	cs = cs ^ (z_value & 0xff) ^ (z_value >> 8) ;
    b400:	90 70       	andi	r25, 0x00	; 0
    b402:	08 27       	eor	r16, r24
    b404:	19 27       	eor	r17, r25
    b406:	23 2f       	mov	r18, r19
    b408:	33 0f       	add	r19, r19
    b40a:	33 0b       	sbc	r19, r19
    b40c:	02 27       	eor	r16, r18
    b40e:	13 27       	eor	r17, r19
	
	uartSendByte( (cs) & 0x7F); 	//11  + nos*2
    b410:	0c 25       	eor	r16, r12
    b412:	1d 25       	eor	r17, r13
    b414:	80 2f       	mov	r24, r16
    b416:	8f 77       	andi	r24, 0x7F	; 127
    b418:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>

	return 0;
}
    b41c:	80 e0       	ldi	r24, 0x00	; 0
    b41e:	90 e0       	ldi	r25, 0x00	; 0
    b420:	df 91       	pop	r29
    b422:	cf 91       	pop	r28
    b424:	1f 91       	pop	r17
    b426:	0f 91       	pop	r16
    b428:	ff 90       	pop	r15
    b42a:	ef 90       	pop	r14
    b42c:	df 90       	pop	r13
    b42e:	cf 90       	pop	r12
    b430:	bf 90       	pop	r11
    b432:	af 90       	pop	r10
    b434:	9f 90       	pop	r9
    b436:	8f 90       	pop	r8
    b438:	08 95       	ret

0000b43a <bin_respond_Aquery>:
A command response ( XYZ values)

***************************/

int bin_respond_Aquery(int mt)
{
    b43a:	8f 92       	push	r8
    b43c:	9f 92       	push	r9
    b43e:	af 92       	push	r10
    b440:	bf 92       	push	r11
    b442:	cf 92       	push	r12
    b444:	df 92       	push	r13
    b446:	ef 92       	push	r14
    b448:	ff 92       	push	r15
    b44a:	0f 93       	push	r16
    b44c:	1f 93       	push	r17
    b44e:	4c 01       	movw	r8, r24
	uartSendByte(MAGIC_RESPONSE);
    b450:	8a ee       	ldi	r24, 0xEA	; 234
    b452:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
	uartSendByte(mt);	
    b456:	88 2d       	mov	r24, r8
    b458:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
	int cs=mt;

	tilt_read(0);
    b45c:	80 e0       	ldi	r24, 0x00	; 0
    b45e:	0e 94 ad 2f 	call	0x5f5a	; 0x5f5a <tilt_read>
	
	SendWord((WORD)x_value);  		// 0 & 1
    b462:	80 91 a5 0d 	lds	r24, 0x0DA5
    b466:	90 91 a6 0d 	lds	r25, 0x0DA6
    b46a:	0e 94 f3 58 	call	0xb1e6	; 0xb1e6 <SendWord>
	cs = cs ^ (x_value & 0xff) ^ (x_value >> 8) ;
    b46e:	a0 90 a5 0d 	lds	r10, 0x0DA5
    b472:	b0 90 a6 0d 	lds	r11, 0x0DA6
    b476:	00 91 a5 0d 	lds	r16, 0x0DA5
    b47a:	10 91 a6 0d 	lds	r17, 0x0DA6
	SendWord((WORD)y_value);  		// 2 & 3
    b47e:	80 91 a7 0d 	lds	r24, 0x0DA7
    b482:	90 91 a8 0d 	lds	r25, 0x0DA8
    b486:	0e 94 f3 58 	call	0xb1e6	; 0xb1e6 <SendWord>
	cs = cs ^ (y_value & 0xff) ^ (y_value >> 8) ;
    b48a:	e0 90 a7 0d 	lds	r14, 0x0DA7
    b48e:	f0 90 a8 0d 	lds	r15, 0x0DA8
    b492:	c0 90 a7 0d 	lds	r12, 0x0DA7
    b496:	d0 90 a8 0d 	lds	r13, 0x0DA8
	SendWord((WORD)z_value);  		// 4 & 5
    b49a:	80 91 af 0d 	lds	r24, 0x0DAF
    b49e:	90 91 b0 0d 	lds	r25, 0x0DB0
    b4a2:	0e 94 f3 58 	call	0xb1e6	; 0xb1e6 <SendWord>
	cs = cs ^ (z_value & 0xff) ^ (z_value >> 8) ;
    b4a6:	80 91 af 0d 	lds	r24, 0x0DAF
    b4aa:	90 91 b0 0d 	lds	r25, 0x0DB0
    b4ae:	20 91 af 0d 	lds	r18, 0x0DAF
    b4b2:	30 91 b0 0d 	lds	r19, 0x0DB0
	tilt_read(0);
	
	SendWord((WORD)x_value);  		// 0 & 1
	cs = cs ^ (x_value & 0xff) ^ (x_value >> 8) ;
	SendWord((WORD)y_value);  		// 2 & 3
	cs = cs ^ (y_value & 0xff) ^ (y_value >> 8) ;
    b4b6:	01 2f       	mov	r16, r17
    b4b8:	11 0f       	add	r17, r17
    b4ba:	11 0b       	sbc	r17, r17
    b4bc:	4f ef       	ldi	r20, 0xFF	; 255
    b4be:	a4 22       	and	r10, r20
    b4c0:	bb 24       	eor	r11, r11
    b4c2:	0a 25       	eor	r16, r10
    b4c4:	1b 25       	eor	r17, r11
    b4c6:	4f ef       	ldi	r20, 0xFF	; 255
    b4c8:	e4 22       	and	r14, r20
    b4ca:	ff 24       	eor	r15, r15
    b4cc:	0e 25       	eor	r16, r14
    b4ce:	1f 25       	eor	r17, r15
    b4d0:	cd 2c       	mov	r12, r13
    b4d2:	dd 0c       	add	r13, r13
    b4d4:	dd 08       	sbc	r13, r13
    b4d6:	0c 25       	eor	r16, r12
    b4d8:	1d 25       	eor	r17, r13
	SendWord((WORD)z_value);  		// 4 & 5
	cs = cs ^ (z_value & 0xff) ^ (z_value >> 8) ;
    b4da:	90 70       	andi	r25, 0x00	; 0
    b4dc:	08 27       	eor	r16, r24
    b4de:	19 27       	eor	r17, r25
    b4e0:	23 2f       	mov	r18, r19
    b4e2:	33 0f       	add	r19, r19
    b4e4:	33 0b       	sbc	r19, r19
    b4e6:	02 27       	eor	r16, r18
    b4e8:	13 27       	eor	r17, r19
	
	uartSendByte( (cs) & 0x7F); 	//6
    b4ea:	08 25       	eor	r16, r8
    b4ec:	19 25       	eor	r17, r9
    b4ee:	80 2f       	mov	r24, r16
    b4f0:	8f 77       	andi	r24, 0x7F	; 127
    b4f2:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>

	return 0;
}
    b4f6:	80 e0       	ldi	r24, 0x00	; 0
    b4f8:	90 e0       	ldi	r25, 0x00	; 0
    b4fa:	1f 91       	pop	r17
    b4fc:	0f 91       	pop	r16
    b4fe:	ff 90       	pop	r15
    b500:	ef 90       	pop	r14
    b502:	df 90       	pop	r13
    b504:	cf 90       	pop	r12
    b506:	bf 90       	pop	r11
    b508:	af 90       	pop	r10
    b50a:	9f 90       	pop	r9
    b50c:	8f 90       	pop	r8
    b50e:	08 95       	ret

0000b510 <bin_respond_Quickquery>:

***************************/


int bin_respond_Quickquery(int mt)
{
    b510:	6f 92       	push	r6
    b512:	7f 92       	push	r7
    b514:	9f 92       	push	r9
    b516:	af 92       	push	r10
    b518:	bf 92       	push	r11
    b51a:	cf 92       	push	r12
    b51c:	df 92       	push	r13
    b51e:	ef 92       	push	r14
    b520:	ff 92       	push	r15
    b522:	0f 93       	push	r16
    b524:	1f 93       	push	r17
    b526:	3c 01       	movw	r6, r24
	BYTE	tmpB;
		
	uartSendByte(MAGIC_RESPONSE);
    b528:	8a ee       	ldi	r24, 0xEA	; 234
    b52a:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
	uartSendByte(mt);	
    b52e:	86 2d       	mov	r24, r6
    b530:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
	int cs=mt;
	
	tmpB=adc_psd();
    b534:	0e 94 9c 2c 	call	0x5938	; 0x5938 <adc_psd>
    b538:	98 2e       	mov	r9, r24
	uartSendByte(tmpB); 			//0
    b53a:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>

	cs ^= tmpB;	

	tilt_read(0);
    b53e:	80 e0       	ldi	r24, 0x00	; 0
    b540:	0e 94 ad 2f 	call	0x5f5a	; 0x5f5a <tilt_read>
	
	SendWord((WORD)x_value);  		// 1
    b544:	80 91 a5 0d 	lds	r24, 0x0DA5
    b548:	90 91 a6 0d 	lds	r25, 0x0DA6
    b54c:	0e 94 f3 58 	call	0xb1e6	; 0xb1e6 <SendWord>
	cs = cs ^ (x_value & 0xff) ^ (x_value >> 8) ;
    b550:	a0 90 a5 0d 	lds	r10, 0x0DA5
    b554:	b0 90 a6 0d 	lds	r11, 0x0DA6
    b558:	00 91 a5 0d 	lds	r16, 0x0DA5
    b55c:	10 91 a6 0d 	lds	r17, 0x0DA6
	SendWord((WORD)y_value);  		// 3
    b560:	80 91 a7 0d 	lds	r24, 0x0DA7
    b564:	90 91 a8 0d 	lds	r25, 0x0DA8
    b568:	0e 94 f3 58 	call	0xb1e6	; 0xb1e6 <SendWord>
	cs = cs ^ (y_value & 0xff) ^ (y_value >> 8) ;
    b56c:	e0 90 a7 0d 	lds	r14, 0x0DA7
    b570:	f0 90 a8 0d 	lds	r15, 0x0DA8
    b574:	c0 90 a7 0d 	lds	r12, 0x0DA7
    b578:	d0 90 a8 0d 	lds	r13, 0x0DA8
	SendWord((WORD)z_value);  		//5
    b57c:	80 91 af 0d 	lds	r24, 0x0DAF
    b580:	90 91 b0 0d 	lds	r25, 0x0DB0
    b584:	0e 94 f3 58 	call	0xb1e6	; 0xb1e6 <SendWord>
	cs = cs ^ (z_value & 0xff) ^ (z_value >> 8) ;
    b588:	80 91 af 0d 	lds	r24, 0x0DAF
    b58c:	90 91 b0 0d 	lds	r25, 0x0DB0
    b590:	20 91 af 0d 	lds	r18, 0x0DAF
    b594:	30 91 b0 0d 	lds	r19, 0x0DB0
	cs ^= tmpB;	

	tilt_read(0);
	
	SendWord((WORD)x_value);  		// 1
	cs = cs ^ (x_value & 0xff) ^ (x_value >> 8) ;
    b598:	01 2f       	mov	r16, r17
    b59a:	11 0f       	add	r17, r17
    b59c:	11 0b       	sbc	r17, r17
    b59e:	4f ef       	ldi	r20, 0xFF	; 255
    b5a0:	a4 22       	and	r10, r20
    b5a2:	bb 24       	eor	r11, r11
    b5a4:	0a 25       	eor	r16, r10
    b5a6:	1b 25       	eor	r17, r11
    b5a8:	4f ef       	ldi	r20, 0xFF	; 255
    b5aa:	e4 22       	and	r14, r20
    b5ac:	ff 24       	eor	r15, r15
    b5ae:	0e 25       	eor	r16, r14
    b5b0:	1f 25       	eor	r17, r15
	SendWord((WORD)y_value);  		// 3
	cs = cs ^ (y_value & 0xff) ^ (y_value >> 8) ;
    b5b2:	cd 2c       	mov	r12, r13
    b5b4:	dd 0c       	add	r13, r13
    b5b6:	dd 08       	sbc	r13, r13
    b5b8:	0c 25       	eor	r16, r12
    b5ba:	1d 25       	eor	r17, r13
    b5bc:	90 70       	andi	r25, 0x00	; 0
    b5be:	08 27       	eor	r16, r24
    b5c0:	19 27       	eor	r17, r25
	SendWord((WORD)z_value);  		//5
	cs = cs ^ (z_value & 0xff) ^ (z_value >> 8) ;
    b5c2:	23 2f       	mov	r18, r19
    b5c4:	33 0f       	add	r19, r19
    b5c6:	33 0b       	sbc	r19, r19
    b5c8:	02 27       	eor	r16, r18
    b5ca:	13 27       	eor	r17, r19
    b5cc:	06 25       	eor	r16, r6
    b5ce:	17 25       	eor	r17, r7
	
	uartSendByte( (cs) & 0x7F); 	//7
    b5d0:	90 26       	eor	r9, r16
    b5d2:	89 2d       	mov	r24, r9
    b5d4:	8f 77       	andi	r24, 0x7F	; 127
    b5d6:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>

	return 0;
}
    b5da:	80 e0       	ldi	r24, 0x00	; 0
    b5dc:	90 e0       	ldi	r25, 0x00	; 0
    b5de:	1f 91       	pop	r17
    b5e0:	0f 91       	pop	r16
    b5e2:	ff 90       	pop	r15
    b5e4:	ef 90       	pop	r14
    b5e6:	df 90       	pop	r13
    b5e8:	cf 90       	pop	r12
    b5ea:	bf 90       	pop	r11
    b5ec:	af 90       	pop	r10
    b5ee:	9f 90       	pop	r9
    b5f0:	7f 90       	pop	r7
    b5f2:	6f 90       	pop	r6
    b5f4:	08 95       	ret

0000b5f6 <bin_read_H>:
H command response

***************************/

int bin_read_H()
{
    b5f6:	9f 92       	push	r9
    b5f8:	af 92       	push	r10
    b5fa:	bf 92       	push	r11
    b5fc:	cf 92       	push	r12
    b5fe:	df 92       	push	r13
    b600:	ef 92       	push	r14
    b602:	ff 92       	push	r15
    b604:	0f 93       	push	r16
    b606:	1f 93       	push	r17
    b608:	df 93       	push	r29
    b60a:	cf 93       	push	r28
    b60c:	cd b7       	in	r28, 0x3d	; 61
    b60e:	de b7       	in	r29, 0x3e	; 62
    b610:	2a 97       	sbiw	r28, 0x0a	; 10
    b612:	0f b6       	in	r0, 0x3f	; 63
    b614:	f8 94       	cli
    b616:	de bf       	out	0x3e, r29	; 62
    b618:	0f be       	out	0x3f, r0	; 63
    b61a:	cd bf       	out	0x3d, r28	; 61
    char sbuf[10];
	uint8_t b0=0, b1=0;
	int cs = 0;
	int i;

	while ((b0=uartGetByte())<0);   
    b61c:	0e 94 9c 22 	call	0x4538	; 0x4538 <uartGetByte>
	cs ^= b0;
	
	if (b0>=10) b0=0;
    b620:	8a 30       	cpi	r24, 0x0A	; 10
    b622:	10 f0       	brcs	.+4      	; 0xb628 <bin_read_H+0x32>
    b624:	bb 24       	eor	r11, r11
    b626:	01 c0       	rjmp	.+2      	; 0xb62a <bin_read_H+0x34>
    b628:	b8 2e       	mov	r11, r24
	uint8_t b0=0, b1=0;
	int cs = 0;
	int i;

	while ((b0=uartGetByte())<0);   
	cs ^= b0;
    b62a:	e8 2e       	mov	r14, r24
    b62c:	ff 24       	eor	r15, r15
    b62e:	8e 01       	movw	r16, r28
    b630:	0f 5f       	subi	r16, 0xFF	; 255
    b632:	1f 4f       	sbci	r17, 0xFF	; 255
    b634:	20 e0       	ldi	r18, 0x00	; 0
	
	if (b0>=10) b0=0;
	
	for (i=0; i<b0; i++)
    b636:	c8 01       	movw	r24, r16
    b638:	a0 2e       	mov	r10, r16
    b63a:	99 2e       	mov	r9, r25
    b63c:	68 01       	movw	r12, r16
    b63e:	cb 0c       	add	r12, r11
    b640:	d1 1c       	adc	r13, r1
    b642:	09 c0       	rjmp	.+18     	; 0xb656 <bin_read_H+0x60>
	{
		while ((b1=uartGetByte())<0); 	
    b644:	0e 94 9c 22 	call	0x4538	; 0x4538 <uartGetByte>
    b648:	28 2f       	mov	r18, r24
		cs ^= b1;
    b64a:	90 e0       	ldi	r25, 0x00	; 0
    b64c:	e8 26       	eor	r14, r24
    b64e:	f9 26       	eor	r15, r25
		sbuf[i] = b1;
    b650:	f8 01       	movw	r30, r16
    b652:	21 93       	st	Z+, r18
    b654:	8f 01       	movw	r16, r30
	while ((b0=uartGetByte())<0);   
	cs ^= b0;
	
	if (b0>=10) b0=0;
	
	for (i=0; i<b0; i++)
    b656:	0c 15       	cp	r16, r12
    b658:	1d 05       	cpc	r17, r13
    b65a:	a1 f7       	brne	.-24     	; 0xb644 <bin_read_H+0x4e>
		while ((b1=uartGetByte())<0); 	
		cs ^= b1;
		sbuf[i] = b1;
	}
	
	if (b1 == (cs&0x7f)) 
    b65c:	c2 2e       	mov	r12, r18
    b65e:	dd 24       	eor	r13, r13
    b660:	87 01       	movw	r16, r14
    b662:	0f 77       	andi	r16, 0x7F	; 127
    b664:	10 70       	andi	r17, 0x00	; 0
    b666:	c0 16       	cp	r12, r16
    b668:	d1 06       	cpc	r13, r17
    b66a:	31 f4       	brne	.+12     	; 0xb678 <bin_read_H+0x82>
		send_bus_str(sbuf, b0);
    b66c:	6b 2d       	mov	r22, r11
    b66e:	70 e0       	ldi	r23, 0x00	; 0
    b670:	8a 2d       	mov	r24, r10
    b672:	99 2d       	mov	r25, r9
    b674:	0e 94 3f 4e 	call	0x9c7e	; 0x9c7e <send_bus_str>
    b678:	20 e0       	ldi	r18, 0x00	; 0
    b67a:	30 e0       	ldi	r19, 0x00	; 0
    b67c:	c0 16       	cp	r12, r16
    b67e:	d1 06       	cpc	r13, r17
    b680:	11 f0       	breq	.+4      	; 0xb686 <bin_read_H+0x90>
    b682:	21 e0       	ldi	r18, 0x01	; 1
    b684:	30 e0       	ldi	r19, 0x00	; 0
	
	return (b1 != (cs&0x7f));
}
    b686:	c9 01       	movw	r24, r18
    b688:	2a 96       	adiw	r28, 0x0a	; 10
    b68a:	0f b6       	in	r0, 0x3f	; 63
    b68c:	f8 94       	cli
    b68e:	de bf       	out	0x3e, r29	; 62
    b690:	0f be       	out	0x3f, r0	; 63
    b692:	cd bf       	out	0x3d, r28	; 61
    b694:	cf 91       	pop	r28
    b696:	df 91       	pop	r29
    b698:	1f 91       	pop	r17
    b69a:	0f 91       	pop	r16
    b69c:	ff 90       	pop	r15
    b69e:	ef 90       	pop	r14
    b6a0:	df 90       	pop	r13
    b6a2:	cf 90       	pop	r12
    b6a4:	bf 90       	pop	r11
    b6a6:	af 90       	pop	r10
    b6a8:	9f 90       	pop	r9
    b6aa:	08 95       	ret

0000b6ac <bin_read_request>:
Core packet recieve request code

***************************/

int bin_read_request()
{
    b6ac:	cf 93       	push	r28
    b6ae:	df 93       	push	r29
	int b0;
	int mt;
	int cs;
	while ((b0=uartGetByte())<0);
    b6b0:	0e 94 9c 22 	call	0x4538	; 0x4538 <uartGetByte>
    b6b4:	97 fd       	sbrc	r25, 7
    b6b6:	fc cf       	rjmp	.-8      	; 0xb6b0 <bin_read_request+0x4>
	if (b0==MAGIC_REQUEST)
    b6b8:	8d 3c       	cpi	r24, 0xCD	; 205
    b6ba:	91 05       	cpc	r25, r1
    b6bc:	09 f0       	breq	.+2      	; 0xb6c0 <bin_read_request+0x14>
    b6be:	57 c0       	rjmp	.+174    	; 0xb76e <bin_read_request+0xc2>
	{
		while ((mt=uartGetByte())<0);
    b6c0:	0e 94 9c 22 	call	0x4538	; 0x4538 <uartGetByte>
    b6c4:	ec 01       	movw	r28, r24
    b6c6:	97 fd       	sbrc	r25, 7
    b6c8:	fb cf       	rjmp	.-10     	; 0xb6c0 <bin_read_request+0x14>
		
		if (mt=='q' || mt=='p' || mt=='v' || mt=='C' || mt=='S' || mt=='Q' || mt=='D'  || mt=='I'  || mt=='A') 
    b6ca:	80 57       	subi	r24, 0x70	; 112
    b6cc:	90 40       	sbci	r25, 0x00	; 0
    b6ce:	02 97       	sbiw	r24, 0x02	; 2
    b6d0:	a8 f0       	brcs	.+42     	; 0xb6fc <bin_read_request+0x50>
    b6d2:	c6 37       	cpi	r28, 0x76	; 118
    b6d4:	d1 05       	cpc	r29, r1
    b6d6:	91 f0       	breq	.+36     	; 0xb6fc <bin_read_request+0x50>
    b6d8:	c3 34       	cpi	r28, 0x43	; 67
    b6da:	d1 05       	cpc	r29, r1
    b6dc:	79 f0       	breq	.+30     	; 0xb6fc <bin_read_request+0x50>
    b6de:	c3 35       	cpi	r28, 0x53	; 83
    b6e0:	d1 05       	cpc	r29, r1
    b6e2:	61 f0       	breq	.+24     	; 0xb6fc <bin_read_request+0x50>
    b6e4:	c1 35       	cpi	r28, 0x51	; 81
    b6e6:	d1 05       	cpc	r29, r1
    b6e8:	49 f0       	breq	.+18     	; 0xb6fc <bin_read_request+0x50>
    b6ea:	c4 34       	cpi	r28, 0x44	; 68
    b6ec:	d1 05       	cpc	r29, r1
    b6ee:	31 f0       	breq	.+12     	; 0xb6fc <bin_read_request+0x50>
    b6f0:	c9 34       	cpi	r28, 0x49	; 73
    b6f2:	d1 05       	cpc	r29, r1
    b6f4:	19 f0       	breq	.+6      	; 0xb6fc <bin_read_request+0x50>
    b6f6:	c1 34       	cpi	r28, 0x41	; 65
    b6f8:	d1 05       	cpc	r29, r1
    b6fa:	79 f4       	brne	.+30     	; 0xb71a <bin_read_request+0x6e>
		{			
			while ((cs=uartGetByte())<0);
    b6fc:	0e 94 9c 22 	call	0x4538	; 0x4538 <uartGetByte>
    b700:	9c 01       	movw	r18, r24
    b702:	97 fd       	sbrc	r25, 7
    b704:	fb cf       	rjmp	.-10     	; 0xb6fc <bin_read_request+0x50>

			if (cs != ((b0 ^ mt) &0x7f))
    b706:	8d ec       	ldi	r24, 0xCD	; 205
    b708:	90 e0       	ldi	r25, 0x00	; 0
    b70a:	8c 27       	eor	r24, r28
    b70c:	9d 27       	eor	r25, r29
    b70e:	8f 77       	andi	r24, 0x7F	; 127
    b710:	90 70       	andi	r25, 0x00	; 0
    b712:	28 17       	cp	r18, r24
    b714:	39 07       	cpc	r19, r25
    b716:	59 f5       	brne	.+86     	; 0xb76e <bin_read_request+0xc2>
    b718:	2c c0       	rjmp	.+88     	; 0xb772 <bin_read_request+0xc6>
				return -1;
			else
				return mt;
		}
		
		if (mt=='x' || mt == 'X')
    b71a:	c8 37       	cpi	r28, 0x78	; 120
    b71c:	d1 05       	cpc	r29, r1
    b71e:	19 f0       	breq	.+6      	; 0xb726 <bin_read_request+0x7a>
    b720:	c8 35       	cpi	r28, 0x58	; 88
    b722:	d1 05       	cpc	r29, r1
    b724:	19 f4       	brne	.+6      	; 0xb72c <bin_read_request+0x80>
		{	
			if (bin_read_x())
    b726:	0e 94 80 57 	call	0xaf00	; 0xaf00 <bin_read_x>
    b72a:	1f c0       	rjmp	.+62     	; 0xb76a <bin_read_request+0xbe>
				return -1;
			else
				return mt;
		}		
		
		if (mt=='m')
    b72c:	cd 36       	cpi	r28, 0x6D	; 109
    b72e:	d1 05       	cpc	r29, r1
    b730:	19 f4       	brne	.+6      	; 0xb738 <bin_read_request+0x8c>
		{
			if (bin_read_m())
    b732:	0e 94 03 58 	call	0xb006	; 0xb006 <bin_read_m>
    b736:	19 c0       	rjmp	.+50     	; 0xb76a <bin_read_request+0xbe>
				return -1;
			else
				return mt;
		}	
				
		if (mt=='H')
    b738:	c8 34       	cpi	r28, 0x48	; 72
    b73a:	d1 05       	cpc	r29, r1
    b73c:	19 f4       	brne	.+6      	; 0xb744 <bin_read_request+0x98>
		{
			if (bin_read_H())
    b73e:	0e 94 fb 5a 	call	0xb5f6	; 0xb5f6 <bin_read_H>
    b742:	13 c0       	rjmp	.+38     	; 0xb76a <bin_read_request+0xbe>
			else
				return mt;
		}	
		
		
		if (mt=='P' || mt=='y' || mt=='Y')
    b744:	c0 35       	cpi	r28, 0x50	; 80
    b746:	d1 05       	cpc	r29, r1
    b748:	31 f0       	breq	.+12     	; 0xb756 <bin_read_request+0xaa>
    b74a:	c9 37       	cpi	r28, 0x79	; 121
    b74c:	d1 05       	cpc	r29, r1
    b74e:	19 f0       	breq	.+6      	; 0xb756 <bin_read_request+0xaa>
    b750:	c9 35       	cpi	r28, 0x59	; 89
    b752:	d1 05       	cpc	r29, r1
    b754:	29 f4       	brne	.+10     	; 0xb760 <bin_read_request+0xb4>
		{
			return  bin_read_p(mt);
    b756:	ce 01       	movw	r24, r28
    b758:	0e 94 47 58 	call	0xb08e	; 0xb08e <bin_read_p>
    b75c:	ec 01       	movw	r28, r24
    b75e:	09 c0       	rjmp	.+18     	; 0xb772 <bin_read_request+0xc6>
		}	

		if (mt=='l')
    b760:	cc 36       	cpi	r28, 0x6C	; 108
    b762:	d1 05       	cpc	r29, r1
    b764:	21 f4       	brne	.+8      	; 0xb76e <bin_read_request+0xc2>
		{
			if (bin_downloadbasic())
    b766:	0e 94 c1 57 	call	0xaf82	; 0xaf82 <bin_downloadbasic>
    b76a:	89 2b       	or	r24, r25
    b76c:	11 f0       	breq	.+4      	; 0xb772 <bin_read_request+0xc6>
    b76e:	cf ef       	ldi	r28, 0xFF	; 255
    b770:	df ef       	ldi	r29, 0xFF	; 255
				return mt;
		}		
	}
	//
	return -1;
}
    b772:	ce 01       	movw	r24, r28
    b774:	df 91       	pop	r29
    b776:	cf 91       	pop	r28
    b778:	08 95       	ret

0000b77a <experimental_binloop>:
You must send a 'p' packet to exit

***************************/

void experimental_binloop()
{
    b77a:	cf 93       	push	r28
    b77c:	df 93       	push	r29
    b77e:	c6 e6       	ldi	r28, 0x66	; 102
    b780:	de e0       	ldi	r29, 0x0E	; 14
	int r;

	while (1) {
		
		while ((r=bin_read_request())<0) ;
    b782:	0e 94 56 5b 	call	0xb6ac	; 0xb6ac <bin_read_request>
    b786:	97 fd       	sbrc	r25, 7
    b788:	fc cf       	rjmp	.-8      	; 0xb782 <experimental_binloop+0x8>
		
		switch (r)
    b78a:	88 35       	cpi	r24, 0x58	; 88
    b78c:	91 05       	cpc	r25, r1
    b78e:	09 f4       	brne	.+2      	; 0xb792 <experimental_binloop+0x18>
    b790:	60 c0       	rjmp	.+192    	; 0xb852 <experimental_binloop+0xd8>
    b792:	89 35       	cpi	r24, 0x59	; 89
    b794:	91 05       	cpc	r25, r1
    b796:	e4 f4       	brge	.+56     	; 0xb7d0 <experimental_binloop+0x56>
    b798:	88 34       	cpi	r24, 0x48	; 72
    b79a:	91 05       	cpc	r25, r1
    b79c:	09 f4       	brne	.+2      	; 0xb7a0 <experimental_binloop+0x26>
    b79e:	61 c0       	rjmp	.+194    	; 0xb862 <experimental_binloop+0xe8>
    b7a0:	89 34       	cpi	r24, 0x49	; 73
    b7a2:	91 05       	cpc	r25, r1
    b7a4:	4c f4       	brge	.+18     	; 0xb7b8 <experimental_binloop+0x3e>
    b7a6:	81 34       	cpi	r24, 0x41	; 65
    b7a8:	91 05       	cpc	r25, r1
    b7aa:	09 f4       	brne	.+2      	; 0xb7ae <experimental_binloop+0x34>
    b7ac:	43 c0       	rjmp	.+134    	; 0xb834 <experimental_binloop+0xba>
    b7ae:	84 34       	cpi	r24, 0x44	; 68
    b7b0:	91 05       	cpc	r25, r1
    b7b2:	09 f0       	breq	.+2      	; 0xb7b6 <experimental_binloop+0x3c>
    b7b4:	5b c0       	rjmp	.+182    	; 0xb86c <experimental_binloop+0xf2>
    b7b6:	39 c0       	rjmp	.+114    	; 0xb82a <experimental_binloop+0xb0>
    b7b8:	80 35       	cpi	r24, 0x50	; 80
    b7ba:	91 05       	cpc	r25, r1
    b7bc:	09 f4       	brne	.+2      	; 0xb7c0 <experimental_binloop+0x46>
    b7be:	4c c0       	rjmp	.+152    	; 0xb858 <experimental_binloop+0xde>
    b7c0:	81 35       	cpi	r24, 0x51	; 81
    b7c2:	91 05       	cpc	r25, r1
    b7c4:	69 f1       	breq	.+90     	; 0xb820 <experimental_binloop+0xa6>
    b7c6:	89 34       	cpi	r24, 0x49	; 73
    b7c8:	91 05       	cpc	r25, r1
    b7ca:	09 f0       	breq	.+2      	; 0xb7ce <experimental_binloop+0x54>
    b7cc:	4f c0       	rjmp	.+158    	; 0xb86c <experimental_binloop+0xf2>
    b7ce:	37 c0       	rjmp	.+110    	; 0xb83e <experimental_binloop+0xc4>
    b7d0:	80 37       	cpi	r24, 0x70	; 112
    b7d2:	91 05       	cpc	r25, r1
    b7d4:	09 f4       	brne	.+2      	; 0xb7d8 <experimental_binloop+0x5e>
    b7d6:	52 c0       	rjmp	.+164    	; 0xb87c <experimental_binloop+0x102>
    b7d8:	81 37       	cpi	r24, 0x71	; 113
    b7da:	91 05       	cpc	r25, r1
    b7dc:	44 f4       	brge	.+16     	; 0xb7ee <experimental_binloop+0x74>
    b7de:	8c 36       	cpi	r24, 0x6C	; 108
    b7e0:	91 05       	cpc	r25, r1
    b7e2:	79 f0       	breq	.+30     	; 0xb802 <experimental_binloop+0x88>
    b7e4:	8d 36       	cpi	r24, 0x6D	; 109
    b7e6:	91 05       	cpc	r25, r1
    b7e8:	09 f0       	breq	.+2      	; 0xb7ec <experimental_binloop+0x72>
    b7ea:	40 c0       	rjmp	.+128    	; 0xb86c <experimental_binloop+0xf2>
    b7ec:	2d c0       	rjmp	.+90     	; 0xb848 <experimental_binloop+0xce>
    b7ee:	86 37       	cpi	r24, 0x76	; 118
    b7f0:	91 05       	cpc	r25, r1
    b7f2:	61 f0       	breq	.+24     	; 0xb80c <experimental_binloop+0x92>
    b7f4:	88 37       	cpi	r24, 0x78	; 120
    b7f6:	91 05       	cpc	r25, r1
    b7f8:	61 f1       	breq	.+88     	; 0xb852 <experimental_binloop+0xd8>
    b7fa:	81 37       	cpi	r24, 0x71	; 113
    b7fc:	91 05       	cpc	r25, r1
    b7fe:	b1 f5       	brne	.+108    	; 0xb86c <experimental_binloop+0xf2>
    b800:	0a c0       	rjmp	.+20     	; 0xb816 <experimental_binloop+0x9c>
		{
		case 'l':
			bin_respond_basicdownload(r); break;
    b802:	8c e6       	ldi	r24, 0x6C	; 108
    b804:	90 e0       	ldi	r25, 0x00	; 0
    b806:	0e 94 d7 58 	call	0xb1ae	; 0xb1ae <bin_respond_basicdownload>
    b80a:	34 c0       	rjmp	.+104    	; 0xb874 <experimental_binloop+0xfa>
		case 'v':
			bin_respond_ver(r); break;
    b80c:	86 e7       	ldi	r24, 0x76	; 118
    b80e:	90 e0       	ldi	r25, 0x00	; 0
    b810:	0e 94 e5 58 	call	0xb1ca	; 0xb1ca <bin_respond_ver>
    b814:	2f c0       	rjmp	.+94     	; 0xb874 <experimental_binloop+0xfa>
		case 'q':
			bin_respond_query(r); break;
    b816:	81 e7       	ldi	r24, 0x71	; 113
    b818:	90 e0       	ldi	r25, 0x00	; 0
    b81a:	0e 94 70 59 	call	0xb2e0	; 0xb2e0 <bin_respond_query>
    b81e:	2a c0       	rjmp	.+84     	; 0xb874 <experimental_binloop+0xfa>
		case 'Q':
			bin_respond_Quickquery(r); break;
    b820:	81 e5       	ldi	r24, 0x51	; 81
    b822:	90 e0       	ldi	r25, 0x00	; 0
    b824:	0e 94 88 5a 	call	0xb510	; 0xb510 <bin_respond_Quickquery>
    b828:	25 c0       	rjmp	.+74     	; 0xb874 <experimental_binloop+0xfa>
		case 'D':
			bin_respond_Dquery(r); break;
    b82a:	84 e4       	ldi	r24, 0x44	; 68
    b82c:	90 e0       	ldi	r25, 0x00	; 0
    b82e:	0e 94 58 59 	call	0xb2b0	; 0xb2b0 <bin_respond_Dquery>
    b832:	20 c0       	rjmp	.+64     	; 0xb874 <experimental_binloop+0xfa>
		case 'A':
			bin_respond_Aquery(r); break;
    b834:	81 e4       	ldi	r24, 0x41	; 65
    b836:	90 e0       	ldi	r25, 0x00	; 0
    b838:	0e 94 1d 5a 	call	0xb43a	; 0xb43a <bin_respond_Aquery>
    b83c:	1b c0       	rjmp	.+54     	; 0xb874 <experimental_binloop+0xfa>
		case 'I':
			bin_respond_Iquery(r); break;
    b83e:	89 e4       	ldi	r24, 0x49	; 73
    b840:	90 e0       	ldi	r25, 0x00	; 0
    b842:	0e 94 73 58 	call	0xb0e6	; 0xb0e6 <bin_respond_Iquery>
    b846:	16 c0       	rjmp	.+44     	; 0xb874 <experimental_binloop+0xfa>
		case 'm':
			bin_respond_m(r); break;
    b848:	8d e6       	ldi	r24, 0x6D	; 109
    b84a:	90 e0       	ldi	r25, 0x00	; 0
    b84c:	0e 94 b2 58 	call	0xb164	; 0xb164 <bin_respond_m>
    b850:	11 c0       	rjmp	.+34     	; 0xb874 <experimental_binloop+0xfa>
		case 'x': case 'X' :
			bin_respond_x(r); break;		
    b852:	0e 94 fc 58 	call	0xb1f8	; 0xb1f8 <bin_respond_x>
    b856:	0e c0       	rjmp	.+28     	; 0xb874 <experimental_binloop+0xfa>
		case 'P':
			bin_respond_p(r); break;		
    b858:	80 e5       	ldi	r24, 0x50	; 80
    b85a:	90 e0       	ldi	r25, 0x00	; 0
    b85c:	0e 94 d0 58 	call	0xb1a0	; 0xb1a0 <bin_respond_p>
    b860:	09 c0       	rjmp	.+18     	; 0xb874 <experimental_binloop+0xfa>
		case 'H':
			bin_respond_H(r); break;	
    b862:	88 e4       	ldi	r24, 0x48	; 72
    b864:	90 e0       	ldi	r25, 0x00	; 0
    b866:	0e 94 de 58 	call	0xb1bc	; 0xb1bc <bin_respond_H>
    b86a:	04 c0       	rjmp	.+8      	; 0xb874 <experimental_binloop+0xfa>
		case 'p':
			// exit back to idle mode
			return;
		default:
			bin_respond_error(PROTOCOL_ERROR);
    b86c:	81 e0       	ldi	r24, 0x01	; 1
    b86e:	90 e0       	ldi	r25, 0x00	; 0
    b870:	0e 94 ec 58 	call	0xb1d8	; 0xb1d8 <bin_respond_error>
    b874:	ce 01       	movw	r24, r28
    b876:	01 97       	sbiw	r24, 0x01	; 1
    b878:	f1 f7       	brne	.-4      	; 0xb876 <experimental_binloop+0xfc>
    b87a:	83 cf       	rjmp	.-250    	; 0xb782 <experimental_binloop+0x8>
		}
			
		_delay_ms(1);
	}
}
    b87c:	df 91       	pop	r29
    b87e:	cf 91       	pop	r28
    b880:	08 95       	ret

0000b882 <ProcButton>:

#define P_BMC504_RESET(A)		if(A) SET_BIT6(PORTB);else CLR_BIT6(PORTB)

void DetectPower	(void);
void ChargeNiMH		(void);
void ProcButton		() {}
    b882:	08 95       	ret

0000b884 <delay_ms>:
void	sciTx1Data(BYTE x)
{
	uartSendByte(x);
}

void 	delay_ms(int x) {_delay_ms(x);}
    b884:	af 92       	push	r10
    b886:	bf 92       	push	r11
    b888:	cf 92       	push	r12
    b88a:	df 92       	push	r13
    b88c:	ef 92       	push	r14
    b88e:	ff 92       	push	r15
    b890:	0f 93       	push	r16
    b892:	1f 93       	push	r17
    b894:	aa 27       	eor	r26, r26
    b896:	97 fd       	sbrc	r25, 7
    b898:	a0 95       	com	r26
    b89a:	ba 2f       	mov	r27, r26
    b89c:	bc 01       	movw	r22, r24
    b89e:	cd 01       	movw	r24, r26
    b8a0:	0e 94 f8 69 	call	0xd3f0	; 0xd3f0 <__floatsisf>
    b8a4:	5b 01       	movw	r10, r22
    b8a6:	6c 01       	movw	r12, r24
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    b8a8:	20 e0       	ldi	r18, 0x00	; 0
    b8aa:	34 e6       	ldi	r19, 0x64	; 100
    b8ac:	46 e6       	ldi	r20, 0x66	; 102
    b8ae:	55 e4       	ldi	r21, 0x45	; 69
    b8b0:	0e 94 c4 67 	call	0xcf88	; 0xcf88 <__mulsf3>
    b8b4:	7b 01       	movw	r14, r22
    b8b6:	8c 01       	movw	r16, r24
	if (__tmp < 1.0)
    b8b8:	20 e0       	ldi	r18, 0x00	; 0
    b8ba:	30 e0       	ldi	r19, 0x00	; 0
    b8bc:	40 e8       	ldi	r20, 0x80	; 128
    b8be:	5f e3       	ldi	r21, 0x3F	; 63
    b8c0:	0e 94 c8 69 	call	0xd390	; 0xd390 <__ltsf2>
    b8c4:	88 23       	and	r24, r24
    b8c6:	1c f4       	brge	.+6      	; 0xb8ce <delay_ms+0x4a>
    b8c8:	61 e0       	ldi	r22, 0x01	; 1
    b8ca:	70 e0       	ldi	r23, 0x00	; 0
    b8cc:	24 c0       	rjmp	.+72     	; 0xb916 <delay_ms+0x92>
		__ticks = 1;
	else if (__tmp > 65535)
    b8ce:	20 e0       	ldi	r18, 0x00	; 0
    b8d0:	3f ef       	ldi	r19, 0xFF	; 255
    b8d2:	4f e7       	ldi	r20, 0x7F	; 127
    b8d4:	57 e4       	ldi	r21, 0x47	; 71
    b8d6:	c8 01       	movw	r24, r16
    b8d8:	b7 01       	movw	r22, r14
    b8da:	0e 94 68 69 	call	0xd2d0	; 0xd2d0 <__gtsf2>
    b8de:	18 16       	cp	r1, r24
    b8e0:	b4 f4       	brge	.+44     	; 0xb90e <delay_ms+0x8a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    b8e2:	20 e0       	ldi	r18, 0x00	; 0
    b8e4:	30 e0       	ldi	r19, 0x00	; 0
    b8e6:	40 e2       	ldi	r20, 0x20	; 32
    b8e8:	51 e4       	ldi	r21, 0x41	; 65
    b8ea:	c6 01       	movw	r24, r12
    b8ec:	b5 01       	movw	r22, r10
    b8ee:	0e 94 c4 67 	call	0xcf88	; 0xcf88 <__mulsf3>
    b8f2:	0e 94 ee 65 	call	0xcbdc	; 0xcbdc <__fixunssfsi>
    b8f6:	80 e7       	ldi	r24, 0x70	; 112
    b8f8:	91 e0       	ldi	r25, 0x01	; 1
    b8fa:	05 c0       	rjmp	.+10     	; 0xb906 <delay_ms+0x82>
    b8fc:	fc 01       	movw	r30, r24
    b8fe:	31 97       	sbiw	r30, 0x01	; 1
    b900:	f1 f7       	brne	.-4      	; 0xb8fe <delay_ms+0x7a>
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    b902:	61 50       	subi	r22, 0x01	; 1
    b904:	70 40       	sbci	r23, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    b906:	61 15       	cp	r22, r1
    b908:	71 05       	cpc	r23, r1
    b90a:	c1 f7       	brne	.-16     	; 0xb8fc <delay_ms+0x78>
    b90c:	07 c0       	rjmp	.+14     	; 0xb91c <delay_ms+0x98>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    b90e:	c8 01       	movw	r24, r16
    b910:	b7 01       	movw	r22, r14
    b912:	0e 94 ee 65 	call	0xcbdc	; 0xcbdc <__fixunssfsi>
    b916:	cb 01       	movw	r24, r22
    b918:	01 97       	sbiw	r24, 0x01	; 1
    b91a:	f1 f7       	brne	.-4      	; 0xb918 <delay_ms+0x94>
    b91c:	1f 91       	pop	r17
    b91e:	0f 91       	pop	r16
    b920:	ff 90       	pop	r15
    b922:	ef 90       	pop	r14
    b924:	df 90       	pop	r13
    b926:	cf 90       	pop	r12
    b928:	bf 90       	pop	r11
    b92a:	af 90       	pop	r10
    b92c:	08 95       	ret

0000b92e <U1I_case100>:
	sciTx1Data(0);
	sciTx1Data(CSize);
}

void U1I_case100(void)
{
    b92e:	80 91 bb 0e 	lds	r24, 0x0EBB
    b932:	80 93 ae 0b 	sts	0x0BAE, r24
	Motion.PF = gRxData;
	gFieldIdx = 0;
    b936:	10 92 45 0e 	sts	0x0E45, r1
    b93a:	10 92 44 0e 	sts	0x0E44, r1
	gRx1Step++;
    b93e:	80 91 55 0e 	lds	r24, 0x0E55
    b942:	90 91 56 0e 	lds	r25, 0x0E56
    b946:	01 96       	adiw	r24, 0x01	; 1
    b948:	90 93 56 0e 	sts	0x0E56, r25
    b94c:	80 93 55 0e 	sts	0x0E55, r24
}
    b950:	08 95       	ret

0000b952 <U1I_case301>:


void U1I_case301(BYTE LC)
{
    b952:	28 2f       	mov	r18, r24
	gFieldIdx++;
    b954:	80 91 44 0e 	lds	r24, 0x0E44
    b958:	90 91 45 0e 	lds	r25, 0x0E45
    b95c:	01 96       	adiw	r24, 0x01	; 1
    b95e:	90 93 45 0e 	sts	0x0E45, r25
    b962:	80 93 44 0e 	sts	0x0E44, r24
	if(gFieldIdx == 4){
    b966:	04 97       	sbiw	r24, 0x04	; 4
    b968:	d9 f4       	brne	.+54     	; 0xb9a0 <U1I_case301+0x4e>
		gFieldIdx = 0;
    b96a:	10 92 45 0e 	sts	0x0E45, r1
    b96e:	10 92 44 0e 	sts	0x0E44, r1
		gFileCheckSum = 0;
    b972:	10 92 b6 0e 	sts	0x0EB6, r1
		if(gRxData == LC)	
    b976:	80 91 bb 0e 	lds	r24, 0x0EBB
    b97a:	82 17       	cp	r24, r18
    b97c:	51 f4       	brne	.+20     	; 0xb992 <U1I_case301+0x40>
			gRx1Step++;
    b97e:	80 91 55 0e 	lds	r24, 0x0E55
    b982:	90 91 56 0e 	lds	r25, 0x0E56
    b986:	01 96       	adiw	r24, 0x01	; 1
    b988:	90 93 56 0e 	sts	0x0E56, r25
    b98c:	80 93 55 0e 	sts	0x0E55, r24
    b990:	08 95       	ret
		else{
			gRx1Step = 0;
    b992:	10 92 56 0e 	sts	0x0E56, r1
    b996:	10 92 55 0e 	sts	0x0E55, r1
			F_DOWNLOAD = 0;
    b99a:	10 92 81 0a 	sts	0x0A81, r1
			RUN_LED2_OFF;
    b99e:	de 9a       	sbi	0x1b, 6	; 27
    b9a0:	08 95       	ret

0000b9a2 <U1I_case302>:
		}
	}
}

void U1I_case302(void)
{
    b9a2:	90 91 bb 0e 	lds	r25, 0x0EBB
    b9a6:	80 91 b6 0e 	lds	r24, 0x0EB6
    b9aa:	89 27       	eor	r24, r25
    b9ac:	80 93 b6 0e 	sts	0x0EB6, r24
	gFileCheckSum ^= gRxData;
	if(gRxData == 1)
    b9b0:	91 30       	cpi	r25, 0x01	; 1
    b9b2:	51 f4       	brne	.+20     	; 0xb9c8 <U1I_case302+0x26>
		gRx1Step++;
    b9b4:	80 91 55 0e 	lds	r24, 0x0E55
    b9b8:	90 91 56 0e 	lds	r25, 0x0E56
    b9bc:	01 96       	adiw	r24, 0x01	; 1
    b9be:	90 93 56 0e 	sts	0x0E56, r25
    b9c2:	80 93 55 0e 	sts	0x0E55, r24
    b9c6:	08 95       	ret
	else{
		gRx1Step = 0;
    b9c8:	10 92 56 0e 	sts	0x0E56, r1
    b9cc:	10 92 55 0e 	sts	0x0E55, r1
		F_DOWNLOAD = 0;
    b9d0:	10 92 81 0a 	sts	0x0A81, r1
		RUN_LED2_OFF;
    b9d4:	de 9a       	sbi	0x1b, 6	; 27
    b9d6:	08 95       	ret

0000b9d8 <U1I_case502>:
	RUN_LED2_OFF;
}


void U1I_case502(BYTE LC)
{
    b9d8:	90 91 b6 0e 	lds	r25, 0x0EB6
    b9dc:	20 91 bb 0e 	lds	r18, 0x0EBB
    b9e0:	92 27       	eor	r25, r18
    b9e2:	90 93 b6 0e 	sts	0x0EB6, r25
	gFileCheckSum ^= gRxData;
	gFieldIdx++;
    b9e6:	20 91 44 0e 	lds	r18, 0x0E44
    b9ea:	30 91 45 0e 	lds	r19, 0x0E45
    b9ee:	2f 5f       	subi	r18, 0xFF	; 255
    b9f0:	3f 4f       	sbci	r19, 0xFF	; 255
    b9f2:	30 93 45 0e 	sts	0x0E45, r19
    b9f6:	20 93 44 0e 	sts	0x0E44, r18
	if(gFieldIdx == LC){
    b9fa:	90 e0       	ldi	r25, 0x00	; 0
    b9fc:	28 17       	cp	r18, r24
    b9fe:	39 07       	cpc	r19, r25
    ba00:	49 f4       	brne	.+18     	; 0xba14 <U1I_case502+0x3c>
		gRx1Step++;
    ba02:	80 91 55 0e 	lds	r24, 0x0E55
    ba06:	90 91 56 0e 	lds	r25, 0x0E56
    ba0a:	01 96       	adiw	r24, 0x01	; 1
    ba0c:	90 93 56 0e 	sts	0x0E56, r25
    ba10:	80 93 55 0e 	sts	0x0E55, r24
    ba14:	08 95       	ret

0000ba16 <U1I_case603>:
	}
}


void U1I_case603(void)
{
    ba16:	10 92 56 0e 	sts	0x0E56, r1
    ba1a:	10 92 55 0e 	sts	0x0E55, r1
			sciTx1Data(gFileCheckSum);
		}
	}
	*/
	gRx1Step = 0;
	F_DOWNLOAD = 0;
    ba1e:	10 92 81 0a 	sts	0x0A81, r1
	RUN_LED2_OFF;
    ba22:	de 9a       	sbi	0x1b, 6	; 27
}
    ba24:	08 95       	ret

0000ba26 <ReadButton>:

//------------------------------------------------------------------------------
//  
//------------------------------------------------------------------------------
void ReadButton(void)
{
    ba26:	99 b3       	in	r25, 0x19	; 25
	BYTE	lbtmp;

	lbtmp = PINA & 0x03;

	if(F_DOWNLOAD) return;
    ba28:	80 91 81 0a 	lds	r24, 0x0A81
    ba2c:	88 23       	and	r24, r24
    ba2e:	09 f0       	breq	.+2      	; 0xba32 <ReadButton+0xc>
    ba30:	93 c0       	rjmp	.+294    	; 0xbb58 <ReadButton+0x132>
//------------------------------------------------------------------------------
void ReadButton(void)
{
	BYTE	lbtmp;

	lbtmp = PINA & 0x03;
    ba32:	89 2f       	mov	r24, r25
    ba34:	83 70       	andi	r24, 0x03	; 3

	if(F_DOWNLOAD) return;

	if(lbtmp == 0x02){
    ba36:	82 30       	cpi	r24, 0x02	; 2
    ba38:	e9 f4       	brne	.+58     	; 0xba74 <ReadButton+0x4e>
		gPF1BtnCnt++;		gPF2BtnCnt = 0;		gPF12BtnCnt = 0;
    ba3a:	80 91 b4 0e 	lds	r24, 0x0EB4
    ba3e:	90 91 b5 0e 	lds	r25, 0x0EB5
    ba42:	01 96       	adiw	r24, 0x01	; 1
    ba44:	90 93 b5 0e 	sts	0x0EB5, r25
    ba48:	80 93 b4 0e 	sts	0x0EB4, r24
    ba4c:	10 92 b8 0e 	sts	0x0EB8, r1
    ba50:	10 92 b7 0e 	sts	0x0EB7, r1
    ba54:	10 92 97 0e 	sts	0x0E97, r1
    ba58:	10 92 96 0e 	sts	0x0E96, r1
       	if(gPF1BtnCnt > 3000){
    ba5c:	89 5b       	subi	r24, 0xB9	; 185
    ba5e:	9b 40       	sbci	r25, 0x0B	; 11
    ba60:	08 f4       	brcc	.+2      	; 0xba64 <ReadButton+0x3e>
    ba62:	7a c0       	rjmp	.+244    	; 0xbb58 <ReadButton+0x132>
			gBtn_val = PF1_BTN_LONG;
    ba64:	84 e0       	ldi	r24, 0x04	; 4
    ba66:	80 93 57 0e 	sts	0x0E57, r24
			gPF1BtnCnt = 0;
    ba6a:	10 92 b5 0e 	sts	0x0EB5, r1
    ba6e:	10 92 b4 0e 	sts	0x0EB4, r1
    ba72:	08 95       	ret
		}
	}
	else if(lbtmp == 0x01){
    ba74:	81 30       	cpi	r24, 0x01	; 1
    ba76:	e9 f4       	brne	.+58     	; 0xbab2 <ReadButton+0x8c>
		gPF1BtnCnt = 0;		gPF2BtnCnt++;		gPF12BtnCnt = 0;
    ba78:	10 92 b5 0e 	sts	0x0EB5, r1
    ba7c:	10 92 b4 0e 	sts	0x0EB4, r1
    ba80:	80 91 b7 0e 	lds	r24, 0x0EB7
    ba84:	90 91 b8 0e 	lds	r25, 0x0EB8
    ba88:	01 96       	adiw	r24, 0x01	; 1
    ba8a:	90 93 b8 0e 	sts	0x0EB8, r25
    ba8e:	80 93 b7 0e 	sts	0x0EB7, r24
    ba92:	10 92 97 0e 	sts	0x0E97, r1
    ba96:	10 92 96 0e 	sts	0x0E96, r1
       	if(gPF2BtnCnt > 3000){
    ba9a:	89 5b       	subi	r24, 0xB9	; 185
    ba9c:	9b 40       	sbci	r25, 0x0B	; 11
    ba9e:	08 f4       	brcc	.+2      	; 0xbaa2 <ReadButton+0x7c>
    baa0:	5b c0       	rjmp	.+182    	; 0xbb58 <ReadButton+0x132>
			gBtn_val = PF2_BTN_LONG;
    baa2:	85 e0       	ldi	r24, 0x05	; 5
    baa4:	80 93 57 0e 	sts	0x0E57, r24
			gPF2BtnCnt = 0;
    baa8:	10 92 b8 0e 	sts	0x0EB8, r1
    baac:	10 92 b7 0e 	sts	0x0EB7, r1
    bab0:	08 95       	ret
		}
	}
	else if(lbtmp == 0x00){
    bab2:	88 23       	and	r24, r24
    bab4:	09 f5       	brne	.+66     	; 0xbaf8 <ReadButton+0xd2>
		gPF1BtnCnt = 0;		gPF2BtnCnt = 0;		gPF12BtnCnt++;
    bab6:	10 92 b5 0e 	sts	0x0EB5, r1
    baba:	10 92 b4 0e 	sts	0x0EB4, r1
    babe:	10 92 b8 0e 	sts	0x0EB8, r1
    bac2:	10 92 b7 0e 	sts	0x0EB7, r1
    bac6:	80 91 96 0e 	lds	r24, 0x0E96
    baca:	90 91 97 0e 	lds	r25, 0x0E97
    bace:	01 96       	adiw	r24, 0x01	; 1
    bad0:	90 93 97 0e 	sts	0x0E97, r25
    bad4:	80 93 96 0e 	sts	0x0E96, r24
       	if(gPF12BtnCnt > 2000){
    bad8:	81 5d       	subi	r24, 0xD1	; 209
    bada:	97 40       	sbci	r25, 0x07	; 7
    badc:	08 f4       	brcc	.+2      	; 0xbae0 <ReadButton+0xba>
    bade:	3c c0       	rjmp	.+120    	; 0xbb58 <ReadButton+0x132>
           	if(F_PF_CHANGED == 0){
    bae0:	80 91 9a 0e 	lds	r24, 0x0E9A
    bae4:	88 23       	and	r24, r24
    bae6:	c1 f5       	brne	.+112    	; 0xbb58 <ReadButton+0x132>
				gBtn_val = PF12_BTN_LONG;
    bae8:	86 e0       	ldi	r24, 0x06	; 6
    baea:	80 93 57 0e 	sts	0x0E57, r24
	       	    gPF12BtnCnt = 0;
    baee:	10 92 97 0e 	sts	0x0E97, r1
    baf2:	10 92 96 0e 	sts	0x0E96, r1
    baf6:	08 95       	ret
			}
		}
	}
	else{
		if(gPF1BtnCnt > 40 && gPF1BtnCnt < 500){
    baf8:	80 91 b4 0e 	lds	r24, 0x0EB4
    bafc:	90 91 b5 0e 	lds	r25, 0x0EB5
    bb00:	89 97       	sbiw	r24, 0x29	; 41
    bb02:	8b 5c       	subi	r24, 0xCB	; 203
    bb04:	91 40       	sbci	r25, 0x01	; 1
    bb06:	10 f4       	brcc	.+4      	; 0xbb0c <ReadButton+0xe6>
			gBtn_val = PF1_BTN_SHORT;
    bb08:	81 e0       	ldi	r24, 0x01	; 1
    bb0a:	09 c0       	rjmp	.+18     	; 0xbb1e <ReadButton+0xf8>
		}
		else if(gPF2BtnCnt > 40 && gPF2BtnCnt < 500){
    bb0c:	80 91 b7 0e 	lds	r24, 0x0EB7
    bb10:	90 91 b8 0e 	lds	r25, 0x0EB8
    bb14:	89 97       	sbiw	r24, 0x29	; 41
    bb16:	8b 5c       	subi	r24, 0xCB	; 203
    bb18:	91 40       	sbci	r25, 0x01	; 1
    bb1a:	20 f4       	brcc	.+8      	; 0xbb24 <ReadButton+0xfe>
			gBtn_val = PF2_BTN_SHORT;
    bb1c:	82 e0       	ldi	r24, 0x02	; 2
    bb1e:	80 93 57 0e 	sts	0x0E57, r24
    bb22:	0c c0       	rjmp	.+24     	; 0xbb3c <ReadButton+0x116>
		}
		else if(gPF12BtnCnt > 40 && gPF12BtnCnt < 500){
    bb24:	80 91 96 0e 	lds	r24, 0x0E96
    bb28:	90 91 97 0e 	lds	r25, 0x0E97
    bb2c:	89 97       	sbiw	r24, 0x29	; 41
    bb2e:	8b 5c       	subi	r24, 0xCB	; 203
    bb30:	91 40       	sbci	r25, 0x01	; 1
    bb32:	10 f4       	brcc	.+4      	; 0xbb38 <ReadButton+0x112>
			gBtn_val = PF12_BTN_SHORT;
    bb34:	83 e0       	ldi	r24, 0x03	; 3
    bb36:	f3 cf       	rjmp	.-26     	; 0xbb1e <ReadButton+0xf8>
		}
		else
			gBtn_val = BTN_NOT_PRESSED;
    bb38:	10 92 57 0e 	sts	0x0E57, r1
		gPF1BtnCnt = 0;
    bb3c:	10 92 b5 0e 	sts	0x0EB5, r1
    bb40:	10 92 b4 0e 	sts	0x0EB4, r1
		gPF2BtnCnt = 0;
    bb44:	10 92 b8 0e 	sts	0x0EB8, r1
    bb48:	10 92 b7 0e 	sts	0x0EB7, r1
		gPF12BtnCnt = 0;
    bb4c:	10 92 97 0e 	sts	0x0E97, r1
    bb50:	10 92 96 0e 	sts	0x0E96, r1
		F_PF_CHANGED = 0;
    bb54:	10 92 9a 0e 	sts	0x0E9A, r1
    bb58:	08 95       	ret

0000bb5a <SelfTest1>:

//------------------------------------------------------------------------------
//  1
//------------------------------------------------------------------------------
void SelfTest1(void)
{
    bb5a:	80 91 ba 0e 	lds	r24, 0x0EBA
    bb5e:	88 23       	and	r24, r24
    bb60:	c1 f5       	brne	.+112    	; 0xbbd2 <SelfTest1+0x78>
	//	 ||(StandardZeroPos[i]-15)>eM_OriginPose[i]){
	//		F_ERR_CODE = ZERO_DATA_ERR;
	//		return;
	//	}
	//}
	PWR_LED1_ON;	delay_ms(60);	PWR_LED1_OFF;
    bb62:	80 91 65 00 	lds	r24, 0x0065
    bb66:	8b 7f       	andi	r24, 0xFB	; 251
    bb68:	80 93 65 00 	sts	0x0065, r24
    bb6c:	8c e3       	ldi	r24, 0x3C	; 60
    bb6e:	90 e0       	ldi	r25, 0x00	; 0
    bb70:	0e 94 42 5c 	call	0xb884	; 0xb884 <delay_ms>
    bb74:	80 91 65 00 	lds	r24, 0x0065
    bb78:	84 60       	ori	r24, 0x04	; 4
    bb7a:	80 93 65 00 	sts	0x0065, r24
	PWR_LED2_ON;	delay_ms(60);	PWR_LED2_OFF;
    bb7e:	af 98       	cbi	0x15, 7	; 21
    bb80:	8c e3       	ldi	r24, 0x3C	; 60
    bb82:	90 e0       	ldi	r25, 0x00	; 0
    bb84:	0e 94 42 5c 	call	0xb884	; 0xb884 <delay_ms>
    bb88:	af 9a       	sbi	0x15, 7	; 21
	RUN_LED1_ON;	delay_ms(60);	RUN_LED1_OFF;
    bb8a:	dd 98       	cbi	0x1b, 5	; 27
    bb8c:	8c e3       	ldi	r24, 0x3C	; 60
    bb8e:	90 e0       	ldi	r25, 0x00	; 0
    bb90:	0e 94 42 5c 	call	0xb884	; 0xb884 <delay_ms>
    bb94:	dd 9a       	sbi	0x1b, 5	; 27
	RUN_LED2_ON;	delay_ms(60);	RUN_LED2_OFF;
    bb96:	de 98       	cbi	0x1b, 6	; 27
    bb98:	8c e3       	ldi	r24, 0x3C	; 60
    bb9a:	90 e0       	ldi	r25, 0x00	; 0
    bb9c:	0e 94 42 5c 	call	0xb884	; 0xb884 <delay_ms>
    bba0:	de 9a       	sbi	0x1b, 6	; 27
	ERR_LED_ON;		delay_ms(60);	ERR_LED_OFF;
    bba2:	df 98       	cbi	0x1b, 7	; 27
    bba4:	8c e3       	ldi	r24, 0x3C	; 60
    bba6:	90 e0       	ldi	r25, 0x00	; 0
    bba8:	0e 94 42 5c 	call	0xb884	; 0xb884 <delay_ms>
    bbac:	df 9a       	sbi	0x1b, 7	; 27

	PF2_LED_ON;		delay_ms(60);	PF2_LED_OFF;
    bbae:	dc 98       	cbi	0x1b, 4	; 27
    bbb0:	8c e3       	ldi	r24, 0x3C	; 60
    bbb2:	90 e0       	ldi	r25, 0x00	; 0
    bbb4:	0e 94 42 5c 	call	0xb884	; 0xb884 <delay_ms>
    bbb8:	dc 9a       	sbi	0x1b, 4	; 27
	PF1_LED2_ON;	delay_ms(60);	PF1_LED2_OFF;
    bbba:	db 98       	cbi	0x1b, 3	; 27
    bbbc:	8c e3       	ldi	r24, 0x3C	; 60
    bbbe:	90 e0       	ldi	r25, 0x00	; 0
    bbc0:	0e 94 42 5c 	call	0xb884	; 0xb884 <delay_ms>
    bbc4:	db 9a       	sbi	0x1b, 3	; 27
	PF1_LED1_ON;	delay_ms(60);	PF1_LED1_OFF;
    bbc6:	da 98       	cbi	0x1b, 2	; 27
    bbc8:	8c e3       	ldi	r24, 0x3C	; 60
    bbca:	90 e0       	ldi	r25, 0x00	; 0
    bbcc:	0e 94 42 5c 	call	0xb884	; 0xb884 <delay_ms>
    bbd0:	da 9a       	sbi	0x1b, 2	; 27
    bbd2:	08 95       	ret

0000bbd4 <IoUpdate>:

//------------------------------------------------------------------------------
// Io  
//------------------------------------------------------------------------------
void IoUpdate(void)
{
    bbd4:	80 91 81 0a 	lds	r24, 0x0A81
    bbd8:	88 23       	and	r24, r24
    bbda:	09 f0       	breq	.+2      	; 0xbbde <IoUpdate+0xa>
    bbdc:	8d c0       	rjmp	.+282    	; 0xbcf8 <IoUpdate+0x124>
	if(F_DOWNLOAD) return;
	if(F_DIRECT_C_EN){
    bbde:	80 91 ba 0e 	lds	r24, 0x0EBA
    bbe2:	88 23       	and	r24, r24
    bbe4:	21 f0       	breq	.+8      	; 0xbbee <IoUpdate+0x1a>
			PF1_LED1_ON;
    bbe6:	da 98       	cbi	0x1b, 2	; 27
			PF1_LED2_OFF;
    bbe8:	db 9a       	sbi	0x1b, 3	; 27
			PF2_LED_ON;
    bbea:	dc 98       	cbi	0x1b, 4	; 27
    bbec:	08 95       	ret
			return;
	}
	switch(F_PF){
    bbee:	80 91 43 0e 	lds	r24, 0x0E43
    bbf2:	82 30       	cpi	r24, 0x02	; 2
    bbf4:	69 f0       	breq	.+26     	; 0xbc10 <IoUpdate+0x3c>
    bbf6:	83 30       	cpi	r24, 0x03	; 3
    bbf8:	18 f4       	brcc	.+6      	; 0xbc00 <IoUpdate+0x2c>
    bbfa:	81 30       	cpi	r24, 0x01	; 1
    bbfc:	99 f4       	brne	.+38     	; 0xbc24 <IoUpdate+0x50>
    bbfe:	05 c0       	rjmp	.+10     	; 0xbc0a <IoUpdate+0x36>
    bc00:	83 30       	cpi	r24, 0x03	; 3
    bc02:	51 f0       	breq	.+20     	; 0xbc18 <IoUpdate+0x44>
    bc04:	84 30       	cpi	r24, 0x04	; 4
    bc06:	71 f4       	brne	.+28     	; 0xbc24 <IoUpdate+0x50>
    bc08:	09 c0       	rjmp	.+18     	; 0xbc1c <IoUpdate+0x48>
		case PF1_HUNO:
			PF1_LED1_ON;
    bc0a:	da 98       	cbi	0x1b, 2	; 27
			PF1_LED2_OFF;
    bc0c:	db 9a       	sbi	0x1b, 3	; 27
    bc0e:	02 c0       	rjmp	.+4      	; 0xbc14 <IoUpdate+0x40>
			PF2_LED_OFF;
			break;
		case PF1_DINO:
			PF1_LED1_ON;
    bc10:	da 98       	cbi	0x1b, 2	; 27
			PF1_LED2_ON;
    bc12:	db 98       	cbi	0x1b, 3	; 27
			PF2_LED_OFF;
    bc14:	dc 9a       	sbi	0x1b, 4	; 27
    bc16:	09 c0       	rjmp	.+18     	; 0xbc2a <IoUpdate+0x56>
			break;
		case PF1_DOGY:
			PF1_LED1_OFF;
    bc18:	da 9a       	sbi	0x1b, 2	; 27
    bc1a:	fb cf       	rjmp	.-10     	; 0xbc12 <IoUpdate+0x3e>
			PF1_LED2_ON;
			PF2_LED_OFF;
			break;
		case PF2_B:
			PF1_LED1_OFF;
    bc1c:	da 9a       	sbi	0x1b, 2	; 27
			PF1_LED2_OFF;
    bc1e:	db 9a       	sbi	0x1b, 3	; 27
			PF2_LED_ON;
    bc20:	dc 98       	cbi	0x1b, 4	; 27
    bc22:	03 c0       	rjmp	.+6      	; 0xbc2a <IoUpdate+0x56>
			break;
		default:
			F_PF = PF2_B;
    bc24:	84 e0       	ldi	r24, 0x04	; 4
    bc26:	80 93 43 0e 	sts	0x0E43, r24
	}

	if(gVOLTAGE>M_T_OF_POWER){
    bc2a:	80 91 92 0d 	lds	r24, 0x0D92
    bc2e:	90 91 93 0d 	lds	r25, 0x0D93
    bc32:	89 59       	subi	r24, 0x99	; 153
    bc34:	91 42       	sbci	r25, 0x21	; 33
    bc36:	58 f0       	brcs	.+22     	; 0xbc4e <IoUpdate+0x7a>
		PWR_LED1_ON;
    bc38:	80 91 65 00 	lds	r24, 0x0065
    bc3c:	8b 7f       	andi	r24, 0xFB	; 251
    bc3e:	80 93 65 00 	sts	0x0065, r24
		PWR_LED2_OFF;
    bc42:	af 9a       	sbi	0x15, 7	; 21
		gPwrLowCount = 0;
    bc44:	10 92 b8 0d 	sts	0x0DB8, r1
    bc48:	10 92 b7 0d 	sts	0x0DB7, r1
    bc4c:	4e c0       	rjmp	.+156    	; 0xbcea <IoUpdate+0x116>
	}
	else if(gVOLTAGE>L_T_OF_POWER){
    bc4e:	80 91 92 0d 	lds	r24, 0x0D92
    bc52:	90 91 93 0d 	lds	r25, 0x0D93
    bc56:	85 5a       	subi	r24, 0xA5	; 165
    bc58:	9f 41       	sbci	r25, 0x1F	; 31
    bc5a:	98 f0       	brcs	.+38     	; 0xbc82 <IoUpdate+0xae>
		PWR_LED1_OFF;
    bc5c:	80 91 65 00 	lds	r24, 0x0065
    bc60:	84 60       	ori	r24, 0x04	; 4
    bc62:	80 93 65 00 	sts	0x0065, r24
		PWR_LED2_ON;
    bc66:	af 98       	cbi	0x15, 7	; 21
		gPwrLowCount++;
    bc68:	80 91 b7 0d 	lds	r24, 0x0DB7
    bc6c:	90 91 b8 0d 	lds	r25, 0x0DB8
    bc70:	01 96       	adiw	r24, 0x01	; 1
    bc72:	90 93 b8 0d 	sts	0x0DB8, r25
    bc76:	80 93 b7 0d 	sts	0x0DB7, r24
		if(gPwrLowCount>5000){
    bc7a:	89 58       	subi	r24, 0x89	; 137
    bc7c:	93 41       	sbci	r25, 0x13	; 19
    bc7e:	a8 f1       	brcs	.+106    	; 0xbcea <IoUpdate+0x116>
    bc80:	2e c0       	rjmp	.+92     	; 0xbcde <IoUpdate+0x10a>
			gPwrLowCount = 0;
			wckPowerDown();
		}
	}
	else{
		PWR_LED1_OFF;
    bc82:	80 91 65 00 	lds	r24, 0x0065
    bc86:	84 60       	ori	r24, 0x04	; 4
    bc88:	80 93 65 00 	sts	0x0065, r24
		if(g10MSEC<25)			PWR_LED2_ON;
    bc8c:	80 91 b8 0a 	lds	r24, 0x0AB8
    bc90:	90 91 b9 0a 	lds	r25, 0x0AB9
    bc94:	49 97       	sbiw	r24, 0x19	; 25
    bc96:	68 f0       	brcs	.+26     	; 0xbcb2 <IoUpdate+0xde>
		else if(g10MSEC<50)		PWR_LED2_OFF;
    bc98:	80 91 b8 0a 	lds	r24, 0x0AB8
    bc9c:	90 91 b9 0a 	lds	r25, 0x0AB9
    bca0:	c2 97       	sbiw	r24, 0x32	; 50
    bca2:	80 f0       	brcs	.+32     	; 0xbcc4 <IoUpdate+0xf0>
		else if(g10MSEC<75)		PWR_LED2_ON;
    bca4:	80 91 b8 0a 	lds	r24, 0x0AB8
    bca8:	90 91 b9 0a 	lds	r25, 0x0AB9
    bcac:	8b 34       	cpi	r24, 0x4B	; 75
    bcae:	91 05       	cpc	r25, r1
    bcb0:	10 f4       	brcc	.+4      	; 0xbcb6 <IoUpdate+0xe2>
    bcb2:	af 98       	cbi	0x15, 7	; 21
    bcb4:	08 c0       	rjmp	.+16     	; 0xbcc6 <IoUpdate+0xf2>
		else if(g10MSEC<100)	PWR_LED2_OFF;
    bcb6:	80 91 b8 0a 	lds	r24, 0x0AB8
    bcba:	90 91 b9 0a 	lds	r25, 0x0AB9
    bcbe:	84 36       	cpi	r24, 0x64	; 100
    bcc0:	91 05       	cpc	r25, r1
    bcc2:	08 f4       	brcc	.+2      	; 0xbcc6 <IoUpdate+0xf2>
    bcc4:	af 9a       	sbi	0x15, 7	; 21
		gPwrLowCount++;
    bcc6:	80 91 b7 0d 	lds	r24, 0x0DB7
    bcca:	90 91 b8 0d 	lds	r25, 0x0DB8
    bcce:	01 96       	adiw	r24, 0x01	; 1
    bcd0:	90 93 b8 0d 	sts	0x0DB8, r25
    bcd4:	80 93 b7 0d 	sts	0x0DB7, r24
		if(gPwrLowCount>3000){
    bcd8:	89 5b       	subi	r24, 0xB9	; 185
    bcda:	9b 40       	sbci	r25, 0x0B	; 11
    bcdc:	30 f0       	brcs	.+12     	; 0xbcea <IoUpdate+0x116>
			gPwrLowCount=0;
    bcde:	10 92 b8 0d 	sts	0x0DB8, r1
    bce2:	10 92 b7 0d 	sts	0x0DB7, r1
			wckPowerDown();
    bce6:	0e 94 31 54 	call	0xa862	; 0xa862 <wckPowerDown>
		}
	}
	if(F_ERR_CODE == NO_ERR)	ERR_LED_OFF;
    bcea:	80 91 53 0e 	lds	r24, 0x0E53
    bcee:	8f 3f       	cpi	r24, 0xFF	; 255
    bcf0:	11 f4       	brne	.+4      	; 0xbcf6 <IoUpdate+0x122>
    bcf2:	df 9a       	sbi	0x1b, 7	; 27
    bcf4:	08 95       	ret
	else ERR_LED_ON;
    bcf6:	df 98       	cbi	0x1b, 7	; 27
    bcf8:	08 95       	ret

0000bcfa <Round>:

BYTE    gDownNumOfM;
BYTE    gDownNumOfA;

int Round(float num,int precision)
{
    bcfa:	af 92       	push	r10
    bcfc:	bf 92       	push	r11
    bcfe:	cf 92       	push	r12
    bd00:	df 92       	push	r13
    bd02:	ef 92       	push	r14
    bd04:	ff 92       	push	r15
    bd06:	0f 93       	push	r16
    bd08:	1f 93       	push	r17
    bd0a:	7b 01       	movw	r14, r22
    bd0c:	8c 01       	movw	r16, r24
	float tempNum;
	tempNum = num;
	if(tempNum - floor(tempNum) >= 0.5)
    bd0e:	0e 94 b0 6e 	call	0xdd60	; 0xdd60 <floor>
    bd12:	5b 01       	movw	r10, r22
    bd14:	6c 01       	movw	r12, r24
    bd16:	9b 01       	movw	r18, r22
    bd18:	ac 01       	movw	r20, r24
    bd1a:	c8 01       	movw	r24, r16
    bd1c:	b7 01       	movw	r22, r14
    bd1e:	0e 94 66 67 	call	0xcecc	; 0xcecc <__subsf3>
    bd22:	20 e0       	ldi	r18, 0x00	; 0
    bd24:	30 e0       	ldi	r19, 0x00	; 0
    bd26:	40 e0       	ldi	r20, 0x00	; 0
    bd28:	5f e3       	ldi	r21, 0x3F	; 63
    bd2a:	0e 94 98 69 	call	0xd330	; 0xd330 <__gesf2>
    bd2e:	88 23       	and	r24, r24
    bd30:	2c f0       	brlt	.+10     	; 0xbd3c <Round+0x42>
		return (int)( ceil(tempNum)  );
    bd32:	c8 01       	movw	r24, r16
    bd34:	b7 01       	movw	r22, r14
    bd36:	0e 94 9d 6e 	call	0xdd3a	; 0xdd3a <ceil>
    bd3a:	02 c0       	rjmp	.+4      	; 0xbd40 <Round+0x46>
	else return (int)(floor(tempNum));
    bd3c:	c6 01       	movw	r24, r12
    bd3e:	b5 01       	movw	r22, r10
    bd40:	0e 94 56 6a 	call	0xd4ac	; 0xd4ac <__fixsfsi>
    bd44:	cb 01       	movw	r24, r22
}
    bd46:	1f 91       	pop	r17
    bd48:	0f 91       	pop	r16
    bd4a:	ff 90       	pop	r15
    bd4c:	ef 90       	pop	r14
    bd4e:	df 90       	pop	r13
    bd50:	cf 90       	pop	r12
    bd52:	bf 90       	pop	r11
    bd54:	af 90       	pop	r10
    bd56:	08 95       	ret

0000bd58 <sciTx1Data>:
	SampleMotion(a); 
}


void	sciTx1Data(BYTE x)
{
    bd58:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
	uartSendByte(x);
}
    bd5c:	08 95       	ret

0000bd5e <SendToPC>:
		return (int)( ceil(tempNum)  );
	else return (int)(floor(tempNum));
}

void SendToPC(BYTE Cmd, BYTE CSize)
{
    bd5e:	0f 93       	push	r16
    bd60:	1f 93       	push	r17
    bd62:	18 2f       	mov	r17, r24
    bd64:	06 2f       	mov	r16, r22
}


void	sciTx1Data(BYTE x)
{
	uartSendByte(x);
    bd66:	8f ef       	ldi	r24, 0xFF	; 255
    bd68:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
	sciTx1Data(F_PF);
	sciTx1Data(0);
	sciTx1Data(0);
	sciTx1Data(0);
	sciTx1Data(CSize);
}
    bd6c:	8f ef       	ldi	r24, 0xFF	; 255
    bd6e:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
    bd72:	8a ea       	ldi	r24, 0xAA	; 170
    bd74:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
    bd78:	85 e5       	ldi	r24, 0x55	; 85
    bd7a:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
    bd7e:	8a ea       	ldi	r24, 0xAA	; 170
    bd80:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
    bd84:	85 e5       	ldi	r24, 0x55	; 85
    bd86:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
    bd8a:	87 e3       	ldi	r24, 0x37	; 55
    bd8c:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
    bd90:	8a eb       	ldi	r24, 0xBA	; 186
    bd92:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
    bd96:	81 2f       	mov	r24, r17
    bd98:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
    bd9c:	80 91 43 0e 	lds	r24, 0x0E43
    bda0:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
    bda4:	80 e0       	ldi	r24, 0x00	; 0
    bda6:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
    bdaa:	80 e0       	ldi	r24, 0x00	; 0
    bdac:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
    bdb0:	80 e0       	ldi	r24, 0x00	; 0
    bdb2:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
    bdb6:	80 2f       	mov	r24, r16
    bdb8:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
    bdbc:	1f 91       	pop	r17
    bdbe:	0f 91       	pop	r16
    bdc0:	08 95       	ret

0000bdc2 <ProcComm>:
}



void ProcComm(void)
{
    bdc2:	80 91 b2 0e 	lds	r24, 0x0EB2
    bdc6:	88 23       	and	r24, r24
    bdc8:	b1 f0       	breq	.+44     	; 0xbdf6 <ProcComm+0x34>
	BYTE	lbtmp;

	if(F_RSV_PSD_READ )
	{
		SendToPC(22,2);
    bdca:	62 e0       	ldi	r22, 0x02	; 2
    bdcc:	86 e1       	ldi	r24, 0x16	; 22
    bdce:	0e 94 af 5e 	call	0xbd5e	; 0xbd5e <SendToPC>
		gFileCheckSum = 0;
    bdd2:	10 92 b6 0e 	sts	0x0EB6, r1
		sciTx1Data(gDistance);
    bdd6:	80 91 99 0d 	lds	r24, 0x0D99
}


void	sciTx1Data(BYTE x)
{
	uartSendByte(x);
    bdda:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
	{
		SendToPC(22,2);
		gFileCheckSum = 0;
		sciTx1Data(gDistance);
		sciTx1Data(0);
		gFileCheckSum ^= gDistance;
    bdde:	80 e0       	ldi	r24, 0x00	; 0
    bde0:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
    bde4:	80 91 99 0d 	lds	r24, 0x0D99
    bde8:	90 91 b6 0e 	lds	r25, 0x0EB6
    bdec:	89 27       	eor	r24, r25
    bdee:	80 93 b6 0e 	sts	0x0EB6, r24
}


void	sciTx1Data(BYTE x)
{
	uartSendByte(x);
    bdf2:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
		sciTx1Data(0);
		gFileCheckSum ^= gDistance;
		sciTx1Data(gFileCheckSum);
	}
		
	if(F_RSV_IR_READ && F_IR_RECEIVED)         // Added in to support IR in remote mode
    bdf6:	80 91 b1 0e 	lds	r24, 0x0EB1
    bdfa:	88 23       	and	r24, r24
    bdfc:	09 f4       	brne	.+2      	; 0xbe00 <ProcComm+0x3e>
    bdfe:	73 c0       	rjmp	.+230    	; 0xbee6 <ProcComm+0x124>
    be00:	80 91 47 0e 	lds	r24, 0x0E47
    be04:	88 23       	and	r24, r24
    be06:	09 f4       	brne	.+2      	; 0xbe0a <ProcComm+0x48>
    be08:	6e c0       	rjmp	.+220    	; 0xbee6 <ProcComm+0x124>
	{  
	        EIMSK &= 0xBF; 
    be0a:	89 b7       	in	r24, 0x39	; 57
    be0c:	8f 7b       	andi	r24, 0xBF	; 191
    be0e:	89 bf       	out	0x39, r24	; 57
	        F_IR_RECEIVED = 0;  
    be10:	10 92 47 0e 	sts	0x0E47, r1
	        
	        if((gIrBuf[0]==eRCodeH[0] && gIrBuf[1]==eRCodeM[0] && gIrBuf[2]==eRCodeL[0])
    be14:	20 91 4a 0e 	lds	r18, 0x0E4A
    be18:	80 91 61 04 	lds	r24, 0x0461
    be1c:	28 17       	cp	r18, r24
    be1e:	69 f4       	brne	.+26     	; 0xbe3a <ProcComm+0x78>
    be20:	90 91 4b 0e 	lds	r25, 0x0E4B
    be24:	80 91 66 04 	lds	r24, 0x0466
    be28:	98 17       	cp	r25, r24
    be2a:	39 f4       	brne	.+14     	; 0xbe3a <ProcComm+0x78>
    be2c:	90 91 4c 0e 	lds	r25, 0x0E4C
    be30:	80 91 6b 04 	lds	r24, 0x046B
    be34:	98 17       	cp	r25, r24
    be36:	09 f4       	brne	.+2      	; 0xbe3a <ProcComm+0x78>
    be38:	40 c0       	rjmp	.+128    	; 0xbeba <ProcComm+0xf8>
    be3a:	80 91 62 04 	lds	r24, 0x0462
    be3e:	28 17       	cp	r18, r24
    be40:	61 f4       	brne	.+24     	; 0xbe5a <ProcComm+0x98>
    be42:	90 91 4b 0e 	lds	r25, 0x0E4B
    be46:	80 91 67 04 	lds	r24, 0x0467
    be4a:	98 17       	cp	r25, r24
    be4c:	31 f4       	brne	.+12     	; 0xbe5a <ProcComm+0x98>
    be4e:	90 91 4c 0e 	lds	r25, 0x0E4C
    be52:	80 91 6c 04 	lds	r24, 0x046C
    be56:	98 17       	cp	r25, r24
    be58:	81 f1       	breq	.+96     	; 0xbeba <ProcComm+0xf8>
    be5a:	80 91 63 04 	lds	r24, 0x0463
    be5e:	28 17       	cp	r18, r24
    be60:	61 f4       	brne	.+24     	; 0xbe7a <ProcComm+0xb8>
    be62:	90 91 4b 0e 	lds	r25, 0x0E4B
    be66:	80 91 68 04 	lds	r24, 0x0468
    be6a:	98 17       	cp	r25, r24
    be6c:	31 f4       	brne	.+12     	; 0xbe7a <ProcComm+0xb8>
    be6e:	90 91 4c 0e 	lds	r25, 0x0E4C
    be72:	80 91 6d 04 	lds	r24, 0x046D
    be76:	98 17       	cp	r25, r24
    be78:	01 f1       	breq	.+64     	; 0xbeba <ProcComm+0xf8>
    be7a:	80 91 64 04 	lds	r24, 0x0464
    be7e:	28 17       	cp	r18, r24
    be80:	61 f4       	brne	.+24     	; 0xbe9a <ProcComm+0xd8>
    be82:	90 91 4b 0e 	lds	r25, 0x0E4B
    be86:	80 91 69 04 	lds	r24, 0x0469
    be8a:	98 17       	cp	r25, r24
    be8c:	31 f4       	brne	.+12     	; 0xbe9a <ProcComm+0xd8>
    be8e:	90 91 4c 0e 	lds	r25, 0x0E4C
    be92:	80 91 6e 04 	lds	r24, 0x046E
    be96:	98 17       	cp	r25, r24
    be98:	81 f0       	breq	.+32     	; 0xbeba <ProcComm+0xf8>
    be9a:	80 91 65 04 	lds	r24, 0x0465
    be9e:	28 17       	cp	r18, r24
    bea0:	11 f5       	brne	.+68     	; 0xbee6 <ProcComm+0x124>
    bea2:	90 91 4b 0e 	lds	r25, 0x0E4B
    bea6:	80 91 6a 04 	lds	r24, 0x046A
    beaa:	98 17       	cp	r25, r24
    beac:	e1 f4       	brne	.+56     	; 0xbee6 <ProcComm+0x124>
    beae:	90 91 4c 0e 	lds	r25, 0x0E4C
    beb2:	80 91 6f 04 	lds	r24, 0x046F
    beb6:	98 17       	cp	r25, r24
    beb8:	b1 f4       	brne	.+44     	; 0xbee6 <ProcComm+0x124>
		 ||(gIrBuf[0]==eRCodeH[1] && gIrBuf[1]==eRCodeM[1] && gIrBuf[2]==eRCodeL[1])
		 ||(gIrBuf[0]==eRCodeH[2] && gIrBuf[1]==eRCodeM[2] && gIrBuf[2]==eRCodeL[2])
		 ||(gIrBuf[0]==eRCodeH[3] && gIrBuf[1]==eRCodeM[3] && gIrBuf[2]==eRCodeL[3])
		 ||(gIrBuf[0]==eRCodeH[4] && gIrBuf[1]==eRCodeM[4] && gIrBuf[2]==eRCodeL[4]))
		 {
	                SendToPC(25,2);
    beba:	62 e0       	ldi	r22, 0x02	; 2
    bebc:	89 e1       	ldi	r24, 0x19	; 25
    bebe:	0e 94 af 5e 	call	0xbd5e	; 0xbd5e <SendToPC>
		        gFileCheckSum = 0;
    bec2:	10 92 b6 0e 	sts	0x0EB6, r1
}


void	sciTx1Data(BYTE x)
{
	uartSendByte(x);
    bec6:	80 91 4d 0e 	lds	r24, 0x0E4D
    beca:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
		 {
	                SendToPC(25,2);
		        gFileCheckSum = 0;
		        sciTx1Data(gIrBuf[3]);
		        sciTx1Data(0);
		        gFileCheckSum ^= gIrBuf[3];
    bece:	80 e0       	ldi	r24, 0x00	; 0
    bed0:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
    bed4:	80 91 4d 0e 	lds	r24, 0x0E4D
    bed8:	90 91 b6 0e 	lds	r25, 0x0EB6
    bedc:	89 27       	eor	r24, r25
    bede:	80 93 b6 0e 	sts	0x0EB6, r24
}


void	sciTx1Data(BYTE x)
{
	uartSendByte(x);
    bee2:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
		        gFileCheckSum ^= gIrBuf[3];
		        sciTx1Data(gFileCheckSum);
		}  	
	}
	
	if(F_RSV_SOUND_READ){
    bee6:	80 91 b3 0e 	lds	r24, 0x0EB3
    beea:	88 23       	and	r24, r24
    beec:	f1 f0       	breq	.+60     	; 0xbf2a <ProcComm+0x168>
		Get_AD_MIC();
    beee:	0e 94 ac 2c 	call	0x5958	; 0x5958 <Get_AD_MIC>
		if(gSoundMinTh <= gSoundLevel){
    bef2:	90 91 98 0d 	lds	r25, 0x0D98
    bef6:	80 91 99 0e 	lds	r24, 0x0E99
    befa:	98 17       	cp	r25, r24
    befc:	b0 f0       	brcs	.+44     	; 0xbf2a <ProcComm+0x168>
			SendToPC(23,2);
    befe:	62 e0       	ldi	r22, 0x02	; 2
    bf00:	87 e1       	ldi	r24, 0x17	; 23
    bf02:	0e 94 af 5e 	call	0xbd5e	; 0xbd5e <SendToPC>
			gFileCheckSum = 0;
    bf06:	10 92 b6 0e 	sts	0x0EB6, r1
			sciTx1Data(gSoundLevel);
    bf0a:	80 91 98 0d 	lds	r24, 0x0D98
}


void	sciTx1Data(BYTE x)
{
	uartSendByte(x);
    bf0e:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
		if(gSoundMinTh <= gSoundLevel){
			SendToPC(23,2);
			gFileCheckSum = 0;
			sciTx1Data(gSoundLevel);
			sciTx1Data(0);
			gFileCheckSum ^= gSoundLevel;
    bf12:	80 e0       	ldi	r24, 0x00	; 0
    bf14:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
    bf18:	80 91 98 0d 	lds	r24, 0x0D98
    bf1c:	90 91 b6 0e 	lds	r25, 0x0EB6
    bf20:	89 27       	eor	r24, r25
    bf22:	80 93 b6 0e 	sts	0x0EB6, r24
}


void	sciTx1Data(BYTE x)
{
	uartSendByte(x);
    bf26:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
			sciTx1Data(0);
			gFileCheckSum ^= gSoundLevel;
			sciTx1Data(gFileCheckSum);
		}
	}
	if(F_RSV_BTN_READ){
    bf2a:	80 91 98 0e 	lds	r24, 0x0E98
    bf2e:	88 23       	and	r24, r24
    bf30:	09 f4       	brne	.+2      	; 0xbf34 <ProcComm+0x172>
    bf32:	3f c0       	rjmp	.+126    	; 0xbfb2 <ProcComm+0x1f0>
		lbtmp = PINA & 0x03;
    bf34:	89 b3       	in	r24, 0x19	; 25
    bf36:	83 70       	andi	r24, 0x03	; 3
		if(lbtmp == 0x02){	
    bf38:	82 30       	cpi	r24, 0x02	; 2
    bf3a:	e9 f4       	brne	.+58     	; 0xbf76 <ProcComm+0x1b4>
			delay_ms(30);
    bf3c:	8e e1       	ldi	r24, 0x1E	; 30
    bf3e:	90 e0       	ldi	r25, 0x00	; 0
    bf40:	0e 94 42 5c 	call	0xb884	; 0xb884 <delay_ms>
			if(lbtmp == 0x02){
				SendToPC(24,2);
    bf44:	62 e0       	ldi	r22, 0x02	; 2
    bf46:	88 e1       	ldi	r24, 0x18	; 24
    bf48:	0e 94 af 5e 	call	0xbd5e	; 0xbd5e <SendToPC>
				gFileCheckSum = 0;
    bf4c:	10 92 b6 0e 	sts	0x0EB6, r1
}


void	sciTx1Data(BYTE x)
{
	uartSendByte(x);
    bf50:	81 e0       	ldi	r24, 0x01	; 1
    bf52:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
			if(lbtmp == 0x02){
				SendToPC(24,2);
				gFileCheckSum = 0;
				sciTx1Data(1);
				sciTx1Data(0);
				gFileCheckSum ^= 1;
    bf56:	80 e0       	ldi	r24, 0x00	; 0
    bf58:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
    bf5c:	80 91 b6 0e 	lds	r24, 0x0EB6
    bf60:	91 e0       	ldi	r25, 0x01	; 1
    bf62:	89 27       	eor	r24, r25
    bf64:	80 93 b6 0e 	sts	0x0EB6, r24
}


void	sciTx1Data(BYTE x)
{
	uartSendByte(x);
    bf68:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
				gFileCheckSum = 0;
				sciTx1Data(1);
				sciTx1Data(0);
				gFileCheckSum ^= 1;
				sciTx1Data(gFileCheckSum);
				delay_ms(200);
    bf6c:	88 ec       	ldi	r24, 0xC8	; 200
    bf6e:	90 e0       	ldi	r25, 0x00	; 0
    bf70:	0e 94 42 5c 	call	0xb884	; 0xb884 <delay_ms>
    bf74:	08 95       	ret
			}
		}
		else if(lbtmp == 0x01){
    bf76:	81 30       	cpi	r24, 0x01	; 1
    bf78:	e1 f4       	brne	.+56     	; 0xbfb2 <ProcComm+0x1f0>
			delay_ms(30);
    bf7a:	8e e1       	ldi	r24, 0x1E	; 30
    bf7c:	90 e0       	ldi	r25, 0x00	; 0
    bf7e:	0e 94 42 5c 	call	0xb884	; 0xb884 <delay_ms>
			if(lbtmp == 0x01){
				SendToPC(24,2);
    bf82:	62 e0       	ldi	r22, 0x02	; 2
    bf84:	88 e1       	ldi	r24, 0x18	; 24
    bf86:	0e 94 af 5e 	call	0xbd5e	; 0xbd5e <SendToPC>
				gFileCheckSum = 0;
    bf8a:	10 92 b6 0e 	sts	0x0EB6, r1
}


void	sciTx1Data(BYTE x)
{
	uartSendByte(x);
    bf8e:	82 e0       	ldi	r24, 0x02	; 2
    bf90:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
			if(lbtmp == 0x01){
				SendToPC(24,2);
				gFileCheckSum = 0;
				sciTx1Data(2);
				sciTx1Data(0);
				gFileCheckSum ^= 2;
    bf94:	80 e0       	ldi	r24, 0x00	; 0
    bf96:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
    bf9a:	80 91 b6 0e 	lds	r24, 0x0EB6
    bf9e:	92 e0       	ldi	r25, 0x02	; 2
    bfa0:	89 27       	eor	r24, r25
    bfa2:	80 93 b6 0e 	sts	0x0EB6, r24
}


void	sciTx1Data(BYTE x)
{
	uartSendByte(x);
    bfa6:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
				gFileCheckSum = 0;
				sciTx1Data(2);
				sciTx1Data(0);
				gFileCheckSum ^= 2;
				sciTx1Data(gFileCheckSum);
				delay_ms(200);
    bfaa:	88 ec       	ldi	r24, 0xC8	; 200
    bfac:	90 e0       	ldi	r25, 0x00	; 0
    bfae:	0e 94 42 5c 	call	0xb884	; 0xb884 <delay_ms>
    bfb2:	08 95       	ret

0000bfb4 <U1I_case703>:
	RUN_LED2_OFF;
}


void U1I_case703(void)
{
    bfb4:	1f 93       	push	r17
    bfb6:	cf 93       	push	r28
    bfb8:	df 93       	push	r29
	WORD    lwtmp;
	BYTE	lbtmp;

	if(gFileCheckSum == gRxData){
    bfba:	90 91 b6 0e 	lds	r25, 0x0EB6
    bfbe:	80 91 bb 0e 	lds	r24, 0x0EBB
    bfc2:	98 17       	cp	r25, r24
    bfc4:	09 f0       	breq	.+2      	; 0xbfc8 <U1I_case703+0x14>
    bfc6:	65 c0       	rjmp	.+202    	; 0xc092 <U1I_case703+0xde>
		if(gDownNumOfM == 0){
    bfc8:	e0 91 bc 0e 	lds	r30, 0x0EBC
    bfcc:	ee 23       	and	r30, r30
    bfce:	61 f4       	brne	.+24     	; 0xbfe8 <U1I_case703+0x34>
			if(gRx1Buf[RX1_BUF_SIZE-2] == 1)
    bfd0:	80 91 af 0e 	lds	r24, 0x0EAF
    bfd4:	81 30       	cpi	r24, 0x01	; 1
    bfd6:	19 f4       	brne	.+6      	; 0xbfde <U1I_case703+0x2a>
    bfd8:	c0 e0       	ldi	r28, 0x00	; 0
    bfda:	d0 e6       	ldi	r29, 0x60	; 96
    bfdc:	3c c0       	rjmp	.+120    	; 0xc056 <U1I_case703+0xa2>
				lwtmp = 0x6000;
			else if(gRx1Buf[RX1_BUF_SIZE-2] == 2)
    bfde:	82 30       	cpi	r24, 0x02	; 2
    bfe0:	d1 f5       	brne	.+116    	; 0xc056 <U1I_case703+0xa2>
    bfe2:	c0 e0       	ldi	r28, 0x00	; 0
    bfe4:	d0 e2       	ldi	r29, 0x20	; 32
    bfe6:	37 c0       	rjmp	.+110    	; 0xc056 <U1I_case703+0xa2>
				lwtmp = 0x2000;
		}
		else{
			if(gRx1Buf[RX1_BUF_SIZE-2] == 1){
    bfe8:	80 91 af 0e 	lds	r24, 0x0EAF
    bfec:	81 30       	cpi	r24, 0x01	; 1
    bfee:	b1 f4       	brne	.+44     	; 0xc01c <U1I_case703+0x68>
				lwtmp = eM_Addr[gDownNumOfM-1] + eM_FSize[gDownNumOfM-1];
    bff0:	f0 e0       	ldi	r31, 0x00	; 0
    bff2:	31 97       	sbiw	r30, 0x01	; 1
    bff4:	ee 0f       	add	r30, r30
    bff6:	ff 1f       	adc	r31, r31
    bff8:	df 01       	movw	r26, r30
    bffa:	a8 56       	subi	r26, 0x68	; 104
    bffc:	bb 4f       	sbci	r27, 0xFB	; 251
    bffe:	2d 91       	ld	r18, X+
    c000:	3c 91       	ld	r19, X
				lwtmp = lwtmp + 64 - (eM_FSize[gDownNumOfM-1]%64);
    c002:	e0 59       	subi	r30, 0x90	; 144
    c004:	fb 4f       	sbci	r31, 0xFB	; 251
    c006:	80 81       	ld	r24, Z
    c008:	91 81       	ldd	r25, Z+1	; 0x01
    c00a:	cc 27       	eor	r28, r28
    c00c:	dd 27       	eor	r29, r29
    c00e:	c8 1b       	sub	r28, r24
    c010:	d9 0b       	sbc	r29, r25
    c012:	c2 1b       	sub	r28, r18
    c014:	d3 0b       	sbc	r29, r19
    c016:	c0 54       	subi	r28, 0x40	; 64
    c018:	d0 4a       	sbci	r29, 0xA0	; 160
    c01a:	19 c0       	rjmp	.+50     	; 0xc04e <U1I_case703+0x9a>
				lwtmp = 0x6000 - lwtmp;
			}
			else if(gRx1Buf[RX1_BUF_SIZE-2] == 2){
    c01c:	82 30       	cpi	r24, 0x02	; 2
    c01e:	d9 f4       	brne	.+54     	; 0xc056 <U1I_case703+0xa2>
				lwtmp = eA_Addr[gDownNumOfA-1] + eA_FSize[gDownNumOfA-1];
    c020:	e0 91 49 0e 	lds	r30, 0x0E49
    c024:	f0 e0       	ldi	r31, 0x00	; 0
    c026:	31 97       	sbiw	r30, 0x01	; 1
    c028:	ee 0f       	add	r30, r30
    c02a:	ff 1f       	adc	r31, r31
    c02c:	df 01       	movw	r26, r30
    c02e:	ac 52       	subi	r26, 0x2C	; 44
    c030:	bb 4f       	sbci	r27, 0xFB	; 251
    c032:	2d 91       	ld	r18, X+
    c034:	3c 91       	ld	r19, X
				lwtmp = lwtmp + 64 - (eA_FSize[gDownNumOfA-1]%64);
    c036:	e0 54       	subi	r30, 0x40	; 64
    c038:	fb 4f       	sbci	r31, 0xFB	; 251
    c03a:	80 81       	ld	r24, Z
    c03c:	91 81       	ldd	r25, Z+1	; 0x01
    c03e:	cc 27       	eor	r28, r28
    c040:	dd 27       	eor	r29, r29
    c042:	c8 1b       	sub	r28, r24
    c044:	d9 0b       	sbc	r29, r25
    c046:	c2 1b       	sub	r28, r18
    c048:	d3 0b       	sbc	r29, r19
    c04a:	c0 54       	subi	r28, 0x40	; 64
    c04c:	d0 48       	sbci	r29, 0x80	; 128
				lwtmp = 0x8000 - lwtmp;
    c04e:	2f 73       	andi	r18, 0x3F	; 63
    c050:	30 70       	andi	r19, 0x00	; 0
    c052:	c2 0f       	add	r28, r18
    c054:	d3 1f       	adc	r29, r19
			}
		}
		SendToPC(15,4);
    c056:	64 e0       	ldi	r22, 0x04	; 4
    c058:	8f e0       	ldi	r24, 0x0F	; 15
    c05a:	0e 94 af 5e 	call	0xbd5e	; 0xbd5e <SendToPC>
		gFileCheckSum = 0;
    c05e:	10 92 b6 0e 	sts	0x0EB6, r1
}


void	sciTx1Data(BYTE x)
{
	uartSendByte(x);
    c062:	80 e0       	ldi	r24, 0x00	; 0
    c064:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
		gFileCheckSum = 0;
		sciTx1Data(0x00);
		sciTx1Data(0x00);
		lbtmp = (BYTE)((lwtmp>>8) & 0xFF);
		sciTx1Data(lbtmp);
		gFileCheckSum ^= lbtmp;
    c068:	80 e0       	ldi	r24, 0x00	; 0
    c06a:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
    c06e:	8d 2f       	mov	r24, r29
    c070:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
    c074:	80 91 b6 0e 	lds	r24, 0x0EB6
    c078:	8d 27       	eor	r24, r29
    c07a:	80 93 b6 0e 	sts	0x0EB6, r24
}


void	sciTx1Data(BYTE x)
{
	uartSendByte(x);
    c07e:	8c 2f       	mov	r24, r28
    c080:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
		lbtmp = (BYTE)((lwtmp>>8) & 0xFF);
		sciTx1Data(lbtmp);
		gFileCheckSum ^= lbtmp;
		lbtmp = (BYTE)(lwtmp & 0xFF);
		sciTx1Data(lbtmp);
		gFileCheckSum ^= lbtmp;
    c084:	80 91 b6 0e 	lds	r24, 0x0EB6
    c088:	8c 27       	eor	r24, r28
    c08a:	80 93 b6 0e 	sts	0x0EB6, r24
}


void	sciTx1Data(BYTE x)
{
	uartSendByte(x);
    c08e:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
		lbtmp = (BYTE)(lwtmp & 0xFF);
		sciTx1Data(lbtmp);
		gFileCheckSum ^= lbtmp;
		sciTx1Data(gFileCheckSum);
	}
	gRx1Step = 0;
    c092:	10 92 56 0e 	sts	0x0E56, r1
    c096:	10 92 55 0e 	sts	0x0E55, r1
	F_DOWNLOAD = 0;
    c09a:	10 92 81 0a 	sts	0x0A81, r1
	RUN_LED2_OFF;
    c09e:	de 9a       	sbi	0x1b, 6	; 27
}
    c0a0:	df 91       	pop	r29
    c0a2:	cf 91       	pop	r28
    c0a4:	1f 91       	pop	r17
    c0a6:	08 95       	ret

0000c0a8 <U1I_case303>:
		RUN_LED2_OFF;
	}
}

void U1I_case303(void)
{
    c0a8:	cf 93       	push	r28
    c0aa:	df 93       	push	r29
	int		i;
	if(gRxData == 1){
    c0ac:	80 91 bb 0e 	lds	r24, 0x0EBB
    c0b0:	81 30       	cpi	r24, 0x01	; 1
    c0b2:	c1 f4       	brne	.+48     	; 0xc0e4 <U1I_case303+0x3c>
		SendToPC(11,16);
    c0b4:	60 e1       	ldi	r22, 0x10	; 16
    c0b6:	8b e0       	ldi	r24, 0x0B	; 11
    c0b8:	0e 94 af 5e 	call	0xbd5e	; 0xbd5e <SendToPC>
		gFileCheckSum = 0;
    c0bc:	10 92 b6 0e 	sts	0x0EB6, r1
    c0c0:	c1 e4       	ldi	r28, 0x41	; 65
    c0c2:	d4 e0       	ldi	r29, 0x04	; 4
}


void	sciTx1Data(BYTE x)
{
	uartSendByte(x);
    c0c4:	88 81       	ld	r24, Y
    c0c6:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
	if(gRxData == 1){
		SendToPC(11,16);
		gFileCheckSum = 0;
		for(i = 0; i < 16; i++){
			sciTx1Data(eM_OriginPose[i]);
			gFileCheckSum ^= eM_OriginPose[i];
    c0ca:	90 91 b6 0e 	lds	r25, 0x0EB6
    c0ce:	89 91       	ld	r24, Y+
    c0d0:	98 27       	eor	r25, r24
    c0d2:	90 93 b6 0e 	sts	0x0EB6, r25
{
	int		i;
	if(gRxData == 1){
		SendToPC(11,16);
		gFileCheckSum = 0;
		for(i = 0; i < 16; i++){
    c0d6:	84 e0       	ldi	r24, 0x04	; 4
    c0d8:	c1 35       	cpi	r28, 0x51	; 81
    c0da:	d8 07       	cpc	r29, r24
    c0dc:	99 f7       	brne	.-26     	; 0xc0c4 <U1I_case303+0x1c>
}


void	sciTx1Data(BYTE x)
{
	uartSendByte(x);
    c0de:	89 2f       	mov	r24, r25
    c0e0:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
			sciTx1Data(eM_OriginPose[i]);
			gFileCheckSum ^= eM_OriginPose[i];
		}
		sciTx1Data(gFileCheckSum);
	}
	gRx1Step = 0;
    c0e4:	10 92 56 0e 	sts	0x0E56, r1
    c0e8:	10 92 55 0e 	sts	0x0E55, r1
	F_DOWNLOAD = 0;
    c0ec:	10 92 81 0a 	sts	0x0A81, r1
	RUN_LED2_OFF;
    c0f0:	de 9a       	sbi	0x1b, 6	; 27
}
    c0f2:	df 91       	pop	r29
    c0f4:	cf 91       	pop	r28
    c0f6:	08 95       	ret

0000c0f8 <process_read>:
//------------------------------------------------------------------------------
// event driven
//------------------------------------------------------------------------------

void process_read()
{
    c0f8:	1f 93       	push	r17
    WORD    i;
    
    //gRxData = UDR1;
	if(F_DIRECT_C_EN){
    c0fa:	80 91 ba 0e 	lds	r24, 0x0EBA
    c0fe:	88 23       	and	r24, r24
    c100:	09 f4       	brne	.+2      	; 0xc104 <process_read+0xc>
    c102:	67 c0       	rjmp	.+206    	; 0xc1d2 <process_read+0xda>
		//while( (UCSR0A & DATA_REGISTER_EMPTY) == 0 );
		//UDR0 = gRxData;
		
		gRxData = uartGetByte();
    c104:	0e 94 9c 22 	call	0x4538	; 0x4538 <uartGetByte>
    c108:	28 2f       	mov	r18, r24
    c10a:	80 93 bb 0e 	sts	0x0EBB, r24
				
		if(gRxData == 0xff){
    c10e:	8f 3f       	cpi	r24, 0xFF	; 255
    c110:	49 f4       	brne	.+18     	; 0xc124 <process_read+0x2c>
			gRx1_DStep = 1;
    c112:	81 e0       	ldi	r24, 0x01	; 1
    c114:	90 e0       	ldi	r25, 0x00	; 0
    c116:	90 93 50 0e 	sts	0x0E50, r25
    c11a:	80 93 4f 0e 	sts	0x0E4F, r24
			gFileCheckSum = 0;
    c11e:	10 92 b6 0e 	sts	0x0EB6, r1
    c122:	22 c4       	rjmp	.+2116   	; 0xc968 <process_read+0x870>
			return;
		}

		
		switch(gRx1_DStep){
    c124:	80 91 4f 0e 	lds	r24, 0x0E4F
    c128:	90 91 50 0e 	lds	r25, 0x0E50
    c12c:	83 30       	cpi	r24, 0x03	; 3
    c12e:	91 05       	cpc	r25, r1
    c130:	d9 f0       	breq	.+54     	; 0xc168 <process_read+0x70>
    c132:	84 30       	cpi	r24, 0x04	; 4
    c134:	91 05       	cpc	r25, r1
    c136:	38 f4       	brcc	.+14     	; 0xc146 <process_read+0x4e>
    c138:	81 30       	cpi	r24, 0x01	; 1
    c13a:	91 05       	cpc	r25, r1
    c13c:	59 f0       	breq	.+22     	; 0xc154 <process_read+0x5c>
    c13e:	02 97       	sbiw	r24, 0x02	; 2
    c140:	09 f0       	breq	.+2      	; 0xc144 <process_read+0x4c>
    c142:	12 c4       	rjmp	.+2084   	; 0xc968 <process_read+0x870>
    c144:	0c c0       	rjmp	.+24     	; 0xc15e <process_read+0x66>
    c146:	84 30       	cpi	r24, 0x04	; 4
    c148:	91 05       	cpc	r25, r1
    c14a:	19 f1       	breq	.+70     	; 0xc192 <process_read+0x9a>
    c14c:	05 97       	sbiw	r24, 0x05	; 5
    c14e:	09 f0       	breq	.+2      	; 0xc152 <process_read+0x5a>
    c150:	0b c4       	rjmp	.+2070   	; 0xc968 <process_read+0x870>
    c152:	2c c0       	rjmp	.+88     	; 0xc1ac <process_read+0xb4>
			case 1:
				if(gRxData == 0xe0) gRx1_DStep = 2;
    c154:	20 3e       	cpi	r18, 0xE0	; 224
    c156:	89 f4       	brne	.+34     	; 0xc17a <process_read+0x82>
    c158:	82 e0       	ldi	r24, 0x02	; 2
    c15a:	90 e0       	ldi	r25, 0x00	; 0
    c15c:	09 c0       	rjmp	.+18     	; 0xc170 <process_read+0x78>
				else gRx1_DStep = 0;
				gFileCheckSum ^= gRxData;
				break;
			case 2:
				if(gRxData == 251) gRx1_DStep = 3;
    c15e:	2b 3f       	cpi	r18, 0xFB	; 251
    c160:	61 f4       	brne	.+24     	; 0xc17a <process_read+0x82>
    c162:	83 e0       	ldi	r24, 0x03	; 3
    c164:	90 e0       	ldi	r25, 0x00	; 0
    c166:	04 c0       	rjmp	.+8      	; 0xc170 <process_read+0x78>
				else gRx1_DStep = 0;
				gFileCheckSum ^= gRxData;
				break;
			case 3:
				if(gRxData == 1) gRx1_DStep = 4;
    c168:	21 30       	cpi	r18, 0x01	; 1
    c16a:	39 f4       	brne	.+14     	; 0xc17a <process_read+0x82>
    c16c:	84 e0       	ldi	r24, 0x04	; 4
    c16e:	90 e0       	ldi	r25, 0x00	; 0
    c170:	90 93 50 0e 	sts	0x0E50, r25
    c174:	80 93 4f 0e 	sts	0x0E4F, r24
    c178:	04 c0       	rjmp	.+8      	; 0xc182 <process_read+0x8a>
				else gRx1_DStep = 0;
    c17a:	10 92 50 0e 	sts	0x0E50, r1
    c17e:	10 92 4f 0e 	sts	0x0E4F, r1
				gFileCheckSum ^= gRxData;
    c182:	80 91 b6 0e 	lds	r24, 0x0EB6
    c186:	90 91 bb 0e 	lds	r25, 0x0EBB
    c18a:	89 27       	eor	r24, r25
    c18c:	80 93 b6 0e 	sts	0x0EB6, r24
    c190:	eb c3       	rjmp	.+2006   	; 0xc968 <process_read+0x870>
				break;
			case 4:
				gRx1_DStep = 5;
    c192:	85 e0       	ldi	r24, 0x05	; 5
    c194:	90 e0       	ldi	r25, 0x00	; 0
    c196:	90 93 50 0e 	sts	0x0E50, r25
    c19a:	80 93 4f 0e 	sts	0x0E4F, r24
				gFileCheckSum ^= gRxData;
				gFileCheckSum &= 0x7F;
    c19e:	80 91 b6 0e 	lds	r24, 0x0EB6
    c1a2:	28 27       	eor	r18, r24
    c1a4:	2f 77       	andi	r18, 0x7F	; 127
    c1a6:	20 93 b6 0e 	sts	0x0EB6, r18
    c1aa:	de c3       	rjmp	.+1980   	; 0xc968 <process_read+0x870>
				break;
			case 5:
				if(gRxData == gFileCheckSum){
    c1ac:	80 91 b6 0e 	lds	r24, 0x0EB6
    c1b0:	28 17       	cp	r18, r24
    c1b2:	51 f4       	brne	.+20     	; 0xc1c8 <process_read+0xd0>
				    TIMSK |= 0x01;
    c1b4:	87 b7       	in	r24, 0x37	; 55
    c1b6:	81 60       	ori	r24, 0x01	; 1
    c1b8:	87 bf       	out	0x37, r24	; 55
					EIMSK |= 0x40;
    c1ba:	89 b7       	in	r24, 0x39	; 57
    c1bc:	80 64       	ori	r24, 0x40	; 64
    c1be:	89 bf       	out	0x39, r24	; 57
					UCSR0B &= 0x7F;
    c1c0:	57 98       	cbi	0x0a, 7	; 10
					UCSR0B |= 0x40;
    c1c2:	56 9a       	sbi	0x0a, 6	; 10
					F_DIRECT_C_EN = 0;
    c1c4:	10 92 ba 0e 	sts	0x0EBA, r1
				}
				gRx1_DStep = 0;
    c1c8:	10 92 50 0e 	sts	0x0E50, r1
    c1cc:	10 92 4f 0e 	sts	0x0E4F, r1
    c1d0:	cb c3       	rjmp	.+1942   	; 0xc968 <process_read+0x870>
    c1d2:	ed e9       	ldi	r30, 0x9D	; 157
    c1d4:	fe e0       	ldi	r31, 0x0E	; 14
		return;
	}
	//UCSR0B &= 0xBF;
	//EIMSK &= 0xBF;

   	for(i = 1; i < RX1_BUF_SIZE; i++) gRx1Buf[i-1] = gRx1Buf[i];
    c1d6:	81 81       	ldd	r24, Z+1	; 0x01
    c1d8:	81 93       	st	Z+, r24
    c1da:	2e e0       	ldi	r18, 0x0E	; 14
    c1dc:	e0 3b       	cpi	r30, 0xB0	; 176
    c1de:	f2 07       	cpc	r31, r18
    c1e0:	d1 f7       	brne	.-12     	; 0xc1d6 <process_read+0xde>
   	gRx1Buf[RX1_BUF_SIZE-1] = gRxData;
    c1e2:	20 91 bb 0e 	lds	r18, 0x0EBB
    c1e6:	20 83       	st	Z, r18

    if(F_DOWNLOAD == 0
    c1e8:	80 91 81 0a 	lds	r24, 0x0A81
    c1ec:	88 23       	and	r24, r24
    c1ee:	49 f5       	brne	.+82     	; 0xc242 <process_read+0x14a>
    c1f0:	80 91 a9 0e 	lds	r24, 0x0EA9
    c1f4:	8f 3f       	cpi	r24, 0xFF	; 255
    c1f6:	29 f5       	brne	.+74     	; 0xc242 <process_read+0x14a>
    c1f8:	80 91 aa 0e 	lds	r24, 0x0EAA
    c1fc:	8f 3f       	cpi	r24, 0xFF	; 255
    c1fe:	09 f5       	brne	.+66     	; 0xc242 <process_read+0x14a>
    c200:	80 91 ab 0e 	lds	r24, 0x0EAB
    c204:	8a 3a       	cpi	r24, 0xAA	; 170
    c206:	e9 f4       	brne	.+58     	; 0xc242 <process_read+0x14a>
    c208:	80 91 ac 0e 	lds	r24, 0x0EAC
    c20c:	85 35       	cpi	r24, 0x55	; 85
    c20e:	c9 f4       	brne	.+50     	; 0xc242 <process_read+0x14a>
    c210:	80 91 ad 0e 	lds	r24, 0x0EAD
    c214:	8a 3a       	cpi	r24, 0xAA	; 170
    c216:	a9 f4       	brne	.+42     	; 0xc242 <process_read+0x14a>
    c218:	80 91 ae 0e 	lds	r24, 0x0EAE
    c21c:	85 35       	cpi	r24, 0x55	; 85
    c21e:	89 f4       	brne	.+34     	; 0xc242 <process_read+0x14a>
    c220:	80 91 af 0e 	lds	r24, 0x0EAF
    c224:	87 33       	cpi	r24, 0x37	; 55
    c226:	69 f4       	brne	.+26     	; 0xc242 <process_read+0x14a>
    c228:	2a 3b       	cpi	r18, 0xBA	; 186
    c22a:	59 f4       	brne	.+22     	; 0xc242 <process_read+0x14a>
     && gRx1Buf[RX1_BUF_SIZE-5] == 0x55
     && gRx1Buf[RX1_BUF_SIZE-4] == 0xAA
     && gRx1Buf[RX1_BUF_SIZE-3] == 0x55
     && gRx1Buf[RX1_BUF_SIZE-2] == 0x37
     && gRx1Buf[RX1_BUF_SIZE-1] == 0xBA){
		F_DOWNLOAD = 1;
    c22c:	81 e0       	ldi	r24, 0x01	; 1
    c22e:	80 93 81 0a 	sts	0x0A81, r24
		F_RSV_SOUND_READ = 0;
    c232:	10 92 b3 0e 	sts	0x0EB3, r1
		F_RSV_BTN_READ = 0;
    c236:	10 92 98 0e 	sts	0x0E98, r1
		RUN_LED2_ON;
    c23a:	de 98       	cbi	0x1b, 6	; 27
		gRx1Step = 1;
    c23c:	81 e0       	ldi	r24, 0x01	; 1
    c23e:	90 e0       	ldi	r25, 0x00	; 0
    c240:	98 c1       	rjmp	.+816    	; 0xc572 <process_read+0x47a>
		UCSR0B |= 0x40;
		EIMSK |= 0x40;
		return;
	}

	switch(gRx1Step){          	
    c242:	80 91 55 0e 	lds	r24, 0x0E55
    c246:	90 91 56 0e 	lds	r25, 0x0E56
    c24a:	35 e0       	ldi	r19, 0x05	; 5
    c24c:	85 31       	cpi	r24, 0x15	; 21
    c24e:	93 07       	cpc	r25, r19
    c250:	09 f4       	brne	.+2      	; 0xc254 <process_read+0x15c>
    c252:	1b c2       	rjmp	.+1078   	; 0xc68a <process_read+0x592>
    c254:	35 e0       	ldi	r19, 0x05	; 5
    c256:	86 31       	cpi	r24, 0x16	; 22
    c258:	93 07       	cpc	r25, r19
    c25a:	08 f0       	brcs	.+2      	; 0xc25e <process_read+0x166>
    c25c:	9e c0       	rjmp	.+316    	; 0xc39a <process_read+0x2a2>
    c25e:	33 e0       	ldi	r19, 0x03	; 3
    c260:	83 32       	cpi	r24, 0x23	; 35
    c262:	93 07       	cpc	r25, r19
    c264:	09 f4       	brne	.+2      	; 0xc268 <process_read+0x170>
    c266:	aa c1       	rjmp	.+852    	; 0xc5bc <process_read+0x4c4>
    c268:	33 e0       	ldi	r19, 0x03	; 3
    c26a:	84 32       	cpi	r24, 0x24	; 36
    c26c:	93 07       	cpc	r25, r19
    c26e:	08 f0       	brcs	.+2      	; 0xc272 <process_read+0x17a>
    c270:	47 c0       	rjmp	.+142    	; 0xc300 <process_read+0x208>
    c272:	32 e0       	ldi	r19, 0x02	; 2
    c274:	88 35       	cpi	r24, 0x58	; 88
    c276:	93 07       	cpc	r25, r19
    c278:	09 f4       	brne	.+2      	; 0xc27c <process_read+0x184>
    c27a:	83 c1       	rjmp	.+774    	; 0xc582 <process_read+0x48a>
    c27c:	32 e0       	ldi	r19, 0x02	; 2
    c27e:	89 35       	cpi	r24, 0x59	; 89
    c280:	93 07       	cpc	r25, r19
    c282:	e0 f4       	brcc	.+56     	; 0xc2bc <process_read+0x1c4>
    c284:	31 e0       	ldi	r19, 0x01	; 1
    c286:	8d 32       	cpi	r24, 0x2D	; 45
    c288:	93 07       	cpc	r25, r19
    c28a:	09 f4       	brne	.+2      	; 0xc28e <process_read+0x196>
    c28c:	fe c1       	rjmp	.+1020   	; 0xc68a <process_read+0x592>
    c28e:	31 e0       	ldi	r19, 0x01	; 1
    c290:	8e 32       	cpi	r24, 0x2E	; 46
    c292:	93 07       	cpc	r25, r19
    c294:	48 f4       	brcc	.+18     	; 0xc2a8 <process_read+0x1b0>
    c296:	81 30       	cpi	r24, 0x01	; 1
    c298:	91 05       	cpc	r25, r1
    c29a:	09 f4       	brne	.+2      	; 0xc29e <process_read+0x1a6>
    c29c:	1d c1       	rjmp	.+570    	; 0xc4d8 <process_read+0x3e0>
    c29e:	8c 52       	subi	r24, 0x2C	; 44
    c2a0:	91 40       	sbci	r25, 0x01	; 1
    c2a2:	09 f0       	breq	.+2      	; 0xc2a6 <process_read+0x1ae>
    c2a4:	5d c3       	rjmp	.+1722   	; 0xc960 <process_read+0x868>
    c2a6:	5a c1       	rjmp	.+692    	; 0xc55c <process_read+0x464>
    c2a8:	31 e0       	ldi	r19, 0x01	; 1
    c2aa:	8e 32       	cpi	r24, 0x2E	; 46
    c2ac:	93 07       	cpc	r25, r19
    c2ae:	09 f4       	brne	.+2      	; 0xc2b2 <process_read+0x1ba>
    c2b0:	c7 c2       	rjmp	.+1422   	; 0xc840 <process_read+0x748>
    c2b2:	8f 52       	subi	r24, 0x2F	; 47
    c2b4:	91 40       	sbci	r25, 0x01	; 1
    c2b6:	09 f0       	breq	.+2      	; 0xc2ba <process_read+0x1c2>
    c2b8:	53 c3       	rjmp	.+1702   	; 0xc960 <process_read+0x868>
    c2ba:	60 c1       	rjmp	.+704    	; 0xc57c <process_read+0x484>
    c2bc:	32 e0       	ldi	r19, 0x02	; 2
    c2be:	8b 35       	cpi	r24, 0x5B	; 91
    c2c0:	93 07       	cpc	r25, r19
    c2c2:	09 f4       	brne	.+2      	; 0xc2c6 <process_read+0x1ce>
    c2c4:	46 c3       	rjmp	.+1676   	; 0xc952 <process_read+0x85a>
    c2c6:	32 e0       	ldi	r19, 0x02	; 2
    c2c8:	8c 35       	cpi	r24, 0x5C	; 92
    c2ca:	93 07       	cpc	r25, r19
    c2cc:	50 f4       	brcc	.+20     	; 0xc2e2 <process_read+0x1ea>
    c2ce:	32 e0       	ldi	r19, 0x02	; 2
    c2d0:	89 35       	cpi	r24, 0x59	; 89
    c2d2:	93 07       	cpc	r25, r19
    c2d4:	09 f4       	brne	.+2      	; 0xc2d8 <process_read+0x1e0>
    c2d6:	5e c1       	rjmp	.+700    	; 0xc594 <process_read+0x49c>
    c2d8:	8a 55       	subi	r24, 0x5A	; 90
    c2da:	92 40       	sbci	r25, 0x02	; 2
    c2dc:	09 f0       	breq	.+2      	; 0xc2e0 <process_read+0x1e8>
    c2de:	40 c3       	rjmp	.+1664   	; 0xc960 <process_read+0x868>
    c2e0:	5b c1       	rjmp	.+694    	; 0xc598 <process_read+0x4a0>
    c2e2:	33 e0       	ldi	r19, 0x03	; 3
    c2e4:	81 32       	cpi	r24, 0x21	; 33
    c2e6:	93 07       	cpc	r25, r19
    c2e8:	09 f4       	brne	.+2      	; 0xc2ec <process_read+0x1f4>
    c2ea:	cf c1       	rjmp	.+926    	; 0xc68a <process_read+0x592>
    c2ec:	33 e0       	ldi	r19, 0x03	; 3
    c2ee:	82 32       	cpi	r24, 0x22	; 34
    c2f0:	93 07       	cpc	r25, r19
    c2f2:	08 f0       	brcs	.+2      	; 0xc2f6 <process_read+0x1fe>
    c2f4:	a5 c2       	rjmp	.+1354   	; 0xc840 <process_read+0x748>
    c2f6:	80 52       	subi	r24, 0x20	; 32
    c2f8:	93 40       	sbci	r25, 0x03	; 3
    c2fa:	09 f0       	breq	.+2      	; 0xc2fe <process_read+0x206>
    c2fc:	31 c3       	rjmp	.+1634   	; 0xc960 <process_read+0x868>
    c2fe:	2e c1       	rjmp	.+604    	; 0xc55c <process_read+0x464>
    c300:	33 e0       	ldi	r19, 0x03	; 3
    c302:	8a 3e       	cpi	r24, 0xEA	; 234
    c304:	93 07       	cpc	r25, r19
    c306:	09 f4       	brne	.+2      	; 0xc30a <process_read+0x212>
    c308:	c4 c1       	rjmp	.+904    	; 0xc692 <process_read+0x59a>
    c30a:	33 e0       	ldi	r19, 0x03	; 3
    c30c:	8b 3e       	cpi	r24, 0xEB	; 235
    c30e:	93 07       	cpc	r25, r19
    c310:	10 f5       	brcc	.+68     	; 0xc356 <process_read+0x25e>
    c312:	33 e0       	ldi	r19, 0x03	; 3
    c314:	86 38       	cpi	r24, 0x86	; 134
    c316:	93 07       	cpc	r25, r19
    c318:	09 f4       	brne	.+2      	; 0xc31c <process_read+0x224>
    c31a:	84 c1       	rjmp	.+776    	; 0xc624 <process_read+0x52c>
    c31c:	33 e0       	ldi	r19, 0x03	; 3
    c31e:	87 38       	cpi	r24, 0x87	; 135
    c320:	93 07       	cpc	r25, r19
    c322:	50 f4       	brcc	.+20     	; 0xc338 <process_read+0x240>
    c324:	33 e0       	ldi	r19, 0x03	; 3
    c326:	84 38       	cpi	r24, 0x84	; 132
    c328:	93 07       	cpc	r25, r19
    c32a:	09 f4       	brne	.+2      	; 0xc32e <process_read+0x236>
    c32c:	72 c1       	rjmp	.+740    	; 0xc612 <process_read+0x51a>
    c32e:	85 58       	subi	r24, 0x85	; 133
    c330:	93 40       	sbci	r25, 0x03	; 3
    c332:	09 f0       	breq	.+2      	; 0xc336 <process_read+0x23e>
    c334:	15 c3       	rjmp	.+1578   	; 0xc960 <process_read+0x868>
    c336:	a9 c1       	rjmp	.+850    	; 0xc68a <process_read+0x592>
    c338:	33 e0       	ldi	r19, 0x03	; 3
    c33a:	88 3e       	cpi	r24, 0xE8	; 232
    c33c:	93 07       	cpc	r25, r19
    c33e:	09 f4       	brne	.+2      	; 0xc342 <process_read+0x24a>
    c340:	9b c1       	rjmp	.+822    	; 0xc678 <process_read+0x580>
    c342:	33 e0       	ldi	r19, 0x03	; 3
    c344:	89 3e       	cpi	r24, 0xE9	; 233
    c346:	93 07       	cpc	r25, r19
    c348:	08 f0       	brcs	.+2      	; 0xc34c <process_read+0x254>
    c34a:	9f c1       	rjmp	.+830    	; 0xc68a <process_read+0x592>
    c34c:	87 58       	subi	r24, 0x87	; 135
    c34e:	93 40       	sbci	r25, 0x03	; 3
    c350:	09 f0       	breq	.+2      	; 0xc354 <process_read+0x25c>
    c352:	06 c3       	rjmp	.+1548   	; 0xc960 <process_read+0x868>
    c354:	74 c1       	rjmp	.+744    	; 0xc63e <process_read+0x546>
    c356:	34 e0       	ldi	r19, 0x04	; 4
    c358:	81 3b       	cpi	r24, 0xB1	; 177
    c35a:	93 07       	cpc	r25, r19
    c35c:	09 f4       	brne	.+2      	; 0xc360 <process_read+0x268>
    c35e:	95 c1       	rjmp	.+810    	; 0xc68a <process_read+0x592>
    c360:	34 e0       	ldi	r19, 0x04	; 4
    c362:	82 3b       	cpi	r24, 0xB2	; 178
    c364:	93 07       	cpc	r25, r19
    c366:	50 f4       	brcc	.+20     	; 0xc37c <process_read+0x284>
    c368:	33 e0       	ldi	r19, 0x03	; 3
    c36a:	8b 3e       	cpi	r24, 0xEB	; 235
    c36c:	93 07       	cpc	r25, r19
    c36e:	09 f4       	brne	.+2      	; 0xc372 <process_read+0x27a>
    c370:	9d c1       	rjmp	.+826    	; 0xc6ac <process_read+0x5b4>
    c372:	80 5b       	subi	r24, 0xB0	; 176
    c374:	94 40       	sbci	r25, 0x04	; 4
    c376:	09 f0       	breq	.+2      	; 0xc37a <process_read+0x282>
    c378:	f3 c2       	rjmp	.+1510   	; 0xc960 <process_read+0x868>
    c37a:	f0 c0       	rjmp	.+480    	; 0xc55c <process_read+0x464>
    c37c:	34 e0       	ldi	r19, 0x04	; 4
    c37e:	83 3b       	cpi	r24, 0xB3	; 179
    c380:	93 07       	cpc	r25, r19
    c382:	09 f4       	brne	.+2      	; 0xc386 <process_read+0x28e>
    c384:	b9 c1       	rjmp	.+882    	; 0xc6f8 <process_read+0x600>
    c386:	34 e0       	ldi	r19, 0x04	; 4
    c388:	83 3b       	cpi	r24, 0xB3	; 179
    c38a:	93 07       	cpc	r25, r19
    c38c:	08 f4       	brcc	.+2      	; 0xc390 <process_read+0x298>
    c38e:	a9 c1       	rjmp	.+850    	; 0xc6e2 <process_read+0x5ea>
    c390:	84 51       	subi	r24, 0x14	; 20
    c392:	95 40       	sbci	r25, 0x05	; 5
    c394:	09 f0       	breq	.+2      	; 0xc398 <process_read+0x2a0>
    c396:	e4 c2       	rjmp	.+1480   	; 0xc960 <process_read+0x868>
    c398:	e1 c0       	rjmp	.+450    	; 0xc55c <process_read+0x464>
    c39a:	36 e0       	ldi	r19, 0x06	; 6
    c39c:	82 34       	cpi	r24, 0x42	; 66
    c39e:	93 07       	cpc	r25, r19
    c3a0:	09 f4       	brne	.+2      	; 0xc3a4 <process_read+0x2ac>
    c3a2:	2f c2       	rjmp	.+1118   	; 0xc802 <process_read+0x70a>
    c3a4:	36 e0       	ldi	r19, 0x06	; 6
    c3a6:	83 34       	cpi	r24, 0x43	; 67
    c3a8:	93 07       	cpc	r25, r19
    c3aa:	08 f0       	brcs	.+2      	; 0xc3ae <process_read+0x2b6>
    c3ac:	48 c0       	rjmp	.+144    	; 0xc43e <process_read+0x346>
    c3ae:	35 e0       	ldi	r19, 0x05	; 5
    c3b0:	8b 37       	cpi	r24, 0x7B	; 123
    c3b2:	93 07       	cpc	r25, r19
    c3b4:	09 f4       	brne	.+2      	; 0xc3b8 <process_read+0x2c0>
    c3b6:	e7 c1       	rjmp	.+974    	; 0xc786 <process_read+0x68e>
    c3b8:	35 e0       	ldi	r19, 0x05	; 5
    c3ba:	8c 37       	cpi	r24, 0x7C	; 124
    c3bc:	93 07       	cpc	r25, r19
    c3be:	e8 f4       	brcc	.+58     	; 0xc3fa <process_read+0x302>
    c3c0:	35 e0       	ldi	r19, 0x05	; 5
    c3c2:	88 37       	cpi	r24, 0x78	; 120
    c3c4:	93 07       	cpc	r25, r19
    c3c6:	09 f4       	brne	.+2      	; 0xc3ca <process_read+0x2d2>
    c3c8:	d5 c1       	rjmp	.+938    	; 0xc774 <process_read+0x67c>
    c3ca:	35 e0       	ldi	r19, 0x05	; 5
    c3cc:	89 37       	cpi	r24, 0x79	; 121
    c3ce:	93 07       	cpc	r25, r19
    c3d0:	50 f4       	brcc	.+20     	; 0xc3e6 <process_read+0x2ee>
    c3d2:	35 e0       	ldi	r19, 0x05	; 5
    c3d4:	86 31       	cpi	r24, 0x16	; 22
    c3d6:	93 07       	cpc	r25, r19
    c3d8:	09 f4       	brne	.+2      	; 0xc3dc <process_read+0x2e4>
    c3da:	b9 c1       	rjmp	.+882    	; 0xc74e <process_read+0x656>
    c3dc:	87 51       	subi	r24, 0x17	; 23
    c3de:	95 40       	sbci	r25, 0x05	; 5
    c3e0:	09 f0       	breq	.+2      	; 0xc3e4 <process_read+0x2ec>
    c3e2:	be c2       	rjmp	.+1404   	; 0xc960 <process_read+0x868>
    c3e4:	bf c1       	rjmp	.+894    	; 0xc764 <process_read+0x66c>
    c3e6:	35 e0       	ldi	r19, 0x05	; 5
    c3e8:	89 37       	cpi	r24, 0x79	; 121
    c3ea:	93 07       	cpc	r25, r19
    c3ec:	09 f4       	brne	.+2      	; 0xc3f0 <process_read+0x2f8>
    c3ee:	4d c1       	rjmp	.+666    	; 0xc68a <process_read+0x592>
    c3f0:	8a 57       	subi	r24, 0x7A	; 122
    c3f2:	95 40       	sbci	r25, 0x05	; 5
    c3f4:	09 f0       	breq	.+2      	; 0xc3f8 <process_read+0x300>
    c3f6:	b4 c2       	rjmp	.+1384   	; 0xc960 <process_read+0x868>
    c3f8:	23 c2       	rjmp	.+1094   	; 0xc840 <process_read+0x748>
    c3fa:	35 e0       	ldi	r19, 0x05	; 5
    c3fc:	8e 3d       	cpi	r24, 0xDE	; 222
    c3fe:	93 07       	cpc	r25, r19
    c400:	09 f4       	brne	.+2      	; 0xc404 <process_read+0x30c>
    c402:	d5 c1       	rjmp	.+938    	; 0xc7ae <process_read+0x6b6>
    c404:	35 e0       	ldi	r19, 0x05	; 5
    c406:	8f 3d       	cpi	r24, 0xDF	; 223
    c408:	93 07       	cpc	r25, r19
    c40a:	50 f4       	brcc	.+20     	; 0xc420 <process_read+0x328>
    c40c:	35 e0       	ldi	r19, 0x05	; 5
    c40e:	8c 3d       	cpi	r24, 0xDC	; 220
    c410:	93 07       	cpc	r25, r19
    c412:	09 f4       	brne	.+2      	; 0xc416 <process_read+0x31e>
    c414:	c1 c1       	rjmp	.+898    	; 0xc798 <process_read+0x6a0>
    c416:	8d 5d       	subi	r24, 0xDD	; 221
    c418:	95 40       	sbci	r25, 0x05	; 5
    c41a:	09 f0       	breq	.+2      	; 0xc41e <process_read+0x326>
    c41c:	a1 c2       	rjmp	.+1346   	; 0xc960 <process_read+0x868>
    c41e:	c5 c1       	rjmp	.+906    	; 0xc7aa <process_read+0x6b2>
    c420:	36 e0       	ldi	r19, 0x06	; 6
    c422:	80 34       	cpi	r24, 0x40	; 64
    c424:	93 07       	cpc	r25, r19
    c426:	09 f4       	brne	.+2      	; 0xc42a <process_read+0x332>
    c428:	e3 c1       	rjmp	.+966    	; 0xc7f0 <process_read+0x6f8>
    c42a:	36 e0       	ldi	r19, 0x06	; 6
    c42c:	81 34       	cpi	r24, 0x41	; 65
    c42e:	93 07       	cpc	r25, r19
    c430:	08 f0       	brcs	.+2      	; 0xc434 <process_read+0x33c>
    c432:	2b c1       	rjmp	.+598    	; 0xc68a <process_read+0x592>
    c434:	8f 5d       	subi	r24, 0xDF	; 223
    c436:	95 40       	sbci	r25, 0x05	; 5
    c438:	09 f0       	breq	.+2      	; 0xc43c <process_read+0x344>
    c43a:	92 c2       	rjmp	.+1316   	; 0xc960 <process_read+0x868>
    c43c:	cc c1       	rjmp	.+920    	; 0xc7d6 <process_read+0x6de>
    c43e:	37 e0       	ldi	r19, 0x07	; 7
    c440:	89 30       	cpi	r24, 0x09	; 9
    c442:	93 07       	cpc	r25, r19
    c444:	09 f4       	brne	.+2      	; 0xc448 <process_read+0x350>
    c446:	21 c1       	rjmp	.+578    	; 0xc68a <process_read+0x592>
    c448:	37 e0       	ldi	r19, 0x07	; 7
    c44a:	8a 30       	cpi	r24, 0x0A	; 10
    c44c:	93 07       	cpc	r25, r19
    c44e:	10 f5       	brcc	.+68     	; 0xc494 <process_read+0x39c>
    c450:	36 e0       	ldi	r19, 0x06	; 6
    c452:	85 3a       	cpi	r24, 0xA5	; 165
    c454:	93 07       	cpc	r25, r19
    c456:	09 f4       	brne	.+2      	; 0xc45a <process_read+0x362>
    c458:	18 c1       	rjmp	.+560    	; 0xc68a <process_read+0x592>
    c45a:	36 e0       	ldi	r19, 0x06	; 6
    c45c:	86 3a       	cpi	r24, 0xA6	; 166
    c45e:	93 07       	cpc	r25, r19
    c460:	50 f4       	brcc	.+20     	; 0xc476 <process_read+0x37e>
    c462:	36 e0       	ldi	r19, 0x06	; 6
    c464:	83 34       	cpi	r24, 0x43	; 67
    c466:	93 07       	cpc	r25, r19
    c468:	09 f4       	brne	.+2      	; 0xc46c <process_read+0x374>
    c46a:	d8 c1       	rjmp	.+944    	; 0xc81c <process_read+0x724>
    c46c:	84 5a       	subi	r24, 0xA4	; 164
    c46e:	96 40       	sbci	r25, 0x06	; 6
    c470:	09 f0       	breq	.+2      	; 0xc474 <process_read+0x37c>
    c472:	76 c2       	rjmp	.+1260   	; 0xc960 <process_read+0x868>
    c474:	73 c0       	rjmp	.+230    	; 0xc55c <process_read+0x464>
    c476:	36 e0       	ldi	r19, 0x06	; 6
    c478:	87 3a       	cpi	r24, 0xA7	; 167
    c47a:	93 07       	cpc	r25, r19
    c47c:	09 f4       	brne	.+2      	; 0xc480 <process_read+0x388>
    c47e:	d7 c1       	rjmp	.+942    	; 0xc82e <process_read+0x736>
    c480:	36 e0       	ldi	r19, 0x06	; 6
    c482:	87 3a       	cpi	r24, 0xA7	; 167
    c484:	93 07       	cpc	r25, r19
    c486:	08 f4       	brcc	.+2      	; 0xc48a <process_read+0x392>
    c488:	db c1       	rjmp	.+950    	; 0xc840 <process_read+0x748>
    c48a:	88 50       	subi	r24, 0x08	; 8
    c48c:	97 40       	sbci	r25, 0x07	; 7
    c48e:	09 f0       	breq	.+2      	; 0xc492 <process_read+0x39a>
    c490:	67 c2       	rjmp	.+1230   	; 0xc960 <process_read+0x868>
    c492:	64 c0       	rjmp	.+200    	; 0xc55c <process_read+0x464>
    c494:	38 e0       	ldi	r19, 0x08	; 8
    c496:	8c 3f       	cpi	r24, 0xFC	; 252
    c498:	93 07       	cpc	r25, r19
    c49a:	09 f4       	brne	.+2      	; 0xc49e <process_read+0x3a6>
    c49c:	21 c2       	rjmp	.+1090   	; 0xc8e0 <process_read+0x7e8>
    c49e:	38 e0       	ldi	r19, 0x08	; 8
    c4a0:	8d 3f       	cpi	r24, 0xFD	; 253
    c4a2:	93 07       	cpc	r25, r19
    c4a4:	50 f4       	brcc	.+20     	; 0xc4ba <process_read+0x3c2>
    c4a6:	37 e0       	ldi	r19, 0x07	; 7
    c4a8:	8a 30       	cpi	r24, 0x0A	; 10
    c4aa:	93 07       	cpc	r25, r19
    c4ac:	09 f4       	brne	.+2      	; 0xc4b0 <process_read+0x3b8>
    c4ae:	c8 c1       	rjmp	.+912    	; 0xc840 <process_read+0x748>
    c4b0:	8b 50       	subi	r24, 0x0B	; 11
    c4b2:	97 40       	sbci	r25, 0x07	; 7
    c4b4:	09 f0       	breq	.+2      	; 0xc4b8 <process_read+0x3c0>
    c4b6:	54 c2       	rjmp	.+1192   	; 0xc960 <process_read+0x868>
    c4b8:	ce c1       	rjmp	.+924    	; 0xc856 <process_read+0x75e>
    c4ba:	38 e0       	ldi	r19, 0x08	; 8
    c4bc:	8e 3f       	cpi	r24, 0xFE	; 254
    c4be:	93 07       	cpc	r25, r19
    c4c0:	09 f4       	brne	.+2      	; 0xc4c4 <process_read+0x3cc>
    c4c2:	17 c2       	rjmp	.+1070   	; 0xc8f2 <process_read+0x7fa>
    c4c4:	38 e0       	ldi	r19, 0x08	; 8
    c4c6:	8e 3f       	cpi	r24, 0xFE	; 254
    c4c8:	93 07       	cpc	r25, r19
    c4ca:	08 f4       	brcc	.+2      	; 0xc4ce <process_read+0x3d6>
    c4cc:	de c0       	rjmp	.+444    	; 0xc68a <process_read+0x592>
    c4ce:	8f 5f       	subi	r24, 0xFF	; 255
    c4d0:	98 40       	sbci	r25, 0x08	; 8
    c4d2:	09 f0       	breq	.+2      	; 0xc4d6 <process_read+0x3de>
    c4d4:	45 c2       	rjmp	.+1162   	; 0xc960 <process_read+0x868>
    c4d6:	17 c2       	rjmp	.+1070   	; 0xc906 <process_read+0x80e>
		case 1:
    	    if(gRxData == 11){
    c4d8:	2b 30       	cpi	r18, 0x0B	; 11
    c4da:	19 f4       	brne	.+6      	; 0xc4e2 <process_read+0x3ea>
    	        gRx1Step = 300;
    c4dc:	8c e2       	ldi	r24, 0x2C	; 44
    c4de:	91 e0       	ldi	r25, 0x01	; 1
    c4e0:	48 c0       	rjmp	.+144    	; 0xc572 <process_read+0x47a>
    	    }
    	    else if(gRxData == 14){
    c4e2:	2e 30       	cpi	r18, 0x0E	; 14
    c4e4:	19 f4       	brne	.+6      	; 0xc4ec <process_read+0x3f4>
    	        gRx1Step = 600;
    c4e6:	88 e5       	ldi	r24, 0x58	; 88
    c4e8:	92 e0       	ldi	r25, 0x02	; 2
    c4ea:	43 c0       	rjmp	.+134    	; 0xc572 <process_read+0x47a>
    	    }
    	    else if(gRxData == 16){
    c4ec:	20 31       	cpi	r18, 0x10	; 16
    c4ee:	19 f4       	brne	.+6      	; 0xc4f6 <process_read+0x3fe>
    	        gRx1Step = 800;
    c4f0:	80 e2       	ldi	r24, 0x20	; 32
    c4f2:	93 e0       	ldi	r25, 0x03	; 3
    c4f4:	3e c0       	rjmp	.+124    	; 0xc572 <process_read+0x47a>
    	    }
    	    else if(gRxData == 17){
    c4f6:	21 31       	cpi	r18, 0x11	; 17
    c4f8:	19 f4       	brne	.+6      	; 0xc500 <process_read+0x408>
    	        gRx1Step = 900;
    c4fa:	84 e8       	ldi	r24, 0x84	; 132
    c4fc:	93 e0       	ldi	r25, 0x03	; 3
    c4fe:	39 c0       	rjmp	.+114    	; 0xc572 <process_read+0x47a>
    	    }
    	    else if(gRxData == 18){
    c500:	22 31       	cpi	r18, 0x12	; 18
    c502:	19 f4       	brne	.+6      	; 0xc50a <process_read+0x412>
    	        gRx1Step = 1000;
    c504:	88 ee       	ldi	r24, 0xE8	; 232
    c506:	93 e0       	ldi	r25, 0x03	; 3
    c508:	34 c0       	rjmp	.+104    	; 0xc572 <process_read+0x47a>
    	    }
    	    else if(gRxData == 20){
    c50a:	24 31       	cpi	r18, 0x14	; 20
    c50c:	19 f4       	brne	.+6      	; 0xc514 <process_read+0x41c>
    	        gRx1Step = 1200;
    c50e:	80 eb       	ldi	r24, 0xB0	; 176
    c510:	94 e0       	ldi	r25, 0x04	; 4
    c512:	2f c0       	rjmp	.+94     	; 0xc572 <process_read+0x47a>
    	    }
    	    else if(gRxData == 21){
    c514:	25 31       	cpi	r18, 0x15	; 21
    c516:	19 f4       	brne	.+6      	; 0xc51e <process_read+0x426>
    	        gRx1Step = 1300;
    c518:	84 e1       	ldi	r24, 0x14	; 20
    c51a:	95 e0       	ldi	r25, 0x05	; 5
    c51c:	2a c0       	rjmp	.+84     	; 0xc572 <process_read+0x47a>
    	    }
    	    else if(gRxData == 22){
    c51e:	26 31       	cpi	r18, 0x16	; 22
    c520:	19 f4       	brne	.+6      	; 0xc528 <process_read+0x430>
    	        gRx1Step = 1400;
    c522:	88 e7       	ldi	r24, 0x78	; 120
    c524:	95 e0       	ldi	r25, 0x05	; 5
    c526:	25 c0       	rjmp	.+74     	; 0xc572 <process_read+0x47a>
    	    }
    	    else if(gRxData == 23){
    c528:	27 31       	cpi	r18, 0x17	; 23
    c52a:	19 f4       	brne	.+6      	; 0xc532 <process_read+0x43a>
    	        gRx1Step = 1500;
    c52c:	8c ed       	ldi	r24, 0xDC	; 220
    c52e:	95 e0       	ldi	r25, 0x05	; 5
    c530:	20 c0       	rjmp	.+64     	; 0xc572 <process_read+0x47a>
    	    }
    	    else if(gRxData == 24){
    c532:	28 31       	cpi	r18, 0x18	; 24
    c534:	19 f4       	brne	.+6      	; 0xc53c <process_read+0x444>
    	        gRx1Step = 1600;
    c536:	80 e4       	ldi	r24, 0x40	; 64
    c538:	96 e0       	ldi	r25, 0x06	; 6
    c53a:	1b c0       	rjmp	.+54     	; 0xc572 <process_read+0x47a>
    	    }   
    	    else if(gRxData == 25){
    c53c:	29 31       	cpi	r18, 0x19	; 25
    c53e:	19 f4       	brne	.+6      	; 0xc546 <process_read+0x44e>
    	        gRx1Step = 1700;
    c540:	84 ea       	ldi	r24, 0xA4	; 164
    c542:	96 e0       	ldi	r25, 0x06	; 6
    c544:	16 c0       	rjmp	.+44     	; 0xc572 <process_read+0x47a>
    	    }
    	    else if(gRxData == 26){
    c546:	2a 31       	cpi	r18, 0x1A	; 26
    c548:	19 f4       	brne	.+6      	; 0xc550 <process_read+0x458>
    	        gRx1Step = 1800;
    c54a:	88 e0       	ldi	r24, 0x08	; 8
    c54c:	97 e0       	ldi	r25, 0x07	; 7
    c54e:	11 c0       	rjmp	.+34     	; 0xc572 <process_read+0x47a>
    	    }
    	    else if(gRxData == 31){
    c550:	2f 31       	cpi	r18, 0x1F	; 31
    c552:	09 f0       	breq	.+2      	; 0xc556 <process_read+0x45e>
    c554:	fe c1       	rjmp	.+1020   	; 0xc952 <process_read+0x85a>
    	        gRx1Step = 2300;
    c556:	8c ef       	ldi	r24, 0xFC	; 252
    c558:	98 e0       	ldi	r25, 0x08	; 8
    c55a:	0b c0       	rjmp	.+22     	; 0xc572 <process_read+0x47a>
	sciTx1Data(CSize);
}

void U1I_case100(void)
{
	Motion.PF = gRxData;
    c55c:	20 93 ae 0b 	sts	0x0BAE, r18
	gFieldIdx = 0;
    c560:	10 92 45 0e 	sts	0x0E45, r1
    c564:	10 92 44 0e 	sts	0x0E44, r1
	gRx1Step++;
    c568:	80 91 55 0e 	lds	r24, 0x0E55
    c56c:	90 91 56 0e 	lds	r25, 0x0E56
    c570:	01 96       	adiw	r24, 0x01	; 1
    c572:	90 93 56 0e 	sts	0x0E56, r25
    c576:	80 93 55 0e 	sts	0x0E55, r24
    c57a:	f2 c1       	rjmp	.+996    	; 0xc960 <process_read+0x868>
       	 	break;
    	case 302:
			U1I_case302();
       	 	break;
    	case 303:
    		U1I_case303();
    c57c:	0e 94 54 60 	call	0xc0a8	; 0xc0a8 <U1I_case303>
    c580:	ef c1       	rjmp	.+990    	; 0xc960 <process_read+0x868>
	sciTx1Data(CSize);
}

void U1I_case100(void)
{
	Motion.PF = gRxData;
    c582:	20 93 ae 0b 	sts	0x0BAE, r18
	gFieldIdx = 0;
    c586:	10 92 45 0e 	sts	0x0E45, r1
    c58a:	10 92 44 0e 	sts	0x0E44, r1
	gRx1Step++;
    c58e:	89 e5       	ldi	r24, 0x59	; 89
    c590:	92 e0       	ldi	r25, 0x02	; 2
    c592:	ef cf       	rjmp	.-34     	; 0xc572 <process_read+0x47a>
       	 	break;
    	case 600:
			U1I_case100();
    	    break;
    	case 601:
			U1I_case301(16);
    c594:	80 e1       	ldi	r24, 0x10	; 16
    c596:	7a c0       	rjmp	.+244    	; 0xc68c <process_read+0x594>
}


void U1I_case502(BYTE LC)
{
	gFileCheckSum ^= gRxData;
    c598:	80 91 b6 0e 	lds	r24, 0x0EB6
    c59c:	82 27       	eor	r24, r18
    c59e:	80 93 b6 0e 	sts	0x0EB6, r24
	gFieldIdx++;
    c5a2:	80 91 44 0e 	lds	r24, 0x0E44
    c5a6:	90 91 45 0e 	lds	r25, 0x0E45
    c5aa:	01 96       	adiw	r24, 0x01	; 1
    c5ac:	90 93 45 0e 	sts	0x0E45, r25
    c5b0:	80 93 44 0e 	sts	0x0E44, r24
	if(gFieldIdx == LC){
    c5b4:	40 97       	sbiw	r24, 0x10	; 16
    c5b6:	09 f0       	breq	.+2      	; 0xc5ba <process_read+0x4c2>
    c5b8:	d3 c1       	rjmp	.+934    	; 0xc960 <process_read+0x868>
    c5ba:	d6 cf       	rjmp	.-84     	; 0xc568 <process_read+0x470>
       	 	break;
    	case 802:
			U1I_case302();
       	 	break;
    	case 803:
			if(gFileCheckSum == gRxData){
    c5bc:	80 91 b6 0e 	lds	r24, 0x0EB6
    c5c0:	82 17       	cp	r24, r18
    c5c2:	09 f0       	breq	.+2      	; 0xc5c6 <process_read+0x4ce>
    c5c4:	c6 c1       	rjmp	.+908    	; 0xc952 <process_read+0x85a>
				SendToPC(16,1);
    c5c6:	61 e0       	ldi	r22, 0x01	; 1
    c5c8:	80 e1       	ldi	r24, 0x10	; 16
    c5ca:	0e 94 af 5e 	call	0xbd5e	; 0xbd5e <SendToPC>
				gFileCheckSum = 0;
    c5ce:	10 92 b6 0e 	sts	0x0EB6, r1
}


void	sciTx1Data(BYTE x)
{
	uartSendByte(x);
    c5d2:	81 e0       	ldi	r24, 0x01	; 1
    c5d4:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
    	case 803:
			if(gFileCheckSum == gRxData){
				SendToPC(16,1);
				gFileCheckSum = 0;
				sciTx1Data(0x01);
				gFileCheckSum ^= 0x01;
    c5d8:	80 91 b6 0e 	lds	r24, 0x0EB6
    c5dc:	11 e0       	ldi	r17, 0x01	; 1
    c5de:	81 27       	eor	r24, r17
    c5e0:	80 93 b6 0e 	sts	0x0EB6, r24
}


void	sciTx1Data(BYTE x)
{
	uartSendByte(x);
    c5e4:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
				SendToPC(16,1);
				gFileCheckSum = 0;
				sciTx1Data(0x01);
				gFileCheckSum ^= 0x01;
				sciTx1Data(gFileCheckSum);
				gRx1Step = 0;
    c5e8:	10 92 56 0e 	sts	0x0E56, r1
    c5ec:	10 92 55 0e 	sts	0x0E55, r1
				F_DOWNLOAD = 0;
    c5f0:	10 92 81 0a 	sts	0x0A81, r1
				RUN_LED2_OFF;
    c5f4:	de 9a       	sbi	0x1b, 6	; 27
			    TIMSK &= 0xFE;
    c5f6:	87 b7       	in	r24, 0x37	; 55
    c5f8:	8e 7f       	andi	r24, 0xFE	; 254
    c5fa:	87 bf       	out	0x37, r24	; 55
				EIMSK &= 0xBF;
    c5fc:	89 b7       	in	r24, 0x39	; 57
    c5fe:	8f 7b       	andi	r24, 0xBF	; 191
    c600:	89 bf       	out	0x39, r24	; 57
				UCSR0B |= 0x80;
    c602:	57 9a       	sbi	0x0a, 7	; 10
				UCSR0B &= 0xBF;
    c604:	56 98       	cbi	0x0a, 6	; 10
				F_DIRECT_C_EN = 1;
    c606:	10 93 ba 0e 	sts	0x0EBA, r17
				PF1_LED1_ON;
    c60a:	da 98       	cbi	0x1b, 2	; 27
				PF1_LED2_OFF;
    c60c:	db 9a       	sbi	0x1b, 3	; 27
				PF2_LED_ON;
    c60e:	dc 98       	cbi	0x1b, 4	; 27
    c610:	ab c1       	rjmp	.+854    	; 0xc968 <process_read+0x870>
	sciTx1Data(CSize);
}

void U1I_case100(void)
{
	Motion.PF = gRxData;
    c612:	20 93 ae 0b 	sts	0x0BAE, r18
	gFieldIdx = 0;
    c616:	10 92 45 0e 	sts	0x0E45, r1
    c61a:	10 92 44 0e 	sts	0x0E44, r1
	gRx1Step++;
    c61e:	85 e8       	ldi	r24, 0x85	; 133
    c620:	93 e0       	ldi	r25, 0x03	; 3
    c622:	a7 cf       	rjmp	.-178    	; 0xc572 <process_read+0x47a>
	}
}

void U1I_case302(void)
{
	gFileCheckSum ^= gRxData;
    c624:	80 91 b6 0e 	lds	r24, 0x0EB6
    c628:	82 27       	eor	r24, r18
    c62a:	80 93 b6 0e 	sts	0x0EB6, r24
	if(gRxData == 1)
    c62e:	80 91 bb 0e 	lds	r24, 0x0EBB
    c632:	81 30       	cpi	r24, 0x01	; 1
    c634:	09 f0       	breq	.+2      	; 0xc638 <process_read+0x540>
    c636:	8d c1       	rjmp	.+794    	; 0xc952 <process_read+0x85a>
		gRx1Step++;
    c638:	87 e8       	ldi	r24, 0x87	; 135
    c63a:	93 e0       	ldi	r25, 0x03	; 3
    c63c:	9a cf       	rjmp	.-204    	; 0xc572 <process_read+0x47a>
       	 	break;
    	case 902:
			U1I_case302();
       	 	break;
    	case 903:
			if(gFileCheckSum == gRxData){
    c63e:	80 91 b6 0e 	lds	r24, 0x0EB6
    c642:	82 17       	cp	r24, r18
    c644:	09 f0       	breq	.+2      	; 0xc648 <process_read+0x550>
    c646:	85 c1       	rjmp	.+778    	; 0xc952 <process_read+0x85a>
				SendToPC(17,2);
    c648:	62 e0       	ldi	r22, 0x02	; 2
    c64a:	81 e1       	ldi	r24, 0x11	; 17
    c64c:	0e 94 af 5e 	call	0xbd5e	; 0xbd5e <SendToPC>
				gFileCheckSum = 0;
    c650:	10 92 b6 0e 	sts	0x0EB6, r1
}


void	sciTx1Data(BYTE x)
{
	uartSendByte(x);
    c654:	80 91 53 0e 	lds	r24, 0x0E53
    c658:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
    	case 903:
			if(gFileCheckSum == gRxData){
				SendToPC(17,2);
				gFileCheckSum = 0;
				sciTx1Data(F_ERR_CODE);
				gFileCheckSum ^= F_ERR_CODE;
    c65c:	80 91 b6 0e 	lds	r24, 0x0EB6
    c660:	90 91 53 0e 	lds	r25, 0x0E53
    c664:	89 27       	eor	r24, r25
    c666:	80 93 b6 0e 	sts	0x0EB6, r24
}


void	sciTx1Data(BYTE x)
{
	uartSendByte(x);
    c66a:	80 91 43 0e 	lds	r24, 0x0E43
    c66e:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
				SendToPC(17,2);
				gFileCheckSum = 0;
				sciTx1Data(F_ERR_CODE);
				gFileCheckSum ^= F_ERR_CODE;
				sciTx1Data(F_PF);
				gFileCheckSum ^= F_PF;
    c672:	80 91 43 0e 	lds	r24, 0x0E43
    c676:	66 c1       	rjmp	.+716    	; 0xc944 <process_read+0x84c>
	sciTx1Data(CSize);
}

void U1I_case100(void)
{
	Motion.PF = gRxData;
    c678:	20 93 ae 0b 	sts	0x0BAE, r18
	gFieldIdx = 0;
    c67c:	10 92 45 0e 	sts	0x0E45, r1
    c680:	10 92 44 0e 	sts	0x0E44, r1
	gRx1Step++;
    c684:	89 ee       	ldi	r24, 0xE9	; 233
    c686:	93 e0       	ldi	r25, 0x03	; 3
    c688:	74 cf       	rjmp	.-280    	; 0xc572 <process_read+0x47a>
       	 	break;
    	case 1000:
			U1I_case100();
    	    break;
    	case 1001:
			U1I_case301(1);
    c68a:	81 e0       	ldi	r24, 0x01	; 1
    c68c:	0e 94 a9 5c 	call	0xb952	; 0xb952 <U1I_case301>
    c690:	67 c1       	rjmp	.+718    	; 0xc960 <process_read+0x868>
	}
}

void U1I_case302(void)
{
	gFileCheckSum ^= gRxData;
    c692:	80 91 b6 0e 	lds	r24, 0x0EB6
    c696:	82 27       	eor	r24, r18
    c698:	80 93 b6 0e 	sts	0x0EB6, r24
	if(gRxData == 1)
    c69c:	80 91 bb 0e 	lds	r24, 0x0EBB
    c6a0:	81 30       	cpi	r24, 0x01	; 1
    c6a2:	09 f0       	breq	.+2      	; 0xc6a6 <process_read+0x5ae>
    c6a4:	56 c1       	rjmp	.+684    	; 0xc952 <process_read+0x85a>
		gRx1Step++;
    c6a6:	8b ee       	ldi	r24, 0xEB	; 235
    c6a8:	93 e0       	ldi	r25, 0x03	; 3
    c6aa:	63 cf       	rjmp	.-314    	; 0xc572 <process_read+0x47a>
       	 	break;
    	case 1002:
			U1I_case302();
       	 	break;
    	case 1003:
			if(gFileCheckSum == gRxData){
    c6ac:	80 91 b6 0e 	lds	r24, 0x0EB6
    c6b0:	82 17       	cp	r24, r18
    c6b2:	09 f0       	breq	.+2      	; 0xc6b6 <process_read+0x5be>
    c6b4:	4e c1       	rjmp	.+668    	; 0xc952 <process_read+0x85a>
				SendToPC(18,2);
    c6b6:	62 e0       	ldi	r22, 0x02	; 2
    c6b8:	82 e1       	ldi	r24, 0x12	; 18
    c6ba:	0e 94 af 5e 	call	0xbd5e	; 0xbd5e <SendToPC>
				gFileCheckSum = 0;
    c6be:	10 92 b6 0e 	sts	0x0EB6, r1
}


void	sciTx1Data(BYTE x)
{
	uartSendByte(x);
    c6c2:	89 e0       	ldi	r24, 0x09	; 9
    c6c4:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
    	case 1003:
			if(gFileCheckSum == gRxData){
				SendToPC(18,2);
				gFileCheckSum = 0;
				sciTx1Data(9);
				gFileCheckSum ^= 9;
    c6c8:	80 91 b6 0e 	lds	r24, 0x0EB6
    c6cc:	99 e0       	ldi	r25, 0x09	; 9
    c6ce:	89 27       	eor	r24, r25
    c6d0:	80 93 b6 0e 	sts	0x0EB6, r24
}


void	sciTx1Data(BYTE x)
{
	uartSendByte(x);
    c6d4:	83 e6       	ldi	r24, 0x63	; 99
    c6d6:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
				SendToPC(18,2);
				gFileCheckSum = 0;
				sciTx1Data(9);
				gFileCheckSum ^= 9;
				sciTx1Data(99);
				gFileCheckSum ^= 99;
    c6da:	80 91 b6 0e 	lds	r24, 0x0EB6
    c6de:	93 e6       	ldi	r25, 0x63	; 99
    c6e0:	33 c1       	rjmp	.+614    	; 0xc948 <process_read+0x850>
    	    break;
    	case 1201:
			U1I_case301(1);
       	 	break;
    	case 1202:
			gFileCheckSum ^= gRxData;
    c6e2:	80 91 b6 0e 	lds	r24, 0x0EB6
    c6e6:	82 27       	eor	r24, r18
    c6e8:	80 93 b6 0e 	sts	0x0EB6, r24
			if(gRxData < 64)
    c6ec:	80 91 bb 0e 	lds	r24, 0x0EBB
    c6f0:	80 34       	cpi	r24, 0x40	; 64
    c6f2:	08 f0       	brcs	.+2      	; 0xc6f6 <process_read+0x5fe>
    c6f4:	2e c1       	rjmp	.+604    	; 0xc952 <process_read+0x85a>
    c6f6:	38 cf       	rjmp	.-400    	; 0xc568 <process_read+0x470>
				F_DOWNLOAD = 0;
				RUN_LED2_OFF;
			}
       	 	break;
    	case 1203:
			if(gFileCheckSum == gRxData){
    c6f8:	80 91 b6 0e 	lds	r24, 0x0EB6
    c6fc:	82 17       	cp	r24, r18
    c6fe:	09 f0       	breq	.+2      	; 0xc702 <process_read+0x60a>
    c700:	28 c1       	rjmp	.+592    	; 0xc952 <process_read+0x85a>
				F_RSV_MOTION = 1;
    c702:	81 e0       	ldi	r24, 0x01	; 1
    c704:	80 93 54 0e 	sts	0x0E54, r24
				if(gRx1Buf[RX1_BUF_SIZE-2] == 0x07)	F_MOTION_STOPPED = 1;
    c708:	90 91 af 0e 	lds	r25, 0x0EAF
    c70c:	97 30       	cpi	r25, 0x07	; 7
    c70e:	11 f4       	brne	.+4      	; 0xc714 <process_read+0x61c>
    c710:	80 93 51 0e 	sts	0x0E51, r24
				gRx1Step = 0;
    c714:	10 92 56 0e 	sts	0x0E56, r1
    c718:	10 92 55 0e 	sts	0x0E55, r1
				F_DOWNLOAD = 0;
    c71c:	10 92 81 0a 	sts	0x0A81, r1
				RUN_LED2_OFF;
    c720:	de 9a       	sbi	0x1b, 6	; 27
				UCSR0B |= 0x40;
    c722:	56 9a       	sbi	0x0a, 6	; 10
				EIMSK |= 0x40;
    c724:	89 b7       	in	r24, 0x39	; 57
    c726:	80 64       	ori	r24, 0x40	; 64
    c728:	89 bf       	out	0x39, r24	; 57
				F_IR_RECEIVED = 1;
    c72a:	81 e0       	ldi	r24, 0x01	; 1
    c72c:	80 93 47 0e 	sts	0x0E47, r24
				gIrBuf[0] = eRCodeH[0];
    c730:	80 91 61 04 	lds	r24, 0x0461
    c734:	80 93 4a 0e 	sts	0x0E4A, r24
				gIrBuf[1] = eRCodeM[0];
    c738:	80 91 66 04 	lds	r24, 0x0466
    c73c:	80 93 4b 0e 	sts	0x0E4B, r24
				gIrBuf[2] = eRCodeL[0];
    c740:	80 91 6b 04 	lds	r24, 0x046B
    c744:	80 93 4c 0e 	sts	0x0E4C, r24
				gIrBuf[3] = gRx1Buf[RX1_BUF_SIZE-2];
    c748:	90 93 4d 0e 	sts	0x0E4D, r25
    c74c:	0d c1       	rjmp	.+538    	; 0xc968 <process_read+0x870>
    	    break;
    	case 1301:
			U1I_case301(1);
       	 	break;
    	case 1302:
			gFileCheckSum ^= gRxData;
    c74e:	80 91 b6 0e 	lds	r24, 0x0EB6
    c752:	82 27       	eor	r24, r18
    c754:	80 93 b6 0e 	sts	0x0EB6, r24
			if(gRxData < 26)
    c758:	80 91 bb 0e 	lds	r24, 0x0EBB
    c75c:	8a 31       	cpi	r24, 0x1A	; 26
    c75e:	08 f0       	brcs	.+2      	; 0xc762 <process_read+0x66a>
    c760:	f8 c0       	rjmp	.+496    	; 0xc952 <process_read+0x85a>
    c762:	02 cf       	rjmp	.-508    	; 0xc568 <process_read+0x470>
				F_DOWNLOAD = 0;
				RUN_LED2_OFF;
			}
       	 	break;
    	case 1303:
			if(gFileCheckSum == gRxData){
    c764:	80 91 b6 0e 	lds	r24, 0x0EB6
    c768:	82 17       	cp	r24, r18
    c76a:	09 f0       	breq	.+2      	; 0xc76e <process_read+0x676>
    c76c:	f2 c0       	rjmp	.+484    	; 0xc952 <process_read+0x85a>
				//SendToSoundIC(gRx1Buf[RX1_BUF_SIZE-2]);
				//delay_ms(200 + Sound_Length[gRx1Buf[RX1_BUF_SIZE-2]-1]);
				SendToPC(21,1);
    c76e:	61 e0       	ldi	r22, 0x01	; 1
    c770:	85 e1       	ldi	r24, 0x15	; 21
    c772:	de c0       	rjmp	.+444    	; 0xc930 <process_read+0x838>
	sciTx1Data(CSize);
}

void U1I_case100(void)
{
	Motion.PF = gRxData;
    c774:	20 93 ae 0b 	sts	0x0BAE, r18
	gFieldIdx = 0;
    c778:	10 92 45 0e 	sts	0x0E45, r1
    c77c:	10 92 44 0e 	sts	0x0E44, r1
	gRx1Step++;
    c780:	89 e7       	ldi	r24, 0x79	; 121
    c782:	95 e0       	ldi	r25, 0x05	; 5
    c784:	f6 ce       	rjmp	.-532    	; 0xc572 <process_read+0x47a>
       	 	break;
    	case 1402:
			U1I_case302();
       	 	break;
    	case 1403:
			if(gFileCheckSum == gRxData){
    c786:	80 91 b6 0e 	lds	r24, 0x0EB6
    c78a:	82 17       	cp	r24, r18
    c78c:	09 f0       	breq	.+2      	; 0xc790 <process_read+0x698>
    c78e:	e1 c0       	rjmp	.+450    	; 0xc952 <process_read+0x85a>
				F_RSV_PSD_READ = 1;
    c790:	81 e0       	ldi	r24, 0x01	; 1
    c792:	80 93 b2 0e 	sts	0x0EB2, r24
    c796:	dd c0       	rjmp	.+442    	; 0xc952 <process_read+0x85a>
	sciTx1Data(CSize);
}

void U1I_case100(void)
{
	Motion.PF = gRxData;
    c798:	20 93 ae 0b 	sts	0x0BAE, r18
	gFieldIdx = 0;
    c79c:	10 92 45 0e 	sts	0x0E45, r1
    c7a0:	10 92 44 0e 	sts	0x0E44, r1
	gRx1Step++;
    c7a4:	8d ed       	ldi	r24, 0xDD	; 221
    c7a6:	95 e0       	ldi	r25, 0x05	; 5
    c7a8:	e4 ce       	rjmp	.-568    	; 0xc572 <process_read+0x47a>
       	 	break;
    	case 1500:
			U1I_case100();
    	    break;
    	case 1501:
			U1I_case301(2);
    c7aa:	82 e0       	ldi	r24, 0x02	; 2
    c7ac:	6f cf       	rjmp	.-290    	; 0xc68c <process_read+0x594>
}


void U1I_case502(BYTE LC)
{
	gFileCheckSum ^= gRxData;
    c7ae:	80 91 b6 0e 	lds	r24, 0x0EB6
    c7b2:	82 27       	eor	r24, r18
    c7b4:	80 93 b6 0e 	sts	0x0EB6, r24
	gFieldIdx++;
    c7b8:	80 91 44 0e 	lds	r24, 0x0E44
    c7bc:	90 91 45 0e 	lds	r25, 0x0E45
    c7c0:	01 96       	adiw	r24, 0x01	; 1
    c7c2:	90 93 45 0e 	sts	0x0E45, r25
    c7c6:	80 93 44 0e 	sts	0x0E44, r24
	if(gFieldIdx == LC){
    c7ca:	02 97       	sbiw	r24, 0x02	; 2
    c7cc:	09 f0       	breq	.+2      	; 0xc7d0 <process_read+0x6d8>
    c7ce:	c8 c0       	rjmp	.+400    	; 0xc960 <process_read+0x868>
		gRx1Step++;
    c7d0:	8f ed       	ldi	r24, 0xDF	; 223
    c7d2:	95 e0       	ldi	r25, 0x05	; 5
    c7d4:	ce ce       	rjmp	.-612    	; 0xc572 <process_read+0x47a>
       	 	break;
    	case 1502:
			U1I_case502(2);
       	 	break;
    	case 1503:
			if(gFileCheckSum == gRxData){
    c7d6:	80 91 b6 0e 	lds	r24, 0x0EB6
    c7da:	82 17       	cp	r24, r18
    c7dc:	09 f0       	breq	.+2      	; 0xc7e0 <process_read+0x6e8>
    c7de:	b9 c0       	rjmp	.+370    	; 0xc952 <process_read+0x85a>
				gSoundMinTh = gRx1Buf[RX1_BUF_SIZE-2];
    c7e0:	80 91 af 0e 	lds	r24, 0x0EAF
    c7e4:	80 93 99 0e 	sts	0x0E99, r24
				F_RSV_SOUND_READ = 1;
    c7e8:	81 e0       	ldi	r24, 0x01	; 1
    c7ea:	80 93 b3 0e 	sts	0x0EB3, r24
    c7ee:	b1 c0       	rjmp	.+354    	; 0xc952 <process_read+0x85a>
	sciTx1Data(CSize);
}

void U1I_case100(void)
{
	Motion.PF = gRxData;
    c7f0:	20 93 ae 0b 	sts	0x0BAE, r18
	gFieldIdx = 0;
    c7f4:	10 92 45 0e 	sts	0x0E45, r1
    c7f8:	10 92 44 0e 	sts	0x0E44, r1
	gRx1Step++;
    c7fc:	81 e4       	ldi	r24, 0x41	; 65
    c7fe:	96 e0       	ldi	r25, 0x06	; 6
    c800:	b8 ce       	rjmp	.-656    	; 0xc572 <process_read+0x47a>
	}
}

void U1I_case302(void)
{
	gFileCheckSum ^= gRxData;
    c802:	80 91 b6 0e 	lds	r24, 0x0EB6
    c806:	82 27       	eor	r24, r18
    c808:	80 93 b6 0e 	sts	0x0EB6, r24
	if(gRxData == 1)
    c80c:	80 91 bb 0e 	lds	r24, 0x0EBB
    c810:	81 30       	cpi	r24, 0x01	; 1
    c812:	09 f0       	breq	.+2      	; 0xc816 <process_read+0x71e>
    c814:	9e c0       	rjmp	.+316    	; 0xc952 <process_read+0x85a>
		gRx1Step++;
    c816:	83 e4       	ldi	r24, 0x43	; 67
    c818:	96 e0       	ldi	r25, 0x06	; 6
    c81a:	ab ce       	rjmp	.-682    	; 0xc572 <process_read+0x47a>
       	 	break;
    	case 1602:
			U1I_case302();
       	 	break;
    	case 1603:
			if(gFileCheckSum == gRxData){
    c81c:	80 91 b6 0e 	lds	r24, 0x0EB6
    c820:	82 17       	cp	r24, r18
    c822:	09 f0       	breq	.+2      	; 0xc826 <process_read+0x72e>
    c824:	96 c0       	rjmp	.+300    	; 0xc952 <process_read+0x85a>
				F_RSV_BTN_READ = 1;
    c826:	81 e0       	ldi	r24, 0x01	; 1
    c828:	80 93 98 0e 	sts	0x0E98, r24
    c82c:	92 c0       	rjmp	.+292    	; 0xc952 <process_read+0x85a>
       	 	        break;
    	case 1702:
			U1I_case302();
       	 	        break;
    	case 1703:
			if(gFileCheckSum == gRxData){
    c82e:	80 91 b6 0e 	lds	r24, 0x0EB6
    c832:	82 17       	cp	r24, r18
    c834:	09 f0       	breq	.+2      	; 0xc838 <process_read+0x740>
    c836:	8d c0       	rjmp	.+282    	; 0xc952 <process_read+0x85a>
				F_RSV_IR_READ = 1;
    c838:	81 e0       	ldi	r24, 0x01	; 1
    c83a:	80 93 b1 0e 	sts	0x0EB1, r24
    c83e:	89 c0       	rjmp	.+274    	; 0xc952 <process_read+0x85a>
	}
}

void U1I_case302(void)
{
	gFileCheckSum ^= gRxData;
    c840:	80 91 b6 0e 	lds	r24, 0x0EB6
    c844:	82 27       	eor	r24, r18
    c846:	80 93 b6 0e 	sts	0x0EB6, r24
	if(gRxData == 1)
    c84a:	80 91 bb 0e 	lds	r24, 0x0EBB
    c84e:	81 30       	cpi	r24, 0x01	; 1
    c850:	09 f0       	breq	.+2      	; 0xc854 <process_read+0x75c>
    c852:	7f c0       	rjmp	.+254    	; 0xc952 <process_read+0x85a>
    c854:	89 ce       	rjmp	.-750    	; 0xc568 <process_read+0x470>
       	 	break;
    	case 1802:
			U1I_case302();
       	 	break;
    	case 1803:
			if(gFileCheckSum == gRxData){
    c856:	80 91 b6 0e 	lds	r24, 0x0EB6
    c85a:	82 17       	cp	r24, r18
    c85c:	09 f0       	breq	.+2      	; 0xc860 <process_read+0x768>
    c85e:	79 c0       	rjmp	.+242    	; 0xc952 <process_read+0x85a>
				SendToPC(26,6);
    c860:	66 e0       	ldi	r22, 0x06	; 6
    c862:	8a e1       	ldi	r24, 0x1A	; 26
    c864:	0e 94 af 5e 	call	0xbd5e	; 0xbd5e <SendToPC>
				gFileCheckSum = 0;
    c868:	10 92 b6 0e 	sts	0x0EB6, r1
				if(gAccX < 0){
    c86c:	80 91 a9 0d 	lds	r24, 0x0DA9
    c870:	87 ff       	sbrs	r24, 7
    c872:	04 c0       	rjmp	.+8      	; 0xc87c <process_read+0x784>
}


void	sciTx1Data(BYTE x)
{
	uartSendByte(x);
    c874:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
        	    }
            	else{
	    			sciTx1Data(gAccX);
    				sciTx1Data(0);
        	    }
				gFileCheckSum ^= gAccX;
    c878:	8f ef       	ldi	r24, 0xFF	; 255
    c87a:	03 c0       	rjmp	.+6      	; 0xc882 <process_read+0x78a>
    c87c:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
    c880:	80 e0       	ldi	r24, 0x00	; 0
    c882:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
    c886:	80 91 b6 0e 	lds	r24, 0x0EB6
    c88a:	90 91 a9 0d 	lds	r25, 0x0DA9
    c88e:	89 27       	eor	r24, r25
    c890:	80 93 b6 0e 	sts	0x0EB6, r24
				if(gAccY < 0){
    c894:	80 91 ab 0d 	lds	r24, 0x0DAB
    c898:	87 ff       	sbrs	r24, 7
    c89a:	04 c0       	rjmp	.+8      	; 0xc8a4 <process_read+0x7ac>
}


void	sciTx1Data(BYTE x)
{
	uartSendByte(x);
    c89c:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
    	        }
        	    else{
    				sciTx1Data(gAccY);
	    			sciTx1Data(0);
    	        }
				gFileCheckSum ^= gAccY;
    c8a0:	8f ef       	ldi	r24, 0xFF	; 255
    c8a2:	03 c0       	rjmp	.+6      	; 0xc8aa <process_read+0x7b2>
    c8a4:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
    c8a8:	80 e0       	ldi	r24, 0x00	; 0
    c8aa:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
    c8ae:	80 91 b6 0e 	lds	r24, 0x0EB6
    c8b2:	90 91 ab 0d 	lds	r25, 0x0DAB
    c8b6:	89 27       	eor	r24, r25
    c8b8:	80 93 b6 0e 	sts	0x0EB6, r24
				if(gAccZ < 0){
    c8bc:	80 91 ad 0d 	lds	r24, 0x0DAD
    c8c0:	87 ff       	sbrs	r24, 7
    c8c2:	04 c0       	rjmp	.+8      	; 0xc8cc <process_read+0x7d4>
}


void	sciTx1Data(BYTE x)
{
	uartSendByte(x);
    c8c4:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
        	    }
            	else{
	    			sciTx1Data(gAccZ);
    				sciTx1Data(0);
        	    }
				gFileCheckSum ^= gAccZ;
    c8c8:	8f ef       	ldi	r24, 0xFF	; 255
    c8ca:	03 c0       	rjmp	.+6      	; 0xc8d2 <process_read+0x7da>
    c8cc:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
    c8d0:	80 e0       	ldi	r24, 0x00	; 0
    c8d2:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
    c8d6:	80 91 b6 0e 	lds	r24, 0x0EB6
    c8da:	90 91 ad 0d 	lds	r25, 0x0DAD
    c8de:	34 c0       	rjmp	.+104    	; 0xc948 <process_read+0x850>
	sciTx1Data(CSize);
}

void U1I_case100(void)
{
	Motion.PF = gRxData;
    c8e0:	20 93 ae 0b 	sts	0x0BAE, r18
	gFieldIdx = 0;
    c8e4:	10 92 45 0e 	sts	0x0E45, r1
    c8e8:	10 92 44 0e 	sts	0x0E44, r1
	gRx1Step++;
    c8ec:	8d ef       	ldi	r24, 0xFD	; 253
    c8ee:	98 e0       	ldi	r25, 0x08	; 8
    c8f0:	40 ce       	rjmp	.-896    	; 0xc572 <process_read+0x47a>
    	    break;
    	case 2301:
			U1I_case301(1);
       	 	break;
    	case 2302:
			gFileCheckSum ^= gRxData;
    c8f2:	80 91 b6 0e 	lds	r24, 0x0EB6
    c8f6:	82 27       	eor	r24, r18
    c8f8:	80 93 b6 0e 	sts	0x0EB6, r24
			if(gRxData < 4)
    c8fc:	80 91 bb 0e 	lds	r24, 0x0EBB
    c900:	84 30       	cpi	r24, 0x04	; 4
    c902:	38 f5       	brcc	.+78     	; 0xc952 <process_read+0x85a>
    c904:	31 ce       	rjmp	.-926    	; 0xc568 <process_read+0x470>
				F_DOWNLOAD = 0;
				RUN_LED2_OFF;
			}
       	 	break;
    	case 2303:
			if(gFileCheckSum == gRxData){
    c906:	80 91 b6 0e 	lds	r24, 0x0EB6
    c90a:	82 17       	cp	r24, r18
    c90c:	11 f5       	brne	.+68     	; 0xc952 <process_read+0x85a>
				if(gRx1Buf[RX1_BUF_SIZE-2] == 1){
    c90e:	80 91 af 0e 	lds	r24, 0x0EAF
    c912:	81 30       	cpi	r24, 0x01	; 1
    c914:	29 f4       	brne	.+10     	; 0xc920 <process_read+0x828>
					gDownNumOfM = 0;
    c916:	10 92 bc 0e 	sts	0x0EBC, r1
					eNumOfM = 0;
    c91a:	10 92 52 04 	sts	0x0452, r1
    c91e:	06 c0       	rjmp	.+12     	; 0xc92c <process_read+0x834>
				}
				else if(gRx1Buf[RX1_BUF_SIZE-2] == 2){
    c920:	82 30       	cpi	r24, 0x02	; 2
    c922:	21 f4       	brne	.+8      	; 0xc92c <process_read+0x834>
					gDownNumOfA = 0;
    c924:	10 92 49 0e 	sts	0x0E49, r1
					eNumOfA = 0;
    c928:	10 92 53 04 	sts	0x0453, r1
				}
				SendToPC(31,1);
    c92c:	61 e0       	ldi	r22, 0x01	; 1
    c92e:	8f e1       	ldi	r24, 0x1F	; 31
    c930:	0e 94 af 5e 	call	0xbd5e	; 0xbd5e <SendToPC>
				gFileCheckSum = 0;
    c934:	10 92 b6 0e 	sts	0x0EB6, r1
}


void	sciTx1Data(BYTE x)
{
	uartSendByte(x);
    c938:	80 91 af 0e 	lds	r24, 0x0EAF
    c93c:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
					eNumOfA = 0;
				}
				SendToPC(31,1);
				gFileCheckSum = 0;
				sciTx1Data(gRx1Buf[RX1_BUF_SIZE-2]);
				gFileCheckSum ^= gRx1Buf[RX1_BUF_SIZE-2];
    c940:	80 91 af 0e 	lds	r24, 0x0EAF
    c944:	90 91 b6 0e 	lds	r25, 0x0EB6
    c948:	89 27       	eor	r24, r25
    c94a:	80 93 b6 0e 	sts	0x0EB6, r24
}


void	sciTx1Data(BYTE x)
{
	uartSendByte(x);
    c94e:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
				gFileCheckSum = 0;
				sciTx1Data(gRx1Buf[RX1_BUF_SIZE-2]);
				gFileCheckSum ^= gRx1Buf[RX1_BUF_SIZE-2];
				sciTx1Data(gFileCheckSum);
			}
			gRx1Step = 0;
    c952:	10 92 56 0e 	sts	0x0E56, r1
    c956:	10 92 55 0e 	sts	0x0E55, r1
			F_DOWNLOAD = 0;
    c95a:	10 92 81 0a 	sts	0x0A81, r1
			RUN_LED2_OFF;
    c95e:	de 9a       	sbi	0x1b, 6	; 27
       	 	break;
	}
	UCSR0B |= 0x40;
    c960:	56 9a       	sbi	0x0a, 6	; 10
	EIMSK |= 0x40;
    c962:	89 b7       	in	r24, 0x39	; 57
    c964:	80 64       	ori	r24, 0x40	; 64
    c966:	89 bf       	out	0x39, r24	; 57
}
    c968:	1f 91       	pop	r17
    c96a:	08 95       	ret

0000c96c <M_Play>:
#include "compatability.h"

#include <util/delay.h>

void M_Play(BYTE a)
{
    c96c:	90 e0       	ldi	r25, 0x00	; 0
    c96e:	0e 94 60 29 	call	0x52c0	; 0x52c0 <SampleMotion>
	SampleMotion(a); 
}
    c972:	08 95       	ret

0000c974 <ProcIr>:

//------------------------------------------------------------------------------
// IR  
//------------------------------------------------------------------------------
void ProcIr(void)
{
    c974:	80 91 81 0a 	lds	r24, 0x0A81
    c978:	88 23       	and	r24, r24
    c97a:	09 f0       	breq	.+2      	; 0xc97e <ProcIr+0xa>
    c97c:	f7 c0       	rjmp	.+494    	; 0xcb6c <ProcIr+0x1f8>
    WORD    i;

	if(F_DOWNLOAD) return;
	if(F_FIRST_M && gIrBuf[3]!=BTN_C && gIrBuf[3]!=BTN_SHARP_A && F_PF!=PF2) return;
    c97e:	80 91 b9 0e 	lds	r24, 0x0EB9
    c982:	88 23       	and	r24, r24
    c984:	59 f0       	breq	.+22     	; 0xc99c <ProcIr+0x28>
    c986:	80 91 4d 0e 	lds	r24, 0x0E4D
    c98a:	87 30       	cpi	r24, 0x07	; 7
    c98c:	39 f0       	breq	.+14     	; 0xc99c <ProcIr+0x28>
    c98e:	8b 32       	cpi	r24, 0x2B	; 43
    c990:	29 f0       	breq	.+10     	; 0xc99c <ProcIr+0x28>
    c992:	80 91 43 0e 	lds	r24, 0x0E43
    c996:	82 30       	cpi	r24, 0x02	; 2
    c998:	09 f0       	breq	.+2      	; 0xc99c <ProcIr+0x28>
    c99a:	e8 c0       	rjmp	.+464    	; 0xcb6c <ProcIr+0x1f8>
	if(F_IR_RECEIVED && !F_RSV_IR_READ){
    c99c:	80 91 47 0e 	lds	r24, 0x0E47
    c9a0:	88 23       	and	r24, r24
    c9a2:	09 f4       	brne	.+2      	; 0xc9a6 <ProcIr+0x32>
    c9a4:	e3 c0       	rjmp	.+454    	; 0xcb6c <ProcIr+0x1f8>
    c9a6:	80 91 b1 0e 	lds	r24, 0x0EB1
    c9aa:	88 23       	and	r24, r24
    c9ac:	09 f0       	breq	.+2      	; 0xc9b0 <ProcIr+0x3c>
    c9ae:	de c0       	rjmp	.+444    	; 0xcb6c <ProcIr+0x1f8>
	    EIMSK &= 0xBF;
    c9b0:	89 b7       	in	r24, 0x39	; 57
    c9b2:	8f 7b       	andi	r24, 0xBF	; 191
    c9b4:	89 bf       	out	0x39, r24	; 57
		F_IR_RECEIVED = 0;
    c9b6:	10 92 47 0e 	sts	0x0E47, r1
		if((gIrBuf[0]==eRCodeH[0] && gIrBuf[1]==eRCodeM[0] && gIrBuf[2]==eRCodeL[0])
    c9ba:	20 91 4a 0e 	lds	r18, 0x0E4A
    c9be:	80 91 61 04 	lds	r24, 0x0461
    c9c2:	28 17       	cp	r18, r24
    c9c4:	69 f4       	brne	.+26     	; 0xc9e0 <ProcIr+0x6c>
    c9c6:	90 91 4b 0e 	lds	r25, 0x0E4B
    c9ca:	80 91 66 04 	lds	r24, 0x0466
    c9ce:	98 17       	cp	r25, r24
    c9d0:	39 f4       	brne	.+14     	; 0xc9e0 <ProcIr+0x6c>
    c9d2:	90 91 4c 0e 	lds	r25, 0x0E4C
    c9d6:	80 91 6b 04 	lds	r24, 0x046B
    c9da:	98 17       	cp	r25, r24
    c9dc:	09 f4       	brne	.+2      	; 0xc9e0 <ProcIr+0x6c>
    c9de:	43 c0       	rjmp	.+134    	; 0xca66 <ProcIr+0xf2>
    c9e0:	80 91 62 04 	lds	r24, 0x0462
    c9e4:	28 17       	cp	r18, r24
    c9e6:	61 f4       	brne	.+24     	; 0xca00 <ProcIr+0x8c>
    c9e8:	90 91 4b 0e 	lds	r25, 0x0E4B
    c9ec:	80 91 67 04 	lds	r24, 0x0467
    c9f0:	98 17       	cp	r25, r24
    c9f2:	31 f4       	brne	.+12     	; 0xca00 <ProcIr+0x8c>
    c9f4:	90 91 4c 0e 	lds	r25, 0x0E4C
    c9f8:	80 91 6c 04 	lds	r24, 0x046C
    c9fc:	98 17       	cp	r25, r24
    c9fe:	99 f1       	breq	.+102    	; 0xca66 <ProcIr+0xf2>
    ca00:	80 91 63 04 	lds	r24, 0x0463
    ca04:	28 17       	cp	r18, r24
    ca06:	61 f4       	brne	.+24     	; 0xca20 <ProcIr+0xac>
    ca08:	90 91 4b 0e 	lds	r25, 0x0E4B
    ca0c:	80 91 68 04 	lds	r24, 0x0468
    ca10:	98 17       	cp	r25, r24
    ca12:	31 f4       	brne	.+12     	; 0xca20 <ProcIr+0xac>
    ca14:	90 91 4c 0e 	lds	r25, 0x0E4C
    ca18:	80 91 6d 04 	lds	r24, 0x046D
    ca1c:	98 17       	cp	r25, r24
    ca1e:	19 f1       	breq	.+70     	; 0xca66 <ProcIr+0xf2>
    ca20:	80 91 64 04 	lds	r24, 0x0464
    ca24:	28 17       	cp	r18, r24
    ca26:	61 f4       	brne	.+24     	; 0xca40 <ProcIr+0xcc>
    ca28:	90 91 4b 0e 	lds	r25, 0x0E4B
    ca2c:	80 91 69 04 	lds	r24, 0x0469
    ca30:	98 17       	cp	r25, r24
    ca32:	31 f4       	brne	.+12     	; 0xca40 <ProcIr+0xcc>
    ca34:	90 91 4c 0e 	lds	r25, 0x0E4C
    ca38:	80 91 6e 04 	lds	r24, 0x046E
    ca3c:	98 17       	cp	r25, r24
    ca3e:	99 f0       	breq	.+38     	; 0xca66 <ProcIr+0xf2>
    ca40:	80 91 65 04 	lds	r24, 0x0465
    ca44:	28 17       	cp	r18, r24
    ca46:	09 f0       	breq	.+2      	; 0xca4a <ProcIr+0xd6>
    ca48:	6d c0       	rjmp	.+218    	; 0xcb24 <ProcIr+0x1b0>
    ca4a:	90 91 4b 0e 	lds	r25, 0x0E4B
    ca4e:	80 91 6a 04 	lds	r24, 0x046A
    ca52:	98 17       	cp	r25, r24
    ca54:	09 f0       	breq	.+2      	; 0xca58 <ProcIr+0xe4>
    ca56:	66 c0       	rjmp	.+204    	; 0xcb24 <ProcIr+0x1b0>
    ca58:	90 91 4c 0e 	lds	r25, 0x0E4C
    ca5c:	80 91 6f 04 	lds	r24, 0x046F
    ca60:	98 17       	cp	r25, r24
    ca62:	09 f0       	breq	.+2      	; 0xca66 <ProcIr+0xf2>
    ca64:	5f c0       	rjmp	.+190    	; 0xcb24 <ProcIr+0x1b0>
		 ||(gIrBuf[0]==eRCodeH[1] && gIrBuf[1]==eRCodeM[1] && gIrBuf[2]==eRCodeL[1])
		 ||(gIrBuf[0]==eRCodeH[2] && gIrBuf[1]==eRCodeM[2] && gIrBuf[2]==eRCodeL[2])
		 ||(gIrBuf[0]==eRCodeH[3] && gIrBuf[1]==eRCodeM[3] && gIrBuf[2]==eRCodeL[3])
		 ||(gIrBuf[0]==eRCodeH[4] && gIrBuf[1]==eRCodeM[4] && gIrBuf[2]==eRCodeL[4])){
			switch(gIrBuf[3]){
    ca66:	80 91 4d 0e 	lds	r24, 0x0E4D
    ca6a:	90 e0       	ldi	r25, 0x00	; 0
    ca6c:	fc 01       	movw	r30, r24
    ca6e:	31 97       	sbiw	r30, 0x01	; 1
    ca70:	e1 33       	cpi	r30, 0x31	; 49
    ca72:	f1 05       	cpc	r31, r1
    ca74:	08 f0       	brcs	.+2      	; 0xca78 <ProcIr+0x104>
    ca76:	56 c0       	rjmp	.+172    	; 0xcb24 <ProcIr+0x1b0>
    ca78:	e4 59       	subi	r30, 0x94	; 148
    ca7a:	ff 4f       	sbci	r31, 0xFF	; 255
    ca7c:	ee 0f       	add	r30, r30
    ca7e:	ff 1f       	adc	r31, r31
    ca80:	05 90       	lpm	r0, Z+
    ca82:	f4 91       	lpm	r31, Z+
    ca84:	e0 2d       	mov	r30, r0
    ca86:	09 94       	ijmp

#include <util/delay.h>

void M_Play(BYTE a)
{
	SampleMotion(a); 
    ca88:	81 e0       	ldi	r24, 0x01	; 1
    ca8a:	90 e0       	ldi	r25, 0x00	; 0
    ca8c:	02 c0       	rjmp	.+4      	; 0xca92 <ProcIr+0x11e>
		 ||(gIrBuf[0]==eRCodeH[3] && gIrBuf[1]==eRCodeM[3] && gIrBuf[2]==eRCodeL[3])
		 ||(gIrBuf[0]==eRCodeH[4] && gIrBuf[1]==eRCodeM[4] && gIrBuf[2]==eRCodeL[4])){
			switch(gIrBuf[3]){
				case BTN_A:
					M_Play(BTN_A);
					break;
    ca8e:	82 e0       	ldi	r24, 0x02	; 2
    ca90:	90 e0       	ldi	r25, 0x00	; 0
    ca92:	0e 94 60 29 	call	0x52c0	; 0x52c0 <SampleMotion>
    ca96:	46 c0       	rjmp	.+140    	; 0xcb24 <ProcIr+0x1b0>

#include <util/delay.h>

void M_Play(BYTE a)
{
	SampleMotion(a); 
    ca98:	83 e0       	ldi	r24, 0x03	; 3
    ca9a:	90 e0       	ldi	r25, 0x00	; 0
    ca9c:	fa cf       	rjmp	.-12     	; 0xca92 <ProcIr+0x11e>
				case BTN_B:
					M_Play(BTN_B);
					break;
				case BTN_LR:
					M_Play(BTN_LR);
					break;
    ca9e:	84 e0       	ldi	r24, 0x04	; 4
    caa0:	90 e0       	ldi	r25, 0x00	; 0
    caa2:	f7 cf       	rjmp	.-18     	; 0xca92 <ProcIr+0x11e>

#include <util/delay.h>

void M_Play(BYTE a)
{
	SampleMotion(a); 
    caa4:	85 e0       	ldi	r24, 0x05	; 5
    caa6:	90 e0       	ldi	r25, 0x00	; 0
    caa8:	f4 cf       	rjmp	.-24     	; 0xca92 <ProcIr+0x11e>
				case BTN_U:
					M_Play(BTN_U);
					break;
				case BTN_RR:
					M_Play(BTN_RR);
					break;
    caaa:	86 e0       	ldi	r24, 0x06	; 6
    caac:	90 e0       	ldi	r25, 0x00	; 0
    caae:	f1 cf       	rjmp	.-30     	; 0xca92 <ProcIr+0x11e>

#include <util/delay.h>

void M_Play(BYTE a)
{
	SampleMotion(a); 
    cab0:	88 e0       	ldi	r24, 0x08	; 8
    cab2:	90 e0       	ldi	r25, 0x00	; 0
    cab4:	ee cf       	rjmp	.-36     	; 0xca92 <ProcIr+0x11e>
				case BTN_L:
					M_Play(BTN_L);
					break;
				case BTN_R:
					M_Play(BTN_R);
					break;
    cab6:	89 e0       	ldi	r24, 0x09	; 9
    cab8:	90 e0       	ldi	r25, 0x00	; 0
    caba:	eb cf       	rjmp	.-42     	; 0xca92 <ProcIr+0x11e>

#include <util/delay.h>

void M_Play(BYTE a)
{
	SampleMotion(a); 
    cabc:	8a e0       	ldi	r24, 0x0A	; 10
    cabe:	90 e0       	ldi	r25, 0x00	; 0
    cac0:	e8 cf       	rjmp	.-48     	; 0xca92 <ProcIr+0x11e>
				case BTN_LA:
					M_Play(BTN_LA);
					break;
				case BTN_D:
					M_Play(BTN_D);
					break;
    cac2:	8b e0       	ldi	r24, 0x0B	; 11
    cac4:	90 e0       	ldi	r25, 0x00	; 0
    cac6:	e5 cf       	rjmp	.-54     	; 0xca92 <ProcIr+0x11e>
				case BTN_RA:
					M_Play(BTN_RA);
					break;
				case BTN_C:
					F_FIRST_M = 0;
    cac8:	10 92 b9 0e 	sts	0x0EB9, r1

#include <util/delay.h>

void M_Play(BYTE a)
{
	SampleMotion(a); 
    cacc:	87 e0       	ldi	r24, 0x07	; 7
    cace:	90 e0       	ldi	r25, 0x00	; 0
    cad0:	e0 cf       	rjmp	.-64     	; 0xca92 <ProcIr+0x11e>
					break;
				case BTN_9:
					break;
				case BTN_0:
					M_Play(BTN_0);
					break;
    cad2:	85 e1       	ldi	r24, 0x15	; 21
    cad4:	90 e0       	ldi	r25, 0x00	; 0
    cad6:	dd cf       	rjmp	.-70     	; 0xca92 <ProcIr+0x11e>
    cad8:	86 e1       	ldi	r24, 0x16	; 22
    cada:	90 e0       	ldi	r25, 0x00	; 0
    cadc:	da cf       	rjmp	.-76     	; 0xca92 <ProcIr+0x11e>

#include <util/delay.h>

void M_Play(BYTE a)
{
	SampleMotion(a); 
    cade:	87 e1       	ldi	r24, 0x17	; 23
    cae0:	90 e0       	ldi	r25, 0x00	; 0
    cae2:	d7 cf       	rjmp	.-82     	; 0xca92 <ProcIr+0x11e>
				case BTN_STAR_A:
					M_Play(BTN_STAR_A);
					break;
				case BTN_STAR_B:
					M_Play(BTN_STAR_B);
					break;
    cae4:	8c e1       	ldi	r24, 0x1C	; 28
    cae6:	90 e0       	ldi	r25, 0x00	; 0
    cae8:	d4 cf       	rjmp	.-88     	; 0xca92 <ProcIr+0x11e>
				case BTN_SHARP_9:
					break;
				case BTN_SHARP_0:
					break;
				case BTN_SHARP_A:
					if(F_PS_PLUGGED){
    caea:	80 91 b1 0d 	lds	r24, 0x0DB1
    caee:	88 23       	and	r24, r24
    caf0:	c9 f0       	breq	.+50     	; 0xcb24 <ProcIr+0x1b0>
						wckPowerDown();
    caf2:	0e 94 31 54 	call	0xa862	; 0xa862 <wckPowerDown>
						ChargeNiMH();
    caf6:	0e 94 4e 3c 	call	0x789c	; 0x789c <ChargeNiMH>
    cafa:	14 c0       	rjmp	.+40     	; 0xcb24 <ProcIr+0x1b0>
					}
					break;
				case BTN_SHARP_B:
					break;
				case BTN_SHARP_C:
					BasicPose(0, 50, 1000, 4);
    cafc:	24 e0       	ldi	r18, 0x04	; 4
    cafe:	30 e0       	ldi	r19, 0x00	; 0
    cb00:	48 ee       	ldi	r20, 0xE8	; 232
    cb02:	53 e0       	ldi	r21, 0x03	; 3
    cb04:	62 e3       	ldi	r22, 0x32	; 50
    cb06:	70 e0       	ldi	r23, 0x00	; 0
    cb08:	80 e0       	ldi	r24, 0x00	; 0
    cb0a:	90 e0       	ldi	r25, 0x00	; 0
    cb0c:	0e 94 9c 26 	call	0x4d38	; 0x4d38 <BasicPose>
					BasicPose(0, 1, 100, 1);
    cb10:	21 e0       	ldi	r18, 0x01	; 1
    cb12:	30 e0       	ldi	r19, 0x00	; 0
    cb14:	44 e6       	ldi	r20, 0x64	; 100
    cb16:	50 e0       	ldi	r21, 0x00	; 0
    cb18:	61 e0       	ldi	r22, 0x01	; 1
    cb1a:	70 e0       	ldi	r23, 0x00	; 0
    cb1c:	80 e0       	ldi	r24, 0x00	; 0
    cb1e:	90 e0       	ldi	r25, 0x00	; 0
    cb20:	0e 94 9c 26 	call	0x4d38	; 0x4d38 <BasicPose>
					break;
			}
		}
		if(F_RSV_MOTION){
    cb24:	80 91 54 0e 	lds	r24, 0x0E54
    cb28:	88 23       	and	r24, r24
    cb2a:	a9 f0       	breq	.+42     	; 0xcb56 <ProcIr+0x1e2>
			F_RSV_MOTION = 0;
    cb2c:	10 92 54 0e 	sts	0x0E54, r1
			SendToPC(20,1);
    cb30:	61 e0       	ldi	r22, 0x01	; 1
    cb32:	84 e1       	ldi	r24, 0x14	; 20
    cb34:	0e 94 af 5e 	call	0xbd5e	; 0xbd5e <SendToPC>
			gFileCheckSum = 0;
    cb38:	10 92 b6 0e 	sts	0x0EB6, r1
}


void	sciTx1Data(BYTE x)
{
	uartSendByte(x);
    cb3c:	80 91 4d 0e 	lds	r24, 0x0E4D
    cb40:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
		if(F_RSV_MOTION){
			F_RSV_MOTION = 0;
			SendToPC(20,1);
			gFileCheckSum = 0;
			sciTx1Data(gIrBuf[3]);
			gFileCheckSum ^= gIrBuf[3];
    cb44:	80 91 4d 0e 	lds	r24, 0x0E4D
    cb48:	90 91 b6 0e 	lds	r25, 0x0EB6
    cb4c:	89 27       	eor	r24, r25
    cb4e:	80 93 b6 0e 	sts	0x0EB6, r24
}


void	sciTx1Data(BYTE x)
{
	uartSendByte(x);
    cb52:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <uartSendByte>
			gFileCheckSum = 0;
			sciTx1Data(gIrBuf[3]);
			gFileCheckSum ^= gIrBuf[3];
			sciTx1Data(gFileCheckSum);
		}
		for(i=0;i<IR_BUFFER_SIZE;i++)	gIrBuf[i]=0;
    cb56:	10 92 4a 0e 	sts	0x0E4A, r1
    cb5a:	10 92 4b 0e 	sts	0x0E4B, r1
    cb5e:	10 92 4c 0e 	sts	0x0E4C, r1
    cb62:	10 92 4d 0e 	sts	0x0E4D, r1
	    EIMSK |= 0x40;
    cb66:	89 b7       	in	r24, 0x39	; 57
    cb68:	80 64       	ori	r24, 0x40	; 64
    cb6a:	89 bf       	out	0x39, r24	; 57
    cb6c:	08 95       	ret

0000cb6e <compatability_mode>:


//------------------------------------------------------------------------------
// compatability mode with standard firmware
//------------------------------------------------------------------------------
void compatability_mode(void) {
    cb6e:	0f 93       	push	r16
    cb70:	1f 93       	push	r17
    cb72:	cf 93       	push	r28
    cb74:	df 93       	push	r29
	WORD    l10MSEC=0;

	P_BMC504_RESET(0);
    cb76:	c6 98       	cbi	0x18, 6	; 24
	delay_ms(20);
    cb78:	84 e1       	ldi	r24, 0x14	; 20
    cb7a:	90 e0       	ldi	r25, 0x00	; 0
    cb7c:	0e 94 42 5c 	call	0xb884	; 0xb884 <delay_ms>
	P_BMC504_RESET(1);
    cb80:	c6 9a       	sbi	0x18, 6	; 24

	SelfTest1();
    cb82:	0e 94 ad 5d 	call	0xbb5a	; 0xbb5a <SelfTest1>
    cb86:	00 e0       	ldi	r16, 0x00	; 0
    cb88:	10 e0       	ldi	r17, 0x00	; 0
	while(1){
		ReadButton();
    cb8a:	0e 94 13 5d 	call	0xba26	; 0xba26 <ReadButton>
		ProcButton();
		IoUpdate();
    cb8e:	0e 94 ea 5d 	call	0xbbd4	; 0xbbd4 <IoUpdate>
		if(g10MSEC == 0 || g10MSEC == 50)
    cb92:	80 91 b8 0a 	lds	r24, 0x0AB8
    cb96:	90 91 b9 0a 	lds	r25, 0x0AB9
    cb9a:	89 2b       	or	r24, r25
    cb9c:	41 f0       	breq	.+16     	; 0xcbae <compatability_mode+0x40>
    cb9e:	80 91 b8 0a 	lds	r24, 0x0AB8
    cba2:	90 91 b9 0a 	lds	r25, 0x0AB9
    cba6:	c2 97       	sbiw	r24, 0x32	; 50
    cba8:	11 f0       	breq	.+4      	; 0xcbae <compatability_mode+0x40>
    cbaa:	e8 01       	movw	r28, r16
    cbac:	0f c0       	rjmp	.+30     	; 0xcbcc <compatability_mode+0x5e>
		{
			if(g10MSEC != l10MSEC)
    cbae:	c0 91 b8 0a 	lds	r28, 0x0AB8
    cbb2:	d0 91 b9 0a 	lds	r29, 0x0AB9
    cbb6:	c0 17       	cp	r28, r16
    cbb8:	d1 07       	cpc	r29, r17
    cbba:	41 f0       	breq	.+16     	; 0xcbcc <compatability_mode+0x5e>
			{
				l10MSEC = g10MSEC;
    cbbc:	c0 91 b8 0a 	lds	r28, 0x0AB8
    cbc0:	d0 91 b9 0a 	lds	r29, 0x0AB9
				Get_VOLTAGE();
    cbc4:	0e 94 00 2d 	call	0x5a00	; 0x5a00 <Get_VOLTAGE>
				DetectPower();
    cbc8:	0e 94 fc 3b 	call	0x77f8	; 0x77f8 <DetectPower>
			}
		}
		ProcIr();
    cbcc:	0e 94 ba 64 	call	0xc974	; 0xc974 <ProcIr>
		AccGetData();
    cbd0:	0e 94 5d 2f 	call	0x5eba	; 0x5eba <AccGetData>
		ProcComm();
    cbd4:	0e 94 e1 5e 	call	0xbdc2	; 0xbdc2 <ProcComm>
    cbd8:	8e 01       	movw	r16, r28
    cbda:	d7 cf       	rjmp	.-82     	; 0xcb8a <compatability_mode+0x1c>

0000cbdc <__fixunssfsi>:
    cbdc:	ef 92       	push	r14
    cbde:	ff 92       	push	r15
    cbe0:	0f 93       	push	r16
    cbe2:	1f 93       	push	r17
    cbe4:	7b 01       	movw	r14, r22
    cbe6:	8c 01       	movw	r16, r24
    cbe8:	20 e0       	ldi	r18, 0x00	; 0
    cbea:	30 e0       	ldi	r19, 0x00	; 0
    cbec:	40 e0       	ldi	r20, 0x00	; 0
    cbee:	5f e4       	ldi	r21, 0x4F	; 79
    cbf0:	0e 94 98 69 	call	0xd330	; 0xd330 <__gesf2>
    cbf4:	88 23       	and	r24, r24
    cbf6:	8c f0       	brlt	.+34     	; 0xcc1a <__fixunssfsi+0x3e>
    cbf8:	20 e0       	ldi	r18, 0x00	; 0
    cbfa:	30 e0       	ldi	r19, 0x00	; 0
    cbfc:	40 e0       	ldi	r20, 0x00	; 0
    cbfe:	5f e4       	ldi	r21, 0x4F	; 79
    cc00:	c8 01       	movw	r24, r16
    cc02:	b7 01       	movw	r22, r14
    cc04:	0e 94 66 67 	call	0xcecc	; 0xcecc <__subsf3>
    cc08:	0e 94 56 6a 	call	0xd4ac	; 0xd4ac <__fixsfsi>
    cc0c:	9b 01       	movw	r18, r22
    cc0e:	ac 01       	movw	r20, r24
    cc10:	20 50       	subi	r18, 0x00	; 0
    cc12:	30 40       	sbci	r19, 0x00	; 0
    cc14:	40 40       	sbci	r20, 0x00	; 0
    cc16:	50 48       	sbci	r21, 0x80	; 128
    cc18:	06 c0       	rjmp	.+12     	; 0xcc26 <__fixunssfsi+0x4a>
    cc1a:	c8 01       	movw	r24, r16
    cc1c:	b7 01       	movw	r22, r14
    cc1e:	0e 94 56 6a 	call	0xd4ac	; 0xd4ac <__fixsfsi>
    cc22:	9b 01       	movw	r18, r22
    cc24:	ac 01       	movw	r20, r24
    cc26:	b9 01       	movw	r22, r18
    cc28:	ca 01       	movw	r24, r20
    cc2a:	1f 91       	pop	r17
    cc2c:	0f 91       	pop	r16
    cc2e:	ff 90       	pop	r15
    cc30:	ef 90       	pop	r14
    cc32:	08 95       	ret

0000cc34 <_fpadd_parts>:
    cc34:	a0 e0       	ldi	r26, 0x00	; 0
    cc36:	b0 e0       	ldi	r27, 0x00	; 0
    cc38:	e0 e2       	ldi	r30, 0x20	; 32
    cc3a:	f6 e6       	ldi	r31, 0x66	; 102
    cc3c:	0c 94 66 6e 	jmp	0xdccc	; 0xdccc <__prologue_saves__>
    cc40:	dc 01       	movw	r26, r24
    cc42:	2b 01       	movw	r4, r22
    cc44:	fa 01       	movw	r30, r20
    cc46:	9c 91       	ld	r25, X
    cc48:	92 30       	cpi	r25, 0x02	; 2
    cc4a:	08 f4       	brcc	.+2      	; 0xcc4e <_fpadd_parts+0x1a>
    cc4c:	39 c1       	rjmp	.+626    	; 0xcec0 <_fpadd_parts+0x28c>
    cc4e:	eb 01       	movw	r28, r22
    cc50:	88 81       	ld	r24, Y
    cc52:	82 30       	cpi	r24, 0x02	; 2
    cc54:	08 f4       	brcc	.+2      	; 0xcc58 <_fpadd_parts+0x24>
    cc56:	33 c1       	rjmp	.+614    	; 0xcebe <_fpadd_parts+0x28a>
    cc58:	94 30       	cpi	r25, 0x04	; 4
    cc5a:	69 f4       	brne	.+26     	; 0xcc76 <_fpadd_parts+0x42>
    cc5c:	84 30       	cpi	r24, 0x04	; 4
    cc5e:	09 f0       	breq	.+2      	; 0xcc62 <_fpadd_parts+0x2e>
    cc60:	2f c1       	rjmp	.+606    	; 0xcec0 <_fpadd_parts+0x28c>
    cc62:	11 96       	adiw	r26, 0x01	; 1
    cc64:	9c 91       	ld	r25, X
    cc66:	11 97       	sbiw	r26, 0x01	; 1
    cc68:	89 81       	ldd	r24, Y+1	; 0x01
    cc6a:	98 17       	cp	r25, r24
    cc6c:	09 f4       	brne	.+2      	; 0xcc70 <_fpadd_parts+0x3c>
    cc6e:	28 c1       	rjmp	.+592    	; 0xcec0 <_fpadd_parts+0x28c>
    cc70:	a5 e7       	ldi	r26, 0x75	; 117
    cc72:	b4 e0       	ldi	r27, 0x04	; 4
    cc74:	25 c1       	rjmp	.+586    	; 0xcec0 <_fpadd_parts+0x28c>
    cc76:	84 30       	cpi	r24, 0x04	; 4
    cc78:	09 f4       	brne	.+2      	; 0xcc7c <_fpadd_parts+0x48>
    cc7a:	21 c1       	rjmp	.+578    	; 0xcebe <_fpadd_parts+0x28a>
    cc7c:	82 30       	cpi	r24, 0x02	; 2
    cc7e:	a9 f4       	brne	.+42     	; 0xccaa <_fpadd_parts+0x76>
    cc80:	92 30       	cpi	r25, 0x02	; 2
    cc82:	09 f0       	breq	.+2      	; 0xcc86 <_fpadd_parts+0x52>
    cc84:	1d c1       	rjmp	.+570    	; 0xcec0 <_fpadd_parts+0x28c>
    cc86:	9a 01       	movw	r18, r20
    cc88:	ad 01       	movw	r20, r26
    cc8a:	88 e0       	ldi	r24, 0x08	; 8
    cc8c:	ea 01       	movw	r28, r20
    cc8e:	09 90       	ld	r0, Y+
    cc90:	ae 01       	movw	r20, r28
    cc92:	e9 01       	movw	r28, r18
    cc94:	09 92       	st	Y+, r0
    cc96:	9e 01       	movw	r18, r28
    cc98:	81 50       	subi	r24, 0x01	; 1
    cc9a:	c1 f7       	brne	.-16     	; 0xcc8c <_fpadd_parts+0x58>
    cc9c:	e2 01       	movw	r28, r4
    cc9e:	89 81       	ldd	r24, Y+1	; 0x01
    cca0:	11 96       	adiw	r26, 0x01	; 1
    cca2:	9c 91       	ld	r25, X
    cca4:	89 23       	and	r24, r25
    cca6:	81 83       	std	Z+1, r24	; 0x01
    cca8:	08 c1       	rjmp	.+528    	; 0xceba <_fpadd_parts+0x286>
    ccaa:	92 30       	cpi	r25, 0x02	; 2
    ccac:	09 f4       	brne	.+2      	; 0xccb0 <_fpadd_parts+0x7c>
    ccae:	07 c1       	rjmp	.+526    	; 0xcebe <_fpadd_parts+0x28a>
    ccb0:	12 96       	adiw	r26, 0x02	; 2
    ccb2:	2d 90       	ld	r2, X+
    ccb4:	3c 90       	ld	r3, X
    ccb6:	13 97       	sbiw	r26, 0x03	; 3
    ccb8:	eb 01       	movw	r28, r22
    ccba:	8a 81       	ldd	r24, Y+2	; 0x02
    ccbc:	9b 81       	ldd	r25, Y+3	; 0x03
    ccbe:	14 96       	adiw	r26, 0x04	; 4
    ccc0:	ad 90       	ld	r10, X+
    ccc2:	bd 90       	ld	r11, X+
    ccc4:	cd 90       	ld	r12, X+
    ccc6:	dc 90       	ld	r13, X
    ccc8:	17 97       	sbiw	r26, 0x07	; 7
    ccca:	ec 80       	ldd	r14, Y+4	; 0x04
    cccc:	fd 80       	ldd	r15, Y+5	; 0x05
    ccce:	0e 81       	ldd	r16, Y+6	; 0x06
    ccd0:	1f 81       	ldd	r17, Y+7	; 0x07
    ccd2:	91 01       	movw	r18, r2
    ccd4:	28 1b       	sub	r18, r24
    ccd6:	39 0b       	sbc	r19, r25
    ccd8:	b9 01       	movw	r22, r18
    ccda:	37 ff       	sbrs	r19, 7
    ccdc:	04 c0       	rjmp	.+8      	; 0xcce6 <_fpadd_parts+0xb2>
    ccde:	66 27       	eor	r22, r22
    cce0:	77 27       	eor	r23, r23
    cce2:	62 1b       	sub	r22, r18
    cce4:	73 0b       	sbc	r23, r19
    cce6:	60 32       	cpi	r22, 0x20	; 32
    cce8:	71 05       	cpc	r23, r1
    ccea:	0c f0       	brlt	.+2      	; 0xccee <_fpadd_parts+0xba>
    ccec:	61 c0       	rjmp	.+194    	; 0xcdb0 <_fpadd_parts+0x17c>
    ccee:	12 16       	cp	r1, r18
    ccf0:	13 06       	cpc	r1, r19
    ccf2:	6c f5       	brge	.+90     	; 0xcd4e <_fpadd_parts+0x11a>
    ccf4:	37 01       	movw	r6, r14
    ccf6:	48 01       	movw	r8, r16
    ccf8:	06 2e       	mov	r0, r22
    ccfa:	04 c0       	rjmp	.+8      	; 0xcd04 <_fpadd_parts+0xd0>
    ccfc:	96 94       	lsr	r9
    ccfe:	87 94       	ror	r8
    cd00:	77 94       	ror	r7
    cd02:	67 94       	ror	r6
    cd04:	0a 94       	dec	r0
    cd06:	d2 f7       	brpl	.-12     	; 0xccfc <_fpadd_parts+0xc8>
    cd08:	21 e0       	ldi	r18, 0x01	; 1
    cd0a:	30 e0       	ldi	r19, 0x00	; 0
    cd0c:	40 e0       	ldi	r20, 0x00	; 0
    cd0e:	50 e0       	ldi	r21, 0x00	; 0
    cd10:	04 c0       	rjmp	.+8      	; 0xcd1a <_fpadd_parts+0xe6>
    cd12:	22 0f       	add	r18, r18
    cd14:	33 1f       	adc	r19, r19
    cd16:	44 1f       	adc	r20, r20
    cd18:	55 1f       	adc	r21, r21
    cd1a:	6a 95       	dec	r22
    cd1c:	d2 f7       	brpl	.-12     	; 0xcd12 <_fpadd_parts+0xde>
    cd1e:	21 50       	subi	r18, 0x01	; 1
    cd20:	30 40       	sbci	r19, 0x00	; 0
    cd22:	40 40       	sbci	r20, 0x00	; 0
    cd24:	50 40       	sbci	r21, 0x00	; 0
    cd26:	2e 21       	and	r18, r14
    cd28:	3f 21       	and	r19, r15
    cd2a:	40 23       	and	r20, r16
    cd2c:	51 23       	and	r21, r17
    cd2e:	21 15       	cp	r18, r1
    cd30:	31 05       	cpc	r19, r1
    cd32:	41 05       	cpc	r20, r1
    cd34:	51 05       	cpc	r21, r1
    cd36:	21 f0       	breq	.+8      	; 0xcd40 <_fpadd_parts+0x10c>
    cd38:	21 e0       	ldi	r18, 0x01	; 1
    cd3a:	30 e0       	ldi	r19, 0x00	; 0
    cd3c:	40 e0       	ldi	r20, 0x00	; 0
    cd3e:	50 e0       	ldi	r21, 0x00	; 0
    cd40:	79 01       	movw	r14, r18
    cd42:	8a 01       	movw	r16, r20
    cd44:	e6 28       	or	r14, r6
    cd46:	f7 28       	or	r15, r7
    cd48:	08 29       	or	r16, r8
    cd4a:	19 29       	or	r17, r9
    cd4c:	3c c0       	rjmp	.+120    	; 0xcdc6 <_fpadd_parts+0x192>
    cd4e:	23 2b       	or	r18, r19
    cd50:	d1 f1       	breq	.+116    	; 0xcdc6 <_fpadd_parts+0x192>
    cd52:	26 0e       	add	r2, r22
    cd54:	37 1e       	adc	r3, r23
    cd56:	35 01       	movw	r6, r10
    cd58:	46 01       	movw	r8, r12
    cd5a:	06 2e       	mov	r0, r22
    cd5c:	04 c0       	rjmp	.+8      	; 0xcd66 <_fpadd_parts+0x132>
    cd5e:	96 94       	lsr	r9
    cd60:	87 94       	ror	r8
    cd62:	77 94       	ror	r7
    cd64:	67 94       	ror	r6
    cd66:	0a 94       	dec	r0
    cd68:	d2 f7       	brpl	.-12     	; 0xcd5e <_fpadd_parts+0x12a>
    cd6a:	21 e0       	ldi	r18, 0x01	; 1
    cd6c:	30 e0       	ldi	r19, 0x00	; 0
    cd6e:	40 e0       	ldi	r20, 0x00	; 0
    cd70:	50 e0       	ldi	r21, 0x00	; 0
    cd72:	04 c0       	rjmp	.+8      	; 0xcd7c <_fpadd_parts+0x148>
    cd74:	22 0f       	add	r18, r18
    cd76:	33 1f       	adc	r19, r19
    cd78:	44 1f       	adc	r20, r20
    cd7a:	55 1f       	adc	r21, r21
    cd7c:	6a 95       	dec	r22
    cd7e:	d2 f7       	brpl	.-12     	; 0xcd74 <_fpadd_parts+0x140>
    cd80:	21 50       	subi	r18, 0x01	; 1
    cd82:	30 40       	sbci	r19, 0x00	; 0
    cd84:	40 40       	sbci	r20, 0x00	; 0
    cd86:	50 40       	sbci	r21, 0x00	; 0
    cd88:	2a 21       	and	r18, r10
    cd8a:	3b 21       	and	r19, r11
    cd8c:	4c 21       	and	r20, r12
    cd8e:	5d 21       	and	r21, r13
    cd90:	21 15       	cp	r18, r1
    cd92:	31 05       	cpc	r19, r1
    cd94:	41 05       	cpc	r20, r1
    cd96:	51 05       	cpc	r21, r1
    cd98:	21 f0       	breq	.+8      	; 0xcda2 <_fpadd_parts+0x16e>
    cd9a:	21 e0       	ldi	r18, 0x01	; 1
    cd9c:	30 e0       	ldi	r19, 0x00	; 0
    cd9e:	40 e0       	ldi	r20, 0x00	; 0
    cda0:	50 e0       	ldi	r21, 0x00	; 0
    cda2:	59 01       	movw	r10, r18
    cda4:	6a 01       	movw	r12, r20
    cda6:	a6 28       	or	r10, r6
    cda8:	b7 28       	or	r11, r7
    cdaa:	c8 28       	or	r12, r8
    cdac:	d9 28       	or	r13, r9
    cdae:	0b c0       	rjmp	.+22     	; 0xcdc6 <_fpadd_parts+0x192>
    cdb0:	82 15       	cp	r24, r2
    cdb2:	93 05       	cpc	r25, r3
    cdb4:	2c f0       	brlt	.+10     	; 0xcdc0 <_fpadd_parts+0x18c>
    cdb6:	1c 01       	movw	r2, r24
    cdb8:	aa 24       	eor	r10, r10
    cdba:	bb 24       	eor	r11, r11
    cdbc:	65 01       	movw	r12, r10
    cdbe:	03 c0       	rjmp	.+6      	; 0xcdc6 <_fpadd_parts+0x192>
    cdc0:	ee 24       	eor	r14, r14
    cdc2:	ff 24       	eor	r15, r15
    cdc4:	87 01       	movw	r16, r14
    cdc6:	11 96       	adiw	r26, 0x01	; 1
    cdc8:	9c 91       	ld	r25, X
    cdca:	d2 01       	movw	r26, r4
    cdcc:	11 96       	adiw	r26, 0x01	; 1
    cdce:	8c 91       	ld	r24, X
    cdd0:	98 17       	cp	r25, r24
    cdd2:	09 f4       	brne	.+2      	; 0xcdd6 <_fpadd_parts+0x1a2>
    cdd4:	45 c0       	rjmp	.+138    	; 0xce60 <_fpadd_parts+0x22c>
    cdd6:	99 23       	and	r25, r25
    cdd8:	39 f0       	breq	.+14     	; 0xcde8 <_fpadd_parts+0x1b4>
    cdda:	a8 01       	movw	r20, r16
    cddc:	97 01       	movw	r18, r14
    cdde:	2a 19       	sub	r18, r10
    cde0:	3b 09       	sbc	r19, r11
    cde2:	4c 09       	sbc	r20, r12
    cde4:	5d 09       	sbc	r21, r13
    cde6:	06 c0       	rjmp	.+12     	; 0xcdf4 <_fpadd_parts+0x1c0>
    cde8:	a6 01       	movw	r20, r12
    cdea:	95 01       	movw	r18, r10
    cdec:	2e 19       	sub	r18, r14
    cdee:	3f 09       	sbc	r19, r15
    cdf0:	40 0b       	sbc	r20, r16
    cdf2:	51 0b       	sbc	r21, r17
    cdf4:	57 fd       	sbrc	r21, 7
    cdf6:	08 c0       	rjmp	.+16     	; 0xce08 <_fpadd_parts+0x1d4>
    cdf8:	11 82       	std	Z+1, r1	; 0x01
    cdfa:	33 82       	std	Z+3, r3	; 0x03
    cdfc:	22 82       	std	Z+2, r2	; 0x02
    cdfe:	24 83       	std	Z+4, r18	; 0x04
    ce00:	35 83       	std	Z+5, r19	; 0x05
    ce02:	46 83       	std	Z+6, r20	; 0x06
    ce04:	57 83       	std	Z+7, r21	; 0x07
    ce06:	1d c0       	rjmp	.+58     	; 0xce42 <_fpadd_parts+0x20e>
    ce08:	81 e0       	ldi	r24, 0x01	; 1
    ce0a:	81 83       	std	Z+1, r24	; 0x01
    ce0c:	33 82       	std	Z+3, r3	; 0x03
    ce0e:	22 82       	std	Z+2, r2	; 0x02
    ce10:	88 27       	eor	r24, r24
    ce12:	99 27       	eor	r25, r25
    ce14:	dc 01       	movw	r26, r24
    ce16:	82 1b       	sub	r24, r18
    ce18:	93 0b       	sbc	r25, r19
    ce1a:	a4 0b       	sbc	r26, r20
    ce1c:	b5 0b       	sbc	r27, r21
    ce1e:	84 83       	std	Z+4, r24	; 0x04
    ce20:	95 83       	std	Z+5, r25	; 0x05
    ce22:	a6 83       	std	Z+6, r26	; 0x06
    ce24:	b7 83       	std	Z+7, r27	; 0x07
    ce26:	0d c0       	rjmp	.+26     	; 0xce42 <_fpadd_parts+0x20e>
    ce28:	22 0f       	add	r18, r18
    ce2a:	33 1f       	adc	r19, r19
    ce2c:	44 1f       	adc	r20, r20
    ce2e:	55 1f       	adc	r21, r21
    ce30:	24 83       	std	Z+4, r18	; 0x04
    ce32:	35 83       	std	Z+5, r19	; 0x05
    ce34:	46 83       	std	Z+6, r20	; 0x06
    ce36:	57 83       	std	Z+7, r21	; 0x07
    ce38:	82 81       	ldd	r24, Z+2	; 0x02
    ce3a:	93 81       	ldd	r25, Z+3	; 0x03
    ce3c:	01 97       	sbiw	r24, 0x01	; 1
    ce3e:	93 83       	std	Z+3, r25	; 0x03
    ce40:	82 83       	std	Z+2, r24	; 0x02
    ce42:	24 81       	ldd	r18, Z+4	; 0x04
    ce44:	35 81       	ldd	r19, Z+5	; 0x05
    ce46:	46 81       	ldd	r20, Z+6	; 0x06
    ce48:	57 81       	ldd	r21, Z+7	; 0x07
    ce4a:	da 01       	movw	r26, r20
    ce4c:	c9 01       	movw	r24, r18
    ce4e:	01 97       	sbiw	r24, 0x01	; 1
    ce50:	a1 09       	sbc	r26, r1
    ce52:	b1 09       	sbc	r27, r1
    ce54:	8f 5f       	subi	r24, 0xFF	; 255
    ce56:	9f 4f       	sbci	r25, 0xFF	; 255
    ce58:	af 4f       	sbci	r26, 0xFF	; 255
    ce5a:	bf 43       	sbci	r27, 0x3F	; 63
    ce5c:	28 f3       	brcs	.-54     	; 0xce28 <_fpadd_parts+0x1f4>
    ce5e:	0b c0       	rjmp	.+22     	; 0xce76 <_fpadd_parts+0x242>
    ce60:	91 83       	std	Z+1, r25	; 0x01
    ce62:	33 82       	std	Z+3, r3	; 0x03
    ce64:	22 82       	std	Z+2, r2	; 0x02
    ce66:	ea 0c       	add	r14, r10
    ce68:	fb 1c       	adc	r15, r11
    ce6a:	0c 1d       	adc	r16, r12
    ce6c:	1d 1d       	adc	r17, r13
    ce6e:	e4 82       	std	Z+4, r14	; 0x04
    ce70:	f5 82       	std	Z+5, r15	; 0x05
    ce72:	06 83       	std	Z+6, r16	; 0x06
    ce74:	17 83       	std	Z+7, r17	; 0x07
    ce76:	83 e0       	ldi	r24, 0x03	; 3
    ce78:	80 83       	st	Z, r24
    ce7a:	24 81       	ldd	r18, Z+4	; 0x04
    ce7c:	35 81       	ldd	r19, Z+5	; 0x05
    ce7e:	46 81       	ldd	r20, Z+6	; 0x06
    ce80:	57 81       	ldd	r21, Z+7	; 0x07
    ce82:	57 ff       	sbrs	r21, 7
    ce84:	1a c0       	rjmp	.+52     	; 0xceba <_fpadd_parts+0x286>
    ce86:	c9 01       	movw	r24, r18
    ce88:	aa 27       	eor	r26, r26
    ce8a:	97 fd       	sbrc	r25, 7
    ce8c:	a0 95       	com	r26
    ce8e:	ba 2f       	mov	r27, r26
    ce90:	81 70       	andi	r24, 0x01	; 1
    ce92:	90 70       	andi	r25, 0x00	; 0
    ce94:	a0 70       	andi	r26, 0x00	; 0
    ce96:	b0 70       	andi	r27, 0x00	; 0
    ce98:	56 95       	lsr	r21
    ce9a:	47 95       	ror	r20
    ce9c:	37 95       	ror	r19
    ce9e:	27 95       	ror	r18
    cea0:	82 2b       	or	r24, r18
    cea2:	93 2b       	or	r25, r19
    cea4:	a4 2b       	or	r26, r20
    cea6:	b5 2b       	or	r27, r21
    cea8:	84 83       	std	Z+4, r24	; 0x04
    ceaa:	95 83       	std	Z+5, r25	; 0x05
    ceac:	a6 83       	std	Z+6, r26	; 0x06
    ceae:	b7 83       	std	Z+7, r27	; 0x07
    ceb0:	82 81       	ldd	r24, Z+2	; 0x02
    ceb2:	93 81       	ldd	r25, Z+3	; 0x03
    ceb4:	01 96       	adiw	r24, 0x01	; 1
    ceb6:	93 83       	std	Z+3, r25	; 0x03
    ceb8:	82 83       	std	Z+2, r24	; 0x02
    ceba:	df 01       	movw	r26, r30
    cebc:	01 c0       	rjmp	.+2      	; 0xcec0 <_fpadd_parts+0x28c>
    cebe:	d2 01       	movw	r26, r4
    cec0:	cd 01       	movw	r24, r26
    cec2:	cd b7       	in	r28, 0x3d	; 61
    cec4:	de b7       	in	r29, 0x3e	; 62
    cec6:	e2 e1       	ldi	r30, 0x12	; 18
    cec8:	0c 94 82 6e 	jmp	0xdd04	; 0xdd04 <__epilogue_restores__>

0000cecc <__subsf3>:
    cecc:	a0 e2       	ldi	r26, 0x20	; 32
    cece:	b0 e0       	ldi	r27, 0x00	; 0
    ced0:	ec e6       	ldi	r30, 0x6C	; 108
    ced2:	f7 e6       	ldi	r31, 0x67	; 103
    ced4:	0c 94 72 6e 	jmp	0xdce4	; 0xdce4 <__prologue_saves__+0x18>
    ced8:	69 83       	std	Y+1, r22	; 0x01
    ceda:	7a 83       	std	Y+2, r23	; 0x02
    cedc:	8b 83       	std	Y+3, r24	; 0x03
    cede:	9c 83       	std	Y+4, r25	; 0x04
    cee0:	2d 83       	std	Y+5, r18	; 0x05
    cee2:	3e 83       	std	Y+6, r19	; 0x06
    cee4:	4f 83       	std	Y+7, r20	; 0x07
    cee6:	58 87       	std	Y+8, r21	; 0x08
    cee8:	e9 e0       	ldi	r30, 0x09	; 9
    ceea:	ee 2e       	mov	r14, r30
    ceec:	f1 2c       	mov	r15, r1
    ceee:	ec 0e       	add	r14, r28
    cef0:	fd 1e       	adc	r15, r29
    cef2:	b7 01       	movw	r22, r14
    cef4:	ce 01       	movw	r24, r28
    cef6:	01 96       	adiw	r24, 0x01	; 1
    cef8:	0e 94 47 6c 	call	0xd88e	; 0xd88e <__unpack_f>
    cefc:	8e 01       	movw	r16, r28
    cefe:	0f 5e       	subi	r16, 0xEF	; 239
    cf00:	1f 4f       	sbci	r17, 0xFF	; 255
    cf02:	b8 01       	movw	r22, r16
    cf04:	ce 01       	movw	r24, r28
    cf06:	05 96       	adiw	r24, 0x05	; 5
    cf08:	0e 94 47 6c 	call	0xd88e	; 0xd88e <__unpack_f>
    cf0c:	8a 89       	ldd	r24, Y+18	; 0x12
    cf0e:	91 e0       	ldi	r25, 0x01	; 1
    cf10:	89 27       	eor	r24, r25
    cf12:	8a 8b       	std	Y+18, r24	; 0x12
    cf14:	ae 01       	movw	r20, r28
    cf16:	47 5e       	subi	r20, 0xE7	; 231
    cf18:	5f 4f       	sbci	r21, 0xFF	; 255
    cf1a:	b8 01       	movw	r22, r16
    cf1c:	c7 01       	movw	r24, r14
    cf1e:	0e 94 1a 66 	call	0xcc34	; 0xcc34 <_fpadd_parts>
    cf22:	0e 94 72 6b 	call	0xd6e4	; 0xd6e4 <__pack_f>
    cf26:	a0 96       	adiw	r28, 0x20	; 32
    cf28:	e6 e0       	ldi	r30, 0x06	; 6
    cf2a:	0c 94 8e 6e 	jmp	0xdd1c	; 0xdd1c <__epilogue_restores__+0x18>

0000cf2e <__addsf3>:
    cf2e:	a0 e2       	ldi	r26, 0x20	; 32
    cf30:	b0 e0       	ldi	r27, 0x00	; 0
    cf32:	ed e9       	ldi	r30, 0x9D	; 157
    cf34:	f7 e6       	ldi	r31, 0x67	; 103
    cf36:	0c 94 72 6e 	jmp	0xdce4	; 0xdce4 <__prologue_saves__+0x18>
    cf3a:	69 83       	std	Y+1, r22	; 0x01
    cf3c:	7a 83       	std	Y+2, r23	; 0x02
    cf3e:	8b 83       	std	Y+3, r24	; 0x03
    cf40:	9c 83       	std	Y+4, r25	; 0x04
    cf42:	2d 83       	std	Y+5, r18	; 0x05
    cf44:	3e 83       	std	Y+6, r19	; 0x06
    cf46:	4f 83       	std	Y+7, r20	; 0x07
    cf48:	58 87       	std	Y+8, r21	; 0x08
    cf4a:	f9 e0       	ldi	r31, 0x09	; 9
    cf4c:	ef 2e       	mov	r14, r31
    cf4e:	f1 2c       	mov	r15, r1
    cf50:	ec 0e       	add	r14, r28
    cf52:	fd 1e       	adc	r15, r29
    cf54:	b7 01       	movw	r22, r14
    cf56:	ce 01       	movw	r24, r28
    cf58:	01 96       	adiw	r24, 0x01	; 1
    cf5a:	0e 94 47 6c 	call	0xd88e	; 0xd88e <__unpack_f>
    cf5e:	8e 01       	movw	r16, r28
    cf60:	0f 5e       	subi	r16, 0xEF	; 239
    cf62:	1f 4f       	sbci	r17, 0xFF	; 255
    cf64:	b8 01       	movw	r22, r16
    cf66:	ce 01       	movw	r24, r28
    cf68:	05 96       	adiw	r24, 0x05	; 5
    cf6a:	0e 94 47 6c 	call	0xd88e	; 0xd88e <__unpack_f>
    cf6e:	ae 01       	movw	r20, r28
    cf70:	47 5e       	subi	r20, 0xE7	; 231
    cf72:	5f 4f       	sbci	r21, 0xFF	; 255
    cf74:	b8 01       	movw	r22, r16
    cf76:	c7 01       	movw	r24, r14
    cf78:	0e 94 1a 66 	call	0xcc34	; 0xcc34 <_fpadd_parts>
    cf7c:	0e 94 72 6b 	call	0xd6e4	; 0xd6e4 <__pack_f>
    cf80:	a0 96       	adiw	r28, 0x20	; 32
    cf82:	e6 e0       	ldi	r30, 0x06	; 6
    cf84:	0c 94 8e 6e 	jmp	0xdd1c	; 0xdd1c <__epilogue_restores__+0x18>

0000cf88 <__mulsf3>:
    cf88:	a0 e2       	ldi	r26, 0x20	; 32
    cf8a:	b0 e0       	ldi	r27, 0x00	; 0
    cf8c:	ea ec       	ldi	r30, 0xCA	; 202
    cf8e:	f7 e6       	ldi	r31, 0x67	; 103
    cf90:	0c 94 66 6e 	jmp	0xdccc	; 0xdccc <__prologue_saves__>
    cf94:	69 83       	std	Y+1, r22	; 0x01
    cf96:	7a 83       	std	Y+2, r23	; 0x02
    cf98:	8b 83       	std	Y+3, r24	; 0x03
    cf9a:	9c 83       	std	Y+4, r25	; 0x04
    cf9c:	2d 83       	std	Y+5, r18	; 0x05
    cf9e:	3e 83       	std	Y+6, r19	; 0x06
    cfa0:	4f 83       	std	Y+7, r20	; 0x07
    cfa2:	58 87       	std	Y+8, r21	; 0x08
    cfa4:	be 01       	movw	r22, r28
    cfa6:	67 5f       	subi	r22, 0xF7	; 247
    cfa8:	7f 4f       	sbci	r23, 0xFF	; 255
    cfaa:	ce 01       	movw	r24, r28
    cfac:	01 96       	adiw	r24, 0x01	; 1
    cfae:	0e 94 47 6c 	call	0xd88e	; 0xd88e <__unpack_f>
    cfb2:	be 01       	movw	r22, r28
    cfb4:	6f 5e       	subi	r22, 0xEF	; 239
    cfb6:	7f 4f       	sbci	r23, 0xFF	; 255
    cfb8:	ce 01       	movw	r24, r28
    cfba:	05 96       	adiw	r24, 0x05	; 5
    cfbc:	0e 94 47 6c 	call	0xd88e	; 0xd88e <__unpack_f>
    cfc0:	99 85       	ldd	r25, Y+9	; 0x09
    cfc2:	92 30       	cpi	r25, 0x02	; 2
    cfc4:	88 f0       	brcs	.+34     	; 0xcfe8 <__mulsf3+0x60>
    cfc6:	89 89       	ldd	r24, Y+17	; 0x11
    cfc8:	82 30       	cpi	r24, 0x02	; 2
    cfca:	c8 f0       	brcs	.+50     	; 0xcffe <__mulsf3+0x76>
    cfcc:	94 30       	cpi	r25, 0x04	; 4
    cfce:	19 f4       	brne	.+6      	; 0xcfd6 <__mulsf3+0x4e>
    cfd0:	82 30       	cpi	r24, 0x02	; 2
    cfd2:	51 f4       	brne	.+20     	; 0xcfe8 <__mulsf3+0x60>
    cfd4:	04 c0       	rjmp	.+8      	; 0xcfde <__mulsf3+0x56>
    cfd6:	84 30       	cpi	r24, 0x04	; 4
    cfd8:	29 f4       	brne	.+10     	; 0xcfe4 <__mulsf3+0x5c>
    cfda:	92 30       	cpi	r25, 0x02	; 2
    cfdc:	81 f4       	brne	.+32     	; 0xcffe <__mulsf3+0x76>
    cfde:	85 e7       	ldi	r24, 0x75	; 117
    cfe0:	94 e0       	ldi	r25, 0x04	; 4
    cfe2:	c6 c0       	rjmp	.+396    	; 0xd170 <__mulsf3+0x1e8>
    cfe4:	92 30       	cpi	r25, 0x02	; 2
    cfe6:	49 f4       	brne	.+18     	; 0xcffa <__mulsf3+0x72>
    cfe8:	20 e0       	ldi	r18, 0x00	; 0
    cfea:	9a 85       	ldd	r25, Y+10	; 0x0a
    cfec:	8a 89       	ldd	r24, Y+18	; 0x12
    cfee:	98 13       	cpse	r25, r24
    cff0:	21 e0       	ldi	r18, 0x01	; 1
    cff2:	2a 87       	std	Y+10, r18	; 0x0a
    cff4:	ce 01       	movw	r24, r28
    cff6:	09 96       	adiw	r24, 0x09	; 9
    cff8:	bb c0       	rjmp	.+374    	; 0xd170 <__mulsf3+0x1e8>
    cffa:	82 30       	cpi	r24, 0x02	; 2
    cffc:	49 f4       	brne	.+18     	; 0xd010 <__mulsf3+0x88>
    cffe:	20 e0       	ldi	r18, 0x00	; 0
    d000:	9a 85       	ldd	r25, Y+10	; 0x0a
    d002:	8a 89       	ldd	r24, Y+18	; 0x12
    d004:	98 13       	cpse	r25, r24
    d006:	21 e0       	ldi	r18, 0x01	; 1
    d008:	2a 8b       	std	Y+18, r18	; 0x12
    d00a:	ce 01       	movw	r24, r28
    d00c:	41 96       	adiw	r24, 0x11	; 17
    d00e:	b0 c0       	rjmp	.+352    	; 0xd170 <__mulsf3+0x1e8>
    d010:	2d 84       	ldd	r2, Y+13	; 0x0d
    d012:	3e 84       	ldd	r3, Y+14	; 0x0e
    d014:	4f 84       	ldd	r4, Y+15	; 0x0f
    d016:	58 88       	ldd	r5, Y+16	; 0x10
    d018:	6d 88       	ldd	r6, Y+21	; 0x15
    d01a:	7e 88       	ldd	r7, Y+22	; 0x16
    d01c:	8f 88       	ldd	r8, Y+23	; 0x17
    d01e:	98 8c       	ldd	r9, Y+24	; 0x18
    d020:	ee 24       	eor	r14, r14
    d022:	ff 24       	eor	r15, r15
    d024:	87 01       	movw	r16, r14
    d026:	aa 24       	eor	r10, r10
    d028:	bb 24       	eor	r11, r11
    d02a:	65 01       	movw	r12, r10
    d02c:	40 e0       	ldi	r20, 0x00	; 0
    d02e:	50 e0       	ldi	r21, 0x00	; 0
    d030:	60 e0       	ldi	r22, 0x00	; 0
    d032:	70 e0       	ldi	r23, 0x00	; 0
    d034:	e0 e0       	ldi	r30, 0x00	; 0
    d036:	f0 e0       	ldi	r31, 0x00	; 0
    d038:	c1 01       	movw	r24, r2
    d03a:	81 70       	andi	r24, 0x01	; 1
    d03c:	90 70       	andi	r25, 0x00	; 0
    d03e:	89 2b       	or	r24, r25
    d040:	e9 f0       	breq	.+58     	; 0xd07c <__mulsf3+0xf4>
    d042:	e6 0c       	add	r14, r6
    d044:	f7 1c       	adc	r15, r7
    d046:	08 1d       	adc	r16, r8
    d048:	19 1d       	adc	r17, r9
    d04a:	9a 01       	movw	r18, r20
    d04c:	ab 01       	movw	r20, r22
    d04e:	2a 0d       	add	r18, r10
    d050:	3b 1d       	adc	r19, r11
    d052:	4c 1d       	adc	r20, r12
    d054:	5d 1d       	adc	r21, r13
    d056:	80 e0       	ldi	r24, 0x00	; 0
    d058:	90 e0       	ldi	r25, 0x00	; 0
    d05a:	a0 e0       	ldi	r26, 0x00	; 0
    d05c:	b0 e0       	ldi	r27, 0x00	; 0
    d05e:	e6 14       	cp	r14, r6
    d060:	f7 04       	cpc	r15, r7
    d062:	08 05       	cpc	r16, r8
    d064:	19 05       	cpc	r17, r9
    d066:	20 f4       	brcc	.+8      	; 0xd070 <__mulsf3+0xe8>
    d068:	81 e0       	ldi	r24, 0x01	; 1
    d06a:	90 e0       	ldi	r25, 0x00	; 0
    d06c:	a0 e0       	ldi	r26, 0x00	; 0
    d06e:	b0 e0       	ldi	r27, 0x00	; 0
    d070:	ba 01       	movw	r22, r20
    d072:	a9 01       	movw	r20, r18
    d074:	48 0f       	add	r20, r24
    d076:	59 1f       	adc	r21, r25
    d078:	6a 1f       	adc	r22, r26
    d07a:	7b 1f       	adc	r23, r27
    d07c:	aa 0c       	add	r10, r10
    d07e:	bb 1c       	adc	r11, r11
    d080:	cc 1c       	adc	r12, r12
    d082:	dd 1c       	adc	r13, r13
    d084:	97 fe       	sbrs	r9, 7
    d086:	08 c0       	rjmp	.+16     	; 0xd098 <__mulsf3+0x110>
    d088:	81 e0       	ldi	r24, 0x01	; 1
    d08a:	90 e0       	ldi	r25, 0x00	; 0
    d08c:	a0 e0       	ldi	r26, 0x00	; 0
    d08e:	b0 e0       	ldi	r27, 0x00	; 0
    d090:	a8 2a       	or	r10, r24
    d092:	b9 2a       	or	r11, r25
    d094:	ca 2a       	or	r12, r26
    d096:	db 2a       	or	r13, r27
    d098:	31 96       	adiw	r30, 0x01	; 1
    d09a:	e0 32       	cpi	r30, 0x20	; 32
    d09c:	f1 05       	cpc	r31, r1
    d09e:	49 f0       	breq	.+18     	; 0xd0b2 <__mulsf3+0x12a>
    d0a0:	66 0c       	add	r6, r6
    d0a2:	77 1c       	adc	r7, r7
    d0a4:	88 1c       	adc	r8, r8
    d0a6:	99 1c       	adc	r9, r9
    d0a8:	56 94       	lsr	r5
    d0aa:	47 94       	ror	r4
    d0ac:	37 94       	ror	r3
    d0ae:	27 94       	ror	r2
    d0b0:	c3 cf       	rjmp	.-122    	; 0xd038 <__mulsf3+0xb0>
    d0b2:	fa 85       	ldd	r31, Y+10	; 0x0a
    d0b4:	ea 89       	ldd	r30, Y+18	; 0x12
    d0b6:	2b 89       	ldd	r18, Y+19	; 0x13
    d0b8:	3c 89       	ldd	r19, Y+20	; 0x14
    d0ba:	8b 85       	ldd	r24, Y+11	; 0x0b
    d0bc:	9c 85       	ldd	r25, Y+12	; 0x0c
    d0be:	28 0f       	add	r18, r24
    d0c0:	39 1f       	adc	r19, r25
    d0c2:	2e 5f       	subi	r18, 0xFE	; 254
    d0c4:	3f 4f       	sbci	r19, 0xFF	; 255
    d0c6:	17 c0       	rjmp	.+46     	; 0xd0f6 <__mulsf3+0x16e>
    d0c8:	ca 01       	movw	r24, r20
    d0ca:	81 70       	andi	r24, 0x01	; 1
    d0cc:	90 70       	andi	r25, 0x00	; 0
    d0ce:	89 2b       	or	r24, r25
    d0d0:	61 f0       	breq	.+24     	; 0xd0ea <__mulsf3+0x162>
    d0d2:	16 95       	lsr	r17
    d0d4:	07 95       	ror	r16
    d0d6:	f7 94       	ror	r15
    d0d8:	e7 94       	ror	r14
    d0da:	80 e0       	ldi	r24, 0x00	; 0
    d0dc:	90 e0       	ldi	r25, 0x00	; 0
    d0de:	a0 e0       	ldi	r26, 0x00	; 0
    d0e0:	b0 e8       	ldi	r27, 0x80	; 128
    d0e2:	e8 2a       	or	r14, r24
    d0e4:	f9 2a       	or	r15, r25
    d0e6:	0a 2b       	or	r16, r26
    d0e8:	1b 2b       	or	r17, r27
    d0ea:	76 95       	lsr	r23
    d0ec:	67 95       	ror	r22
    d0ee:	57 95       	ror	r21
    d0f0:	47 95       	ror	r20
    d0f2:	2f 5f       	subi	r18, 0xFF	; 255
    d0f4:	3f 4f       	sbci	r19, 0xFF	; 255
    d0f6:	77 fd       	sbrc	r23, 7
    d0f8:	e7 cf       	rjmp	.-50     	; 0xd0c8 <__mulsf3+0x140>
    d0fa:	0c c0       	rjmp	.+24     	; 0xd114 <__mulsf3+0x18c>
    d0fc:	44 0f       	add	r20, r20
    d0fe:	55 1f       	adc	r21, r21
    d100:	66 1f       	adc	r22, r22
    d102:	77 1f       	adc	r23, r23
    d104:	17 fd       	sbrc	r17, 7
    d106:	41 60       	ori	r20, 0x01	; 1
    d108:	ee 0c       	add	r14, r14
    d10a:	ff 1c       	adc	r15, r15
    d10c:	00 1f       	adc	r16, r16
    d10e:	11 1f       	adc	r17, r17
    d110:	21 50       	subi	r18, 0x01	; 1
    d112:	30 40       	sbci	r19, 0x00	; 0
    d114:	40 30       	cpi	r20, 0x00	; 0
    d116:	90 e0       	ldi	r25, 0x00	; 0
    d118:	59 07       	cpc	r21, r25
    d11a:	90 e0       	ldi	r25, 0x00	; 0
    d11c:	69 07       	cpc	r22, r25
    d11e:	90 e4       	ldi	r25, 0x40	; 64
    d120:	79 07       	cpc	r23, r25
    d122:	60 f3       	brcs	.-40     	; 0xd0fc <__mulsf3+0x174>
    d124:	2b 8f       	std	Y+27, r18	; 0x1b
    d126:	3c 8f       	std	Y+28, r19	; 0x1c
    d128:	db 01       	movw	r26, r22
    d12a:	ca 01       	movw	r24, r20
    d12c:	8f 77       	andi	r24, 0x7F	; 127
    d12e:	90 70       	andi	r25, 0x00	; 0
    d130:	a0 70       	andi	r26, 0x00	; 0
    d132:	b0 70       	andi	r27, 0x00	; 0
    d134:	80 34       	cpi	r24, 0x40	; 64
    d136:	91 05       	cpc	r25, r1
    d138:	a1 05       	cpc	r26, r1
    d13a:	b1 05       	cpc	r27, r1
    d13c:	61 f4       	brne	.+24     	; 0xd156 <__mulsf3+0x1ce>
    d13e:	47 fd       	sbrc	r20, 7
    d140:	0a c0       	rjmp	.+20     	; 0xd156 <__mulsf3+0x1ce>
    d142:	e1 14       	cp	r14, r1
    d144:	f1 04       	cpc	r15, r1
    d146:	01 05       	cpc	r16, r1
    d148:	11 05       	cpc	r17, r1
    d14a:	29 f0       	breq	.+10     	; 0xd156 <__mulsf3+0x1ce>
    d14c:	40 5c       	subi	r20, 0xC0	; 192
    d14e:	5f 4f       	sbci	r21, 0xFF	; 255
    d150:	6f 4f       	sbci	r22, 0xFF	; 255
    d152:	7f 4f       	sbci	r23, 0xFF	; 255
    d154:	40 78       	andi	r20, 0x80	; 128
    d156:	1a 8e       	std	Y+26, r1	; 0x1a
    d158:	fe 17       	cp	r31, r30
    d15a:	11 f0       	breq	.+4      	; 0xd160 <__mulsf3+0x1d8>
    d15c:	81 e0       	ldi	r24, 0x01	; 1
    d15e:	8a 8f       	std	Y+26, r24	; 0x1a
    d160:	4d 8f       	std	Y+29, r20	; 0x1d
    d162:	5e 8f       	std	Y+30, r21	; 0x1e
    d164:	6f 8f       	std	Y+31, r22	; 0x1f
    d166:	78 a3       	std	Y+32, r23	; 0x20
    d168:	83 e0       	ldi	r24, 0x03	; 3
    d16a:	89 8f       	std	Y+25, r24	; 0x19
    d16c:	ce 01       	movw	r24, r28
    d16e:	49 96       	adiw	r24, 0x19	; 25
    d170:	0e 94 72 6b 	call	0xd6e4	; 0xd6e4 <__pack_f>
    d174:	a0 96       	adiw	r28, 0x20	; 32
    d176:	e2 e1       	ldi	r30, 0x12	; 18
    d178:	0c 94 82 6e 	jmp	0xdd04	; 0xdd04 <__epilogue_restores__>

0000d17c <__divsf3>:
    d17c:	a8 e1       	ldi	r26, 0x18	; 24
    d17e:	b0 e0       	ldi	r27, 0x00	; 0
    d180:	e4 ec       	ldi	r30, 0xC4	; 196
    d182:	f8 e6       	ldi	r31, 0x68	; 104
    d184:	0c 94 6e 6e 	jmp	0xdcdc	; 0xdcdc <__prologue_saves__+0x10>
    d188:	69 83       	std	Y+1, r22	; 0x01
    d18a:	7a 83       	std	Y+2, r23	; 0x02
    d18c:	8b 83       	std	Y+3, r24	; 0x03
    d18e:	9c 83       	std	Y+4, r25	; 0x04
    d190:	2d 83       	std	Y+5, r18	; 0x05
    d192:	3e 83       	std	Y+6, r19	; 0x06
    d194:	4f 83       	std	Y+7, r20	; 0x07
    d196:	58 87       	std	Y+8, r21	; 0x08
    d198:	b9 e0       	ldi	r27, 0x09	; 9
    d19a:	eb 2e       	mov	r14, r27
    d19c:	f1 2c       	mov	r15, r1
    d19e:	ec 0e       	add	r14, r28
    d1a0:	fd 1e       	adc	r15, r29
    d1a2:	b7 01       	movw	r22, r14
    d1a4:	ce 01       	movw	r24, r28
    d1a6:	01 96       	adiw	r24, 0x01	; 1
    d1a8:	0e 94 47 6c 	call	0xd88e	; 0xd88e <__unpack_f>
    d1ac:	8e 01       	movw	r16, r28
    d1ae:	0f 5e       	subi	r16, 0xEF	; 239
    d1b0:	1f 4f       	sbci	r17, 0xFF	; 255
    d1b2:	b8 01       	movw	r22, r16
    d1b4:	ce 01       	movw	r24, r28
    d1b6:	05 96       	adiw	r24, 0x05	; 5
    d1b8:	0e 94 47 6c 	call	0xd88e	; 0xd88e <__unpack_f>
    d1bc:	29 85       	ldd	r18, Y+9	; 0x09
    d1be:	22 30       	cpi	r18, 0x02	; 2
    d1c0:	08 f4       	brcc	.+2      	; 0xd1c4 <__divsf3+0x48>
    d1c2:	7c c0       	rjmp	.+248    	; 0xd2bc <__divsf3+0x140>
    d1c4:	39 89       	ldd	r19, Y+17	; 0x11
    d1c6:	32 30       	cpi	r19, 0x02	; 2
    d1c8:	10 f4       	brcc	.+4      	; 0xd1ce <__divsf3+0x52>
    d1ca:	b8 01       	movw	r22, r16
    d1cc:	7a c0       	rjmp	.+244    	; 0xd2c2 <__divsf3+0x146>
    d1ce:	8a 85       	ldd	r24, Y+10	; 0x0a
    d1d0:	9a 89       	ldd	r25, Y+18	; 0x12
    d1d2:	89 27       	eor	r24, r25
    d1d4:	8a 87       	std	Y+10, r24	; 0x0a
    d1d6:	24 30       	cpi	r18, 0x04	; 4
    d1d8:	11 f0       	breq	.+4      	; 0xd1de <__divsf3+0x62>
    d1da:	22 30       	cpi	r18, 0x02	; 2
    d1dc:	31 f4       	brne	.+12     	; 0xd1ea <__divsf3+0x6e>
    d1de:	23 17       	cp	r18, r19
    d1e0:	09 f0       	breq	.+2      	; 0xd1e4 <__divsf3+0x68>
    d1e2:	6c c0       	rjmp	.+216    	; 0xd2bc <__divsf3+0x140>
    d1e4:	65 e7       	ldi	r22, 0x75	; 117
    d1e6:	74 e0       	ldi	r23, 0x04	; 4
    d1e8:	6c c0       	rjmp	.+216    	; 0xd2c2 <__divsf3+0x146>
    d1ea:	34 30       	cpi	r19, 0x04	; 4
    d1ec:	39 f4       	brne	.+14     	; 0xd1fc <__divsf3+0x80>
    d1ee:	1d 86       	std	Y+13, r1	; 0x0d
    d1f0:	1e 86       	std	Y+14, r1	; 0x0e
    d1f2:	1f 86       	std	Y+15, r1	; 0x0f
    d1f4:	18 8a       	std	Y+16, r1	; 0x10
    d1f6:	1c 86       	std	Y+12, r1	; 0x0c
    d1f8:	1b 86       	std	Y+11, r1	; 0x0b
    d1fa:	04 c0       	rjmp	.+8      	; 0xd204 <__divsf3+0x88>
    d1fc:	32 30       	cpi	r19, 0x02	; 2
    d1fe:	21 f4       	brne	.+8      	; 0xd208 <__divsf3+0x8c>
    d200:	84 e0       	ldi	r24, 0x04	; 4
    d202:	89 87       	std	Y+9, r24	; 0x09
    d204:	b7 01       	movw	r22, r14
    d206:	5d c0       	rjmp	.+186    	; 0xd2c2 <__divsf3+0x146>
    d208:	2b 85       	ldd	r18, Y+11	; 0x0b
    d20a:	3c 85       	ldd	r19, Y+12	; 0x0c
    d20c:	8b 89       	ldd	r24, Y+19	; 0x13
    d20e:	9c 89       	ldd	r25, Y+20	; 0x14
    d210:	28 1b       	sub	r18, r24
    d212:	39 0b       	sbc	r19, r25
    d214:	3c 87       	std	Y+12, r19	; 0x0c
    d216:	2b 87       	std	Y+11, r18	; 0x0b
    d218:	ed 84       	ldd	r14, Y+13	; 0x0d
    d21a:	fe 84       	ldd	r15, Y+14	; 0x0e
    d21c:	0f 85       	ldd	r16, Y+15	; 0x0f
    d21e:	18 89       	ldd	r17, Y+16	; 0x10
    d220:	ad 88       	ldd	r10, Y+21	; 0x15
    d222:	be 88       	ldd	r11, Y+22	; 0x16
    d224:	cf 88       	ldd	r12, Y+23	; 0x17
    d226:	d8 8c       	ldd	r13, Y+24	; 0x18
    d228:	ea 14       	cp	r14, r10
    d22a:	fb 04       	cpc	r15, r11
    d22c:	0c 05       	cpc	r16, r12
    d22e:	1d 05       	cpc	r17, r13
    d230:	40 f4       	brcc	.+16     	; 0xd242 <__divsf3+0xc6>
    d232:	ee 0c       	add	r14, r14
    d234:	ff 1c       	adc	r15, r15
    d236:	00 1f       	adc	r16, r16
    d238:	11 1f       	adc	r17, r17
    d23a:	21 50       	subi	r18, 0x01	; 1
    d23c:	30 40       	sbci	r19, 0x00	; 0
    d23e:	3c 87       	std	Y+12, r19	; 0x0c
    d240:	2b 87       	std	Y+11, r18	; 0x0b
    d242:	20 e0       	ldi	r18, 0x00	; 0
    d244:	30 e0       	ldi	r19, 0x00	; 0
    d246:	40 e0       	ldi	r20, 0x00	; 0
    d248:	50 e0       	ldi	r21, 0x00	; 0
    d24a:	80 e0       	ldi	r24, 0x00	; 0
    d24c:	90 e0       	ldi	r25, 0x00	; 0
    d24e:	a0 e0       	ldi	r26, 0x00	; 0
    d250:	b0 e4       	ldi	r27, 0x40	; 64
    d252:	6f e1       	ldi	r22, 0x1F	; 31
    d254:	70 e0       	ldi	r23, 0x00	; 0
    d256:	ea 14       	cp	r14, r10
    d258:	fb 04       	cpc	r15, r11
    d25a:	0c 05       	cpc	r16, r12
    d25c:	1d 05       	cpc	r17, r13
    d25e:	40 f0       	brcs	.+16     	; 0xd270 <__divsf3+0xf4>
    d260:	28 2b       	or	r18, r24
    d262:	39 2b       	or	r19, r25
    d264:	4a 2b       	or	r20, r26
    d266:	5b 2b       	or	r21, r27
    d268:	ea 18       	sub	r14, r10
    d26a:	fb 08       	sbc	r15, r11
    d26c:	0c 09       	sbc	r16, r12
    d26e:	1d 09       	sbc	r17, r13
    d270:	b6 95       	lsr	r27
    d272:	a7 95       	ror	r26
    d274:	97 95       	ror	r25
    d276:	87 95       	ror	r24
    d278:	ee 0c       	add	r14, r14
    d27a:	ff 1c       	adc	r15, r15
    d27c:	00 1f       	adc	r16, r16
    d27e:	11 1f       	adc	r17, r17
    d280:	61 50       	subi	r22, 0x01	; 1
    d282:	70 40       	sbci	r23, 0x00	; 0
    d284:	41 f7       	brne	.-48     	; 0xd256 <__divsf3+0xda>
    d286:	da 01       	movw	r26, r20
    d288:	c9 01       	movw	r24, r18
    d28a:	8f 77       	andi	r24, 0x7F	; 127
    d28c:	90 70       	andi	r25, 0x00	; 0
    d28e:	a0 70       	andi	r26, 0x00	; 0
    d290:	b0 70       	andi	r27, 0x00	; 0
    d292:	80 34       	cpi	r24, 0x40	; 64
    d294:	91 05       	cpc	r25, r1
    d296:	a1 05       	cpc	r26, r1
    d298:	b1 05       	cpc	r27, r1
    d29a:	61 f4       	brne	.+24     	; 0xd2b4 <__divsf3+0x138>
    d29c:	27 fd       	sbrc	r18, 7
    d29e:	0a c0       	rjmp	.+20     	; 0xd2b4 <__divsf3+0x138>
    d2a0:	e1 14       	cp	r14, r1
    d2a2:	f1 04       	cpc	r15, r1
    d2a4:	01 05       	cpc	r16, r1
    d2a6:	11 05       	cpc	r17, r1
    d2a8:	29 f0       	breq	.+10     	; 0xd2b4 <__divsf3+0x138>
    d2aa:	20 5c       	subi	r18, 0xC0	; 192
    d2ac:	3f 4f       	sbci	r19, 0xFF	; 255
    d2ae:	4f 4f       	sbci	r20, 0xFF	; 255
    d2b0:	5f 4f       	sbci	r21, 0xFF	; 255
    d2b2:	20 78       	andi	r18, 0x80	; 128
    d2b4:	2d 87       	std	Y+13, r18	; 0x0d
    d2b6:	3e 87       	std	Y+14, r19	; 0x0e
    d2b8:	4f 87       	std	Y+15, r20	; 0x0f
    d2ba:	58 8b       	std	Y+16, r21	; 0x10
    d2bc:	be 01       	movw	r22, r28
    d2be:	67 5f       	subi	r22, 0xF7	; 247
    d2c0:	7f 4f       	sbci	r23, 0xFF	; 255
    d2c2:	cb 01       	movw	r24, r22
    d2c4:	0e 94 72 6b 	call	0xd6e4	; 0xd6e4 <__pack_f>
    d2c8:	68 96       	adiw	r28, 0x18	; 24
    d2ca:	ea e0       	ldi	r30, 0x0A	; 10
    d2cc:	0c 94 8a 6e 	jmp	0xdd14	; 0xdd14 <__epilogue_restores__+0x10>

0000d2d0 <__gtsf2>:
    d2d0:	a8 e1       	ldi	r26, 0x18	; 24
    d2d2:	b0 e0       	ldi	r27, 0x00	; 0
    d2d4:	ee e6       	ldi	r30, 0x6E	; 110
    d2d6:	f9 e6       	ldi	r31, 0x69	; 105
    d2d8:	0c 94 72 6e 	jmp	0xdce4	; 0xdce4 <__prologue_saves__+0x18>
    d2dc:	69 83       	std	Y+1, r22	; 0x01
    d2de:	7a 83       	std	Y+2, r23	; 0x02
    d2e0:	8b 83       	std	Y+3, r24	; 0x03
    d2e2:	9c 83       	std	Y+4, r25	; 0x04
    d2e4:	2d 83       	std	Y+5, r18	; 0x05
    d2e6:	3e 83       	std	Y+6, r19	; 0x06
    d2e8:	4f 83       	std	Y+7, r20	; 0x07
    d2ea:	58 87       	std	Y+8, r21	; 0x08
    d2ec:	89 e0       	ldi	r24, 0x09	; 9
    d2ee:	e8 2e       	mov	r14, r24
    d2f0:	f1 2c       	mov	r15, r1
    d2f2:	ec 0e       	add	r14, r28
    d2f4:	fd 1e       	adc	r15, r29
    d2f6:	b7 01       	movw	r22, r14
    d2f8:	ce 01       	movw	r24, r28
    d2fa:	01 96       	adiw	r24, 0x01	; 1
    d2fc:	0e 94 47 6c 	call	0xd88e	; 0xd88e <__unpack_f>
    d300:	8e 01       	movw	r16, r28
    d302:	0f 5e       	subi	r16, 0xEF	; 239
    d304:	1f 4f       	sbci	r17, 0xFF	; 255
    d306:	b8 01       	movw	r22, r16
    d308:	ce 01       	movw	r24, r28
    d30a:	05 96       	adiw	r24, 0x05	; 5
    d30c:	0e 94 47 6c 	call	0xd88e	; 0xd88e <__unpack_f>
    d310:	89 85       	ldd	r24, Y+9	; 0x09
    d312:	82 30       	cpi	r24, 0x02	; 2
    d314:	40 f0       	brcs	.+16     	; 0xd326 <__gtsf2+0x56>
    d316:	89 89       	ldd	r24, Y+17	; 0x11
    d318:	82 30       	cpi	r24, 0x02	; 2
    d31a:	28 f0       	brcs	.+10     	; 0xd326 <__gtsf2+0x56>
    d31c:	b8 01       	movw	r22, r16
    d31e:	c7 01       	movw	r24, r14
    d320:	0e 94 bf 6c 	call	0xd97e	; 0xd97e <__fpcmp_parts_f>
    d324:	01 c0       	rjmp	.+2      	; 0xd328 <__gtsf2+0x58>
    d326:	8f ef       	ldi	r24, 0xFF	; 255
    d328:	68 96       	adiw	r28, 0x18	; 24
    d32a:	e6 e0       	ldi	r30, 0x06	; 6
    d32c:	0c 94 8e 6e 	jmp	0xdd1c	; 0xdd1c <__epilogue_restores__+0x18>

0000d330 <__gesf2>:
    d330:	a8 e1       	ldi	r26, 0x18	; 24
    d332:	b0 e0       	ldi	r27, 0x00	; 0
    d334:	ee e9       	ldi	r30, 0x9E	; 158
    d336:	f9 e6       	ldi	r31, 0x69	; 105
    d338:	0c 94 72 6e 	jmp	0xdce4	; 0xdce4 <__prologue_saves__+0x18>
    d33c:	69 83       	std	Y+1, r22	; 0x01
    d33e:	7a 83       	std	Y+2, r23	; 0x02
    d340:	8b 83       	std	Y+3, r24	; 0x03
    d342:	9c 83       	std	Y+4, r25	; 0x04
    d344:	2d 83       	std	Y+5, r18	; 0x05
    d346:	3e 83       	std	Y+6, r19	; 0x06
    d348:	4f 83       	std	Y+7, r20	; 0x07
    d34a:	58 87       	std	Y+8, r21	; 0x08
    d34c:	89 e0       	ldi	r24, 0x09	; 9
    d34e:	e8 2e       	mov	r14, r24
    d350:	f1 2c       	mov	r15, r1
    d352:	ec 0e       	add	r14, r28
    d354:	fd 1e       	adc	r15, r29
    d356:	b7 01       	movw	r22, r14
    d358:	ce 01       	movw	r24, r28
    d35a:	01 96       	adiw	r24, 0x01	; 1
    d35c:	0e 94 47 6c 	call	0xd88e	; 0xd88e <__unpack_f>
    d360:	8e 01       	movw	r16, r28
    d362:	0f 5e       	subi	r16, 0xEF	; 239
    d364:	1f 4f       	sbci	r17, 0xFF	; 255
    d366:	b8 01       	movw	r22, r16
    d368:	ce 01       	movw	r24, r28
    d36a:	05 96       	adiw	r24, 0x05	; 5
    d36c:	0e 94 47 6c 	call	0xd88e	; 0xd88e <__unpack_f>
    d370:	89 85       	ldd	r24, Y+9	; 0x09
    d372:	82 30       	cpi	r24, 0x02	; 2
    d374:	40 f0       	brcs	.+16     	; 0xd386 <__gesf2+0x56>
    d376:	89 89       	ldd	r24, Y+17	; 0x11
    d378:	82 30       	cpi	r24, 0x02	; 2
    d37a:	28 f0       	brcs	.+10     	; 0xd386 <__gesf2+0x56>
    d37c:	b8 01       	movw	r22, r16
    d37e:	c7 01       	movw	r24, r14
    d380:	0e 94 bf 6c 	call	0xd97e	; 0xd97e <__fpcmp_parts_f>
    d384:	01 c0       	rjmp	.+2      	; 0xd388 <__gesf2+0x58>
    d386:	8f ef       	ldi	r24, 0xFF	; 255
    d388:	68 96       	adiw	r28, 0x18	; 24
    d38a:	e6 e0       	ldi	r30, 0x06	; 6
    d38c:	0c 94 8e 6e 	jmp	0xdd1c	; 0xdd1c <__epilogue_restores__+0x18>

0000d390 <__ltsf2>:
    d390:	a8 e1       	ldi	r26, 0x18	; 24
    d392:	b0 e0       	ldi	r27, 0x00	; 0
    d394:	ee ec       	ldi	r30, 0xCE	; 206
    d396:	f9 e6       	ldi	r31, 0x69	; 105
    d398:	0c 94 72 6e 	jmp	0xdce4	; 0xdce4 <__prologue_saves__+0x18>
    d39c:	69 83       	std	Y+1, r22	; 0x01
    d39e:	7a 83       	std	Y+2, r23	; 0x02
    d3a0:	8b 83       	std	Y+3, r24	; 0x03
    d3a2:	9c 83       	std	Y+4, r25	; 0x04
    d3a4:	2d 83       	std	Y+5, r18	; 0x05
    d3a6:	3e 83       	std	Y+6, r19	; 0x06
    d3a8:	4f 83       	std	Y+7, r20	; 0x07
    d3aa:	58 87       	std	Y+8, r21	; 0x08
    d3ac:	89 e0       	ldi	r24, 0x09	; 9
    d3ae:	e8 2e       	mov	r14, r24
    d3b0:	f1 2c       	mov	r15, r1
    d3b2:	ec 0e       	add	r14, r28
    d3b4:	fd 1e       	adc	r15, r29
    d3b6:	b7 01       	movw	r22, r14
    d3b8:	ce 01       	movw	r24, r28
    d3ba:	01 96       	adiw	r24, 0x01	; 1
    d3bc:	0e 94 47 6c 	call	0xd88e	; 0xd88e <__unpack_f>
    d3c0:	8e 01       	movw	r16, r28
    d3c2:	0f 5e       	subi	r16, 0xEF	; 239
    d3c4:	1f 4f       	sbci	r17, 0xFF	; 255
    d3c6:	b8 01       	movw	r22, r16
    d3c8:	ce 01       	movw	r24, r28
    d3ca:	05 96       	adiw	r24, 0x05	; 5
    d3cc:	0e 94 47 6c 	call	0xd88e	; 0xd88e <__unpack_f>
    d3d0:	89 85       	ldd	r24, Y+9	; 0x09
    d3d2:	82 30       	cpi	r24, 0x02	; 2
    d3d4:	40 f0       	brcs	.+16     	; 0xd3e6 <__ltsf2+0x56>
    d3d6:	89 89       	ldd	r24, Y+17	; 0x11
    d3d8:	82 30       	cpi	r24, 0x02	; 2
    d3da:	28 f0       	brcs	.+10     	; 0xd3e6 <__ltsf2+0x56>
    d3dc:	b8 01       	movw	r22, r16
    d3de:	c7 01       	movw	r24, r14
    d3e0:	0e 94 bf 6c 	call	0xd97e	; 0xd97e <__fpcmp_parts_f>
    d3e4:	01 c0       	rjmp	.+2      	; 0xd3e8 <__ltsf2+0x58>
    d3e6:	81 e0       	ldi	r24, 0x01	; 1
    d3e8:	68 96       	adiw	r28, 0x18	; 24
    d3ea:	e6 e0       	ldi	r30, 0x06	; 6
    d3ec:	0c 94 8e 6e 	jmp	0xdd1c	; 0xdd1c <__epilogue_restores__+0x18>

0000d3f0 <__floatsisf>:
    d3f0:	a8 e0       	ldi	r26, 0x08	; 8
    d3f2:	b0 e0       	ldi	r27, 0x00	; 0
    d3f4:	ee ef       	ldi	r30, 0xFE	; 254
    d3f6:	f9 e6       	ldi	r31, 0x69	; 105
    d3f8:	0c 94 6f 6e 	jmp	0xdcde	; 0xdcde <__prologue_saves__+0x12>
    d3fc:	9b 01       	movw	r18, r22
    d3fe:	ac 01       	movw	r20, r24
    d400:	83 e0       	ldi	r24, 0x03	; 3
    d402:	89 83       	std	Y+1, r24	; 0x01
    d404:	da 01       	movw	r26, r20
    d406:	c9 01       	movw	r24, r18
    d408:	88 27       	eor	r24, r24
    d40a:	b7 fd       	sbrc	r27, 7
    d40c:	83 95       	inc	r24
    d40e:	99 27       	eor	r25, r25
    d410:	aa 27       	eor	r26, r26
    d412:	bb 27       	eor	r27, r27
    d414:	b8 2e       	mov	r11, r24
    d416:	21 15       	cp	r18, r1
    d418:	31 05       	cpc	r19, r1
    d41a:	41 05       	cpc	r20, r1
    d41c:	51 05       	cpc	r21, r1
    d41e:	19 f4       	brne	.+6      	; 0xd426 <__floatsisf+0x36>
    d420:	82 e0       	ldi	r24, 0x02	; 2
    d422:	89 83       	std	Y+1, r24	; 0x01
    d424:	3a c0       	rjmp	.+116    	; 0xd49a <__floatsisf+0xaa>
    d426:	88 23       	and	r24, r24
    d428:	a9 f0       	breq	.+42     	; 0xd454 <__floatsisf+0x64>
    d42a:	20 30       	cpi	r18, 0x00	; 0
    d42c:	80 e0       	ldi	r24, 0x00	; 0
    d42e:	38 07       	cpc	r19, r24
    d430:	80 e0       	ldi	r24, 0x00	; 0
    d432:	48 07       	cpc	r20, r24
    d434:	80 e8       	ldi	r24, 0x80	; 128
    d436:	58 07       	cpc	r21, r24
    d438:	29 f4       	brne	.+10     	; 0xd444 <__floatsisf+0x54>
    d43a:	60 e0       	ldi	r22, 0x00	; 0
    d43c:	70 e0       	ldi	r23, 0x00	; 0
    d43e:	80 e0       	ldi	r24, 0x00	; 0
    d440:	9f ec       	ldi	r25, 0xCF	; 207
    d442:	30 c0       	rjmp	.+96     	; 0xd4a4 <__floatsisf+0xb4>
    d444:	ee 24       	eor	r14, r14
    d446:	ff 24       	eor	r15, r15
    d448:	87 01       	movw	r16, r14
    d44a:	e2 1a       	sub	r14, r18
    d44c:	f3 0a       	sbc	r15, r19
    d44e:	04 0b       	sbc	r16, r20
    d450:	15 0b       	sbc	r17, r21
    d452:	02 c0       	rjmp	.+4      	; 0xd458 <__floatsisf+0x68>
    d454:	79 01       	movw	r14, r18
    d456:	8a 01       	movw	r16, r20
    d458:	8e e1       	ldi	r24, 0x1E	; 30
    d45a:	c8 2e       	mov	r12, r24
    d45c:	d1 2c       	mov	r13, r1
    d45e:	dc 82       	std	Y+4, r13	; 0x04
    d460:	cb 82       	std	Y+3, r12	; 0x03
    d462:	ed 82       	std	Y+5, r14	; 0x05
    d464:	fe 82       	std	Y+6, r15	; 0x06
    d466:	0f 83       	std	Y+7, r16	; 0x07
    d468:	18 87       	std	Y+8, r17	; 0x08
    d46a:	c8 01       	movw	r24, r16
    d46c:	b7 01       	movw	r22, r14
    d46e:	0e 94 23 6b 	call	0xd646	; 0xd646 <__clzsi2>
    d472:	01 97       	sbiw	r24, 0x01	; 1
    d474:	18 16       	cp	r1, r24
    d476:	19 06       	cpc	r1, r25
    d478:	84 f4       	brge	.+32     	; 0xd49a <__floatsisf+0xaa>
    d47a:	08 2e       	mov	r0, r24
    d47c:	04 c0       	rjmp	.+8      	; 0xd486 <__floatsisf+0x96>
    d47e:	ee 0c       	add	r14, r14
    d480:	ff 1c       	adc	r15, r15
    d482:	00 1f       	adc	r16, r16
    d484:	11 1f       	adc	r17, r17
    d486:	0a 94       	dec	r0
    d488:	d2 f7       	brpl	.-12     	; 0xd47e <__floatsisf+0x8e>
    d48a:	ed 82       	std	Y+5, r14	; 0x05
    d48c:	fe 82       	std	Y+6, r15	; 0x06
    d48e:	0f 83       	std	Y+7, r16	; 0x07
    d490:	18 87       	std	Y+8, r17	; 0x08
    d492:	c8 1a       	sub	r12, r24
    d494:	d9 0a       	sbc	r13, r25
    d496:	dc 82       	std	Y+4, r13	; 0x04
    d498:	cb 82       	std	Y+3, r12	; 0x03
    d49a:	ba 82       	std	Y+2, r11	; 0x02
    d49c:	ce 01       	movw	r24, r28
    d49e:	01 96       	adiw	r24, 0x01	; 1
    d4a0:	0e 94 72 6b 	call	0xd6e4	; 0xd6e4 <__pack_f>
    d4a4:	28 96       	adiw	r28, 0x08	; 8
    d4a6:	e9 e0       	ldi	r30, 0x09	; 9
    d4a8:	0c 94 8b 6e 	jmp	0xdd16	; 0xdd16 <__epilogue_restores__+0x12>

0000d4ac <__fixsfsi>:
    d4ac:	ac e0       	ldi	r26, 0x0C	; 12
    d4ae:	b0 e0       	ldi	r27, 0x00	; 0
    d4b0:	ec e5       	ldi	r30, 0x5C	; 92
    d4b2:	fa e6       	ldi	r31, 0x6A	; 106
    d4b4:	0c 94 76 6e 	jmp	0xdcec	; 0xdcec <__prologue_saves__+0x20>
    d4b8:	69 83       	std	Y+1, r22	; 0x01
    d4ba:	7a 83       	std	Y+2, r23	; 0x02
    d4bc:	8b 83       	std	Y+3, r24	; 0x03
    d4be:	9c 83       	std	Y+4, r25	; 0x04
    d4c0:	be 01       	movw	r22, r28
    d4c2:	6b 5f       	subi	r22, 0xFB	; 251
    d4c4:	7f 4f       	sbci	r23, 0xFF	; 255
    d4c6:	ce 01       	movw	r24, r28
    d4c8:	01 96       	adiw	r24, 0x01	; 1
    d4ca:	0e 94 47 6c 	call	0xd88e	; 0xd88e <__unpack_f>
    d4ce:	8d 81       	ldd	r24, Y+5	; 0x05
    d4d0:	82 30       	cpi	r24, 0x02	; 2
    d4d2:	61 f1       	breq	.+88     	; 0xd52c <__fixsfsi+0x80>
    d4d4:	82 30       	cpi	r24, 0x02	; 2
    d4d6:	50 f1       	brcs	.+84     	; 0xd52c <__fixsfsi+0x80>
    d4d8:	84 30       	cpi	r24, 0x04	; 4
    d4da:	21 f4       	brne	.+8      	; 0xd4e4 <__fixsfsi+0x38>
    d4dc:	8e 81       	ldd	r24, Y+6	; 0x06
    d4de:	88 23       	and	r24, r24
    d4e0:	51 f1       	breq	.+84     	; 0xd536 <__fixsfsi+0x8a>
    d4e2:	2e c0       	rjmp	.+92     	; 0xd540 <__fixsfsi+0x94>
    d4e4:	2f 81       	ldd	r18, Y+7	; 0x07
    d4e6:	38 85       	ldd	r19, Y+8	; 0x08
    d4e8:	37 fd       	sbrc	r19, 7
    d4ea:	20 c0       	rjmp	.+64     	; 0xd52c <__fixsfsi+0x80>
    d4ec:	6e 81       	ldd	r22, Y+6	; 0x06
    d4ee:	2f 31       	cpi	r18, 0x1F	; 31
    d4f0:	31 05       	cpc	r19, r1
    d4f2:	1c f0       	brlt	.+6      	; 0xd4fa <__fixsfsi+0x4e>
    d4f4:	66 23       	and	r22, r22
    d4f6:	f9 f0       	breq	.+62     	; 0xd536 <__fixsfsi+0x8a>
    d4f8:	23 c0       	rjmp	.+70     	; 0xd540 <__fixsfsi+0x94>
    d4fa:	8e e1       	ldi	r24, 0x1E	; 30
    d4fc:	90 e0       	ldi	r25, 0x00	; 0
    d4fe:	82 1b       	sub	r24, r18
    d500:	93 0b       	sbc	r25, r19
    d502:	29 85       	ldd	r18, Y+9	; 0x09
    d504:	3a 85       	ldd	r19, Y+10	; 0x0a
    d506:	4b 85       	ldd	r20, Y+11	; 0x0b
    d508:	5c 85       	ldd	r21, Y+12	; 0x0c
    d50a:	04 c0       	rjmp	.+8      	; 0xd514 <__fixsfsi+0x68>
    d50c:	56 95       	lsr	r21
    d50e:	47 95       	ror	r20
    d510:	37 95       	ror	r19
    d512:	27 95       	ror	r18
    d514:	8a 95       	dec	r24
    d516:	d2 f7       	brpl	.-12     	; 0xd50c <__fixsfsi+0x60>
    d518:	66 23       	and	r22, r22
    d51a:	b1 f0       	breq	.+44     	; 0xd548 <__fixsfsi+0x9c>
    d51c:	50 95       	com	r21
    d51e:	40 95       	com	r20
    d520:	30 95       	com	r19
    d522:	21 95       	neg	r18
    d524:	3f 4f       	sbci	r19, 0xFF	; 255
    d526:	4f 4f       	sbci	r20, 0xFF	; 255
    d528:	5f 4f       	sbci	r21, 0xFF	; 255
    d52a:	0e c0       	rjmp	.+28     	; 0xd548 <__fixsfsi+0x9c>
    d52c:	20 e0       	ldi	r18, 0x00	; 0
    d52e:	30 e0       	ldi	r19, 0x00	; 0
    d530:	40 e0       	ldi	r20, 0x00	; 0
    d532:	50 e0       	ldi	r21, 0x00	; 0
    d534:	09 c0       	rjmp	.+18     	; 0xd548 <__fixsfsi+0x9c>
    d536:	2f ef       	ldi	r18, 0xFF	; 255
    d538:	3f ef       	ldi	r19, 0xFF	; 255
    d53a:	4f ef       	ldi	r20, 0xFF	; 255
    d53c:	5f e7       	ldi	r21, 0x7F	; 127
    d53e:	04 c0       	rjmp	.+8      	; 0xd548 <__fixsfsi+0x9c>
    d540:	20 e0       	ldi	r18, 0x00	; 0
    d542:	30 e0       	ldi	r19, 0x00	; 0
    d544:	40 e0       	ldi	r20, 0x00	; 0
    d546:	50 e8       	ldi	r21, 0x80	; 128
    d548:	b9 01       	movw	r22, r18
    d54a:	ca 01       	movw	r24, r20
    d54c:	2c 96       	adiw	r28, 0x0c	; 12
    d54e:	e2 e0       	ldi	r30, 0x02	; 2
    d550:	0c 94 92 6e 	jmp	0xdd24	; 0xdd24 <__epilogue_restores__+0x20>

0000d554 <__floatunsisf>:
    d554:	a8 e0       	ldi	r26, 0x08	; 8
    d556:	b0 e0       	ldi	r27, 0x00	; 0
    d558:	e0 eb       	ldi	r30, 0xB0	; 176
    d55a:	fa e6       	ldi	r31, 0x6A	; 106
    d55c:	0c 94 70 6e 	jmp	0xdce0	; 0xdce0 <__prologue_saves__+0x14>
    d560:	7b 01       	movw	r14, r22
    d562:	8c 01       	movw	r16, r24
    d564:	61 15       	cp	r22, r1
    d566:	71 05       	cpc	r23, r1
    d568:	81 05       	cpc	r24, r1
    d56a:	91 05       	cpc	r25, r1
    d56c:	19 f4       	brne	.+6      	; 0xd574 <__floatunsisf+0x20>
    d56e:	82 e0       	ldi	r24, 0x02	; 2
    d570:	89 83       	std	Y+1, r24	; 0x01
    d572:	60 c0       	rjmp	.+192    	; 0xd634 <__floatunsisf+0xe0>
    d574:	83 e0       	ldi	r24, 0x03	; 3
    d576:	89 83       	std	Y+1, r24	; 0x01
    d578:	8e e1       	ldi	r24, 0x1E	; 30
    d57a:	c8 2e       	mov	r12, r24
    d57c:	d1 2c       	mov	r13, r1
    d57e:	dc 82       	std	Y+4, r13	; 0x04
    d580:	cb 82       	std	Y+3, r12	; 0x03
    d582:	ed 82       	std	Y+5, r14	; 0x05
    d584:	fe 82       	std	Y+6, r15	; 0x06
    d586:	0f 83       	std	Y+7, r16	; 0x07
    d588:	18 87       	std	Y+8, r17	; 0x08
    d58a:	c8 01       	movw	r24, r16
    d58c:	b7 01       	movw	r22, r14
    d58e:	0e 94 23 6b 	call	0xd646	; 0xd646 <__clzsi2>
    d592:	bc 01       	movw	r22, r24
    d594:	61 50       	subi	r22, 0x01	; 1
    d596:	70 40       	sbci	r23, 0x00	; 0
    d598:	77 ff       	sbrs	r23, 7
    d59a:	39 c0       	rjmp	.+114    	; 0xd60e <__floatunsisf+0xba>
    d59c:	ee 27       	eor	r30, r30
    d59e:	ff 27       	eor	r31, r31
    d5a0:	e6 1b       	sub	r30, r22
    d5a2:	f7 0b       	sbc	r31, r23
    d5a4:	20 e0       	ldi	r18, 0x00	; 0
    d5a6:	30 e0       	ldi	r19, 0x00	; 0
    d5a8:	40 e0       	ldi	r20, 0x00	; 0
    d5aa:	50 e0       	ldi	r21, 0x00	; 0
    d5ac:	81 e0       	ldi	r24, 0x01	; 1
    d5ae:	90 e0       	ldi	r25, 0x00	; 0
    d5b0:	a0 e0       	ldi	r26, 0x00	; 0
    d5b2:	b0 e0       	ldi	r27, 0x00	; 0
    d5b4:	0e 2e       	mov	r0, r30
    d5b6:	04 c0       	rjmp	.+8      	; 0xd5c0 <__floatunsisf+0x6c>
    d5b8:	88 0f       	add	r24, r24
    d5ba:	99 1f       	adc	r25, r25
    d5bc:	aa 1f       	adc	r26, r26
    d5be:	bb 1f       	adc	r27, r27
    d5c0:	0a 94       	dec	r0
    d5c2:	d2 f7       	brpl	.-12     	; 0xd5b8 <__floatunsisf+0x64>
    d5c4:	01 97       	sbiw	r24, 0x01	; 1
    d5c6:	a1 09       	sbc	r26, r1
    d5c8:	b1 09       	sbc	r27, r1
    d5ca:	8e 21       	and	r24, r14
    d5cc:	9f 21       	and	r25, r15
    d5ce:	a0 23       	and	r26, r16
    d5d0:	b1 23       	and	r27, r17
    d5d2:	00 97       	sbiw	r24, 0x00	; 0
    d5d4:	a1 05       	cpc	r26, r1
    d5d6:	b1 05       	cpc	r27, r1
    d5d8:	21 f0       	breq	.+8      	; 0xd5e2 <__floatunsisf+0x8e>
    d5da:	21 e0       	ldi	r18, 0x01	; 1
    d5dc:	30 e0       	ldi	r19, 0x00	; 0
    d5de:	40 e0       	ldi	r20, 0x00	; 0
    d5e0:	50 e0       	ldi	r21, 0x00	; 0
    d5e2:	04 c0       	rjmp	.+8      	; 0xd5ec <__floatunsisf+0x98>
    d5e4:	16 95       	lsr	r17
    d5e6:	07 95       	ror	r16
    d5e8:	f7 94       	ror	r15
    d5ea:	e7 94       	ror	r14
    d5ec:	ea 95       	dec	r30
    d5ee:	d2 f7       	brpl	.-12     	; 0xd5e4 <__floatunsisf+0x90>
    d5f0:	2e 29       	or	r18, r14
    d5f2:	3f 29       	or	r19, r15
    d5f4:	40 2b       	or	r20, r16
    d5f6:	51 2b       	or	r21, r17
    d5f8:	2d 83       	std	Y+5, r18	; 0x05
    d5fa:	3e 83       	std	Y+6, r19	; 0x06
    d5fc:	4f 83       	std	Y+7, r20	; 0x07
    d5fe:	58 87       	std	Y+8, r21	; 0x08
    d600:	8e e1       	ldi	r24, 0x1E	; 30
    d602:	90 e0       	ldi	r25, 0x00	; 0
    d604:	86 1b       	sub	r24, r22
    d606:	97 0b       	sbc	r25, r23
    d608:	9c 83       	std	Y+4, r25	; 0x04
    d60a:	8b 83       	std	Y+3, r24	; 0x03
    d60c:	13 c0       	rjmp	.+38     	; 0xd634 <__floatunsisf+0xe0>
    d60e:	61 15       	cp	r22, r1
    d610:	71 05       	cpc	r23, r1
    d612:	81 f0       	breq	.+32     	; 0xd634 <__floatunsisf+0xe0>
    d614:	06 2e       	mov	r0, r22
    d616:	04 c0       	rjmp	.+8      	; 0xd620 <__floatunsisf+0xcc>
    d618:	ee 0c       	add	r14, r14
    d61a:	ff 1c       	adc	r15, r15
    d61c:	00 1f       	adc	r16, r16
    d61e:	11 1f       	adc	r17, r17
    d620:	0a 94       	dec	r0
    d622:	d2 f7       	brpl	.-12     	; 0xd618 <__floatunsisf+0xc4>
    d624:	ed 82       	std	Y+5, r14	; 0x05
    d626:	fe 82       	std	Y+6, r15	; 0x06
    d628:	0f 83       	std	Y+7, r16	; 0x07
    d62a:	18 87       	std	Y+8, r17	; 0x08
    d62c:	c6 1a       	sub	r12, r22
    d62e:	d7 0a       	sbc	r13, r23
    d630:	dc 82       	std	Y+4, r13	; 0x04
    d632:	cb 82       	std	Y+3, r12	; 0x03
    d634:	1a 82       	std	Y+2, r1	; 0x02
    d636:	ce 01       	movw	r24, r28
    d638:	01 96       	adiw	r24, 0x01	; 1
    d63a:	0e 94 72 6b 	call	0xd6e4	; 0xd6e4 <__pack_f>
    d63e:	28 96       	adiw	r28, 0x08	; 8
    d640:	e8 e0       	ldi	r30, 0x08	; 8
    d642:	0c 94 8c 6e 	jmp	0xdd18	; 0xdd18 <__epilogue_restores__+0x14>

0000d646 <__clzsi2>:
    d646:	ef 92       	push	r14
    d648:	ff 92       	push	r15
    d64a:	0f 93       	push	r16
    d64c:	1f 93       	push	r17
    d64e:	7b 01       	movw	r14, r22
    d650:	8c 01       	movw	r16, r24
    d652:	80 e0       	ldi	r24, 0x00	; 0
    d654:	e8 16       	cp	r14, r24
    d656:	80 e0       	ldi	r24, 0x00	; 0
    d658:	f8 06       	cpc	r15, r24
    d65a:	81 e0       	ldi	r24, 0x01	; 1
    d65c:	08 07       	cpc	r16, r24
    d65e:	80 e0       	ldi	r24, 0x00	; 0
    d660:	18 07       	cpc	r17, r24
    d662:	88 f4       	brcc	.+34     	; 0xd686 <__clzsi2+0x40>
    d664:	8f ef       	ldi	r24, 0xFF	; 255
    d666:	e8 16       	cp	r14, r24
    d668:	f1 04       	cpc	r15, r1
    d66a:	01 05       	cpc	r16, r1
    d66c:	11 05       	cpc	r17, r1
    d66e:	31 f0       	breq	.+12     	; 0xd67c <__clzsi2+0x36>
    d670:	28 f0       	brcs	.+10     	; 0xd67c <__clzsi2+0x36>
    d672:	88 e0       	ldi	r24, 0x08	; 8
    d674:	90 e0       	ldi	r25, 0x00	; 0
    d676:	a0 e0       	ldi	r26, 0x00	; 0
    d678:	b0 e0       	ldi	r27, 0x00	; 0
    d67a:	17 c0       	rjmp	.+46     	; 0xd6aa <__clzsi2+0x64>
    d67c:	80 e0       	ldi	r24, 0x00	; 0
    d67e:	90 e0       	ldi	r25, 0x00	; 0
    d680:	a0 e0       	ldi	r26, 0x00	; 0
    d682:	b0 e0       	ldi	r27, 0x00	; 0
    d684:	12 c0       	rjmp	.+36     	; 0xd6aa <__clzsi2+0x64>
    d686:	80 e0       	ldi	r24, 0x00	; 0
    d688:	e8 16       	cp	r14, r24
    d68a:	80 e0       	ldi	r24, 0x00	; 0
    d68c:	f8 06       	cpc	r15, r24
    d68e:	80 e0       	ldi	r24, 0x00	; 0
    d690:	08 07       	cpc	r16, r24
    d692:	81 e0       	ldi	r24, 0x01	; 1
    d694:	18 07       	cpc	r17, r24
    d696:	28 f0       	brcs	.+10     	; 0xd6a2 <__clzsi2+0x5c>
    d698:	88 e1       	ldi	r24, 0x18	; 24
    d69a:	90 e0       	ldi	r25, 0x00	; 0
    d69c:	a0 e0       	ldi	r26, 0x00	; 0
    d69e:	b0 e0       	ldi	r27, 0x00	; 0
    d6a0:	04 c0       	rjmp	.+8      	; 0xd6aa <__clzsi2+0x64>
    d6a2:	80 e1       	ldi	r24, 0x10	; 16
    d6a4:	90 e0       	ldi	r25, 0x00	; 0
    d6a6:	a0 e0       	ldi	r26, 0x00	; 0
    d6a8:	b0 e0       	ldi	r27, 0x00	; 0
    d6aa:	20 e2       	ldi	r18, 0x20	; 32
    d6ac:	30 e0       	ldi	r19, 0x00	; 0
    d6ae:	40 e0       	ldi	r20, 0x00	; 0
    d6b0:	50 e0       	ldi	r21, 0x00	; 0
    d6b2:	28 1b       	sub	r18, r24
    d6b4:	39 0b       	sbc	r19, r25
    d6b6:	4a 0b       	sbc	r20, r26
    d6b8:	5b 0b       	sbc	r21, r27
    d6ba:	04 c0       	rjmp	.+8      	; 0xd6c4 <__clzsi2+0x7e>
    d6bc:	16 95       	lsr	r17
    d6be:	07 95       	ror	r16
    d6c0:	f7 94       	ror	r15
    d6c2:	e7 94       	ror	r14
    d6c4:	8a 95       	dec	r24
    d6c6:	d2 f7       	brpl	.-12     	; 0xd6bc <__clzsi2+0x76>
    d6c8:	f7 01       	movw	r30, r14
    d6ca:	e3 58       	subi	r30, 0x83	; 131
    d6cc:	fb 4f       	sbci	r31, 0xFB	; 251
    d6ce:	80 81       	ld	r24, Z
    d6d0:	28 1b       	sub	r18, r24
    d6d2:	31 09       	sbc	r19, r1
    d6d4:	41 09       	sbc	r20, r1
    d6d6:	51 09       	sbc	r21, r1
    d6d8:	c9 01       	movw	r24, r18
    d6da:	1f 91       	pop	r17
    d6dc:	0f 91       	pop	r16
    d6de:	ff 90       	pop	r15
    d6e0:	ef 90       	pop	r14
    d6e2:	08 95       	ret

0000d6e4 <__pack_f>:
    d6e4:	df 92       	push	r13
    d6e6:	ef 92       	push	r14
    d6e8:	ff 92       	push	r15
    d6ea:	0f 93       	push	r16
    d6ec:	1f 93       	push	r17
    d6ee:	fc 01       	movw	r30, r24
    d6f0:	e4 80       	ldd	r14, Z+4	; 0x04
    d6f2:	f5 80       	ldd	r15, Z+5	; 0x05
    d6f4:	06 81       	ldd	r16, Z+6	; 0x06
    d6f6:	17 81       	ldd	r17, Z+7	; 0x07
    d6f8:	d1 80       	ldd	r13, Z+1	; 0x01
    d6fa:	80 81       	ld	r24, Z
    d6fc:	82 30       	cpi	r24, 0x02	; 2
    d6fe:	48 f4       	brcc	.+18     	; 0xd712 <__pack_f+0x2e>
    d700:	80 e0       	ldi	r24, 0x00	; 0
    d702:	90 e0       	ldi	r25, 0x00	; 0
    d704:	a0 e1       	ldi	r26, 0x10	; 16
    d706:	b0 e0       	ldi	r27, 0x00	; 0
    d708:	e8 2a       	or	r14, r24
    d70a:	f9 2a       	or	r15, r25
    d70c:	0a 2b       	or	r16, r26
    d70e:	1b 2b       	or	r17, r27
    d710:	a5 c0       	rjmp	.+330    	; 0xd85c <__pack_f+0x178>
    d712:	84 30       	cpi	r24, 0x04	; 4
    d714:	09 f4       	brne	.+2      	; 0xd718 <__pack_f+0x34>
    d716:	9f c0       	rjmp	.+318    	; 0xd856 <__pack_f+0x172>
    d718:	82 30       	cpi	r24, 0x02	; 2
    d71a:	21 f4       	brne	.+8      	; 0xd724 <__pack_f+0x40>
    d71c:	ee 24       	eor	r14, r14
    d71e:	ff 24       	eor	r15, r15
    d720:	87 01       	movw	r16, r14
    d722:	05 c0       	rjmp	.+10     	; 0xd72e <__pack_f+0x4a>
    d724:	e1 14       	cp	r14, r1
    d726:	f1 04       	cpc	r15, r1
    d728:	01 05       	cpc	r16, r1
    d72a:	11 05       	cpc	r17, r1
    d72c:	19 f4       	brne	.+6      	; 0xd734 <__pack_f+0x50>
    d72e:	e0 e0       	ldi	r30, 0x00	; 0
    d730:	f0 e0       	ldi	r31, 0x00	; 0
    d732:	96 c0       	rjmp	.+300    	; 0xd860 <__pack_f+0x17c>
    d734:	62 81       	ldd	r22, Z+2	; 0x02
    d736:	73 81       	ldd	r23, Z+3	; 0x03
    d738:	9f ef       	ldi	r25, 0xFF	; 255
    d73a:	62 38       	cpi	r22, 0x82	; 130
    d73c:	79 07       	cpc	r23, r25
    d73e:	0c f0       	brlt	.+2      	; 0xd742 <__pack_f+0x5e>
    d740:	5b c0       	rjmp	.+182    	; 0xd7f8 <__pack_f+0x114>
    d742:	22 e8       	ldi	r18, 0x82	; 130
    d744:	3f ef       	ldi	r19, 0xFF	; 255
    d746:	26 1b       	sub	r18, r22
    d748:	37 0b       	sbc	r19, r23
    d74a:	2a 31       	cpi	r18, 0x1A	; 26
    d74c:	31 05       	cpc	r19, r1
    d74e:	2c f0       	brlt	.+10     	; 0xd75a <__pack_f+0x76>
    d750:	20 e0       	ldi	r18, 0x00	; 0
    d752:	30 e0       	ldi	r19, 0x00	; 0
    d754:	40 e0       	ldi	r20, 0x00	; 0
    d756:	50 e0       	ldi	r21, 0x00	; 0
    d758:	2a c0       	rjmp	.+84     	; 0xd7ae <__pack_f+0xca>
    d75a:	b8 01       	movw	r22, r16
    d75c:	a7 01       	movw	r20, r14
    d75e:	02 2e       	mov	r0, r18
    d760:	04 c0       	rjmp	.+8      	; 0xd76a <__pack_f+0x86>
    d762:	76 95       	lsr	r23
    d764:	67 95       	ror	r22
    d766:	57 95       	ror	r21
    d768:	47 95       	ror	r20
    d76a:	0a 94       	dec	r0
    d76c:	d2 f7       	brpl	.-12     	; 0xd762 <__pack_f+0x7e>
    d76e:	81 e0       	ldi	r24, 0x01	; 1
    d770:	90 e0       	ldi	r25, 0x00	; 0
    d772:	a0 e0       	ldi	r26, 0x00	; 0
    d774:	b0 e0       	ldi	r27, 0x00	; 0
    d776:	04 c0       	rjmp	.+8      	; 0xd780 <__pack_f+0x9c>
    d778:	88 0f       	add	r24, r24
    d77a:	99 1f       	adc	r25, r25
    d77c:	aa 1f       	adc	r26, r26
    d77e:	bb 1f       	adc	r27, r27
    d780:	2a 95       	dec	r18
    d782:	d2 f7       	brpl	.-12     	; 0xd778 <__pack_f+0x94>
    d784:	01 97       	sbiw	r24, 0x01	; 1
    d786:	a1 09       	sbc	r26, r1
    d788:	b1 09       	sbc	r27, r1
    d78a:	8e 21       	and	r24, r14
    d78c:	9f 21       	and	r25, r15
    d78e:	a0 23       	and	r26, r16
    d790:	b1 23       	and	r27, r17
    d792:	00 97       	sbiw	r24, 0x00	; 0
    d794:	a1 05       	cpc	r26, r1
    d796:	b1 05       	cpc	r27, r1
    d798:	21 f0       	breq	.+8      	; 0xd7a2 <__pack_f+0xbe>
    d79a:	81 e0       	ldi	r24, 0x01	; 1
    d79c:	90 e0       	ldi	r25, 0x00	; 0
    d79e:	a0 e0       	ldi	r26, 0x00	; 0
    d7a0:	b0 e0       	ldi	r27, 0x00	; 0
    d7a2:	9a 01       	movw	r18, r20
    d7a4:	ab 01       	movw	r20, r22
    d7a6:	28 2b       	or	r18, r24
    d7a8:	39 2b       	or	r19, r25
    d7aa:	4a 2b       	or	r20, r26
    d7ac:	5b 2b       	or	r21, r27
    d7ae:	da 01       	movw	r26, r20
    d7b0:	c9 01       	movw	r24, r18
    d7b2:	8f 77       	andi	r24, 0x7F	; 127
    d7b4:	90 70       	andi	r25, 0x00	; 0
    d7b6:	a0 70       	andi	r26, 0x00	; 0
    d7b8:	b0 70       	andi	r27, 0x00	; 0
    d7ba:	80 34       	cpi	r24, 0x40	; 64
    d7bc:	91 05       	cpc	r25, r1
    d7be:	a1 05       	cpc	r26, r1
    d7c0:	b1 05       	cpc	r27, r1
    d7c2:	39 f4       	brne	.+14     	; 0xd7d2 <__pack_f+0xee>
    d7c4:	27 ff       	sbrs	r18, 7
    d7c6:	09 c0       	rjmp	.+18     	; 0xd7da <__pack_f+0xf6>
    d7c8:	20 5c       	subi	r18, 0xC0	; 192
    d7ca:	3f 4f       	sbci	r19, 0xFF	; 255
    d7cc:	4f 4f       	sbci	r20, 0xFF	; 255
    d7ce:	5f 4f       	sbci	r21, 0xFF	; 255
    d7d0:	04 c0       	rjmp	.+8      	; 0xd7da <__pack_f+0xf6>
    d7d2:	21 5c       	subi	r18, 0xC1	; 193
    d7d4:	3f 4f       	sbci	r19, 0xFF	; 255
    d7d6:	4f 4f       	sbci	r20, 0xFF	; 255
    d7d8:	5f 4f       	sbci	r21, 0xFF	; 255
    d7da:	e0 e0       	ldi	r30, 0x00	; 0
    d7dc:	f0 e0       	ldi	r31, 0x00	; 0
    d7de:	20 30       	cpi	r18, 0x00	; 0
    d7e0:	a0 e0       	ldi	r26, 0x00	; 0
    d7e2:	3a 07       	cpc	r19, r26
    d7e4:	a0 e0       	ldi	r26, 0x00	; 0
    d7e6:	4a 07       	cpc	r20, r26
    d7e8:	a0 e4       	ldi	r26, 0x40	; 64
    d7ea:	5a 07       	cpc	r21, r26
    d7ec:	10 f0       	brcs	.+4      	; 0xd7f2 <__pack_f+0x10e>
    d7ee:	e1 e0       	ldi	r30, 0x01	; 1
    d7f0:	f0 e0       	ldi	r31, 0x00	; 0
    d7f2:	79 01       	movw	r14, r18
    d7f4:	8a 01       	movw	r16, r20
    d7f6:	27 c0       	rjmp	.+78     	; 0xd846 <__pack_f+0x162>
    d7f8:	60 38       	cpi	r22, 0x80	; 128
    d7fa:	71 05       	cpc	r23, r1
    d7fc:	64 f5       	brge	.+88     	; 0xd856 <__pack_f+0x172>
    d7fe:	fb 01       	movw	r30, r22
    d800:	e1 58       	subi	r30, 0x81	; 129
    d802:	ff 4f       	sbci	r31, 0xFF	; 255
    d804:	d8 01       	movw	r26, r16
    d806:	c7 01       	movw	r24, r14
    d808:	8f 77       	andi	r24, 0x7F	; 127
    d80a:	90 70       	andi	r25, 0x00	; 0
    d80c:	a0 70       	andi	r26, 0x00	; 0
    d80e:	b0 70       	andi	r27, 0x00	; 0
    d810:	80 34       	cpi	r24, 0x40	; 64
    d812:	91 05       	cpc	r25, r1
    d814:	a1 05       	cpc	r26, r1
    d816:	b1 05       	cpc	r27, r1
    d818:	39 f4       	brne	.+14     	; 0xd828 <__pack_f+0x144>
    d81a:	e7 fe       	sbrs	r14, 7
    d81c:	0d c0       	rjmp	.+26     	; 0xd838 <__pack_f+0x154>
    d81e:	80 e4       	ldi	r24, 0x40	; 64
    d820:	90 e0       	ldi	r25, 0x00	; 0
    d822:	a0 e0       	ldi	r26, 0x00	; 0
    d824:	b0 e0       	ldi	r27, 0x00	; 0
    d826:	04 c0       	rjmp	.+8      	; 0xd830 <__pack_f+0x14c>
    d828:	8f e3       	ldi	r24, 0x3F	; 63
    d82a:	90 e0       	ldi	r25, 0x00	; 0
    d82c:	a0 e0       	ldi	r26, 0x00	; 0
    d82e:	b0 e0       	ldi	r27, 0x00	; 0
    d830:	e8 0e       	add	r14, r24
    d832:	f9 1e       	adc	r15, r25
    d834:	0a 1f       	adc	r16, r26
    d836:	1b 1f       	adc	r17, r27
    d838:	17 ff       	sbrs	r17, 7
    d83a:	05 c0       	rjmp	.+10     	; 0xd846 <__pack_f+0x162>
    d83c:	16 95       	lsr	r17
    d83e:	07 95       	ror	r16
    d840:	f7 94       	ror	r15
    d842:	e7 94       	ror	r14
    d844:	31 96       	adiw	r30, 0x01	; 1
    d846:	87 e0       	ldi	r24, 0x07	; 7
    d848:	16 95       	lsr	r17
    d84a:	07 95       	ror	r16
    d84c:	f7 94       	ror	r15
    d84e:	e7 94       	ror	r14
    d850:	8a 95       	dec	r24
    d852:	d1 f7       	brne	.-12     	; 0xd848 <__pack_f+0x164>
    d854:	05 c0       	rjmp	.+10     	; 0xd860 <__pack_f+0x17c>
    d856:	ee 24       	eor	r14, r14
    d858:	ff 24       	eor	r15, r15
    d85a:	87 01       	movw	r16, r14
    d85c:	ef ef       	ldi	r30, 0xFF	; 255
    d85e:	f0 e0       	ldi	r31, 0x00	; 0
    d860:	6e 2f       	mov	r22, r30
    d862:	67 95       	ror	r22
    d864:	66 27       	eor	r22, r22
    d866:	67 95       	ror	r22
    d868:	90 2f       	mov	r25, r16
    d86a:	9f 77       	andi	r25, 0x7F	; 127
    d86c:	d7 94       	ror	r13
    d86e:	dd 24       	eor	r13, r13
    d870:	d7 94       	ror	r13
    d872:	8e 2f       	mov	r24, r30
    d874:	86 95       	lsr	r24
    d876:	49 2f       	mov	r20, r25
    d878:	46 2b       	or	r20, r22
    d87a:	58 2f       	mov	r21, r24
    d87c:	5d 29       	or	r21, r13
    d87e:	b7 01       	movw	r22, r14
    d880:	ca 01       	movw	r24, r20
    d882:	1f 91       	pop	r17
    d884:	0f 91       	pop	r16
    d886:	ff 90       	pop	r15
    d888:	ef 90       	pop	r14
    d88a:	df 90       	pop	r13
    d88c:	08 95       	ret

0000d88e <__unpack_f>:
    d88e:	fc 01       	movw	r30, r24
    d890:	db 01       	movw	r26, r22
    d892:	40 81       	ld	r20, Z
    d894:	51 81       	ldd	r21, Z+1	; 0x01
    d896:	22 81       	ldd	r18, Z+2	; 0x02
    d898:	62 2f       	mov	r22, r18
    d89a:	6f 77       	andi	r22, 0x7F	; 127
    d89c:	70 e0       	ldi	r23, 0x00	; 0
    d89e:	22 1f       	adc	r18, r18
    d8a0:	22 27       	eor	r18, r18
    d8a2:	22 1f       	adc	r18, r18
    d8a4:	93 81       	ldd	r25, Z+3	; 0x03
    d8a6:	89 2f       	mov	r24, r25
    d8a8:	88 0f       	add	r24, r24
    d8aa:	82 2b       	or	r24, r18
    d8ac:	28 2f       	mov	r18, r24
    d8ae:	30 e0       	ldi	r19, 0x00	; 0
    d8b0:	99 1f       	adc	r25, r25
    d8b2:	99 27       	eor	r25, r25
    d8b4:	99 1f       	adc	r25, r25
    d8b6:	11 96       	adiw	r26, 0x01	; 1
    d8b8:	9c 93       	st	X, r25
    d8ba:	11 97       	sbiw	r26, 0x01	; 1
    d8bc:	21 15       	cp	r18, r1
    d8be:	31 05       	cpc	r19, r1
    d8c0:	a9 f5       	brne	.+106    	; 0xd92c <__unpack_f+0x9e>
    d8c2:	41 15       	cp	r20, r1
    d8c4:	51 05       	cpc	r21, r1
    d8c6:	61 05       	cpc	r22, r1
    d8c8:	71 05       	cpc	r23, r1
    d8ca:	11 f4       	brne	.+4      	; 0xd8d0 <__unpack_f+0x42>
    d8cc:	82 e0       	ldi	r24, 0x02	; 2
    d8ce:	37 c0       	rjmp	.+110    	; 0xd93e <__unpack_f+0xb0>
    d8d0:	82 e8       	ldi	r24, 0x82	; 130
    d8d2:	9f ef       	ldi	r25, 0xFF	; 255
    d8d4:	13 96       	adiw	r26, 0x03	; 3
    d8d6:	9c 93       	st	X, r25
    d8d8:	8e 93       	st	-X, r24
    d8da:	12 97       	sbiw	r26, 0x02	; 2
    d8dc:	9a 01       	movw	r18, r20
    d8de:	ab 01       	movw	r20, r22
    d8e0:	67 e0       	ldi	r22, 0x07	; 7
    d8e2:	22 0f       	add	r18, r18
    d8e4:	33 1f       	adc	r19, r19
    d8e6:	44 1f       	adc	r20, r20
    d8e8:	55 1f       	adc	r21, r21
    d8ea:	6a 95       	dec	r22
    d8ec:	d1 f7       	brne	.-12     	; 0xd8e2 <__unpack_f+0x54>
    d8ee:	83 e0       	ldi	r24, 0x03	; 3
    d8f0:	8c 93       	st	X, r24
    d8f2:	0d c0       	rjmp	.+26     	; 0xd90e <__unpack_f+0x80>
    d8f4:	22 0f       	add	r18, r18
    d8f6:	33 1f       	adc	r19, r19
    d8f8:	44 1f       	adc	r20, r20
    d8fa:	55 1f       	adc	r21, r21
    d8fc:	12 96       	adiw	r26, 0x02	; 2
    d8fe:	8d 91       	ld	r24, X+
    d900:	9c 91       	ld	r25, X
    d902:	13 97       	sbiw	r26, 0x03	; 3
    d904:	01 97       	sbiw	r24, 0x01	; 1
    d906:	13 96       	adiw	r26, 0x03	; 3
    d908:	9c 93       	st	X, r25
    d90a:	8e 93       	st	-X, r24
    d90c:	12 97       	sbiw	r26, 0x02	; 2
    d90e:	20 30       	cpi	r18, 0x00	; 0
    d910:	80 e0       	ldi	r24, 0x00	; 0
    d912:	38 07       	cpc	r19, r24
    d914:	80 e0       	ldi	r24, 0x00	; 0
    d916:	48 07       	cpc	r20, r24
    d918:	80 e4       	ldi	r24, 0x40	; 64
    d91a:	58 07       	cpc	r21, r24
    d91c:	58 f3       	brcs	.-42     	; 0xd8f4 <__unpack_f+0x66>
    d91e:	14 96       	adiw	r26, 0x04	; 4
    d920:	2d 93       	st	X+, r18
    d922:	3d 93       	st	X+, r19
    d924:	4d 93       	st	X+, r20
    d926:	5c 93       	st	X, r21
    d928:	17 97       	sbiw	r26, 0x07	; 7
    d92a:	08 95       	ret
    d92c:	2f 3f       	cpi	r18, 0xFF	; 255
    d92e:	31 05       	cpc	r19, r1
    d930:	79 f4       	brne	.+30     	; 0xd950 <__unpack_f+0xc2>
    d932:	41 15       	cp	r20, r1
    d934:	51 05       	cpc	r21, r1
    d936:	61 05       	cpc	r22, r1
    d938:	71 05       	cpc	r23, r1
    d93a:	19 f4       	brne	.+6      	; 0xd942 <__unpack_f+0xb4>
    d93c:	84 e0       	ldi	r24, 0x04	; 4
    d93e:	8c 93       	st	X, r24
    d940:	08 95       	ret
    d942:	64 ff       	sbrs	r22, 4
    d944:	03 c0       	rjmp	.+6      	; 0xd94c <__unpack_f+0xbe>
    d946:	81 e0       	ldi	r24, 0x01	; 1
    d948:	8c 93       	st	X, r24
    d94a:	12 c0       	rjmp	.+36     	; 0xd970 <__unpack_f+0xe2>
    d94c:	1c 92       	st	X, r1
    d94e:	10 c0       	rjmp	.+32     	; 0xd970 <__unpack_f+0xe2>
    d950:	2f 57       	subi	r18, 0x7F	; 127
    d952:	30 40       	sbci	r19, 0x00	; 0
    d954:	13 96       	adiw	r26, 0x03	; 3
    d956:	3c 93       	st	X, r19
    d958:	2e 93       	st	-X, r18
    d95a:	12 97       	sbiw	r26, 0x02	; 2
    d95c:	83 e0       	ldi	r24, 0x03	; 3
    d95e:	8c 93       	st	X, r24
    d960:	87 e0       	ldi	r24, 0x07	; 7
    d962:	44 0f       	add	r20, r20
    d964:	55 1f       	adc	r21, r21
    d966:	66 1f       	adc	r22, r22
    d968:	77 1f       	adc	r23, r23
    d96a:	8a 95       	dec	r24
    d96c:	d1 f7       	brne	.-12     	; 0xd962 <__unpack_f+0xd4>
    d96e:	70 64       	ori	r23, 0x40	; 64
    d970:	14 96       	adiw	r26, 0x04	; 4
    d972:	4d 93       	st	X+, r20
    d974:	5d 93       	st	X+, r21
    d976:	6d 93       	st	X+, r22
    d978:	7c 93       	st	X, r23
    d97a:	17 97       	sbiw	r26, 0x07	; 7
    d97c:	08 95       	ret

0000d97e <__fpcmp_parts_f>:
    d97e:	1f 93       	push	r17
    d980:	dc 01       	movw	r26, r24
    d982:	fb 01       	movw	r30, r22
    d984:	9c 91       	ld	r25, X
    d986:	92 30       	cpi	r25, 0x02	; 2
    d988:	08 f4       	brcc	.+2      	; 0xd98c <__fpcmp_parts_f+0xe>
    d98a:	47 c0       	rjmp	.+142    	; 0xda1a <__fpcmp_parts_f+0x9c>
    d98c:	80 81       	ld	r24, Z
    d98e:	82 30       	cpi	r24, 0x02	; 2
    d990:	08 f4       	brcc	.+2      	; 0xd994 <__fpcmp_parts_f+0x16>
    d992:	43 c0       	rjmp	.+134    	; 0xda1a <__fpcmp_parts_f+0x9c>
    d994:	94 30       	cpi	r25, 0x04	; 4
    d996:	51 f4       	brne	.+20     	; 0xd9ac <__fpcmp_parts_f+0x2e>
    d998:	11 96       	adiw	r26, 0x01	; 1
    d99a:	1c 91       	ld	r17, X
    d99c:	84 30       	cpi	r24, 0x04	; 4
    d99e:	99 f5       	brne	.+102    	; 0xda06 <__fpcmp_parts_f+0x88>
    d9a0:	81 81       	ldd	r24, Z+1	; 0x01
    d9a2:	68 2f       	mov	r22, r24
    d9a4:	70 e0       	ldi	r23, 0x00	; 0
    d9a6:	61 1b       	sub	r22, r17
    d9a8:	71 09       	sbc	r23, r1
    d9aa:	3f c0       	rjmp	.+126    	; 0xda2a <__fpcmp_parts_f+0xac>
    d9ac:	84 30       	cpi	r24, 0x04	; 4
    d9ae:	21 f0       	breq	.+8      	; 0xd9b8 <__fpcmp_parts_f+0x3a>
    d9b0:	92 30       	cpi	r25, 0x02	; 2
    d9b2:	31 f4       	brne	.+12     	; 0xd9c0 <__fpcmp_parts_f+0x42>
    d9b4:	82 30       	cpi	r24, 0x02	; 2
    d9b6:	b9 f1       	breq	.+110    	; 0xda26 <__fpcmp_parts_f+0xa8>
    d9b8:	81 81       	ldd	r24, Z+1	; 0x01
    d9ba:	88 23       	and	r24, r24
    d9bc:	89 f1       	breq	.+98     	; 0xda20 <__fpcmp_parts_f+0xa2>
    d9be:	2d c0       	rjmp	.+90     	; 0xda1a <__fpcmp_parts_f+0x9c>
    d9c0:	11 96       	adiw	r26, 0x01	; 1
    d9c2:	1c 91       	ld	r17, X
    d9c4:	11 97       	sbiw	r26, 0x01	; 1
    d9c6:	82 30       	cpi	r24, 0x02	; 2
    d9c8:	f1 f0       	breq	.+60     	; 0xda06 <__fpcmp_parts_f+0x88>
    d9ca:	81 81       	ldd	r24, Z+1	; 0x01
    d9cc:	18 17       	cp	r17, r24
    d9ce:	d9 f4       	brne	.+54     	; 0xda06 <__fpcmp_parts_f+0x88>
    d9d0:	12 96       	adiw	r26, 0x02	; 2
    d9d2:	2d 91       	ld	r18, X+
    d9d4:	3c 91       	ld	r19, X
    d9d6:	13 97       	sbiw	r26, 0x03	; 3
    d9d8:	82 81       	ldd	r24, Z+2	; 0x02
    d9da:	93 81       	ldd	r25, Z+3	; 0x03
    d9dc:	82 17       	cp	r24, r18
    d9de:	93 07       	cpc	r25, r19
    d9e0:	94 f0       	brlt	.+36     	; 0xda06 <__fpcmp_parts_f+0x88>
    d9e2:	28 17       	cp	r18, r24
    d9e4:	39 07       	cpc	r19, r25
    d9e6:	bc f0       	brlt	.+46     	; 0xda16 <__fpcmp_parts_f+0x98>
    d9e8:	14 96       	adiw	r26, 0x04	; 4
    d9ea:	8d 91       	ld	r24, X+
    d9ec:	9d 91       	ld	r25, X+
    d9ee:	0d 90       	ld	r0, X+
    d9f0:	bc 91       	ld	r27, X
    d9f2:	a0 2d       	mov	r26, r0
    d9f4:	24 81       	ldd	r18, Z+4	; 0x04
    d9f6:	35 81       	ldd	r19, Z+5	; 0x05
    d9f8:	46 81       	ldd	r20, Z+6	; 0x06
    d9fa:	57 81       	ldd	r21, Z+7	; 0x07
    d9fc:	28 17       	cp	r18, r24
    d9fe:	39 07       	cpc	r19, r25
    da00:	4a 07       	cpc	r20, r26
    da02:	5b 07       	cpc	r21, r27
    da04:	18 f4       	brcc	.+6      	; 0xda0c <__fpcmp_parts_f+0x8e>
    da06:	11 23       	and	r17, r17
    da08:	41 f0       	breq	.+16     	; 0xda1a <__fpcmp_parts_f+0x9c>
    da0a:	0a c0       	rjmp	.+20     	; 0xda20 <__fpcmp_parts_f+0xa2>
    da0c:	82 17       	cp	r24, r18
    da0e:	93 07       	cpc	r25, r19
    da10:	a4 07       	cpc	r26, r20
    da12:	b5 07       	cpc	r27, r21
    da14:	40 f4       	brcc	.+16     	; 0xda26 <__fpcmp_parts_f+0xa8>
    da16:	11 23       	and	r17, r17
    da18:	19 f0       	breq	.+6      	; 0xda20 <__fpcmp_parts_f+0xa2>
    da1a:	61 e0       	ldi	r22, 0x01	; 1
    da1c:	70 e0       	ldi	r23, 0x00	; 0
    da1e:	05 c0       	rjmp	.+10     	; 0xda2a <__fpcmp_parts_f+0xac>
    da20:	6f ef       	ldi	r22, 0xFF	; 255
    da22:	7f ef       	ldi	r23, 0xFF	; 255
    da24:	02 c0       	rjmp	.+4      	; 0xda2a <__fpcmp_parts_f+0xac>
    da26:	60 e0       	ldi	r22, 0x00	; 0
    da28:	70 e0       	ldi	r23, 0x00	; 0
    da2a:	cb 01       	movw	r24, r22
    da2c:	1f 91       	pop	r17
    da2e:	08 95       	ret

0000da30 <do_rand>:
    da30:	a0 e0       	ldi	r26, 0x00	; 0
    da32:	b0 e0       	ldi	r27, 0x00	; 0
    da34:	ee e1       	ldi	r30, 0x1E	; 30
    da36:	fd e6       	ldi	r31, 0x6D	; 109
    da38:	0c 94 6e 6e 	jmp	0xdcdc	; 0xdcdc <__prologue_saves__+0x10>
    da3c:	ec 01       	movw	r28, r24
    da3e:	a8 80       	ld	r10, Y
    da40:	b9 80       	ldd	r11, Y+1	; 0x01
    da42:	ca 80       	ldd	r12, Y+2	; 0x02
    da44:	db 80       	ldd	r13, Y+3	; 0x03
    da46:	a1 14       	cp	r10, r1
    da48:	b1 04       	cpc	r11, r1
    da4a:	c1 04       	cpc	r12, r1
    da4c:	d1 04       	cpc	r13, r1
    da4e:	41 f4       	brne	.+16     	; 0xda60 <do_rand+0x30>
    da50:	84 e2       	ldi	r24, 0x24	; 36
    da52:	a8 2e       	mov	r10, r24
    da54:	89 ed       	ldi	r24, 0xD9	; 217
    da56:	b8 2e       	mov	r11, r24
    da58:	8b e5       	ldi	r24, 0x5B	; 91
    da5a:	c8 2e       	mov	r12, r24
    da5c:	87 e0       	ldi	r24, 0x07	; 7
    da5e:	d8 2e       	mov	r13, r24
    da60:	c6 01       	movw	r24, r12
    da62:	b5 01       	movw	r22, r10
    da64:	2d e1       	ldi	r18, 0x1D	; 29
    da66:	33 ef       	ldi	r19, 0xF3	; 243
    da68:	41 e0       	ldi	r20, 0x01	; 1
    da6a:	50 e0       	ldi	r21, 0x00	; 0
    da6c:	0e 94 4d 6f 	call	0xde9a	; 0xde9a <__divmodsi4>
    da70:	27 ea       	ldi	r18, 0xA7	; 167
    da72:	31 e4       	ldi	r19, 0x41	; 65
    da74:	40 e0       	ldi	r20, 0x00	; 0
    da76:	50 e0       	ldi	r21, 0x00	; 0
    da78:	0e 94 2e 6f 	call	0xde5c	; 0xde5c <__mulsi3>
    da7c:	7b 01       	movw	r14, r22
    da7e:	8c 01       	movw	r16, r24
    da80:	c6 01       	movw	r24, r12
    da82:	b5 01       	movw	r22, r10
    da84:	2d e1       	ldi	r18, 0x1D	; 29
    da86:	33 ef       	ldi	r19, 0xF3	; 243
    da88:	41 e0       	ldi	r20, 0x01	; 1
    da8a:	50 e0       	ldi	r21, 0x00	; 0
    da8c:	0e 94 4d 6f 	call	0xde9a	; 0xde9a <__divmodsi4>
    da90:	ca 01       	movw	r24, r20
    da92:	b9 01       	movw	r22, r18
    da94:	2c ee       	ldi	r18, 0xEC	; 236
    da96:	34 ef       	ldi	r19, 0xF4	; 244
    da98:	4f ef       	ldi	r20, 0xFF	; 255
    da9a:	5f ef       	ldi	r21, 0xFF	; 255
    da9c:	0e 94 2e 6f 	call	0xde5c	; 0xde5c <__mulsi3>
    daa0:	6e 0d       	add	r22, r14
    daa2:	7f 1d       	adc	r23, r15
    daa4:	80 1f       	adc	r24, r16
    daa6:	91 1f       	adc	r25, r17
    daa8:	97 ff       	sbrs	r25, 7
    daaa:	04 c0       	rjmp	.+8      	; 0xdab4 <do_rand+0x84>
    daac:	61 50       	subi	r22, 0x01	; 1
    daae:	70 40       	sbci	r23, 0x00	; 0
    dab0:	80 40       	sbci	r24, 0x00	; 0
    dab2:	90 48       	sbci	r25, 0x80	; 128
    dab4:	68 83       	st	Y, r22
    dab6:	79 83       	std	Y+1, r23	; 0x01
    dab8:	8a 83       	std	Y+2, r24	; 0x02
    daba:	9b 83       	std	Y+3, r25	; 0x03
    dabc:	9b 01       	movw	r18, r22
    dabe:	3f 77       	andi	r19, 0x7F	; 127
    dac0:	c9 01       	movw	r24, r18
    dac2:	cd b7       	in	r28, 0x3d	; 61
    dac4:	de b7       	in	r29, 0x3e	; 62
    dac6:	ea e0       	ldi	r30, 0x0A	; 10
    dac8:	0c 94 8a 6e 	jmp	0xdd14	; 0xdd14 <__epilogue_restores__+0x10>

0000dacc <rand_r>:
    dacc:	0e 94 18 6d 	call	0xda30	; 0xda30 <do_rand>
    dad0:	08 95       	ret

0000dad2 <rand>:
    dad2:	8d e7       	ldi	r24, 0x7D	; 125
    dad4:	95 e0       	ldi	r25, 0x05	; 5
    dad6:	0e 94 18 6d 	call	0xda30	; 0xda30 <do_rand>
    dada:	08 95       	ret

0000dadc <srand>:
    dadc:	a0 e0       	ldi	r26, 0x00	; 0
    dade:	b0 e0       	ldi	r27, 0x00	; 0
    dae0:	80 93 7d 05 	sts	0x057D, r24
    dae4:	90 93 7e 05 	sts	0x057E, r25
    dae8:	a0 93 7f 05 	sts	0x057F, r26
    daec:	b0 93 80 05 	sts	0x0580, r27
    daf0:	08 95       	ret

0000daf2 <strcat>:
    daf2:	fb 01       	movw	r30, r22
    daf4:	dc 01       	movw	r26, r24
    daf6:	0d 90       	ld	r0, X+
    daf8:	00 20       	and	r0, r0
    dafa:	e9 f7       	brne	.-6      	; 0xdaf6 <strcat+0x4>
    dafc:	11 97       	sbiw	r26, 0x01	; 1
    dafe:	01 90       	ld	r0, Z+
    db00:	0d 92       	st	X+, r0
    db02:	00 20       	and	r0, r0
    db04:	e1 f7       	brne	.-8      	; 0xdafe <strcat+0xc>
    db06:	08 95       	ret

0000db08 <strcmp>:
    db08:	fb 01       	movw	r30, r22
    db0a:	dc 01       	movw	r26, r24
    db0c:	8d 91       	ld	r24, X+
    db0e:	01 90       	ld	r0, Z+
    db10:	80 19       	sub	r24, r0
    db12:	01 10       	cpse	r0, r1
    db14:	d9 f3       	breq	.-10     	; 0xdb0c <strcmp+0x4>
    db16:	99 0b       	sbc	r25, r25
    db18:	08 95       	ret

0000db1a <strcpy>:
    db1a:	fb 01       	movw	r30, r22
    db1c:	dc 01       	movw	r26, r24
    db1e:	01 90       	ld	r0, Z+
    db20:	0d 92       	st	X+, r0
    db22:	00 20       	and	r0, r0
    db24:	e1 f7       	brne	.-8      	; 0xdb1e <strcpy+0x4>
    db26:	08 95       	ret

0000db28 <strstr>:
    db28:	fb 01       	movw	r30, r22
    db2a:	51 91       	ld	r21, Z+
    db2c:	55 23       	and	r21, r21
    db2e:	a9 f0       	breq	.+42     	; 0xdb5a <strstr+0x32>
    db30:	bf 01       	movw	r22, r30
    db32:	dc 01       	movw	r26, r24
    db34:	4d 91       	ld	r20, X+
    db36:	45 17       	cp	r20, r21
    db38:	41 11       	cpse	r20, r1
    db3a:	e1 f7       	brne	.-8      	; 0xdb34 <strstr+0xc>
    db3c:	59 f4       	brne	.+22     	; 0xdb54 <strstr+0x2c>
    db3e:	cd 01       	movw	r24, r26
    db40:	01 90       	ld	r0, Z+
    db42:	00 20       	and	r0, r0
    db44:	49 f0       	breq	.+18     	; 0xdb58 <strstr+0x30>
    db46:	4d 91       	ld	r20, X+
    db48:	40 15       	cp	r20, r0
    db4a:	41 11       	cpse	r20, r1
    db4c:	c9 f3       	breq	.-14     	; 0xdb40 <strstr+0x18>
    db4e:	fb 01       	movw	r30, r22
    db50:	41 11       	cpse	r20, r1
    db52:	ef cf       	rjmp	.-34     	; 0xdb32 <strstr+0xa>
    db54:	81 e0       	ldi	r24, 0x01	; 1
    db56:	90 e0       	ldi	r25, 0x00	; 0
    db58:	01 97       	sbiw	r24, 0x01	; 1
    db5a:	08 95       	ret

0000db5c <__eerd_block>:
    db5c:	a0 e0       	ldi	r26, 0x00	; 0
    db5e:	b0 e0       	ldi	r27, 0x00	; 0
    db60:	e4 eb       	ldi	r30, 0xB4	; 180
    db62:	fd e6       	ldi	r31, 0x6D	; 109
    db64:	0c 94 70 6e 	jmp	0xdce0	; 0xdce0 <__prologue_saves__+0x14>
    db68:	7c 01       	movw	r14, r24
    db6a:	eb 01       	movw	r28, r22
    db6c:	8a 01       	movw	r16, r20
    db6e:	69 01       	movw	r12, r18
    db70:	09 c0       	rjmp	.+18     	; 0xdb84 <__eerd_block+0x28>
    db72:	ce 01       	movw	r24, r28
    db74:	21 96       	adiw	r28, 0x01	; 1
    db76:	f6 01       	movw	r30, r12
    db78:	09 95       	icall
    db7a:	f7 01       	movw	r30, r14
    db7c:	81 93       	st	Z+, r24
    db7e:	7f 01       	movw	r14, r30
    db80:	01 50       	subi	r16, 0x01	; 1
    db82:	10 40       	sbci	r17, 0x00	; 0
    db84:	01 15       	cp	r16, r1
    db86:	11 05       	cpc	r17, r1
    db88:	a1 f7       	brne	.-24     	; 0xdb72 <__eerd_block+0x16>
    db8a:	cd b7       	in	r28, 0x3d	; 61
    db8c:	de b7       	in	r29, 0x3e	; 62
    db8e:	e8 e0       	ldi	r30, 0x08	; 8
    db90:	0c 94 8c 6e 	jmp	0xdd18	; 0xdd18 <__epilogue_restores__+0x14>

0000db94 <__eerd_word>:
    db94:	df 92       	push	r13
    db96:	ef 92       	push	r14
    db98:	ff 92       	push	r15
    db9a:	0f 93       	push	r16
    db9c:	1f 93       	push	r17
    db9e:	7b 01       	movw	r14, r22
    dba0:	8c 01       	movw	r16, r24
    dba2:	fb 01       	movw	r30, r22
    dba4:	09 95       	icall
    dba6:	d8 2e       	mov	r13, r24
    dba8:	c8 01       	movw	r24, r16
    dbaa:	01 96       	adiw	r24, 0x01	; 1
    dbac:	f7 01       	movw	r30, r14
    dbae:	09 95       	icall
    dbb0:	98 2f       	mov	r25, r24
    dbb2:	8d 2d       	mov	r24, r13
    dbb4:	1f 91       	pop	r17
    dbb6:	0f 91       	pop	r16
    dbb8:	ff 90       	pop	r15
    dbba:	ef 90       	pop	r14
    dbbc:	df 90       	pop	r13
    dbbe:	08 95       	ret

0000dbc0 <__eewr_block>:
    dbc0:	a0 e0       	ldi	r26, 0x00	; 0
    dbc2:	b0 e0       	ldi	r27, 0x00	; 0
    dbc4:	e6 ee       	ldi	r30, 0xE6	; 230
    dbc6:	fd e6       	ldi	r31, 0x6D	; 109
    dbc8:	0c 94 70 6e 	jmp	0xdce0	; 0xdce0 <__prologue_saves__+0x14>
    dbcc:	ec 01       	movw	r28, r24
    dbce:	7b 01       	movw	r14, r22
    dbd0:	8a 01       	movw	r16, r20
    dbd2:	69 01       	movw	r12, r18
    dbd4:	09 c0       	rjmp	.+18     	; 0xdbe8 <__eewr_block+0x28>
    dbd6:	f7 01       	movw	r30, r14
    dbd8:	61 91       	ld	r22, Z+
    dbda:	7f 01       	movw	r14, r30
    dbdc:	ce 01       	movw	r24, r28
    dbde:	21 96       	adiw	r28, 0x01	; 1
    dbe0:	f6 01       	movw	r30, r12
    dbe2:	09 95       	icall
    dbe4:	01 50       	subi	r16, 0x01	; 1
    dbe6:	10 40       	sbci	r17, 0x00	; 0
    dbe8:	01 15       	cp	r16, r1
    dbea:	11 05       	cpc	r17, r1
    dbec:	a1 f7       	brne	.-24     	; 0xdbd6 <__eewr_block+0x16>
    dbee:	cd b7       	in	r28, 0x3d	; 61
    dbf0:	de b7       	in	r29, 0x3e	; 62
    dbf2:	e8 e0       	ldi	r30, 0x08	; 8
    dbf4:	0c 94 8c 6e 	jmp	0xdd18	; 0xdd18 <__epilogue_restores__+0x14>

0000dbf8 <__eewr_word>:
    dbf8:	df 92       	push	r13
    dbfa:	ef 92       	push	r14
    dbfc:	ff 92       	push	r15
    dbfe:	0f 93       	push	r16
    dc00:	1f 93       	push	r17
    dc02:	d7 2e       	mov	r13, r23
    dc04:	7a 01       	movw	r14, r20
    dc06:	8c 01       	movw	r16, r24
    dc08:	fa 01       	movw	r30, r20
    dc0a:	09 95       	icall
    dc0c:	6d 2d       	mov	r22, r13
    dc0e:	c8 01       	movw	r24, r16
    dc10:	01 96       	adiw	r24, 0x01	; 1
    dc12:	f7 01       	movw	r30, r14
    dc14:	09 95       	icall
    dc16:	1f 91       	pop	r17
    dc18:	0f 91       	pop	r16
    dc1a:	ff 90       	pop	r15
    dc1c:	ef 90       	pop	r14
    dc1e:	df 90       	pop	r13
    dc20:	08 95       	ret

0000dc22 <__udivmodqi4>:
    dc22:	99 1b       	sub	r25, r25
    dc24:	79 e0       	ldi	r23, 0x09	; 9
    dc26:	04 c0       	rjmp	.+8      	; 0xdc30 <__udivmodqi4_ep>

0000dc28 <__udivmodqi4_loop>:
    dc28:	99 1f       	adc	r25, r25
    dc2a:	96 17       	cp	r25, r22
    dc2c:	08 f0       	brcs	.+2      	; 0xdc30 <__udivmodqi4_ep>
    dc2e:	96 1b       	sub	r25, r22

0000dc30 <__udivmodqi4_ep>:
    dc30:	88 1f       	adc	r24, r24
    dc32:	7a 95       	dec	r23
    dc34:	c9 f7       	brne	.-14     	; 0xdc28 <__udivmodqi4_loop>
    dc36:	80 95       	com	r24
    dc38:	08 95       	ret

0000dc3a <__udivmodhi4>:
    dc3a:	aa 1b       	sub	r26, r26
    dc3c:	bb 1b       	sub	r27, r27
    dc3e:	51 e1       	ldi	r21, 0x11	; 17
    dc40:	07 c0       	rjmp	.+14     	; 0xdc50 <__udivmodhi4_ep>

0000dc42 <__udivmodhi4_loop>:
    dc42:	aa 1f       	adc	r26, r26
    dc44:	bb 1f       	adc	r27, r27
    dc46:	a6 17       	cp	r26, r22
    dc48:	b7 07       	cpc	r27, r23
    dc4a:	10 f0       	brcs	.+4      	; 0xdc50 <__udivmodhi4_ep>
    dc4c:	a6 1b       	sub	r26, r22
    dc4e:	b7 0b       	sbc	r27, r23

0000dc50 <__udivmodhi4_ep>:
    dc50:	88 1f       	adc	r24, r24
    dc52:	99 1f       	adc	r25, r25
    dc54:	5a 95       	dec	r21
    dc56:	a9 f7       	brne	.-22     	; 0xdc42 <__udivmodhi4_loop>
    dc58:	80 95       	com	r24
    dc5a:	90 95       	com	r25
    dc5c:	bc 01       	movw	r22, r24
    dc5e:	cd 01       	movw	r24, r26
    dc60:	08 95       	ret

0000dc62 <__divmodhi4>:
    dc62:	97 fb       	bst	r25, 7
    dc64:	09 2e       	mov	r0, r25
    dc66:	07 26       	eor	r0, r23
    dc68:	0a d0       	rcall	.+20     	; 0xdc7e <__divmodhi4_neg1>
    dc6a:	77 fd       	sbrc	r23, 7
    dc6c:	04 d0       	rcall	.+8      	; 0xdc76 <__divmodhi4_neg2>
    dc6e:	e5 df       	rcall	.-54     	; 0xdc3a <__udivmodhi4>
    dc70:	06 d0       	rcall	.+12     	; 0xdc7e <__divmodhi4_neg1>
    dc72:	00 20       	and	r0, r0
    dc74:	1a f4       	brpl	.+6      	; 0xdc7c <__divmodhi4_exit>

0000dc76 <__divmodhi4_neg2>:
    dc76:	70 95       	com	r23
    dc78:	61 95       	neg	r22
    dc7a:	7f 4f       	sbci	r23, 0xFF	; 255

0000dc7c <__divmodhi4_exit>:
    dc7c:	08 95       	ret

0000dc7e <__divmodhi4_neg1>:
    dc7e:	f6 f7       	brtc	.-4      	; 0xdc7c <__divmodhi4_exit>
    dc80:	90 95       	com	r25
    dc82:	81 95       	neg	r24
    dc84:	9f 4f       	sbci	r25, 0xFF	; 255
    dc86:	08 95       	ret

0000dc88 <__udivmodsi4>:
    dc88:	a1 e2       	ldi	r26, 0x21	; 33
    dc8a:	1a 2e       	mov	r1, r26
    dc8c:	aa 1b       	sub	r26, r26
    dc8e:	bb 1b       	sub	r27, r27
    dc90:	fd 01       	movw	r30, r26
    dc92:	0d c0       	rjmp	.+26     	; 0xdcae <__udivmodsi4_ep>

0000dc94 <__udivmodsi4_loop>:
    dc94:	aa 1f       	adc	r26, r26
    dc96:	bb 1f       	adc	r27, r27
    dc98:	ee 1f       	adc	r30, r30
    dc9a:	ff 1f       	adc	r31, r31
    dc9c:	a2 17       	cp	r26, r18
    dc9e:	b3 07       	cpc	r27, r19
    dca0:	e4 07       	cpc	r30, r20
    dca2:	f5 07       	cpc	r31, r21
    dca4:	20 f0       	brcs	.+8      	; 0xdcae <__udivmodsi4_ep>
    dca6:	a2 1b       	sub	r26, r18
    dca8:	b3 0b       	sbc	r27, r19
    dcaa:	e4 0b       	sbc	r30, r20
    dcac:	f5 0b       	sbc	r31, r21

0000dcae <__udivmodsi4_ep>:
    dcae:	66 1f       	adc	r22, r22
    dcb0:	77 1f       	adc	r23, r23
    dcb2:	88 1f       	adc	r24, r24
    dcb4:	99 1f       	adc	r25, r25
    dcb6:	1a 94       	dec	r1
    dcb8:	69 f7       	brne	.-38     	; 0xdc94 <__udivmodsi4_loop>
    dcba:	60 95       	com	r22
    dcbc:	70 95       	com	r23
    dcbe:	80 95       	com	r24
    dcc0:	90 95       	com	r25
    dcc2:	9b 01       	movw	r18, r22
    dcc4:	ac 01       	movw	r20, r24
    dcc6:	bd 01       	movw	r22, r26
    dcc8:	cf 01       	movw	r24, r30
    dcca:	08 95       	ret

0000dccc <__prologue_saves__>:
    dccc:	2f 92       	push	r2
    dcce:	3f 92       	push	r3
    dcd0:	4f 92       	push	r4
    dcd2:	5f 92       	push	r5
    dcd4:	6f 92       	push	r6
    dcd6:	7f 92       	push	r7
    dcd8:	8f 92       	push	r8
    dcda:	9f 92       	push	r9
    dcdc:	af 92       	push	r10
    dcde:	bf 92       	push	r11
    dce0:	cf 92       	push	r12
    dce2:	df 92       	push	r13
    dce4:	ef 92       	push	r14
    dce6:	ff 92       	push	r15
    dce8:	0f 93       	push	r16
    dcea:	1f 93       	push	r17
    dcec:	cf 93       	push	r28
    dcee:	df 93       	push	r29
    dcf0:	cd b7       	in	r28, 0x3d	; 61
    dcf2:	de b7       	in	r29, 0x3e	; 62
    dcf4:	ca 1b       	sub	r28, r26
    dcf6:	db 0b       	sbc	r29, r27
    dcf8:	0f b6       	in	r0, 0x3f	; 63
    dcfa:	f8 94       	cli
    dcfc:	de bf       	out	0x3e, r29	; 62
    dcfe:	0f be       	out	0x3f, r0	; 63
    dd00:	cd bf       	out	0x3d, r28	; 61
    dd02:	09 94       	ijmp

0000dd04 <__epilogue_restores__>:
    dd04:	2a 88       	ldd	r2, Y+18	; 0x12
    dd06:	39 88       	ldd	r3, Y+17	; 0x11
    dd08:	48 88       	ldd	r4, Y+16	; 0x10
    dd0a:	5f 84       	ldd	r5, Y+15	; 0x0f
    dd0c:	6e 84       	ldd	r6, Y+14	; 0x0e
    dd0e:	7d 84       	ldd	r7, Y+13	; 0x0d
    dd10:	8c 84       	ldd	r8, Y+12	; 0x0c
    dd12:	9b 84       	ldd	r9, Y+11	; 0x0b
    dd14:	aa 84       	ldd	r10, Y+10	; 0x0a
    dd16:	b9 84       	ldd	r11, Y+9	; 0x09
    dd18:	c8 84       	ldd	r12, Y+8	; 0x08
    dd1a:	df 80       	ldd	r13, Y+7	; 0x07
    dd1c:	ee 80       	ldd	r14, Y+6	; 0x06
    dd1e:	fd 80       	ldd	r15, Y+5	; 0x05
    dd20:	0c 81       	ldd	r16, Y+4	; 0x04
    dd22:	1b 81       	ldd	r17, Y+3	; 0x03
    dd24:	aa 81       	ldd	r26, Y+2	; 0x02
    dd26:	b9 81       	ldd	r27, Y+1	; 0x01
    dd28:	ce 0f       	add	r28, r30
    dd2a:	d1 1d       	adc	r29, r1
    dd2c:	0f b6       	in	r0, 0x3f	; 63
    dd2e:	f8 94       	cli
    dd30:	de bf       	out	0x3e, r29	; 62
    dd32:	0f be       	out	0x3f, r0	; 63
    dd34:	cd bf       	out	0x3d, r28	; 61
    dd36:	ed 01       	movw	r28, r26
    dd38:	08 95       	ret

0000dd3a <ceil>:
    dd3a:	50 d0       	rcall	.+160    	; 0xdddc <__fp_trunc>
    dd3c:	80 f0       	brcs	.+32     	; 0xdd5e <ceil+0x24>
    dd3e:	9f 37       	cpi	r25, 0x7F	; 127
    dd40:	40 f4       	brcc	.+16     	; 0xdd52 <ceil+0x18>
    dd42:	91 11       	cpse	r25, r1
    dd44:	0e f4       	brtc	.+2      	; 0xdd48 <ceil+0xe>
    dd46:	62 c0       	rjmp	.+196    	; 0xde0c <__fp_szero>
    dd48:	60 e0       	ldi	r22, 0x00	; 0
    dd4a:	70 e0       	ldi	r23, 0x00	; 0
    dd4c:	80 e8       	ldi	r24, 0x80	; 128
    dd4e:	9f e3       	ldi	r25, 0x3F	; 63
    dd50:	08 95       	ret
    dd52:	26 f0       	brts	.+8      	; 0xdd5c <ceil+0x22>
    dd54:	1b 16       	cp	r1, r27
    dd56:	61 1d       	adc	r22, r1
    dd58:	71 1d       	adc	r23, r1
    dd5a:	81 1d       	adc	r24, r1
    dd5c:	14 c0       	rjmp	.+40     	; 0xdd86 <__fp_mintl>
    dd5e:	2e c0       	rjmp	.+92     	; 0xddbc <__fp_mpack>

0000dd60 <floor>:
    dd60:	3d d0       	rcall	.+122    	; 0xdddc <__fp_trunc>
    dd62:	80 f0       	brcs	.+32     	; 0xdd84 <floor+0x24>
    dd64:	9f 37       	cpi	r25, 0x7F	; 127
    dd66:	40 f4       	brcc	.+16     	; 0xdd78 <floor+0x18>
    dd68:	91 11       	cpse	r25, r1
    dd6a:	0e f0       	brts	.+2      	; 0xdd6e <floor+0xe>
    dd6c:	4f c0       	rjmp	.+158    	; 0xde0c <__fp_szero>
    dd6e:	60 e0       	ldi	r22, 0x00	; 0
    dd70:	70 e0       	ldi	r23, 0x00	; 0
    dd72:	80 e8       	ldi	r24, 0x80	; 128
    dd74:	9f eb       	ldi	r25, 0xBF	; 191
    dd76:	08 95       	ret
    dd78:	26 f4       	brtc	.+8      	; 0xdd82 <floor+0x22>
    dd7a:	1b 16       	cp	r1, r27
    dd7c:	61 1d       	adc	r22, r1
    dd7e:	71 1d       	adc	r23, r1
    dd80:	81 1d       	adc	r24, r1
    dd82:	01 c0       	rjmp	.+2      	; 0xdd86 <__fp_mintl>
    dd84:	1b c0       	rjmp	.+54     	; 0xddbc <__fp_mpack>

0000dd86 <__fp_mintl>:
    dd86:	88 23       	and	r24, r24
    dd88:	71 f4       	brne	.+28     	; 0xdda6 <__fp_mintl+0x20>
    dd8a:	77 23       	and	r23, r23
    dd8c:	21 f0       	breq	.+8      	; 0xdd96 <__fp_mintl+0x10>
    dd8e:	98 50       	subi	r25, 0x08	; 8
    dd90:	87 2b       	or	r24, r23
    dd92:	76 2f       	mov	r23, r22
    dd94:	07 c0       	rjmp	.+14     	; 0xdda4 <__fp_mintl+0x1e>
    dd96:	66 23       	and	r22, r22
    dd98:	11 f4       	brne	.+4      	; 0xdd9e <__fp_mintl+0x18>
    dd9a:	99 27       	eor	r25, r25
    dd9c:	0d c0       	rjmp	.+26     	; 0xddb8 <__fp_mintl+0x32>
    dd9e:	90 51       	subi	r25, 0x10	; 16
    dda0:	86 2b       	or	r24, r22
    dda2:	70 e0       	ldi	r23, 0x00	; 0
    dda4:	60 e0       	ldi	r22, 0x00	; 0
    dda6:	2a f0       	brmi	.+10     	; 0xddb2 <__fp_mintl+0x2c>
    dda8:	9a 95       	dec	r25
    ddaa:	66 0f       	add	r22, r22
    ddac:	77 1f       	adc	r23, r23
    ddae:	88 1f       	adc	r24, r24
    ddb0:	da f7       	brpl	.-10     	; 0xdda8 <__fp_mintl+0x22>
    ddb2:	88 0f       	add	r24, r24
    ddb4:	96 95       	lsr	r25
    ddb6:	87 95       	ror	r24
    ddb8:	97 f9       	bld	r25, 7
    ddba:	08 95       	ret

0000ddbc <__fp_mpack>:
    ddbc:	9f 3f       	cpi	r25, 0xFF	; 255
    ddbe:	49 f0       	breq	.+18     	; 0xddd2 <__fp_mpack+0x16>
    ddc0:	91 50       	subi	r25, 0x01	; 1
    ddc2:	28 f4       	brcc	.+10     	; 0xddce <__fp_mpack+0x12>
    ddc4:	86 95       	lsr	r24
    ddc6:	77 95       	ror	r23
    ddc8:	67 95       	ror	r22
    ddca:	b7 95       	ror	r27
    ddcc:	9f 5f       	subi	r25, 0xFF	; 255
    ddce:	80 38       	cpi	r24, 0x80	; 128
    ddd0:	9f 4f       	sbci	r25, 0xFF	; 255
    ddd2:	88 0f       	add	r24, r24
    ddd4:	96 95       	lsr	r25
    ddd6:	87 95       	ror	r24
    ddd8:	97 f9       	bld	r25, 7
    ddda:	08 95       	ret

0000dddc <__fp_trunc>:
    dddc:	25 d0       	rcall	.+74     	; 0xde28 <__fp_splitA>
    ddde:	a0 f0       	brcs	.+40     	; 0xde08 <__fp_trunc+0x2c>
    dde0:	be e7       	ldi	r27, 0x7E	; 126
    dde2:	b9 17       	cp	r27, r25
    dde4:	88 f4       	brcc	.+34     	; 0xde08 <__fp_trunc+0x2c>
    dde6:	bb 27       	eor	r27, r27
    dde8:	9f 38       	cpi	r25, 0x8F	; 143
    ddea:	60 f4       	brcc	.+24     	; 0xde04 <__fp_trunc+0x28>
    ddec:	16 16       	cp	r1, r22
    ddee:	b1 1d       	adc	r27, r1
    ddf0:	67 2f       	mov	r22, r23
    ddf2:	78 2f       	mov	r23, r24
    ddf4:	88 27       	eor	r24, r24
    ddf6:	98 5f       	subi	r25, 0xF8	; 248
    ddf8:	f7 cf       	rjmp	.-18     	; 0xdde8 <__fp_trunc+0xc>
    ddfa:	86 95       	lsr	r24
    ddfc:	77 95       	ror	r23
    ddfe:	67 95       	ror	r22
    de00:	b1 1d       	adc	r27, r1
    de02:	93 95       	inc	r25
    de04:	96 39       	cpi	r25, 0x96	; 150
    de06:	c8 f3       	brcs	.-14     	; 0xddfa <__fp_trunc+0x1e>
    de08:	08 95       	ret

0000de0a <__fp_zero>:
    de0a:	e8 94       	clt

0000de0c <__fp_szero>:
    de0c:	bb 27       	eor	r27, r27
    de0e:	66 27       	eor	r22, r22
    de10:	77 27       	eor	r23, r23
    de12:	cb 01       	movw	r24, r22
    de14:	97 f9       	bld	r25, 7
    de16:	08 95       	ret

0000de18 <__fp_split3>:
    de18:	57 fd       	sbrc	r21, 7
    de1a:	90 58       	subi	r25, 0x80	; 128
    de1c:	44 0f       	add	r20, r20
    de1e:	55 1f       	adc	r21, r21
    de20:	59 f0       	breq	.+22     	; 0xde38 <__fp_splitA+0x10>
    de22:	5f 3f       	cpi	r21, 0xFF	; 255
    de24:	71 f0       	breq	.+28     	; 0xde42 <__fp_splitA+0x1a>
    de26:	47 95       	ror	r20

0000de28 <__fp_splitA>:
    de28:	88 0f       	add	r24, r24
    de2a:	97 fb       	bst	r25, 7
    de2c:	99 1f       	adc	r25, r25
    de2e:	61 f0       	breq	.+24     	; 0xde48 <__fp_splitA+0x20>
    de30:	9f 3f       	cpi	r25, 0xFF	; 255
    de32:	79 f0       	breq	.+30     	; 0xde52 <__fp_splitA+0x2a>
    de34:	87 95       	ror	r24
    de36:	08 95       	ret
    de38:	12 16       	cp	r1, r18
    de3a:	13 06       	cpc	r1, r19
    de3c:	14 06       	cpc	r1, r20
    de3e:	55 1f       	adc	r21, r21
    de40:	f2 cf       	rjmp	.-28     	; 0xde26 <__fp_split3+0xe>
    de42:	46 95       	lsr	r20
    de44:	f1 df       	rcall	.-30     	; 0xde28 <__fp_splitA>
    de46:	08 c0       	rjmp	.+16     	; 0xde58 <__fp_splitA+0x30>
    de48:	16 16       	cp	r1, r22
    de4a:	17 06       	cpc	r1, r23
    de4c:	18 06       	cpc	r1, r24
    de4e:	99 1f       	adc	r25, r25
    de50:	f1 cf       	rjmp	.-30     	; 0xde34 <__fp_splitA+0xc>
    de52:	86 95       	lsr	r24
    de54:	71 05       	cpc	r23, r1
    de56:	61 05       	cpc	r22, r1
    de58:	08 94       	sec
    de5a:	08 95       	ret

0000de5c <__mulsi3>:
    de5c:	62 9f       	mul	r22, r18
    de5e:	d0 01       	movw	r26, r0
    de60:	73 9f       	mul	r23, r19
    de62:	f0 01       	movw	r30, r0
    de64:	82 9f       	mul	r24, r18
    de66:	e0 0d       	add	r30, r0
    de68:	f1 1d       	adc	r31, r1
    de6a:	64 9f       	mul	r22, r20
    de6c:	e0 0d       	add	r30, r0
    de6e:	f1 1d       	adc	r31, r1
    de70:	92 9f       	mul	r25, r18
    de72:	f0 0d       	add	r31, r0
    de74:	83 9f       	mul	r24, r19
    de76:	f0 0d       	add	r31, r0
    de78:	74 9f       	mul	r23, r20
    de7a:	f0 0d       	add	r31, r0
    de7c:	65 9f       	mul	r22, r21
    de7e:	f0 0d       	add	r31, r0
    de80:	99 27       	eor	r25, r25
    de82:	72 9f       	mul	r23, r18
    de84:	b0 0d       	add	r27, r0
    de86:	e1 1d       	adc	r30, r1
    de88:	f9 1f       	adc	r31, r25
    de8a:	63 9f       	mul	r22, r19
    de8c:	b0 0d       	add	r27, r0
    de8e:	e1 1d       	adc	r30, r1
    de90:	f9 1f       	adc	r31, r25
    de92:	bd 01       	movw	r22, r26
    de94:	cf 01       	movw	r24, r30
    de96:	11 24       	eor	r1, r1
    de98:	08 95       	ret

0000de9a <__divmodsi4>:
    de9a:	97 fb       	bst	r25, 7
    de9c:	09 2e       	mov	r0, r25
    de9e:	05 26       	eor	r0, r21
    dea0:	0e d0       	rcall	.+28     	; 0xdebe <__divmodsi4_neg1>
    dea2:	57 fd       	sbrc	r21, 7
    dea4:	04 d0       	rcall	.+8      	; 0xdeae <__divmodsi4_neg2>
    dea6:	f0 de       	rcall	.-544    	; 0xdc88 <__udivmodsi4>
    dea8:	0a d0       	rcall	.+20     	; 0xdebe <__divmodsi4_neg1>
    deaa:	00 1c       	adc	r0, r0
    deac:	38 f4       	brcc	.+14     	; 0xdebc <__divmodsi4_exit>

0000deae <__divmodsi4_neg2>:
    deae:	50 95       	com	r21
    deb0:	40 95       	com	r20
    deb2:	30 95       	com	r19
    deb4:	21 95       	neg	r18
    deb6:	3f 4f       	sbci	r19, 0xFF	; 255
    deb8:	4f 4f       	sbci	r20, 0xFF	; 255
    deba:	5f 4f       	sbci	r21, 0xFF	; 255

0000debc <__divmodsi4_exit>:
    debc:	08 95       	ret

0000debe <__divmodsi4_neg1>:
    debe:	f6 f7       	brtc	.-4      	; 0xdebc <__divmodsi4_exit>
    dec0:	90 95       	com	r25
    dec2:	80 95       	com	r24
    dec4:	70 95       	com	r23
    dec6:	61 95       	neg	r22
    dec8:	7f 4f       	sbci	r23, 0xFF	; 255
    deca:	8f 4f       	sbci	r24, 0xFF	; 255
    decc:	9f 4f       	sbci	r25, 0xFF	; 255
    dece:	08 95       	ret

0000ded0 <_exit>:
    ded0:	f8 94       	cli

0000ded2 <__stop_program>:
    ded2:	ff cf       	rjmp	.-2      	; 0xded2 <__stop_program>
