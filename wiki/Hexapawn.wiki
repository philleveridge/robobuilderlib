#summary hexapawn - heuristic AI - on a robot !

= Introduction =

<img src=http://robobuilderlib.googlecode.com/files/IMG_3218.2.JPG width=350 >


wikipedia http://en.wikipedia.org/wiki/Hexapawn
{{{
"Gardner specifically constructed it as a game with a small game tree,
 in order to demonstrate how it could be played by a heuristic AI 
implemented by a mechanical computer."
}}}

Inspired by http://www.atomclub.nl/sites/Fpga/www.howell1964.freeserve.co.uk/Acorn/Atom/amb/AtomMagic.htm

Demos new $input and set @a`[`x`]`=y

Source: http://code.google.com/p/robobuilderlib/source/browse/trunk/basic/examples/hexpawn.rbas

{{{
: r
Run Program 
C C C    0 1 2
         3 4 5
H H H    6 7 8
Input your move 
? 63
My move 14
C   C    0 1 2
H C      3 4 5
  H H    6 7 8
Input your move 
? 
}}}


= Details =

==initialise==

<code language="vb">
	c=1 'computer
	h=2 'human
	'stored positions
	p=100
	list s=$zeros(p)
</code>

==display board==

<code language="vb">
newg:
	'clear board
	list b=9,c,c,c,0,0,0,h,h,h
main:
	t=h
	for i=0 to 8
		out (B[i]=0)*32+(B[i]=c)*`C+(B[i]=h)*`H
		out 32
		if i=2 then
			print "   0 1 2"
		endif
		if i=5 then
			print "   3 4 5"
		endif
		if i=8 then
			print "   6 7 8"
		endif
	next i
</code>


==read user move==
This use new $input feature to read move. 
<code language="vb">
	'Check if legal human move available - if not finished
	for m=10 to 87
		gosub cm
		if e=0 then ym
	next m
	goto yl
ym:
	print "Input your move "
	let m=$input
	if m=0 then yl
	gosub cm
	if e<>0 then ym
	gosub mp
</code>

==The robot make its move==

Code the board and then search for position in possible list

<code language="vb">
	print "My move ";
	t=c
	x=B[0]+(4*B[3])+(16*B[6])+64
	y=B[1]+(4*B[4])+(16*B[7])+64
	z=B[2]+(4*B[5])+(16*B[8])+64
	v=0
mm:
	u=0
	if S[v]>128 then mend
	if S[v]=0 then newe
	if S[v]=x and S[v+1]=y and S[v+2]=z then sm
	u=1
	if S[v]=z and S[v+1]=y and S[v+2]=x then sm
	v=v+2
mend:
	v=v+1
	if v<p then mm
	print "v=";v
	end
</code>

==add new entry==
Adds code position to store
<code language="vb">
newe:
	S[v]=x 
	S[v+1]=y
	S[v+2]=z
	S[v+3]=0
	w=v+3
	for m=0 to 78
		if (m mod 10)<9 then
			gosub cm
			if e=0 then
				set S[w]=m+128
				w=w+1
				set S[w] = 0
			endif
		endif
	next m
</code>

==select move==
 select move, if u=0 use as stored, u=1 mean switch rows
<code language="vb">
sm:
	v=v+3
	if S[v]<128 then delm
	m=S[v]-128

	if u=0 then sme

	if m/10<3 then
		m=m+60
		goto sm2
	endif
	if m/10>5 then
		m=m-60
	endif
sm2:
	if m%10<3 then   
		m=m+6
		goto sme
	endif
	if m%10>5 then
		m=m-6
	endif
sme:
	print m,"u=";u
	gosub mp
	l=v
	goto main
</code>

==delete moves==
Remove move from store because we lost - no use
<code language="vb">
delm:
	for v=l to p-1
		set S[v]=S[v+1]
	next v
</code>

==win or loose - its playing the game that's important ==
<code language="vb">
yw:
	print "??"
	print "you win!"
 	goto ag
yl:
	print "you loose - haha"
ag:
	print "Another game? press 1"
	wait key
	k=$kir
	if k=`1 or k=12 then newg
	end
</code>

==check move==
Set return value in e, e=0 good, e=1 bad
<code language="vb">
cm:
	e=1
	f=m/10
	g=m mod 10
	if (B[f]<>T) or (B[G]=t) then
		return
	endif
	if B[G]=0 then
		'move - must be straight
		if ((t=c) and (g=f+3)) or ((t=h) and (g=f-3)) then good
	else
		'take - must be diagonal
		if ((t=c) and ((g=f+4) or (g=g+2)) and ((g/3-f/3)=1)) then good
		if ((t=h) and ((g=f-4) or (g=f-2)) and ((f/3-g/3)=1)) then good
	endif
	return
good:
	e=0
	return
</code>

==move piece==
Move in variable m. 63 means move from location 6 to location 3
<code language="vb">
mp:
	B[m/10]=0
	B[m%10]=t
	return
</code>