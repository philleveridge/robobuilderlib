#summary Advanced Basic demos

= Introduction =

A functional BASIC interpreter running on the Robobuilder RBC unit. So for all those who would like to try programming - but are daunted by the complexity of writing in C - and yet want more than Action builder, download and try it out !!

Writing your first program couldn't be easier, after downloading the firmware and uploading on to the robot using the RBC upgrade tool, connect a terminal program such as hyper terminal or putty and reset the power.

The firmware has 19 built-in motions to try out, including football kicks. Full access to all sensor such as PSD, accelerometer and IR port. Its fast enough to program in continuous walking and auto balance. 

If you find bugs - please report them on the Google site.

= Latest demos =
See new wiki pages for latest demos (all require BasicIDE/JBasic - [BasicClient] for details on the IDE)

  * [ArmsMoving Continuous arm movement using a cubic function]
  * [Cwalk2 Continuous Walking]
  * [sample FFT Sound Sample]
  * [neuron1 Neural Network demo (XOR problem)]
  * [MazeNavigation Maze Navigation]
  * [Generate On fly generating a gait using sine waves]
  * [Kinematics Simepl inverse 2D kinematic demo]
  * [Planner Simple MDP type motion planner]
  * [evo2 Using Genetic algorithm]
  * [AutoAssocNets Auto-associative Network (ANN) demo - using matrices]
  * [HopfieldNetwork Hopfiled Network demo - using matrices]

= Advanced demos =

  * [#Continuous_Walking Continuous walk using pre-planned moves]
  * [#Basic_auto-balance Very simple auto balance whilst standing]
  * [#Mirror_moves One arm mirroring other arm moving]
  * [#Dynamic_distance_sensor Arm reacting to object proximity]
  * [#Generating_a_walking_gait Generating a walking gate using sine waves]
  * [#Modify_RBC_Serial_Number Modify EPROM serial number]

----

== Continuous Walking ==

See above for a more advanced version with auto-balance

{{{
5 STAND 16
10 PRINT "press any key start"
15 LET K=$kbd
20 LET A=25
30 PRINT "R";
35 MOVE @{16,123,156,212,80,108,126,73,40,150,141,68,44,40,138,208,195},1,A
40 MOVE @{16,130,165,201,81,115,134,81,31,147,149,72,44,40,145,209,201},1,A
45 MOVE @{16,132,171,197,83,117,137,86,28,148,152,78,43,41,154,209,206},1,A
50 MOVE @{16,132,175,195,87,117,139,91,27,152,154,87,43,43,164,209,211},1,A
55 MOVE @{16,132,178,197,91,117,137,95,28,157,152,97,43,48,172,209,213},1,A
60 MOVE @{16,130,179,201,95,115,134,96,31,161,149,105,43,53,179,210,214},1,A
65 MOVE @{16,127,178,206,98,112,130,95,35,166,145,111,42,57,182,210,214},1,A
70 MOVE @{16,124,175,212,100,109,127,92,40,170,142,113,42,59,183,210,214},1,A
75 PRINT "L";
80 MOVE @{16,124,175,212,100,109,127,92,40,170,142,113,42,59,183,210,214},1,A
85 MOVE @{16,120,172,217,102,105,123,88,46,170,138,111,42,57,182,210,214},1,A
90 MOVE @{16,116,167,221,103,101,120,83,51,169,135,106,43,53,179,210,214},1,A
95 MOVE @{16,113,162,224,102,98,118,77,55,167,133,97,43,48,173,209,213},1,A
100 MOVE @{16,111,157,225,98,96,118,73,57,163,133,87,43,43,164,209,211},1,A
105 MOVE @{16,113,153,224,93,98,118,70,55,159,133,79,43,41,154,209,206},1,A
110 MOVE @{16,116,152,221,89,101,120,69,51,155,135,72,44,40,146,209,201},1,A
115 MOVE @{16,120,153,217,84,105,123,70,46,152,138,69,44,40,140,208,197},1,A
120 MOVE @{16,123,156,212,80,108,126,73,40,150,141,68,44,40,138,208,195},1,A
125 GOTO 30
}}}

==How it works==

Line 5 STAND - instructs the robot to take up basic posture. line 15 causes the program to wait for a key press - you could alternatively make it wait for IR remote by switch $KBD for $IR.

Line 35 move @{...},1,A moves servos from their current position to the new position, as specified in the list @{...}. First number is length of list i.e. 16. There are two other parameters, the '1' is the number of increments to take and the 'A' is a variable containing 25, the total length of time i.e. 25ms. You can vary A or switch for a constant etc...

Line 125 GOTO will cause the program to loop for ever (or until 'Esc' is pressed on keyboard). Line 25 and 70 produce 'RLRL... etc on the serial port.

To run type 'r'. in command mode ':' prompt or the red square on IR. The program is in flash so its still there even after being turned off. Just turn back on and press the red button ! (you'll need to switch the KBD for IR first - or it after standing it will wait for keyboard input)

Lots of mods to expand this are possible. The program could check for $PSD value or check, or see if its fallen over, by testing the accelerometer $X / $Y or $Z. You can vary the speed by changing the value 'A' -etc ...

----

== Basic auto-balance ==

See above for how to use ON based events to add balance to other motions

{{{
10 STAND 16
20 Print "Press any key"
30 if $kir<0 then 30
40 list m=7,-4,-2,-1,0,1,2,4
50 Let d=$find($z, @{7,-15,-10,-5,0,5,10,15}
60 let o=@m[d]
70 wait 10
80 print $z;"-";d;"-";o
90 servo 10=$servo(10)+o
100 servo 13=$servo(13)-o
110 wait 10
120 if $kir<0 then 40
}}}

== How it works ==

Line 10 causes the robot takes up Basic pose. Line 30 make it wait until keyboard or IR input. Line 40 set up list of offset values. Lines 50 maps the output of the z axis of the accelerometer ($z) to a range using the $find function. Line 60 then translates that into a displacement to apply to the servo. In lines 90 and 100 it updates the current position of the servo $servo(x) with the offset o. Line 120 cause the program to loop until either keyboard or IR remote is pressed ($kir) is received. If -1 it means no input.

----

== Mirror moves ==

Run the program and then move the right arm - and watch the left arm follow!

{{{
5 stand 16
10 servo 13=@
20 servo 14=@
30 servo 15=@
40 print "ready"
50 if $kir<0 then 50
60 let a=$servo(13)
70 let b=$servo(14)
80 let c=$servo(15)
90 servo 10=254-a
100 servo 11=254-b
110 servo 12=254-c
120 wait 50
130 goto 60
}}}

== How it works ==

The program first lines 10-30 puts servos 13,14,15 into passive mode, this makes them free to move. These servos form the right arm of the robot. It then loops reading their current position on line 60-80. Its then moves the left arm by corresponding amount. Because the left arm servos are reverse they move in the opposite direction, hence the 254-a. 

----

== Dynamic distance sensor ==

The arms dynamically move as the distance sensor detects your presence !! 

{{{
10 stand 16
20 servo 13=200
30 servo 10=50
40 let a=$psd
45 print "Psd=";$PSD
50 servo 13=250-a
60 servo 10=a
70 wait 200
80 goto 40
}}}

==How it works==
The value of the PSD sensor (always between 10 and 50) is used to set the position of servo 10 and 13 (the shoulders). These will move in unison based on the value. If nothing in range PSD will return 50, so servo 13 is set at 200 and servo 10=50, whilst at closet approach PSD will be 10 and Servo 13=240 and servo 10=10.

----

== Generating a walking gait ==

A more advanced example [Generate] can be seen above.

In one of the examples above I show continuous walking by sending out a sequence of predefined servo moves. But its possible to generate a walking gate mathematically using sine waves. The position of each servo can be defined as

{{{
Position = Offset + Amplitude * SIN (angle + phase)
}}}

As the angle goes through 360 degrees the servo position will vary about the offset by +/- the amplitude during each walking cycle.

To program this in BASIC needs the function $SIN(angle) will returns a sine value between -32768 and +32768 for angle values between 0 and 255. So to use the I create the following code:

{{{
FOR X=0 to 15
   LET P = B + (A*$SIN((X + C)*16)/32)/1024
NEXT X

    P = Position
    X = Angle   (0->15)
    A = amplitude
    B = offset
    C = phase   (0->15)
}}}

To enable each servo to have a different value of A, B and C I put those values into three indexed lists as follows

{{{
LIST A=16, 10, 13, 15,11, 10, 10,13,15, 11, 10,22, 1, 9, 22,  1,  9
LIST B=16,122,166,210,92,107,129,83,42,159,144,91,43,50,161,209,205
LIST C=16,  0,  2,  8, 5,  0, 15, 2, 8,  6, 15, 5,11, 5,  5,  5,  5
}}}

A contains a 16 element list containing the amplitudes of the sine waves. To access a list element use `@A[Y]` where Y is a value between 0 and 15. `@A[0]` will point to the value 10 (not 16 which is just the length and not stored).

So putting this all together the following code will generate a continuous walking motion,:

{{{
5 DATA A=10,13,15,11,10,10,13,15,11,10,22,1,9,22,1,9
10 DATA B=122,166,210,92,107,129,83,42,159,144,91,43,50,161,209,205
15 DATA C=0,2,8,5,0,15,2,8,6,15,5,11,5,5,5,5
20 FOR X=0 TO 15
25 FOR Y=0 TO 15
30 LET P=@B[Y]+@A[Y]*$SIN((X+@C[y])*16)/32768
50 PRINT P;":";
55 SERVO y=p
60 NEXT Y
65 PRINT ""
70 NEXT X
75 IF $KIR<0 THEN 20
}}}

==How it works==
Note lines 5-15 use the DATA statement instead of LIST. This is to improve speed as DATA values are evaluated but must simple values between 0 and 255, so reading is faster.
The lines 30 calculates the SIN wave value for each servo in turn. The calculation is sent to the servo in line 55. The program is fast enough to run a smooth walking gate. It will continue to run until it detects IR or keyboard press (or you turn it off!)

----

== Modify RBC Serial Number ==

Some times the firmware can get corrupted and the serial number is lost. When this happens the standard firmware won't download programs from the internet as they won't match the serial number. So to inspect the firmware you need to read the Flash memory using the $ROM() function. Type 'i' and enter the following program:

{{{
10 FOR I=1 to 13
20 OUT $ROM(I);
30 NEXT I
40 PRINT
}}}

If you see 13 digits all is well. If not find your serial number (its printed on the RBC unit) and update the ROM from interactive /input mode using for example:

{{{
POKE 1,`0
POKE 2,`1
etc ...
}}}

Note the "Back-quote" which converts the from Ascii character to numeric value. So `0 become 48.

*Use this with CAUTION !!!!!*

----

=== Please Note ===
_Basic programs are stored in flash - it will overwrite any action or motion scripts you have created. If / when you revert to standard firmware you will need to reload them.

It is possible (hopefully unlikely) that if the firmware goes wildly wrong it could overwrite your serial number and/or zero positions - these are recoverable but with some effort (see above)_

----