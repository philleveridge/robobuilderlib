#summary Integer Basic interpreter for embedded systems
#labels Phase-Requirements
= Introduction =

This custom firmware for Robobuilder gives it the ability to create and store simple programs in an elementary BASIC language. The software is stable beta release. *_Always download latest version firmware _*

This BASIC is a simple integer version based on Dartmouth Basic (see wiki http://en.wikipedia.org/wiki/BASIC). But with some additional features to support robotics on the Robobuilder RBC robots.

== Feature Summary == 
  # A-Z 32 bit signed integer variables
  # IF THEN ELSE
  # GOTO & GOSUB/RETURN
  # FOR NEXT Loops
  # PRINT
  # END
  # Immediate mode so commands can be run direct from command line
  # Debug mode to allow trace of programs
  # Full maths expression including AND OR
  # Maths functions suc as SIN and COS
  # Special features including access to Servo (Read/ Write), sensors PSD and Accelerometer
  # Lists (A-Z) (and soon MATrix commands)
  # Built in motions (19 including football kick)
  # Built in FFT - can access sound samples and process in realtime
  # Built in Neural network calculation
  # Event handling
  # I2C communication
  # Offset feature supports different robot configs  
  # Hardware access to LED and Buttons
  # Cross platform support for Linux, Windows and Omnima (openwrt)
  # See manual for fuller explanation : http://code.google.com/p/robobuilderlib/downloads/detail?name=Robobuilder%20Basic%20V2.2.2.pdf
  # For example programs see [SimpleDemos] and [BasicDemos]

== Recent updates ==
  # improved stability and expression handling. 
  # Event handling with ON TIME x GOSUB y and ON KEY GOSUB y (see example 22 - [SimpleDemos#22])
  # AND, OR and MOD are supported i.e. PRINT (1=1) AND (2=2) prints 1 (true). The old | % & still work as well 
   # Expression use 32 bit integer arithmetic - previously it was 16 bit, this make the range much better for complex expression - like above
  # There's a new variant of MOVE command MOVE A,B,C,D - see below
  # Command mode extensions
    # p option - set all servos passive 
    # Q option - queries all servo values and displays result 
  # New options on SCALE command to enable threshold 
  # List handling features. List are  separate from variable.
     # New List functions $SHUF and $MAP 
     # New List operators '+' '-' and '.' 
     # New options on LIST to support stacks and hence Procedure and Functions
     # New SCALE function
  # Versions for Linux and Windows now has floating point. 
  # New extended commands: covering image processing ExtendedCommands 
 
== Latest Bug fixes ==
     #  fix to expression handler and Cos function
     #  fix to edit lines 

= Getting started =
Download latest firmware (.HEX) and upload on to the RBC module using the [http://robobuilderlib.googlecode.com/files/rbctool.jpg RBCUpgrade] tool as per Robobuilder [http://robosavvy.com/RoboSavvyPages/Robobuilder/UsersManual/Robobuilder_User_Guide_EN.pdf manual pg 70].

If you're not using Windows, you can still download the custom firmware into your bot using the [ http://www.strout.net/info/robotics/utilities/avrbl-downloader/AVRBL Downloader tool]. Or there's a Java based tool available in the source tree.

If you want just to try it out (and not load on to Robot) then there are  windows and Linux OS builds is available  (basic.exe). It input/outputs using console. Some Robot hardware functions are available if the robot is running DCMP firmware connected om serial port.

So assuming you have downloaded the program (and installed the firmware) - reset the power on the RBC and connect a [http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html VT100 terminal emulator] on the serial port (i.e. COM1 at 115200). You should see the following:
{{{
Basic v=$Revision: 538 $
Commands: i r l c z q s V R F $

16 servos connected
0 lines in memory
:
}}}

At the prompt type one of the following
  * i - input a new program [. at start of line will exit input mode]
  * r - run current program [or press Red button on IR remote]
  * R - run in TRACE mode
  * l - list current program (or L to also list variable values)
  * c - clear memory
  * z - download (requires client - see below)
  * p - sets passive (input mode) on the servos
  * q - check servos connected (Q- will output values)
  * V - print version / build
  * s - stand
  * $ - enter demo mode
  * X - enter battery charge mode
  * g - Go to specific line number

For more details and programming guide see the PDF manual.

The start mode is command mode signified by ':'. On pressing I it enters input mode and  you get a '>' prompt, In input mode any valid program code with a line number is stored in flash - and will be there after you turn the robot off. With no line number the command will be immediately executed. 

== Example session ==

{{{
Basic v=$Revision: 538 $
Commands: i r l c z q s V R F $
16 servos connected
0 lines in memory
: i
Enter Program '.' to Finish
> print "hello world"
hello world
> 10 print "hello world"
> .

1 lines entered, [25/3072] Bytes
: l
List Program
10 PRINT "hello world"
: i
Enter Program '.' to Finish
> 20 goto 10
> .

1 lines entered, [28/3072] Bytes
: l
List Program
10 PRINT "hello"
20 GOTO 10
: c
Clear Program
: l
List Program
}}}

If the program ever gets into a recurring loop (either accidentally or deliberately) then press 'Esc' on the PC keyboard. If that fails then hit the 'OFF' button (on the robot!)

Notice how each time you enter input mode its adds to the current program. If you want to start over then press 'c.  To run the program press 'r' (and then Esc!)

= Language Specification =

{{{
Language Spec:
VAR    A-Z  (integer only)
OPER   + - * \ ( ) = < > % <= >= <> & | 
CMD    LET:FOR:NEXT:GOTO:IF:THEN:ELSE:PRINT:END:SET:RUN:POKE
       WAIT:STEP:PUT:SERVO:MOVE:GOSUB:RETURN:LIST:STAND:OUT
       I2CI:I2CO:OFFSET:SPEED:MTYPE
STRING " ... "
EXPR1  VAR | LITERAL
EXPR2  EXPR1 | STRING
LIST   EXPR2 [,EXPR2]
EXPR   EXPR1 OPER EXPR1  

SYNTAX:
[LINE no] LET  VAR '=' EXPR 
[LINE no] GOTO [Line No]
[LINE no] PRINT LIST [;]
[LINE No] END
[LINE no] IF  EXPR THEN LINE no ELSE Line No
[LINE No] FOR VAR '=' EXPR 'To' EXPR
[LINE No] NEXT VAR
[LINE No] WAIT number
[Line No] SERVO ID=EXPR | '@' | '~'
[LINE No] LIST [VAR]=N,1,2,3 ..
[LINE No] MOVE @[VAR],c,d | @[Var] | a,b,c,d
[Line No] GOSUB [Line No]
[Line No] RETURN
[Line No] STAND [16 | 18]  
[LINE No] PUT VAR '=' $PORTA|B|C:0-7
[LINE No] OUT EXPR,EXPR
[Line No] RUN number
[Line No] PLAY number
[Line No] OFFSET [# | List | "blank"]
[Line No] IC2O number,List
[Line No] IC2I number,number,List
[Line No] SPEED number
[Line No] MTYPE number
[Line No] STEP ID=number,number,number
[Line No] SAMPLE a,b[,c[,d]]
[Line No] FFT list,scale
[Line No] SCALE list,scale
[Line No] SET index,value
[Line No] SORT @array  | SORT #a,b,c
[Line No] INSERT index,value
[Line No] DELETE index
[Line No] SELECT index,index
[Line No] GEN No_Gn,length,Mute rate%,Mute rnge,Val[min,max],type
[Line No] NETWORK No input,No outputs,flag,no lay 1,no lay 2, no lay3
[Line No] MAT [DEF|TRAN|MULT|ZERO|CONV] [args;args;...]
}}}

== Example syntax ==

||Command||Description||
||SERVO ID=POS  ||set servo id to position POS / @ / ~||
||LIST v=n,1,2,..n   ||Set V to a list of n elements ||
||MOVE @P,c,d    ||sends a Scene of servos position in array P,c steps in total of d ms (i.e. @A,10,1000 each step is 100ms||
||MOVE a,b,c,d    ||sends a Scene of servos position in @![a,a+b] c steps d ms so each step d/c >25ms||
||POKE 10,A     ||Put A into Byte 10||
||PUT PORT:A:8 = 3 ||set DDR of Port A = 3 (PIN0,PIN1 readable)||
||PUT PORT:A:2 = 1 ||set Port A bit 2 =1 (assuming writeable)||
||WAIT 200       ||Wait for a an amount of time in ms i.e. 200ms||
||STAND 16      ||set servos to basic posture (for 16 or 18 servo bots)||
||OFFSET        ||Defines a numeric offset array to be applied to MOVE and PLAY commands||
||RUN 0         ||Call Built in action using code i.e. RUN 0, would punch left See built in motion list below||
||I2CO 51,@{3,1,2,3}||will send 3 bytes to I2C address 51 ||
||I2CI 52,5,@{2,1,1}||will read 5 bytes from address 52 after first send 2 bytes (1,1) to the same address.||
||SPEED 2||Speed torque setting on Move 0-4 (0 maximum, 4 minimum) ||
||MTYPE 3||Set Motion type 0: Acc, 1=Deacc, 2=AccDeac, 3=Linear ||
||STEP 5=30,50,5||STEP servo 5 from position 30 to position 50 in increments of 5 checking progress and stopping if obstruction||
||SORT #a,b,c||specialised sort for use with GEN- tbc||
||GEN 8,6,0,0,0,5,2||GENerate array,||
||NETWORK  2,1,4,2,0,1||creates a 3 neuron network (2 input 1 output) ||
||SCALE || Scale command will scale a list or threshold a list ||
||MAT || Matrix commands options DEF, MULT, TRAN, ZERO, CONV, PRINT||

== Functions and Special variables ==
Functions an variables can be used in an expression, for example LET A=$X would set A to the current value of X accelerometer. The value of $X changes in real time.

||Specials ($)||Description||
||$X, $Y, $Z   ||accelerometer values||
||$IR          ||wait for IR remote and get button pressed LET A=$IR||
||$KBD         ||wait for keyboard press||
||$KIR         ||Scan keyboard and IR port return immediate -1 if nothing pressed||
||$PSD         ||PSD sensor value||
||$VOLT        ||Battery voltage||
||$TICK        ||Number of tenths of a second||
||$PORT        ||Read Bit 6 of Port A .. LET A=$PORT:A:6 ||
||$RND         ||Random numbers - different number each time called ||
||$MIC         ||Microphone level||
||$SERVO(id)   ||position of servo id, i.e.  LET A=$SERVO(5) get Servo ID 5 position ||
||$ABS(x)      ||Absolute value of x returned||
||$ROM(x)      ||Contents of ROM location x, i.e. LET A=$ROM(10)||
||$MAPIR(x)    ||Maps value from IR to built in action code||
||$FIND(x, @A) ||Look for item less than or equal to X and return index||
||$CVB2I(x)    ||Converts byte to int, i.e. 4 -> 4 and 254 -> -2||
||$MAX(@n)||return maximum element value in array n ||
||$MIN(@n)|| return minimum element value in array n    ||
||$NORM||   ||
||$SUM(@n)|| return sum of element values in array n    ||
||$SIN(x)||Sine of X where X 0-233 and return is +/-32K||
||$COS(x)||Cosine of X where X 0-233 and return is +/-32K||
||$RANGE(a,b,c)||return b < a < c ||
||$SIG(x[,n])||  SIGMOID(x) - different scaling options set by n||
||$DSIG(x)||SIGMOID derivative i.e.returns x*(1-x)  ||
||$STAND(x)||return an array of positions related to stand  ||
||$ZEROS(x)||return an array of zeros  ||
||$SHUF(x)||create a list of shuffled numbers from 1-X ||
||$MAP(@x,@y)||Map array X using array Y ||
||$SCALE(@A,x[,y,z]||Scale array A by X or Threshold A where A(i)>=x y else z||



== Built in motions ==
The following motions can be access by the RUN command - see above

{{{
0) PunchLeft
1) PunchRight
2) SidewalkLeft
3) SidewalkRight
4) TurnLeft
5) TurnRight
6) GetupBack
7) GetupFront
8) WalkForward
9) WalkBackward
10)lshoot
11)rshoot
12)rsidewalk
13)lsidewalk
14)standupr
15)standupf
16)sitdown
17)hi
18)kick left front turn
}}}