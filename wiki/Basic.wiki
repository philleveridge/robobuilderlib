#summary Simple Mini Basic interpreter
#labels Phase-Requirements
= Introduction =

This gives Robobuilder the ability to create simple actions in an elementary basic language. The software is beta release.

*_New version  firmware (v367)_* - http://robobuilderlib.googlecode.com/files/Basic367.hex

Next extract Basic.hex and upload on to the RBC module using the [http://robobuilderlib.googlecode.com/files/rbctool.jpg RBCUpgrade] tool as per Robobuilder [http://robosavvy.com/RoboSavvyPages/Robobuilder/UsersManual/Robobuilder_User_Guide_EN.pdf manual pg 70].

If you're not using Windows, you can still download the custom firmware into your bot using the [ http://www.strout.net/info/robotics/utilities/avrbl-downloader/AVRBL Downloader tool]. Or there's a Java based tool available in the source tree.


If you want just to try it out (and not load on to Robot) then there is nn old windows OS build is available  (basic.exe). It input/outputs using windows console. Robot hardware functions are stubbed out.  And now there is a *_New: A linux build available_* - http://robobuilderlib.googlecode.com/files/Basic372

So assuming you have downloaded the program (and installed the firmware - reset the power on the RBC and connect a [http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html vt100 terminal emulator]. You should see the following:
{{{
Basic v=$Revision: 366 $
Commands: i r l c z q s V R F $

16 servos connected
0 lines in memory
:
}}}

At the prompt type 
  * i - input a new program [. at start of line will exit input mode]
  * r - run current program [or press Red button on IR remote]
  * R - run in TRACE mode
  * l - list current program
  * c - clear memory
  * z - download (requires client - see below)
  * q - check servos connected
  * V - print version / build
  * s - stand
  * $ - enter demo mode
  * X - enter bat charge mode
  * g - Go to specific line number

There is also a windows client application (BasicClient.exe) to simplify the download of programs - see wiki for more details.

For more details and programming guide see the PDF  manual also in the ZIP file.

The start mode is command mode signified by ':'. On pressing I it enters input mode and  you get a '>' prompt, In input mode any valid program code with a line number is stored in flash - and will be there after you turn the robot off. With no line number the command will be immediately executed. 

Here is an example session :

{{{
Basic v=$Revision: 367 $
Commands: i r l c z q s V R F $
16 servos connected
0 lines in memory
: i
Enter Program '.' to Finish
> print "hello world"
hello world
> 10 print "hello world"
> .

1 lines entered, [25/3072] Bytes
: l
List Program
10 PRINT "hello world"
: i
Enter Program '.' to Finish
> 20 goto 10
> .

1 lines entered, [28/3072] Bytes
: l
List Program
10 PRINT "hello"
20 GOTO 10
: c
Clear Program
: l
List Program
}}}

If the program ever gets into a recurring loop (either accidentally or deliberately) then press 'Esc' on the PC keyboard. If that fails then hit the 'OFF' button (on the robot!)

Notice how each time you enter input mode its adds to the current program. If you want to start over then press 'c.  To run the program press 'r' (and then Esc!)

_See examples below of programs that have been tested. _

For advanced demos see BasicDemos http://code.google.com/p/robobuilderlib/wiki/BasicDemos

== Details ==

{{{
Language Spec:
VAR    A-Z  (integer only)
OPER   + - * \ ( ) = < > % <= >= <> & | 
CMD    LET:FOR:NEXT:GOTO:IF:THEN:ELSE:PRINT:END:SET:RUN:POKE
       WAIT:STEP:PUT:SERVO:MOVE:GOSUB:RETURN:LIST:STAND:OUT
       I2CI:I2CO:OFFSET:SPEED:MTYPE
STRING " ... "
EXPR1  VAR | LITERAL
EXPR2  EXPR1 | STRING
LIST   EXPR2 [,EXPR2]
EXPR   EXPR1 OPER EXPR1  

SYNTAX:
[LINE no] LET  VAR '=' EXPR 
[LINE no] GOTO [Line No]
[LINE no] PRINT LIST [;]
[LINE No] END
[LINE no] IF  EXPR THEN LINE no ELSE Line No
[LINE No] FOR VAR '=' EXPR 'To' EXPR
[LINE No] NEXT VAR
[LINE No] WAIT number
[Line No] SERVO ID=EXPR | '@' | '~'
[LINE No] LIST [VAR]=N,1,2,3 ..
[LINE No] MOVE @[VAR],1,25 
[Line No] GOSUB [Line No]
[Line No] RETURN
[Line No] STAND [16 | 18]  
[LINE No] PUT VAR '=' $PORTA|B|C:0-7
[LINE No] OUT EXPR,EXPR
[Line No] RUN number
[Line No] PLAY number
[Line No] OFFSET [# | List | "blank"]
[Line No] IC2O number,List
[Line No] IC2I number,number,List
[Line No] SPEED number
[Line No] MTYPE number
[Line No] STEP ID=number,number,number
[Line No] SAMPLE a,b[,c[,d]]
[Line No] FFT list,scale
[Line No] SCALE list,scale
[Line No] SET index,value
[Line No] SORT @array  | SORT #a,b,c
[Line No] INSERT index,value
[Line No] DELETE index
[Line No] SELECT index,index
[Line No] GEN No_Gn,length,Mute rate%,Mute rnge,Val[min,max]
[Line No] NETWORK - new  tbc
}}}

||Special register access ($)||Description||
||$X, $Y, $Z   ||accelerometer values||
||$IR          ||wait for IR remote and get button pressed LET A=$IR||
||$KBD         ||wait for keyboard press||
||$KIR         ||Scan keyboard and IR port return immediate -1 if nothing pressed||
||$PSD         ||PSD sensor value||
||$VOLT        ||Battery voltage||
||$TICK        ||Number of tenths of a second||
||$PORT        ||Read Bit 6 of Port A .. LET A=$PORT:A:6 ||
||$RND         ||Random numbers - different number each time called ||
||$MIC         ||Microphone level||
||$SERVO(id)   ||position of servo id, i.e.  LET A=$SERVO(5) get Servo ID 5 position ||
||$ABS(x)      ||Absolute value of x returned||
||$ROM(x)      ||Contents of ROM location x, i.e. LET A=$ROM(10)||
||$MAPIR(x)    ||Maps value from IR to built in action code||
||$FIND(x, @A) ||Look for item less than or equal to X and return index||
||$CVB2I(x)    ||Converts byte to int, i.e. 4 -> 4 and 254 -> -2||
||$MAX(@n)||return maximum element value in array n ||
||$MIN(@n)|| return minimum element value in array n    ||
||$NORM||   ||
||$SUM(@n)|| return sum of element values in array n    ||
||$HAM(@a,@b)||    ||
||$SIN(x)||Sine of X where X 0-233 and return is +/-32K||
||$COS(x)||Cosine of X where X 0-233 and return is +/-32K||
||$RANGE(a,b,c)||return b < a < c ||
||$SIG(x[,n])||  SIGMOID(x) - different scaling options set by n||
||$DSIG(x)||SIGMOID derivative i.e.returns x*(1-x)  ||
||$STAND(x)||return an array of positions related to stand  ||
||$ZEROS(x)||return an array of zeros  ||


||Command||Description||
||SERVO ID=POS  ||set servo id to position POS / @ / ~||
||LIST v=n,1,2,..n   ||Set V to a list of n elements ||
||MOVE @P,a,b    ||sends a Scene of servos position in array P,a steps in b ms Note: b/a > 25||
||POKE 10,A     ||Put A into Byte 10||
||PUT PORT:A:8 = 3 ||set DDR of Port A = 3 (PIN0,PIN1 readable)||
||PUT PORT:A:2 = 1 ||set Port A bit 2 =1 (assuming writeable)||
||WAIT 200       ||Wait for a an amount of time in ms i.e. 200ms||
||STAND 16      ||set servos to basic posture (for 16 or 18 servo bots)||
||OFFSET        ||Defines a numeric offset array to be applied to MOVE and PLAY commands||
||RUN 0         ||Call Built in action using code i.e. RUN 0, would punch left See built in motion list below||
||I2CO 51,@{3,1,2,3}||will send 3 bytes to I2C address 51 ||
||I2CI 52,5,@{2,1,1}||will read 5 bytes from address 52 after first send 2 bytes (1,1) to the same address.||
||SPEED 2||Speed torque setting on Move 0-4 (0 maximum, 4 minimum) ||
||MTYPE 3||Set Motion type 0: Acc, 1=Deacc, 2=AccDeac, 3=Linear ||
||STEP 5=30,50,5||STEP servo 5 from position 30 to position 50 in increments of 5 checking progress and stopping if obstruction||
||SORT #a,b,c||specialised sort for use with GEN- tbc||
||GEN 8,6,0,0,0,5,2||tbc||
||NETWORK  2,1,4,2,0,1||creates a 3 neuron network (2 input 1 output) ||
*Built in motions:*
{{{
0) PunchLeft
1) PunchRight
2) SidewalkLeft
3) SidewalkRight
4) TurnLeft
5) TurnRight
6) GetupBack
7) GetupFront
8) WalkForward
9) WalkBackward
10)lshoot
11)rshoot
12)rsidewalk
13)lsidewalk
14)standupr
15)standupf
16)sitdown
17)hi
18)kick left front turn
}}}

= Examples  =

These are available from examples sub- folder
http://code.google.com/p/robobuilderlib/source/browse/#svn/trunk/examples
{{{
1) simple loop
10 LET A=1
20 PRINT A
30 LET A=A+1
35 WAIT 500
40 IF A<10 THEN 20 
50 END

2) read from console and IR port
10 LET A=$KBD
20 PRINT A
30 LET A=$IR
40 PRINT A
50 GOTO 10

3) Loops
10 FOR A=1 to 5
20 PRINT A
30 NEXT A

4) compound PRINT
10 LET A=(5+3)*(2+1)
20 PRINT "The answer is ";A
30 END

5) read and set servo
This reads current position of servo 12 and then moves and extra 5
10 let a=$servo(12)
20 print "Pos=";a
30 servo 12=a+5

6) read accelerometer values
10 print $TICK;" X=";$X;" Y=";$Y;" Z=";$Z
20 wait 500
30 goto 10

7) Read button pressed 
10 let A=$IR
20 print "Received=";A

8) More  complex - press a button on IR and do action (like standard firmware)
10 STAND 16
20 RUN $MAPIR($IR)
30 GOTO 20

9) Simple LISTS
10 print "List test"
20 list a=5,4,3,2,1,5
30 print @a[1]
40 print @a
Output:
3
4,3,2,1,5
Note: lists are number from zero. First element (5) is the length of the list

10) OUT - show PSD sensor output as a bar
10 out 45,$psd
20 out 42
30 print
40 goto 10
Output:
----------*
Ascii value '-' 45, '*' 42, and If $PSD value is say 10 

11) ROM  and OUT - displays serial number
10 FOR I=1 to 13
20 OUT $ROM(I)
30 NEXT I
40 PRINT 

12) Use of  Passive
10 SERVO 12=@
20 Print "Servo 12 = "; $SERVO(12)
30 wait 500
40 goto 20

12a) Changing Red/Blue IO port values
10 LET A=0
20 SERVO 12=~A
25 WAIT 50
30 LET A=A+1
40 GOTO 20
Output:
Servo 12 will flash red/blue light (assuming its a transparent servo!)
IO ports. ~0, ~1, ~2, ~3

13) Gosub and Return
10 print "Hello";
20 gosub 50
30 print " back";
40 end
50 print " Here";
60 return
Output:
Hello Here back

14) Take up basic pose 
10 MOVE @{16,125,179,199,88,108,126,72,49,163,141,51,47,49,199,205,205},10,1000
Its simpler to use STAND 16 - but this show use of the MOVE command with a literal/inline LIST. 

Note: There is one subtle difference with STAND in that its not affected by the OFFSET command where as MOVE is.

15) Index through a list
10 list a=5,65,66,67,68,69
20 for i=0 to 4
30 out @a[i]
40 next i
50 print
output:
ABCDE

15.1 Modify entries in a list
10 PRINT @{5,1,2,3,4,5}
20 SET 3,7
30 PRINT @!
40 INSERT 3,8
50 PRINT @!
60 DELETE 3
70 PRINT @!
output:
1,2,3,4,5
1,2,3,7,7
1,2,3,8,7,5
1,2,3,7,5


16) Generate random numbers
Also use % to get modulo of $rnd - so example return 10 numbers between 0 and 5
10 for i=1 to 10
20 print $rnd % 6
30 next i
output:
5
5
0
etc ..

17) I2C comm example(s)
This examples reads values from the optional accelerometer (address 112). The bytes are available from current array @![n]. Note use of $CVB2I() - converts the read bytes values to integers i.e. 255 -> -1. 

10 FOR I=1 to 10
20 I2CO 112,@{1,2}
30 I2CI 113,6
40 PRINT "X=";$CVB2I(@![1]);" Y=";$CVB2I(@![3]);" Z=";$CVB2I(@![5])
50 WAIT 250
60 NEXT I
output:
X=5 Y=-2 Z=6
X=5 Y=-2 Z=7
...

18) Lights proximity detector
10 LET P=$PSD
20 LIGHTS P-10
30 GOTO 10
output:
The lights on the back of the Robot (Run,Pwr, Err) will act as a bargraph showing how close an object is to PSD sensor 

19) Close gripper
10 STEP 18=70,120,5
output:
Assuming a gripper is connected to Servo 18 this function will slowly close the gripper until it either is fully closed or its movement is stopped by an object in it grasp.
}}}

Grippers available from Ipswich Robotics : 
[http://www.shapeways.com/model/55863/gripper_left.html Left gripper] or 
[http://www.shapeways.com/model/55864/gripper___right.html Right gripper]

{{{
20) Reading PF1 and PF2
The buttons on the back of the RBC are normally logic high and go low when pressed. The are access via bits 0 &1 on PORTA -

10 print "Press PF1 or PF2 to start"
20 if ($port:a:0=1)&($port:a:1=2) then 20
30 print "Done"

Note the use of the & for logic AND.

21) Switch LEDS on and OFF
The LEDs can be access via the PORT as well. Red Power LED is on Port C bit 7. This LED is on when bit is zero and off when bit is 1. So the following will flash the light
10 LIGHTS 0
20 put port:c:7=1
30 wait 500
40 put port:c:7=0
50 wait 500
60 GOTO 20

}}}