#summary Simple Mini Basic complier/interpreter
#labels Phase-Requirements
= Introduction =

This gives Robobuilder the ability to create simple actions in an elementary basic language. The software is alpha/beta release.

Download [http://code.google.com/p/robobuilderlib/downloads/detail?name=Basic.hex basic.hex] on to the RBC module using the [http://robobuilderlib.googlecode.com/files/rbctool.jpg RBCUpgrade] tool as per Robobuilder [http://robosavvy.com/RoboSavvyPages/Robobuilder/UsersManual/Robobuilder_User_Guide_EN.pdf manual pg 70].

A windows OS build is available - [http://code.google.com/p/robobuilderlib/downloads/detail?name=Basic.exe basic.exe]. it input/outputs using windows console. Robot hardware functions are stubbed out. 

Turn on the RBC and connect a [http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html vt100 terminal emulator]. You should see the following:
{{{
Basic v=$Revision: 216 $
Commands: i r l c z q
16 servos connected
0 lines in memory
:
}}}

At the prompt type 
  * i - input a new program [. at start of line will exit input mode]
  * r - run current program [or press Red button on IR remote]
  * l - list current program
  * c - clear memory
  * z - download (requires client - see below)
  * q - check servos connected

There is also a [http://code.google.com/p/robobuilderlib/downloads/detail?name=BasicClient.exe windows client application] to simplify the download of programs - http://code.google.com/p/robobuilderlib/wiki/BasicClient - for more details

In input mode you get a '>' prompt, in command mode a ':'. In input mode a command with a line number is stored in flash - and will be there after you turn the robot off. With no line number the command will be immediately executed. 

So for instance - an example session :

{{{
Basic v=$Revision: 216 $
Commands: i r l c z q
16 servos connected
0 lines in memory
: i
Enter Program '.' to Finish
> print "hello world"
hello world
> 10 print "hello world"
> .

1 lines entered, [25/3072] Bytes
: l
List Program
10 PRINT "hello world"
: i
Enter Program '.' to Finish
> 20 goto 10
> .

1 lines entered, [28/3072] Bytes
: l
List Program
10 PRINT "hello"
20 GOTO 10
: c
Clear Program
: l
List Program
}}}

If the program ever gets into a recurring loop (either accidentally or deliberately) then press 'Esc' on the PC keyboard. If that fails then hit the 'OFF' button (on the robot!)

Notice how each time you enter input mode its adds to the current program. If you want to start over then press 'c.  To run the program press 'r' (and then Esc!)

_See examples below of programs that have been tested. _

== Details ==

{{{
Language Spec:
VAR    A-Z  (integer only)
OPER   + - * \ ( ) = < > % <= >= <>
CMD    LET:FOR:NEXT:GOTO:IF:THEN:ELSE:PRINT:END:SET:XACT:WAIT
STRING " ... "
EXPR1  VAR | LITERAL
EXPR2  EXPR1 | STRING
LIST   EXPR2 [,EXPR2]
EXPR   EXPR1 OPER EXPR1  

SYNTAX:
[LINE no] LET  VAR '=' EXPR 
[LINE no] GOTO [Line No]
[LINE no] PRINT LIST [;]
[LINE No] END
[LINE no] IF  EXPR THEN LINE no ELSE Line No
[LINE No] FOR VAR '=' EXPR 'To' EXPR
[LINE No] NEXT VAR
[LINE No] WAIT number
[Line No] SERVO ID=EXPR | '@' | '~'
[LINE No] LIST [VAR]=N,1,2,3 ..
[LINE No] MOVE @[VAR],100,20
[Line No] GOSUB [Line No]
[Line No] RETURN
[Line No] STAND [16 | 18]  
[LINE No] PUT VAR '=' $PORTA|B|C:0-7
[LINE No] OUT EXPR,EXPR
[Line No] RUN number
[Line No] PLAY number
[Line No] OFFSET [# | List | "blank"]
}}}
*_Coming Soon_*
{{{
[Line No] IC2O number,List
[Line No] IC2I number,number,List
[Line No] SPEED number
[Line No] MTYPE number,number,List
[Line No] STEP ID=number,number,number
}}}

||Special register access ($)||Description||
||$X, $Y, $Z   ||accelerometer values||
||$IR          ||wait for IR remote and get button pressed LET A=$IR||
||$KBD         ||wait for keyboard press||
||$PSD         ||PSD sensor value||
||$VOLT        ||Battery voltage||
||$TICK        ||Number of tenths of a second||
||$PORT        ||Read Bit 6 of Port A .. LET A=$PORT:A:6 ||
||$RND         ||Random numbers - different number each time called ||
||$MIC         ||Microphone level||
||$TYPE        ||Number of servos i.e. 16||
||$SERVO(id)   ||position of servo id, i.e.  LET A=$SERVO(5) get Servo ID 5 position ||
||$ABS(x)      ||Absolute value of x returned||
||$ROM(x)      ||Contents of ROM location x, i.e. LET A=$ROM(10)||
||$MAPIR(x)    ||Maps value from IR to built in action code||
||$FIND(x, @A) ||Look for item less than or equal to X and return index||
||$CVB2I(x)    ||Converts byte to int, i.e. 4 -> 4 and 254 -> -2||


||Command||Description||
||SERVO ID=POS  ||set servo id to position POS / @ / ~||
||LIST/MOVE     ||sends a Scene - 'n' Servo Positions, Plus time, no frames||
||POKE 10,A     ||Put A into Byte 10||
||PUT PORT:A:8 = 3 ||set DDR of Port A = 3 (PIN0,PIN1 readable)||
||PUT PORT:A:2 = 1 ||set Port A bit 2 =1 (assuming writeable)||
||WAIT 200       ||Wait for a an amount of time in ms i.e. 200ms||
||STAND 16      ||set servos to basic posture (for 16 or 18 servo bots)||
||OFFSET        ||Defines a numeric offset array to be applied to MOVE and PLAY commands||
||RUN 0         ||Call Built in action using code i.e. RUN 0, would punch left See built in motion list below||
||I2CO 51,@{3,1,2,3}||will send 3 bytes to I2C address 51 ||
||I2CI 52,5,@{2,1,1}||will read 5 bytes from address 52 after first send 2 bytes (1,1) to the same address.||
||SPEED 2||Speed torque setting on Move 0-4 (0 maximum, 4 minimum) ||
||MTYPE 3||Set Motion type 0: Acc, 1=Deacc, 2=AccDeac, 3=Linear ||

*Built in motions:*
{{{
0) PunchLeft
1) PunchRight
2) SidewalkLeft
3) SidewalkRight
4) TurnLeft
5) TurnRight
6) GetupBack
7) GetupFront
8) WalkForward
9) WalkBackward
10)lshoot
11)rshoot
12)rsidewalk
13)lsidewalk
14)standupr
15)standupf
16)sitdown
17)hi
18)kick left front turn
}}}

= Examples  =

These are available from examples sub- folder
http://code.google.com/p/robobuilderlib/source/browse/#svn/trunk/examples
{{{
1) simple loop
10 LET A=1
20 PRINT A
30 LET A=A+1
35 WAIT 500
40 IF A<10 THEN 20 
50 END

2) read from console and IR port
10 LET A=$KBD
20 PRINT A
30 LET A=$IR
40 PRINT A
50 GOTO 10

3) Loops
10 FOR A=1 to 5
20 PRINT A
30 NEXT A

4) compound PRINT
10 LET A=(5+3)*(2+1)
20 PRINT "The answer is ";A
30 END

5) read and set servo
This reads current position of servo 12 and then moves and extra 5
10 let a=$servo(12)
20 print "Pos=";a
30 servo 12=a+5

6) read accelerometer values
10 print $TICK;" X=";$X;" Y=";$Y;" Z=";$Z
20 wait 500
30 goto 10

7) Read button pressed 
10 let A=$IR
20 print "Received=";A

8) More  complex - press a button on IR and do action (like standard firmware)
10 STAND 16
20 RUN $MAPIR($IR)
30 GOTO 20

9) Simple LISTS
10 print "List test"
20 list a=5,4,3,2,1,5
30 print @a[1]
40 print @a
Output:
3
4,3,2,1,5
Note: lists are number from zero. First element (5) is the length of the list

10) OUT - show PSD sensor output as a bar
10 out 45,$psd
20 out 42
30 print
40 goto 10
Output:
----------*
Ascii value '-' 45, '*' 42, and If $PSD value is say 10 

11) ROM  and OUT - displays serial number
10 FOR I=1 to 13
20 OUT $ROM(I)
30 NEXT I
40 PRINT 

12) Use of  Passive
10 SERVO 12=@
20 Print "Servo 12 = "; $SERVO(12)
30 wait 500
40 goto 20

12a) Changing Red/Blue IO port values
10 LET A=0
20 SERVO 12=~A
25 WAIT 50
30 LET A=A+1
40 GOTO 20
Output:
Servo 12 will flash red/blue light (assuming its a transparent servo!)
IO ports. ~0, ~1, ~2, ~3

13) Gosub and Return
10 print "Hello";
20 gosub 50
30 print " back";
40 end
50 print " Here";
60 return
Output:
Hello Here back

14) Take up basic pose 
10 MOVE @{16,125,179,199,88,108,126,72,49,163,141,51,47,49,199,205,205},10,1000
Its simpler to use STAND 16 - but this show use of the MOVE command with a literal/inline LIST

15) Index through a list
10 list a=5,65,66,67,68,69
20 for i=0 to 4
30 out @a[i]
40 next i
50 print
output:
ABCDE

16) Generate random numbers
Also use % to get modulo of $rnd - so example return 10 numbers between 0 and 5
10 for i=1 to 10
20 print $rnd % 6
30 next i
output:
5
5
0
etc ..

17) I2C comm example(s)
This examples reads values from the optional accelerometer (address 112). The bytes are available from current array @![n]. Note use of $CVB2I() - converts the read bytes values to integers i.e. 255 -> -1. 

10 FOR I=1 to 10
20 I2CO 112,@{1,2}
30 I2CI 113,6
40 PRINT "X=";$CVB2I(@![1]);" Y=";$CVB2I(@![3]);" Z=";$CVB2I(@![5])
50 WAIT 250
60 NEXT I
output:
X=5 Y=-2 Z=6
X=5 Y=-2 Z=7
...

18) Lights proximity detector
10 LET P=$PSD
20 LIGHTS P-10
30 GOTO 10
output:
The lights on the back of the Robot (Run,Pwr, Err) will act as a bargraph showing how close an object is to PSD sensor 

19) Close gripper
10 STEP 18=70,120,5
output:
Assuming a gripper is connected to Servo 18 this function will slowly close the gripper until it either is fully closed or its movement is stopped by an object in it grasp.
}}}

Grippers available from Ipswich Robotics : 
[http://www.shapeways.com/model/55863/gripper_left.html Left gripper] or 
[http://www.shapeways.com/model/55864/gripper___right.html Right gripper]